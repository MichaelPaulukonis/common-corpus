NASA SP-223 



THE NASTRAN PROGRAMMER'S MANUAL 



Frank J. Douglas 
Editor 



September 1970 




Scientific and Technical Information Division 

OFFICE OF TECHNOLOGY UTILIZATION 1970 

NATIONAL AERONAUTICS AND SPACE ADMINISTRATION 

V^ashington, D.C. 



For sale from Computer Softwore Management and Information Center (COSMIC) 
Barrows Hall, University of Georgia, Athens, Georgia 30601 - Price $15.00 



FOREWORD 



For many decades the art of structural analysis remained essentially stagnant, not because of 
lack of theoretical understanding but because of limitations on capability for numerical computa- 
tion. The analyst was constrained to apply approximate continuum solutions of the equations of 
elasticity to his structure which yield, for the most part, average stress and strain distributions 
not taking account of localized structural features. Fortunately, most aircraft could be approxi- 
mated by a collection of beam-like one-dimensional structures-that is, structures where state of 
deformation could be adequately described by a set of functions of a single space coordinate. But, 
spacecraft structures and very high speed aircraft began to depart appreciably from such idealiza- 
tions. Structural analysts began to adapt theory to aircraft structures viewed as an assemblage of 
a finite number of elastic components over 20 years ago. In one of the first papers on the subject, 
Levy in 1947 isolated each component, placed it in static equilibrium, and regarded the internal 
forces as the unknown quantities. The principle of minimum strain energy was applied to determine 
the correct internal force distribution. Subsequent papers by Schuerch, Levy, Turner, Clough, 
Martin and others took the deformations of the various discrete components of the structure as the 
unknown quantities, instead of the forces on the components. The correct deformation pattern was 
obtained by applying the principle of minimum potential energy. In all of these applications, 
matrix formulations were developed early as a means of organizing the bookkeeping. Numerical 
solutions were, for the most part, reduced to the processes of addition, subtraction, multiplica- 
tion, inversion and finding the characteristic roots and vectors of matrices. But the analyst was 
limited at first by the desk calculator. The inversion of ten by ten matrices by Grout's or an 
equivalent method was a formidable exercise. It is no wonder that the earliest users of digital 
computers in the aircraft companies were the Structures and Dynamics Divisions of the Engineering 
Department. It was indeed fortunate that the birth of the digital computer came when it did. 

But the development of software for structural analysis became a separated and individualistic 
activity with little or no coordination. There grew a tendency toward proprietary secrecy. Little 
compatability was developed among the various structural analysis programs throughout the country. 
The present program, called NASTRAN. is an attempt to bring together the best features of the state 



of the art into a single progra. for the analysis of large complex structures. The result .s an 
exemplary beginning. It will not satisfy every requirement at first. But. it fon.s a framework 
for an enormous step forward in the development of a co^non base. The NASA staff and contractors 
who conceived of and took part in this important new development are to be contended for the.r 
foresight and skill . 



Dr. Raymond L. Bisplinghoff 
Dean, School of Engineering 
Massachusetts Institute of Technology 



INTRODUCTION TO THE NASTRAN PROGRAM 

, The acronym NASTRAN is formed from NAsa STRuctural ANalysis. NASTRAN is a 
general purpose digital computer program for the analysis of large complex struc- 
tures and has its origins in the research councils of NASA. During the annual 
review of NASA's research program in the area of structural dynamics by Douglas 
Michel of Headquarters in January 1964, it became apparent that there was consid- 
erable effort by many of the Centers to develop computer programs for structural 
analysis, designed to meet each of the Centers' particular needs. It was sug- 
gested that perhaps a single program could meet all their needs. The Office of 
Advanced Research and Technology appointed a committee with representation from 
eight NASA Centers to study this possibility. Thus formed, the AD HOC GROUP ON 
COMPUTER METHODS IN STRUCTURAL ANALYSIS was constituted as follows: 

Ames Research Center Richard M. Beam 

Perry P. Polentz 

Flight Research Center Richard J. Rosecrans 

Goddard Space Flight Center Thomas G. Butler 

Peter A. Smi dinger 

Jet Propulsion Laboratory Marshall E. Alper 

Robert M. Bamford 
Langley Research Center Herbert J. Cunningham 

Lewis Research Center William C. Scott 

James D. McAleese 

Manned Spacecraft Center C. Thomas Modlin, Jr. 

William W . Renegar 

Marshall Space Flight Center Robert L. McComas 

Adjoint Member: James Johnson from Wright Patterson Air Force Base 

Chairman: Thomas G. Butler 

After six months of investigation, the Ad Hoc Group reported to Headquarters that 
there was no digital program in existence which had broad, uniform capabilities 

i (3/1/70) 



in the three interdependent disciplines of analytical mechanics, numerical 
methods, and computer programming. The Group did observe that ther^ was consider- 
able capability dispersed throughout the aerospace industry which had not been 
collected into a single program. They found also that there was a tendency toward 
proprietary secrecy which inhibited exchange of information. Communication was 
further hindered by the lack of compatibility between any two companies' struc- 
tural analysis programs. The Ad Hoc Group recommended that NASA sponsor an en- 
tirely new program aimed at bringing together all the best in the state-of-the- 
arts. NASA is indebted to many people, but especially to these individuals in 
the several companies for assisting the Ad Hoc Group during its investigations: 

M. John Turner of Boeing Seattle 

W. J. Crichlaw of Lockheed Burbank 

Paul H. Denke of Douglas Long Beach 

Robert J. Melosh of Philco Western Development Labs 

Richard H. Gallagher of Bell of Buffalo 

P. L. Marshall of North American Columbus 

Stanley Kaufman of Martin Baltimore 

Headquarters endorsed the recommendations of the Ad Hoc Group and commissioned 

them to draw up a set of specifications. Fortunately, the papers from the first 

Wright Field Conference, "On Matrix Methods in Structural Analysis", were at hand 

to consult. The objectives of the specifications are now being achieved: 

Combine the best of the state-of -the-arts in 3 disciplines. 

Incorporate both the Force and the Displacement approaches of finite elements, 

Organize to be General Purpose. 

Embody large three dimensional structural capability. 

Establish computer independence. 

Provide for modification without cascading effects. 

Build in the maximum of user convenience. 

Document all aspects to gain maximum visibility. 

The contract to implement the NASTRAN specifications was awarded to Computer 
Sciences Corporation (CSC) with MacNeal Schwendler, Martin Baltimore, and later 

11 (3/1/70) ^ 



Ben Aerosystems Company as sub-contractors. The team that CSC assembled was one 
that identified strongly with the project. The designers were Dr. Richard H. 
MacNeal , Dr. Paul R. Peabody, Prof. C. W. McCormick, Mr. Stanley Kaufman, Mr. 
Thomas L. Clark, and Mr. David B. Hall. Except for Dr. Peabody, all of the 
designers were also involved with the implementation. The team of computer pro- 
grammers was led by Mr. Keith H. Redner. The other principal members of the 
implementation team were Richard S. Pyle, Carl Hennrich, Steven E. Wall, Frank J. 
Douglas, Howard Dielmann, and David Herting. The quality of the NASTRAN program 
and its documentation is testimony to the purposeful ness with which this implemen- 
tation team applied themselves. We in NASA extend our sincere gratitude to all 
these men. This team has often exceeded the state-of -the-arts guidelines that 
were set down. A few examples are: the Segment File Allocator, the General 
Input/Output Module, matrix decomposition with active columns, the inclusion of 
scalar nonl i neari ties in control system dynamics, the generality in the plot 
module, and the development of the self-contained "inverse power with shifts" 
module for eigenvalue extraction. The overall design of the program has set a new 
standard for general purpose programs of any discipline. The framework used in 
NASTRAN can be disassociated from elastic structures and be applied to other dis- 
ciplines, because there are no semantic implications in the executive operations. 
The program abounds in service code, that threads through every step of the prob- 
lem physics, providing convenience to the analyst. 

The NASTRAN Project personnel at Goddard Space Flight Center also strongly 
identified with the program. They are: Richard D. McConnell, William R. Case, 
James B. Mason, William L. Cook, and Edward F. Puccinelli. Their unflagging 
efforts in debugging and editing have been indispensable. 

Many policy decisions had to be made as to the content of NASTRAN. The total 
framework of the program was considered to be the most important; i.e., commen- 
surate large problem capability from basic statics for general conditions to 
advanced dynamics; with an executive system that could manage problems unbounded 
by core; was compact in its space requirements; could restart problems; could 
operate efficiently over different computers; and still be maintainable. This is 

ill (3/1/70) 



a costly venture and one could not expect the program to be complete in all its 
details. We wanted it to be complete in its principals and essentials. Conse- 
quently, some aspects were of necessity postponed. 

It was decided that only basic finite elements would be included to deal with 
one and two dimensional elastic relationships such as beams, plates and axisym- 
metric shells. Economy of running time for the state-of -the-arts elements was a 
determining factor in their selection More sophisticated and new elements have 
appeared in the state-of-the-art since the inception of this program, which can 
easily be incorporated. 

An interesting type of decision erupted as a result of third generation 
computers. The relative costs of input-output and sorting operations had to be 
compared against regeneration whenever calculated data was used subsequently. In 
the majority of instances, the decision was made in favor of regeneration because 
the quantity of input data (usually from single precision engineering sources) was 
small; the compute time for regeneration was usually less than the associated 
input-output time; the quantity of generated data was usually orders of magnitude 
greater (and in double precision) compared to the engineering source data, and 
the read and write operations and subsequent logical operations for sorting and 
merging were very time-consuming. 

In the matter of eigenvalues, the range of demands is such that no single 
current routine will satisfy all requirements. Two principal types of routines 
were decided upon; those that transform the whole matrix for simultaneous deter- 
mination of roots and those that perform separate operations on the original 
matrix for each root extracted. The former is more efficient for a large number 
of roots, while the latter type is more efficient for a few roots of large 
matrices. Solution of complex matrices is performed only by the root tracking 
schemes and not by transformation methods, because existing transformation tech- 
niques for complex matrices are too expensive. 

There was advice from many sources that the time was not right for a large 
general purpose program, because the flux in hardware and software was too great. 
The fear was that the endeavor would result in a program which would be obsolete 

iv (3/1/70) 



before it was finished. The rapidly changing computer technology had the opposite 
effect on the NASTRAN Project. The situation forced men to think more generally 
so that viability could be preserved in spanning the gap between second and third 
generation machines and anticipating the impact of fourth generation computers. 
The decision was made to write a single program in FORTRAN IV with some exception- 
al areas to be written in assembly language. FORTRAN IV version 13 in its various 
forms on different computers seems to have stabilized out as a language that will 
have currency for a reasonable time in the future. More than 99% of the program 
is written in this FORTRAN. The program is modular so that updating is a matter 
of revamping material wtthin a module without modifying its external appearances. 

The task of writing a program that performed efficiently on different manu- 
facturers' computers forced many decisions. It was very tempting to capitulate 
to the disparities amongst the computers and resign ourselves to the rationale 
that for each computer, there would be a different version of NASTRAN. Fortu- 
nately, the decision was made to create just one version of NASTRAN. In some 
respects, this decision might have been viewed by some as having a corroding 
effect on the program. The conception derives from the condition that code was 
not written simultaneously for all computers. It was written first for the 
"development computer - the IBM Direct Coupled 7094/7040"; subsequently, it was 
tried on the others. Failures of programming designs on subsequent machines 
decreased the set of admissable procedures that remained in the intersection of 
the languages of all required computers. Fortunately, the remaining subset is 
sufficiently versatile, that it was possible to achieve commonality without 
becoming primitive. To date, the computers for which NASTRAN has been adopted are: 
IBM 7094/7044, UNIVAC 1108, CDC6600, and IBM 360. One serious lack of common 
intersection was in core management. NASTRAN is so large that logic demands that 
it be designed in multiple links horizontally and in many levels of overlay 
vertically with the additional ability to manage core dynamically. When it was 
found that Control Data did not provide for this type of core management, the 
decision was made to write a loader to replace that which Control Data offered 
with their SCOPE 3 operating system. The basic set of NASTRAN functional modules 

V (3/1/70) 



is thus preserved as a single unit for all computers. Problems in trouble-shoot- 
ing and maintenance are thus confined to a single source. This decision affected 
the compatibility with time sharing of the IBM TSS type. An entirely different 
version of NASTRAN would be required to adapt the program to the TSS system. 
Well-founded doubts also persist about its eventual execution efficiency. Conse- 
quently, NASTRAN is not designed to operate under a time sharing system. 

Originally, a number of conveniences were going to be built into NASTRAN. 
As design evolved, the number of convenience nominees expanded. It was finally 
decided that conveniences having to do with the preparation of input data in 
NASTRAN format were properly external to the program. All such routines could be 
classified as NASTRAN auxiliary programs. Examples of this classification are: 
the automatic generation of grid points and elastic elements for an analytically 
known geometry, the computation of equation ordering for the minimization of the 
bandwidth of non zero elements in the stiffness matrix, or the formatting of 
experimental data as input to the General Element. Hundreds of such programs will 
probably be written and their lives will probably be short. For these reasons, 
they are considered external auxiliaries. Circulation of announcements about such 
programs will be made to users of the program, so they can be obtained easily. 

Hopefully, the framework that has been built has also been sufficiently well 
fleshed out that it will serve a sizable portion of the large problems in the 
structural analysis community currently. It is intended that new capability be 
added or outdated capability be replaced by augmenting or replacing modules. 
An entire chapter in the Programmer's Manual has been devoted to the topic of 
Modifications and Additions in anticipation of serving this particular activity. 
The traffic in the development of new and increasingly versatile elastic modules 
is expected to be the most active. As analysts increase their use of the program, 
their detailed needs will become better defined with the consequent result that 
the traffic in "convenience code" will also be expected to increase. It is our 
strong desire that all such new features be called to the attention of the 
NASTRAN Project so that these ideas and routines can be disseminated to a broad 

audience. Thomas G. Butler 

NASTRAN Project Manager 
Goddard Space Flight Center 
Greenbelt, Maryland 
vi (3/1/70) 



PREFACE TO THE NASTRAN PROGRAMMER'S MANUAL 

The Programmer's Manual is one of three manuals that constitute the documentation for NASTRAN, 
the other two being the Theoretical Manual and the User's Manual. The Programmer's Manual is 
divided into six major sections: section 1, NASTRAN Programming Fundamentals; section 2, Data 
Block and Table Descriptions; section 3. Subroutine Descriptions; section 4, Module Functional 
Descriptions; section 5, NASTRAN - Operating System Interfaces; and section 6, Modifications and 
Additions to NASTRAN. 

Section 1 is a general overview of the program, and as such it should be read as background 
material for all sections which follow. 

Section 2 contains descriptions of the data blocks, which are the principal means of data 
communication between the program's functional modules (a module is defined to be a group of sub- 
routines which perform a specific function) and the NASTRAN Executive System. Two indexes for the 
data block descriptions, one sorted alphabetically on data block names and the other sorted 
alphabetically on the names of the modules from which the data blocks are output, are given in 
sections 2.2.1 and 2.2.2 respectively. Section 2 also contains a) descriptions of tables, both 
core and noncore resident, maintained by the NASTRAN Executive System and b) descriptions of mis- 
cellaneous tables which are accessed by a class of modules. Alphabetical indexes for these tables 
are given at the beginning of sections 2.4 and 2.5 respectively. 

Sections 3 and 4 contain descriptions of the (utility or general purpose) subroutines and 
modules of NASTRAN respectively. The reader is directed to the alphabetical indexes, sorted on 
entry point names, in sections 3.2 and 4.1.3 respectively for these sections. An index to the 
Module Functional Descriptions, sorted alphabetically on module names, is given in section 4.1.2. 
The reader is urged to read the introductory material to sections 3 and 4 before using these 
sections. 

Section 5 treats computer and operating system dependent matters such as operating system 
control cards and generation of the absolute (executable) NASTRAN system. 

Section 6 describes the means by which modifications and additions to NASTRAN are implemented. 

The learning of any new system, whether it be an operating system or a large applications 
system like NASTRAN, is made more difficult than it ought to be because of the use by the designers 

vii (3/1/70) 



of the system of new mnemonics, acronyms, phrases and "buzz" words. In order to aid the reader In 
learning such connonly used NASTRAN terms, a single source reference, section 7, the NASTRAN 
Dictionary, of the User's Manual Is provided. The programner Is advised to secure a copy of at 
least this section of the User's Manual for his clay- to-day reference. 



vill (3/1/70) 



TABLE OF CONTENTS 

Section Page No. 
1. NASTRAN PROGRAMMING FUNDAMENTALS 

1 . 1 PROGRAM OVERVIEW 1.1-1 

1.1.1 Objecti ves 1.1-1 

1.1.2 Program Organization 1.1-3 

1.2 NASTRAN EXECUTIVE SYSTEM 1.2-1 

1.2.1 Introduction 1.2-1 

1.2.2 Executive Operations During the Preface 1.2-4 

1.2.3 Executive Operations During Problem Solution 1.2-9 

1.3 WORD SIZE AND COMPUTER HARDWARE CONSIDERATIONS 1.3-1 

1.3.1 Introduction 1.3-1 

1.3.2 Alphanumeric Data 1.3-2 

1.3.3 Word Packing 1.3-2 

1.4 SYSTEM BLOCK DATA SUBPROGRAM (SEMDBD) 1.4-1 

1.5 THE OPEN CORE CONCEPT 1.5-1 

1.5.1 Introduction 1.5-1 

1.5.2 Definition of Open Core 1.5-1 

1.5.3 Example of an Application of Open Core 1.5-1 

1.6 NASTRAN INPUT/OUTPUT 1.6-1 

1 .6.1 Introduction 1 .6-1 

1.6.2 Use of the Operating System Input File 1.6-1 

1.6.3 Use of the Operating System Output File 1.6-2 

1.6.4 GIN0 1.6-3 

1.7 NASTRAN MATRIX ROUTINES 1.7-1 

1.7.1 Introduction 1.7-1 

1.7.2 Matrix Packing and Unpacking 1.7-1 

1.7.3 The Nested Vector Set Concept Used to Represent Components 

of Displacement 1 .7-2 

1.8 GENERATION OF MATRICES 1.8-1 

1.8.1 The ECPT Data Block 1.8-1 



ix (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section Page No. 

1,8,2 Structural Elements 1.8-2 

1.9 TERMINATION PHILOSOPHY AND DIAGNOSTIC MESSAGES 1,9-1 

1.10 RESTARTS IN NASTRAN 1.10-1 

2. DATA BLOCK AND TABLE DESCRIPTIONS 

2 . 1 INTRODUCT ION 2.1-1 

2.2 DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 2.2-1 

2.2.1 Index for Data Block Descriptions Sorted on Data Block Names 2.2-3 

2.2.2 Index for Data Block Descript-'ons Sorted Alphabetically by Module.. 2.2-11 

2.3 DATA BLOCK DESCRIPTIONS 2.3-1 

2.3.1 Data Blocks Output From Module IFPl 2.3-1 

2.3.2 Data Blocks Output From Module IFP 2.3-5 

2.3.3 Data Blocks Output From Module GPl 2.3-31 

2.3.4 Data Blocks Output From Module GP2 2.3-36 

2.3.5 Data Blocks Output From Module PLTSET 2.3-37 

2.3.6 Data Blocks Output From Module PL0T 2.3-40 ■ 

2.3.7 Data Blocks Output From Module GP3 2.3-41 , 

2.3.8 Data Blocks Output From Module TAl 2.3-45 

2.3.9 Data Blocks Output From Module SMAl 2.3-56 

2.3.10 Data Blocks Output From Module Sf^2 2.3-58 

2.3.11 Data Blocks Output From Module GPWG 2.3-59 

2.3.12 Data Blocks Output From Module SMA3 2.3-60 

2.3.13 Data Blocks Output From Module GP4 2.3-61 

2.3.14 Data Blocks Output From Module GPSP 2.3-63 

2.3.15 Data Blocks Output From Module MCEl 2.3-64 

2.3.16 Data Blocks Output From Module MCE2 2.3-65 

2.3.17 Data Blocks Output From Module SCEl 2.3-67 

2.3.18 Data Blocks Output From Module SMPl 2.3-70 

2.3.19 Data Blocks Output From Module RBMGl 2.3-73 

2.3.20 Data Blocks Output From Module RBMG2 2.3-75 

2.3.21 Data Blocks Output From Module RBMG3 2.3-77 

2.3.22 Data Blocks Output From Module RBMG4 2.3-78 

X (3/1/70) 



TABLE OF CONTENTS (Continued) 



Section 



2.3.23 


Data Bl 


2.3.24 


Data Bl 


2.3.25 


Data Bl 


2.3.26 


Data Bl 


2.3.27 


Data Bl 


2.3.28 


Data Bl 


2,3.29 


Data Bl 


2.3.30 


Data Bl 


2.3.31 


Data Bl 


2.3.32 


Data Bl 


2.3.33 


Data Bl 


2.3.34 


Data Bl 


2.3.35 


Data Bl 


2.3.36 


Data Bl 


2.3.37 


Data Bl 


2.3.38 


Data 31 


2.3.39 


Data Bl 


2.3.40 


Data Bl 


2.3.41 


Data Bl 


2.3.42 


Data Bl 


2.3.43 


Data Bl 


2.3.44 


Data Bl 


2.3.45 


Data Bl 


2.3.46 


Data Bl 


2.3.47 


Data Bl 


2.3.48 


Data Bl 


2.3.49 


Data Bl 


2.3.50 


Data Bl 


2.3.51 


Element 


2.3.52 


Element 



Page No. 

locks Output From Module SSGl 2.3-79 

locks Output From Module SSG2 2.3-80 

locks Output From Module SSG3 2.3-81 

locks Output From Module SSG4 2.3-83 

locks Output From Module SDRl 2.3-84 

locks Output From Module SDR2 2.3-88 

locks Output From Module DPD 2.3-114 

locks Output From Module READ 2.3-125 

locks Output From Module DSMGl 2.3-128 

locks Output From Module SMP2 2.3-129 

locks Output From Module DSMG2 2.3-130 

locks Output From Module PLAl 2.3-132 

locks Output From Module ADD 2.3-137 

locks Output From Module PLA2 2.3-138 

locks Output From Module PLA3 2.3-139 

locks Output From Module PLA4 2.3-140 

locks Output From Module CASE 2.3-141 

locks Output From Module MTRXIN 2.3-142 

locks Output From Module GKAD 2.3-143 

locks Output From Module CEAD 2.3-146 

locks Output From Module VDR 2.3-149 

locks Output From Module FRRD 2.3-158 

locks Output From Module SDR3 2.3-160 

locks Output From Module XYTRAN 2.3-175 

locks Output From Module RAND0M 2.3-179 

locks Output From Module TRD 2.3-181 

locks Output From Module GKAM 2.3-183 

locks Output From Module DDRl 2.3-184 

Element Stress Output Data Description 2.3-185 

Element Force Output Data Description 2.3-189 



xi (3/1/70) 



TABLE OF CONTENTS (Continued) 

^ ^j Page No. 

Section — ^ 

2.3.53 Data Blocks Output From Module DDR2 2.3-192 

2.4 EXECUTIVE TABLE DESCRIPTIONS 2.4-1 

2.4.1 Executive Tables Which are Permanently Core Resident 2.4-2 

2.4.2 Executive Tables Not Permanently Core Resident 2.4-15 

2.5 MISCELLANEOUS TABLE DESCRIPTIONS 2.5-1 

2.5.1 Miscellaneous Tables Which are Permanently Core Resident 2.5-2 

2.5.2 Miscellaneous Tables Not Permanently Core Resident 2.5-6 

3. SUBROUTINE DESCRIPTIONS 

3 . 1 INTRODUCTION 3.1-1 

3.2 ALPHABETICAL INDEX OF ENTRY POINTS FOR SUBROUTINE DESCRIPTIONS 3.2-1 

3.3 EXECUTIVE SUBROUTINE DESCRIPTIONS 3.3-1 

3.3.1 XSEMl (Executive Sequence Monitor, Preface) 3.3-1 

3.3.2 BTSTRP (Bootstrap Generator) 3.3-2 

3.3.3 SEHINT (Sequence Monitor Initialization) 3.3-3 

3.3.4 GNFIAT (Generate FIAT) 3.3-5 

3.3.5 ENDSYS (End-of-Link) 3.3-6 

3.3.6 SEARCH (Search, Load, and Execute Link) 3.3-8 

3.3.7 XSEMi (Link i Main Program, i = 2,3,...) 3.3-9 

3.3.8 XSEMXX (Sequence Monitor - Deck Generator) 3.3-11 

3.3.9 GNFIST (Generate FIST) 3.3-12 

3.3.10 XE0T (End-of-Tape) 3.3-14 

3.3.11 SSWTCH (Sense Switches) 3.3-15 

3.3.12 C0NMSG (Console Message Writer) 3.3-16 

3.3.13 TTLPRG (Title Page Writer) 3.3-17 

3.4 UTILITY SUBROUTINE DESCRIPTIONS 3.4-1 

3.4.1 MAPFNS (Machine Word Functions) 3.4-1 

3.4.2 0PEN (Initiate Activity on a File) 3.4-3 

3.4.3 WRITE (Write Data in a Logical Record) 3.4-4 

3.4.4 CLi3SE (Terminate Activity on a File) 3.4-5 

3.4.5 READ (Read Data From a Logical Record) 3.4-6 



xii (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section Page No. 

3.4.6 FWDREC (Forward Space One Logical Record) 3.4-8 

3.4.7 BCKREC (Backspace One Logical Record) 3.4-9 

3.4.8 REWIND (Position File to the Load Point) 3.4-10 

3.4.9 E0F (Write an End-of-File) 3.4-11 

3.4.10 SKPFIL (Skip Files Forward or Backward) 3.4-12 

3.4.11 XGIN0 (GIN0 Utility Routine) 3.4-13 

3.4.12 GIN0 (Genersl Input/Output Routine) 3.4-15 

3.4.13 JIPNC0R (Transmit Logical Records To/From Core Storage) 3.4-20 

3.4.14 G0PEN (Short Form for Subroutine 0PEN With Header Record 

Processing) 3.4-22 

3.4.15 FREAD (Short Form for Subroutine READ) 3.4-23 

3.4.16 WRTTRL (Write Trailer) 3.4-24 

3.4.17 FNAME (File Name) 3.4-25 

3.4.18 CLSTAB (Close a GIN0 File and Write a Nonzero Trailer) 3.4-26 

3.4.19 XRCARD (Executive Free-Field Card Data Conversion Routine) 3.4-27 

3.4.20 RCARD (Fixed Field Card Data Conversion Routine) 3.4-32 

3.4.21 TAPBIT (Tape Bit Test) 3.4-35 

3.4.22 PEXIT (Problem Exit) 3.4-36 

3.4.23 TMT0G0 (Time-To-Go) 3.4-37 

3.4.24 PAGE (Page Heading) 3.4-38 

3.4.25 MESAGE (Message) 3.4-39 

3.4.26 MSGWRT (Message Writer) 3.4-40 

3.4.27 USRMSG (User Message Writer) 3.4-41 

3.4.28 MATDUM (Matrix Dump (Print) Routine) 3.4-42 

3.4.29 TABPRT (Table Printer) 3.4-43 

3.4.30 PREL0C (Position Data Block to Requested Record) 3.4-44 

3.4.31 S0RT (Sort a Table) 3.4-45 

3.4.32 GMMATD (General Matrix Multiply and Transpose - Double 

Precision) 3.4-49 

3.4.33 GMMATS (General Matrix Multiply and Transpose - Single Precision).. 3.4-52 

3.4.34 INVERD (Double Precision In Core Inverse Routine) 3.4-53 



xiii (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section Page No. 

3.4.35 INVERS (Single Precision In Core Inverse Routine) 3.4-54 

3.4.36 PREMAT (Material, Property Utility). 3.4-55 

3.4.37 PRETRD (Utility for Modules Which Use the CSTM Data Block - 

Double Precision Version) 3.4-64 

3.4.38 PRETRS (Utility for Modules Which Use the CSTM Data Block - 

Single Precision Version) 3.4-66 

3.4.39 PRETAB (Table Look-Up) 3.4-67 

3.4.40 AXIS (Draw an Axis on a Plot) 3.4-70 

3.4.41 AXISi (Axis Routine for Plotter 1) 3.4-72 

3.4.42 SKPFRM (Skip a Variable Nimiber of Frames) 3.4-73 

3.4.43 SELCAM (To Initiate a New Plot) 3.4-74 

3.4.44 IDPLUT (Generate an "ID" Plot) 3.4-75 

3.4.45 INTGPX (Search a List of Integers) 3.4-76 

3.4.46 INTLST (Interpret a List of Integers) 3.4-77 

3.4.47 LINE (Draw a Line on a Plotter) 3.4-78 

3.4.48 LINE1 (Draw a Line on Plotter 1) 3.4-79 

3.4.49 PRINT (Print a Title on a Plotter) 3.4-81 

3.4.50 RDM0DX (Read a File Containing XRCARD Translations) 3.4-83 

3.4.51 SGIN0 (GINU for Unformatted Tapes) 3.4-85 

3.4.52 STPL0T (To Initiate a New Plot or Terminate the Current Plot) 3.4-87 

3.4.53 SYMBOL (Type a Symbol on a Plotter) 3.4-88 

3.4.54 TIPE (Type a Line of Characters on a Plotter) 3.4-90 

3.4.55 TYPEi (Type a Line of Characters on Plotter i) ,. 3.4-92 

3.4.56 TYPFLT (Type a Floating Point Number 't)n a Plotter) 3.4-94 

3.4.57 TYPINT (Type an Integer Number on a Plotter) 3.4-96 

3.4.58 WPLTl (Write a Plotter Command for Plotter 1) 3.4-98 

3.4.59 WPLT2 (Write a Plotter Command for Plotters 2 and 8) 3.4-100 

3.4.60 WPLT3 (Write a Plotter Command for Plotter 3) 3.4-102 

3.4.61 GIN0I0 (GINU Input/Output Routine) 3.4-103 

3.4.62 EJECT (Automatic Page Eject) 3.4-105 

3.4.63 PLAMAT (Material Property Utility for Two-Dimensional Elements 

in Piecewise Linear Analysis) 3.4-106 



xiv (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section Page No. 

3.4.64 WPLT4 (Write a Plotter Command for Plotters 4 through 7) 3.4-108 

3.4.65 WPLT9 (Write a Plotter Command for Plotter 9) 3.4-110 

3.4.66 WPLTIO (Write a Plotter Command for the NASTRAN General Purpose 

P'.otter) 3.4-ni 

3.4.67 PLTSET (Plotting Parameter Initialization) 3.4-113 

3.4.68 DRWCHR (To Draw a Line of Characters) 3.4-115 

3.4.69 FNDPLT (Determine the Internal Plotter and Model Indices) 3.4-117 

3.5 MATRIX SUBROUTINE DESCRIPTIONS 3.5-1 

3.5.1 BLDPK (Build a Packed Column of a Matrix) 3.5-1 

3.5.2 PACK (Pack a Column of a Matrix) 3.5-5 

3.5.3 INTPK (Interpret a Packed Column of a Matrix) 3.5-7 

3.5.4 UNPACK (Unpack a Packed Column of a Matrix) 3.5-10 

3.5.5 CALCV (Compute a Partitioning Vector) 3.5-12 

3.5.6 PARTN - MERGE (Partition a Matrix - Merge Matrices Together) 3.5-13 

3.5.7 SSG2A (Driver for PARTN) 3.5-16 

3.5.8 SDRIB (Driver for MERGE) 3.5-17 

3.5.9 UPART (Symmetric Partition Driver) 3.5-18 

3.5.10 ADD (Matrix Addition Routine) 3.5-19 

3.5.11 SSG2C (Driver for ADD) 3.5-20 

3.5.12 MPYAD (Matrix Multiplication Routine) 3.5-22 

3.5.13 SSG2B (Driver for MPYAD) 3.5-29 

3.5.14 SDCUMP (Symmetric Decomposition) 3.5-30 

3.5.15 DECjJMP (Unsymmetric Matrix Decomposition) 3.5-44 

3.5.16 CDCUMP (Complex Matrix Decomposition) 3.5-62 

3.5.17 FBS (Forward - Backward Substitution) 3.5-64 

3.5.18 SSG3A (Driver for FBS) 3.5-66 

3.5.19 GFBS (General Forward - Backward Substitution) 3.5-67 

3.5.20 S0LVER (Simultaneous Equation Solution Routine) 3.5-69 

3.5.21 DMPY (Multiply a Diagonal Matrix by an Arbitrary Matrix) 3.5-71 

3.5.22 ELIM (Perform a Matrix Reduction) 3.5-73 

3.5.23 FACTOR (Decompose a Matrix Into Triangular Factors) 3.5-74 

XV (3/1/70) 



TABLE OF CONTENTS (Continued) 

r ^- Page No. 

Se ction — = 

3.5.24 TRANPl (Driver for TRNSP) 3.5-75 

3.5.25 TRNSP (Matrix Transpose) 3.5-76 

4. MODULE FUNCTIONAL DESCRIPTIONS 

4.1 GENERAL COMMENTS AND INDEXES 4.1-1 

4.1.1 Use of Module Functional Descriptions 4.1-2 

4.1.2 Alphabetical Index of Module Functional Descriptions 4.1-7 

4.1.3 Alphabetical Index of Entry Points in Module Functional 

Descriptions 4.1-8 

4.2 EXECUTIVE PREFACE MODULE XCSA (EXECUTIVE CONTROL SECTION ANALYSIS) 4.2-1 

4.3 EXECUTIVE PREFACE MODULE IFPl (INPUT FILE PROCESSOR, PART 1) 4.3-1 

4.4 EXECUTIVE PREFACE MODULE XS0RT (EXECUTIVE BULK DATA CARD SORT) 4.4-1 

4.5 EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 4.5-1 

4.6 EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 4.6-1 

4.7 EXECUTIVE PREFACE MODULE XGPI (EXECUTIVE GENERAL PROBLEM INITIALIZATION).... 4.7-1 

4.8 EXECUTIVE PREFACE MODULE UMFEDIT (USER MASTER FILE EDITOR) 4.8-1 

4.9 EXECUTIVE MODULE XSFA (EXECUTIVE SEGMENT FILE ALLOCATOR) 4.9-1 

4.10 EXECUTIVE DMAP MODULE CHKPNT (CHECKPOINT) 4.10-1 

4.11 EXECUTIVE DMAP INSTRUCTION REPT (REPEAT A GROUP OF DMAP INSTRUCTIONS) 4.11-1 

4.12 EXECUTIVE DMAP INSTRUCTION JUMP (UNCONDITIONAL DMAP TRANSFER) 4.12-1 

4.13 EXECUTIVE DMAP INSTRUCTION CfiiND (CONDITIONAL TRANSFER) 4.13-1 

4.14 EXECUTIVE DMAP INSTRUCTION EXIT (TERMINATE DMAP PROGRAM) 4.14-1 

4.15 EXECUTIVE DMAP MODULE SAVE (SAVE VARIABLE PARAMETER VALUES) 4.15-1 

4.16 EXECUTIVE DMAP MODULE PURGE (EXPLICIT DATA BLOCK PURGE) 4.16-1 

4.17 EXECUTIVE DMAP MODULE EQUIV (DATA BLOCK NAME EQUIVALENCE) 4.17-1 

4.18 EXECUTIVE DMAP INSTRUCTION END (END OF DMAP PROGRAM) 4.18-1 

4.19 EXECUTIVE DMAP MODULE PARAM (PARAMETER PROCESSOR) 4.19-1 

4.20 EXECUTIVE DMAP MODULE SETVAL (SET VALUES) 4.20-1 

4.21 FUNCTIONAL MODULE GPl (GEOMETRY PROCESSOR - PHASE 1) 4.21-1 

4.22 FUNCTIONAL MODULE GP2 (GEOMETRY PROCESSOR - PHASE 2) 4.22-1 

4.23 FUNCTIONAL MODULE PLTSET (PLOT SET DEFINITION PROCESSOR) 4.23-1 

4.24 FUNCTIONAL MODULE PL(3T (STRUCTURAL PLOTTER) 4.24-1 

xvi (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section Page No. 

4.25 FUNCTIONAL MODULE GP3 (GEOMETRY PROCESSOR - PHASE 3) 4.25-1 

4.26 FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 4.26-1 

4.27 FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 4.27-1 

4.28 FUNCTIONAL MODULE SMA2 (STRUCTURAL MATRIX ASSEMBLER - PHASE 2) 4.28-1 

4.29 FUNCTIONAL MODULE GPWG (GRID POINT WEIGHT GENERATOR) 4.29-1 

4.30 FUNCTIONAL MODULE SMA3 (STRUCTURAL MATRIX ASSEMBLER - PHASE 3) 4.30-1 

4.31 FUNCTIONAL MODULE GP4 (GEOMETRY PROCESSOR - PHASE 4) 4.31-1 

4.32 FUNCTIONAL MODULE GPSP (GRID POINT SINGULARITY PROCESSOR) 4.32-1 

4.33 FUNCTIONAL MODULE MCEl (MULTIPOINT CONSTRAINT ELIMINATOR - PHASE 1) 4.33-1 

4.34 FUNCTIONAL MODULE MCE2 (MULTIPOINT CONSTRAINT ELIMINATOR - PHASE 2) 4.34-1 

4.35 FUNCTIONAL MODULE SCEl (SINGLE-POINT CONSTRAINT ELIMINATOR) 4.35-1 

4.36 FUNCTIONAL MODULE SMPl (STRUCTURAL MATRIX PARTITIONER - PHASE 1) 4.36-1 

4.37 FUNCTIONAL MODULE RBMGl (RIGID BODY MATRIX GENERATOR - PHASE 1) 4.37-1 

4.38 FUNCTIONAL MODULE RBMG2 (RIGID BODY MATRIX GENERATOR - PHASE 2) 4.38-1 

4.39 FUNCTIONAL MODULE RBMG3 (RIGID BODY MATRIX GENERATOR - PHASE 3) 4.39-1 

4.40 FUNCTIONAL MODULE RBMG4 (RIGID BODY MATRIX GENERATOR - PHASE 4) 4.40-1 

4.41 FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 4.41-1 

4.42 FUNCTIONAL MODULE SSG2 (STATIC SOLUTION GENERATOR - PHASE 2) 4.42-1 

4.43 FUNCTIONAL MODULE SSG3 (STATIC SOLUTION GENERATOR - PHASE 3) 4.43-1 

4.44 FUNCTIONAL MODULE SSG4 (STATIC SOLUTION GENERATOR - PHASE 4) 4.44-1 

4.45 FUNCTIONAL MODULE SDRl (STRESS DATA RECOVERY - PHASE 1) 4.45-1 

4.46 FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 4.46-1 

4.47 FUNCTIONAL MODULE DPD (DYNAMICS POOL DISTRIBUTOR) 4.47-1 

4.48 FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 4.48-1 

4.49 FUNCTIONAL MODULE DSMGl (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 1). 4.49-1 

4.50 FUNCTIONAL MODULE SMP2 (STRUCTURAL MATRIX PARTITIONER - PHASE 2) 4.50-1 

4.51 FUNCTIONAL MODULE DSMG2 (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 2). 4.51-1 

4.52 FUNCTIONAL MODULE PLAl (PIECEWISE LINEAR ANALYSIS - PHASE 1) 4.52-1 

4.53 FUNCTIONAL MODULE PLA2 (PIECEWISE LINEAR ANALYSIS - PHASE 2) 4.53-1 

4.54 FUNCTIONAL MODULE PLA3 (PIECEWISE LINEAR ANALYSIS - PHASE 3) 4.54-1 



xvii (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section ^^aejo: 

4.55 FUNCTIONAL MODULE PLA4 (PIECEWISE LINEAR ANALYSIS - PHASE 4) 4,55-1 

4.56 FUNCTIONAL MODULE CASE (SIMPLIFY CASE CONTROL) 4.56-1 

4.57 FUNCTIONAL MODULE MTRXIN (MATRIX INPUT) 4.57-1 

4.58 FUNCTIONAL MODULE GKAD (GENERAL K ASSEMBLER DIRECT) 4.58-1 

4.59 FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 4.59-1 

4.60 FUNCTIONAL MODULE VDR (VECTOR DATA RECOVERY) 4.60-1 

4.61 FUNCTIONAL MODULE FRRD (FREQUENCY RESPONSE - DISPLACEMENT APPROACH) 4.61-1 

4.62 FUNCTIONAL MODULE SDR3 (STRESS DATA RECOVERY - PHASE 3 - S0RT1 to S(3RT2 

PROCESSOR) ^^-62-1 

4.63 FUNCTIONAL MODULE XYTRAN (XY - OUTPUT DATA TRANSLATOR) 4.63-1 

4.64 FUNCTIONAL MODULE RAND0M (RANDOM ANALYSIS MODULE) 4.64-1 

4.65 FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 4.65-1 

4.66 FUNCTIONAL MODULE GKAM (GENERAL K ASSEMBLER MODAL) 4.66-1 

4.67 FUNCTIONAL MODULE DDRl (DYNAMIC DATA RECOVERY - PART 1) 4.67-1 

4.68 FUNCTIONAL MODULE DDR2 (DYNAMIC DATA RECOVERY - PART 2) 4.68-1 

4.69 OUTPUT MODULE XYPL0T (X-Y DATA PLOTTER) 4.69-1 

4.70 OUTPUT MODULE 0FP (OUTPUT FILE PROCESSOR) 4.70-1 

4.71 OUTPUT MODULE MATPRN (GENERAL MATRIX PRINTER) 4.71-1 

4.72 OUTPUT MODULE MATGPR (DISPLACEMENT METHOD MATRIX PRINTER) 4.72-1 

4.73 OUTPUT MODULE MATPRT (MATRIX PRINTER) 4.73-1 

4.74 OUTPUT MODULE SEEMAT (PICTORIAL MATRIX PRINTER) 4.74-1 

4.75 OUTPUT MODULE TABPT (TABLE PRINTER) 4.75-1 

4.76 OUTPUT MODULE PRTMSG (MESSAGE WRITER) 4.76-1 

4.77 OUTPUT MODULE PRTPARM (PARAMETER AND DMAP MESSAGE PRINTER) 4.77-1 

4.78 MATRIX MODULE ADD (ADD TWO MATRICES) 4.78-1 

4.79 MATRIX MODULE MPYAD (MULTIPLY ADD) 4.79-1 

4.80 MATRIX MODULE S(3LVE (SOLVES THE MATRIX EQUATION [A][X] = [B]) 4.80-1 

4.81 MATRIX MODULE DEC0MP (MATRIX DECOMPOSITION) 4.81-1 

4.82 MATRIX MODULE FBS (FORWARD - BACKWARD SUBSTITUTION) 4.82-1 

4.83 MATRIX MODULE PARTN (PARTITION A MATRIX) 4.83-1 

4.84 MATRIX MODULE MERGE (MERGE MATRICES TOGETHER) 4.84-1 



xviii (3/1/70) 



lABLL 01- CONTENTS (Continued) 

Section Page No. 

4.85 MATRIX MODULE TRNSP (TRANSPOSE A MATRIX) 4.85-1 

4.86 MATRIX MODULE SMPYAD (STRING MULTIPLY ADD) 4.86-1 

4.87 STRUCTURAL ELEMENT DESCRIPTIONS 4.87-1 

4.87.1 The RjlD, C0NR0D, and TUBE Elements 4.87-7 

4.87.1.1 Input Data for the R0D, TUBE, C0NR0D Elements 4.87-7 

4.87.1.? Stiffness Matrix Calculation (Subroutines KR0D and 

KTUBE of Module SMAl) 4.87-8 

4.87.1.3 Lumped Mass Matrix Calculation (Subroutines MR0D and MTUBE 

of Module SMA2) 4.87-9 

4.87.1.4 Element Load Calculations (Subroutine EDTL of Module 

SSGl ) 4.87-10 

4.87.1.5 Element Stress Calculations (Subroutines SR0D1 and 

SR0D2 of Module SDR2) 4.87-10 

4.87.1.6 Differential Stiffness Matrix Calculation (Subroutine 

DR0D of Module DSMGl) 4.87-12 

4.87.1.7 Piecewise Linear Analysis Calculations (Subroutine 
PSR0D of Module PLA3 and Subroutine PKR0D of Module 

PLA4) 4.87-14 

4.87.1.8 Coupled Mass Matrix Calculation (Subroutine MCR0D of 

Module SMA2) 4.87-16a 

4.87.2 The BAR Element 4.87-17 

4.87.2.1 Input Data for the BAR Element 4.87-17 

4.87.2.2 Stiffness Matrix Calculation (Subroutine KBAR of 

Module SMAl) 4.87-18 

4.87.2.3 Lumped Mass Matrix Calculation (Subroutine MBAR of 

Modul e SMA2) 4 . 87-25 

4.87.2.4 Element Load Calculation (Subroutine BAR of Module 

SSGl ) 4.87-26 

4.87.2.5 Element Stress Calculations (Subroutines SBARl and 

SBAR2 of Module SDR2) 4.87-27 

4.87.2.6 Differential Stiffness Matrix Calculation (Subroutine 

DBEAM of Module DSMGl) 4.87-29 

4.87.2.7 Piecewise Linear Analysis Calculatioiis (Subroutine 
PSBAR of Module PLA3 and Subroutine PKBAR of Module 

PLA4) 4.87-32 

4.87.2.8 "Consistent" Mass Matrix Calculation (Subroutine 

MCBAR of Module SMA2) 4.87-36 



4.87.3 The SHEAR Panel and TWIST Panel Elements 4, 



xix (3/1/70) 



87-38 



TABLE OF CONTENTS (Continued) 

Section P^ailS^ 

4.87.3.1 Input Data for SHEAR and TWIST Panels 4.87-38 

4.87.3.2 Definition of Element Geometry 4.87-39 

4.87.3.3 Coefficient Generation 4.87-41 

4.87.3.4 Stiffness Matrix Formulation For a SHEAR Panel 

(Subroutine KPANEL of Module SMAl) 4.87-46 

4 87 3.5 TWIST Element Stiffness Matrix Generation (Subroutine 

KPANEL of Module SMAl ) 4.87-47 

4 87.3.6 Mass Matrix Generation (Subroutine MASSTQ of Module 

SMA2) 4.87-48 

4.87.3.7 SHEAR Element Stress and Force Calculations 

(Subroutine SPANLl and SPANL2 of Module SDR2) 4.87-50 

4.87.3.8 TWIST Element Stress and Force Calculations 

(Subroutines SPANLl and SPANL2 of Module SDR2) 4.87-52 

4.87.3.9 SHEAR Panel Differential Stiffness Calculations 

(Subroutine DSHEAR of Module DSGMl) 4.87-54 

4.87.4 TRMEM and QDMEM Elements 4.87-58 

4.87.4.1 Input Data for the TRMEM and QDMEM Elements 4.87-58 

4.87.4.2 Basic Equations for TRMEM 4.87-59 

4.87.4.3 Stiffness Matrix Calculation for TRMEM (Subroutine 

KTRMEM of Module SMAl) 4.87-61 

4.87.4.4 Mass Matrix Calculation for the TRMEM Element 

(Subroutine MASSTQ of Module SMA2) 4.87-62 

4.87.4.5 Element Load Calculations for the TRMEM Element 

(Subroutine TRIMEM of Module SSGl) 4.87-63 

4.87.4.6 Element Stress Calculations for the TRMEM Element 
(Subroutines STRMEl and STQME2 of Module SDR2) 4.87-63 

4.87.4.7 Differential Stiffness Matrix Calculations for the 

TRMEM Element (Subroutine DTRMEM of Module DSMGl) 4.87-67 

4.87.4.8 General Calculations for the QDMEM by the QDMEM 
Driver Routines (Subroutines KQDMEM of Module SMAl, 

SQDMEl of Module SDR2, DQDMEM of Module DSMGl) 4.87-67 

4.87.4.9 Stiffness Matrix Calculations for the QDMEM 4.87-70 

4 87.4.10 Element Stress Calculations for the QDMEM (Subroutine 

SQDMEl and STQME2 of Module SDR2) 4.87-70 

4 87 4.11 Mass Matrix Generation for the QDMEM Element (Subroutine 

MASSTQ of Module SMA2) 4.87-74 

4.87.4.12 Thermal Load Computation for the QDMEM 4.87-76 

4.87.4.13 Differential Stiffness Computations for the QDMEM 
(Subroutines DQDMEM and DTRMEM of Module DSGMl) 4.87-76 



XX (3/1/70) 



Section 



TABLE OF CONTENTS (Continued) 

Page No . 

4.87.4.14 Piecewise Linear Analysis Calculations (Subroutines 
PSTRM and PSQDM of Module PLA3 and Subroutines PKTRM 
PKTRM and PKQDM of Module PLA4) 4.87-76a 

4.87.5 The TRBSC, TRPLT and QDPLT Elements 4.87-78 

4.87.5.1 Input Data for the TRBSC and TRPLT Elements 4.87-78 

4.87.5.2 General Calculation for the TRBSC Element 4.87-79 

4.87.5.3 Stiffness Matrix Calculations for the TRBSC Element 
(Subroutine KTRBSC of Module SMAl) 4.87-84 

4.87.5.4 Stress Calculations for the TRBSC Element 4.87-85 

4.87.5.5 Stiffness Matrix Calculations for the TRPLT Element 
(Subroutine KTRPLT of Module SMAl) 4.87-87 

4.87.5.6 Structural Damping Matrices for the TRPLT Element 4.87-95 

4.87.5.7 Stress and Element Force Calculations for the TRPLT 

Element (Subroutines STRPLl and SBSPL2 of Module SDR2)... 4.87-95 

4.87.5.8 Stiffness Matrix Calculations for the QDPLT Element 
(Subroutine KQDPLT of Module SMAl) 4.87-97 

4.87.5.9 Stress and Element Force Calculations for the QDPLT 

Element (Subroutines SQDPLl and SBSPL2 of Module SDR2)... 4.87-102 

4.87.5.10 Lumped Mass Matrix Generation for the TRBSC, TRPLT, and 

QDPLT Elements (Subroutine MASSTQ of Module SMA2) 4.87-104 

4.87.5.11 Coupled Mass Matrix Calculations for the TRBSC Element 
(Subroutine MTRBSC of Module SMA2) 4.87-104a 

4.87.6 The TRIAl , TRIA2, QUADl and QUAD2 Elements 4.87-106 

4.87.6.1 Input Data for the TRIAl, TRIA2, QUADl and qUAD2 4.87-106 

4.87.6.2 Stiffness Matrix Calculations (Subroutine KTRIQD of 

Module SMAl ) 4.87-107 

4.87.6.3 Lumped Mass Matrix Generation (Subroutine MASSTO of 

Module SMA2) ^ 4_87.io8 

4.87.6.4 Thermal Load Calculations (Subroutine EDTL of Module 

^^'^'^' 4. 87-1 08 

4.87.6.5 Element Stress and Force Calculations (Subroutines 

STRQDl and STRQD2 of Module SDR2) 4.87-108 

4.87.6.6 Differential Stiffness Matrix Calculations 4.87-109 

4.87.6.7 Coupled Mass Matrix Calculations (Subroutine MTRIQD 

of Module SMA2) ; 4.87-109 

4.87.6.8 Piecewise Linear Analysis Calculations (Subroutines 
PSTRIl, PSTRI2. PSQADl, and PSQAD2 of Module PLA3 and 

PKTRIl, PKTRI2, PKQADl and PKQAD2 of Module PLA4) 4 8''-109a 



xxi (3/1/70) 



Section 



TABLE OF CONTENTS (Continued) 

Page No. 

4.87.7 The ELASi , MASSi and DAMPi Elements 4.87-110 

4.87.7.1 Input Data for the ELASi, MASSi and DAMPi Elements 4.87-110 

4 87 7.2 ELASi Stiffness Matrix Generation (Subroutine KELAS 

of Module SMAl) 4.87-110 

4 87 7.3 MASSi Mass Matrix Generation (Subroutine MASSD of 

Module SMA2) '*•"'■ ' ' ' 

4 87 7.4 DAMPi Damping Matrix Generation (Subroutine MASSD of . ^-i ^^^ 

Module SMA2) '^•^'- ' ' ' 

4 87 7 5 ELASi Stress and Force Recovery (Subroutines SELASl and 

SELAS2 of Module SDR2) 4.87-11 1 

4.87.8 Concentrated Mass Elements C0NM1 , C0NM2 4.87-113 

4.87.8.1 ECPT Entries for the C0NM1 Mass Element 4.87-113 

4 87.8.2 Mass Matrix Calculations for the C0NM1 Element 

(Subroutine MC0NMX of Module SMA2) 4.87-113 

4.87.8.3 ECPT Entries for the C0NM2 Mass Element 4.87-114 

4 87 8.4 Mass Matrix Calculations for the C0NM2 Element 

(Subroutine MC0NMX of Module SMA2) 4.87-114 

4.87.9 The C0NEAX Element 4.87-117 

4.87.9.1 Input Data for the C0NEAX Element 4.87-117 

4 87 9 2 Stiffness Matrix Calculations (Subroutine KC0NE of „ o-, m 

Module SMAl) 4.87-11/ 



4 87 9 3 Mass Matrix Computation (Subroutine MC0NE of Module 
smz) 

4.87.9.4 Element Load Calculations (Subroutine C0NE of Module 



SSGl) '^•S^-nS 

4 87 9.5 Element Stress Calculations (Subroutines SC0NE1, SC0NE2, 

SC0NE3 of Module SDR2) 4.87-123 

4 87 9 6 Differential Stiffness Matrix Calculations (Subroutine 

DC0NE of Module DSMGl) 4.87-127a 

4.87.10 The TRIARG Element 4.87-128 

4.87.10.1 Input Data for the TRIARG Element 4.87-128 

4.87.10.2 General Geometric Calculations 4.87-129 

4.87.10.3 Integral Calculations 4.87-130 

4.87.10.4 Elastic Constants Matrix Calculations 4.87-132 

4 87 10.5 Stiffness Matrix Generation (Subroutine KTRIRG of 

Module SMAl) 4.87-133 



xxii (3/1/70) 



TABLE OF CONTEMTS (Continued) 

Section Page No. 

4.87.10.6 Mass Matrix Calculations (Subroutine MTRIRG of 

Module SMA2) 4.87-135 

4.87.10.7 Thermal Load Calculations (Subroutine TTRIRG of 

Module SSGl ) 4.87-136 

4.87.10.8 Element Force and Stress Calculations (Subroutines 

STRIRl and STRIR2 of Module SDR2) 4.87-136 

4.87.11 The TRAPRG Element 4.87-139 

4.87.11.1 Input Data for the TRAPRG Element 4.87-139 

4.87.11.2 General Calculations 4.87-140 

4.87.11.3 Integral Calculations 4.87-142 

4.87.11.4 Elastic Constants Matrix Calculation 4.87-144 

4.87.11.5 Stiffness Matrix Generation (Subroutine KTRAPR of 

Module SMAl) 4.87-144 

4.87.11.6 Mass Matrix Calculation (Subroutine MTRAPR of Module 

Sf-^A2) 4.87-146 

4.87.11.7 Thermal Load Calculations (Subroutine TTRAPR of Module 

SSGl ) 4.87-147 

4.87.11.8 Element Force and Stress Calculations (Subroutines 

STRAPl and STRAP2 of Module SDR2) 4.87-148 

4.87.12 The T0RDRG Element 4.87-152 

4.87.12.1 Input Data for the T0RDRG Element 4.87-152 

4.87.12.2 General Calculations 4.87-153 

4.87.12.3 Integral Calculations 4.87-156 

4.87.12.4 Elastic Constants Matrix Calculations 4.87-160 

4.87.12.5 Stiffness Matrix Calculations (Subroutine KT0RDR of 

Module SMAl ) 4.87-160 

4.87.12.6 Mass Matrix Calculations (Subroutine MT0RDR of Module 

SMA2) 4.87-165 

4.87.12.7 Thermal Load Calculations (Subroutine TTjIRDR of Module 

SSGl ) 4.87-166 

4.87.12.8 Element Force and Stress Calculations (Subroutines 

ST0RD1 and ST0RD2 of Module SDR2) 4.87-168 

4.87.13 The VISC Element 4.87-175 

4.87.13.1 Input Data for the VISC Element 4.87-175 

4.87.13.2 Damping Matrix Calculations (Subroutine BVISC of 

Module SMA2) 4.87-175 



xxiii (3/1/70) 



TABLE OF CONTEMTS (Continued) 

_ ^. Page No. 

Section — '^ 

4.87.14 Integral Calculations for the TRIAR6, TRAPRG Elements 4.87-177 

4.87.14.1 Integral Calculation for q > and any p. (Function 



DKINT), 



4.87-179 



4 87 14.2 Integral Calculation for p > and q < - 1 (Function 

DK89) 4.87-179 

4 87.14.3 Integral Calculation for p < and q < - 1 (Function 

DKIOO) 4.87-180 

4 87.14.4 Integral Calculations for p > - 1 and q = -1 (Function 

DKJAB) 4.87-181 

4 87.14.5 Integral Calculations for p > - 1 and q = -1 (Function 

DK219) 4.87-182 

4.87.14.6 Integral Calculations for p = -1 and q = -1 (Function 

DK211) 4.87-182 

4.88 DETERMINANT METHOD OF EIGENVALUE EXTRACTION 4.88-1 

5. NASTRAN - OPERATING SYSTEM INTERFACES 

5.1 INTRODUCTION ^-^"^ 

5.2 NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 5.2-1 

5.2.1 Introducti on 5.2-1 

5.2.2 Input/Output ^•2"'' 

5.2.3 Link Switching ^-2-3 

5.2.4 Overlay Considerations and Implementation of Open Core 5.2-3 

5.2.5 Execution Deck Setup 5.2-5 

5.2.6 Generation of the NASTRAN Executable System ("Subsysing") 5.2-8 

5.2.7 Machine Dependent Routines 5.2-10 

5.2.8 Flow Charts for the DCS Machine Language GIN0 Routines 5.2-11 

5.2.9 DCS Overlay Diagrams 5.2-30 

5.3 NASTRAN ON THE IBM SYSTEM/360 OPERATING SYSTEM (0S) 5.3-1 

5.3.1 Introduction 5.3-1 

5.3.2 Input/Output 5.3-2 

5.3.3 Link Switching 5.3-2 

5.3.4 Overlay Considerations and Open Core Implementation 5.3-3 

5.3.5 Executi on Deck Setup 5.3-4 

5.3.6 Generation of the NASTRAN Executable System (SUBSYSING) 5.3-9 



xxiv (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section Page No. 

5.3.7 Machine Dependent Routines 5.3-10 

5.3.8 Special Error Codes from NASTRAN on the System/360 5.3-11 

5.4 NASTRAK ON THE UNIVAC 1108 (EXEC 8) 5.4-1 

5.4.1 Introduction 5.4-1 

5.4.2 Inpu t/Ou tpu t 5 . 4_ 1 

5.4.3 Link Switching 5.4-2 

5.4.4 Overlay Considerations and Implementation of Open Core 5.4-3 

5.4.5 Execution Deck Setup 5.4-5 

5.4.6 Generation of the NASTRAN Executable System (Subsysing) 5.4-7 

5.4.7 Machine Dependent Routines 5.4-8 

5.5 NASTRAN ON THE CDC 6400/6600 (SCOPE 3) 5.5-1 

5.5.1 Introduction 5.5-1 

5.5.2 Input/Output 5.5-1 

5.5.3 Layout of Core Storage 5.5-4 

5.5.4 Execution Deck Setup 5.5-6 

5.5.5 Generation of the NASTRAN Executable System 5.5-9 

5.5.6 Machine Dependent Routines 5.5-10 

5.6 THE CDC 5400/6600 LINKAGE EDITOR 5.6-1 

5.6.1 Introduction 5.6-1 

5.6.2 Preparing for Linkage Editor Processing 5.6-6 

5.6.3 Designing an Overlay Program 5.6-7 

5.6.4 Linkage Editor Control Statements 5.6-12 

5.6.5 Examples of Linkage Editor Processing 5.6-23 

5.6.6 Storage Requirements for the Linkage Editor 5.6-29 

6. MODIFICATIONS AND ADDITIONS TO NASTRAN 

6 . 1 INTRODUCTION 6 j . 1 

6.2 F0RTRAN IV LANGUAGE RESTRICTIONS 6.2-1 

6.3 THE EXECUTIVE CONTROL DECK 6.3-1 

6.3.1 The KASTRAN Card 6.3-1 

6.4 THE CASE CONTROL DECK 6.4-1 



XXV (3/1/70) 



TABLE OF CONTENTS (Continued) 

Section Paae_No^ 

6.5 THE BULK DATA DECK 6.5-1 

6.6 RIGID FORMATS ^-^-l 

6.7 FUNCTIONAL MODULES 6-7-1 

6.8 STRUCTURAL ELEMENTS 6.8-1 

6.8.1 IFP (Input File Processor) 6.8-1 

6.8.2 GPl, GP2, 6P3, and TAl (Geometry Processor and Table Assembler 

Modules) 6.8-1 

6.8.3 PLTSET (Plot Set Definition Processor) 6.8-2 

6.8.4 SMAl (Structural Matrix Assembler - Phase 1) 6.8-3 

6.8.5 SMA2 (Structural Matrix Assembler - Phase 2) 6.8-3 

6.8.6 SS61 (Static So'iution Generator - Phase 1) 6.8-3 

6.8.7 SDR2 (Stress Data Recovery - Phase 2) 6.8-3 

6.8.8 DSMGl (Differential Stiffness Matrix Generator - Phase 1) 6.8-4 

6.8.9 PLAl (Piecewise Linear Analysis - Phase 1) 6.8-5 

6.8.10 PLA3 (Piecewise Linear Analysis - Phase 3) 6.8-6 

6.8.11 PLA4 (Piecewise Linear Analysis - Phase 4) 6.8-6 

6.8.12 (JFP (Output File Processor) 6.8-7 

6.9 PRINTED OUTPUT 6.9-1 

6.10 PLOHER OUTPUT 6.10-1 

6.10.1 Changes to the Plotter Software 6.10-1 

6.10.2 Changes to the FLJIT Module, the Structural Plotter 6.10-3 

6.10.3 Changes to the XYPLBIT Module, the XY Plotter 6.10-4 

6.10.4 Changes to the SEEMAT Module, the Matrix Plotter 6.10-4 

6.10.5 Use of the NASTRAN Plotter Software in a New Module 6.10-6 

6.10.6 NASTRAN General Purpose Plotter 6.10-14 

6.11 ADDITION OF A NEW LINK 6.11-1 

6.11.1 Modules to Include 6.11-1 

6.11.2 Addition of New Modules 6.11-1 

6.11.3 Generation of a New Link Specification Table and a New Link 

Driver 6.11-2 

6.11.4 Subsys the New Link 6.11-4 

6.11.5 Increasing the Link Limit 6.11-4 

xxvi (3/1/70) 



PROGRAM OVERVIEW 

1.1 PROGRAM OVERVIEW 

1.1.1 Objectives 

The NASTRAN program has been designed according to two classes of criteria. The first class 
relates to functional requirements for the solution of an extremely wide range of large and com- 
plex problems in structural analysis with high accuracy and computational efficiency. These cri- 
teria are achieved by developing and incorporating the most advanced mathematical models and com- 
putational algorithms that have been proven in practice. In particular, they are achieved by 
providing such features as the bandwidth-with-active-column technique in matrix decomposition; 
packing routines to take maximum advantage of matrix sparsity so as to conserve input/output time; 
highly stable and efficient algorithms for the solution of problems in eigenvalue analysis and 
transient response; and an elegant approach to modeling the effects of control systems and other 
nonstructural components. 

The second class of criteria relates to the operational and organizational aspects of the 

program. These aspects are somewhat divorced from structural analysis itself; yet they are of 

equal importance in determining the usefulness and quality of the program. Chief among these 
criteria are: 

1. Simplicity of problem input deck preparation. 

2. Minimization of chances for human error in problem preparation. 

3. Minimization of need for manual intervention during program execution. 

4. Ease of program modification and extension to new functional capability. 

5. Ease of program extension to new computer configurations and operating systems, and 
generality in ability to operate efficiently under a wide set of configuration capabilities. 

6. Capability for step by step problem solution, without penalty of repeated problem set up. 

7. Capability for problem restart following unplanned interruptions or problem preparation 
error. 

8. Minimization of system overhead, in the three vital areas: 

a. Diversion of core storage from functional use in problem solution. 



1.1-1 



NASTRAN PROGRAMMING FUNDAMENTALS 

b. Diversion of auxiliary storage units from functional to system usage. 

c. System housekeeping time for performing executive functions that do not directly 
further problem solution. 

These criteria are achieved in liASTRAN through modular separation of functional capabilities, 
organized under an efficient, problem-independent Executive System, 

This approach is absolutely essential for any complex multi -operation, multi-file application 
program such as NASTRAN. To see this, one must examine the implications of modularity in program 
organization. 

Any application computer program provides a selection of computational sequences. These are 
controlled by the user through externally provided options and parameter values. Since no user 
will wish to observe the result of each calculation, these options also provide for the selection 
of the data to be output. 

In addition to externally set options, internal switches whose setting depend upon tests 
performed during the calculations will control the computation sequences. There is, therefore, 
a natural separation of computations into functional blocks. The principal blocks are called 
functional modules; modules themselves of course may, and usually must, be further organized on a 
sub-modular basis. 

Despite this separation, however, it is clear that modules cannot be completely independent, 
since they are all directed toward solution of the same general problem. In particular, they 
must intercoirmunicate data among themselves. The principal problem in organizing any application 
program, large or small, is designing the data interfaces between nodules. 

For small programs, the standard techniques are to commuricate data via subroutine calling 
sequences and common data regions in core. For programs that handle larger amounts of data, 
auxiliary storage is used; however, strict specifications of the devices used and of the data 
record formats are usually imposed. 

The penalty paid is that of "side effects". A change in a minor subroutine initiates a 
modification of the data interfaces that propagates through the entire program. When the program 
is small, these effects may not be serious. For a complex program like NASTRAN, however, they 
would be disastrous. 



1.1-2 



PROGRAM OVERVIEW 

This problem has been solved in NASTRAN by a separation of system functions, performed by 
an Executive System, from problem solution functions, accomplished by modules separated strictly 
along functional lines. Each module is independent of all other modules in the sense that 
modification of a module, or addition of a new module, will not in general require modification 
of other modules. Even so, programming constraints on module development do exist but are minor. 
The essential restrictions are: 

1. Modules may Interface with other modules only through auxiliary storage files, as opposed 
to passing information between each other while in core. 

2. Since the availability and allocation of auxiliary files for module execution interact 
with the execution of other modules, no module can specify or allocate files for its input or 
output data. All auxiliary storage allocation is reserved as an Executive function. 

3. Modules operate as independent subprograms, and may not call, or be called by, other 
modules. They may be entered only from the Executive System. 

4. Modules may interface with the Executive System through a parameter table that is 
maintained by the Executive System. User-specified options and parameters are communicated 
to modules in this way. The major line of communication is one-way, from user to Executive 
routine to module. However, in addition, an appreciable two way communication, from module 
back to executive routine (and therefore to other modules) is permitted via the parameter table. 

5. Intra-module parameter communication is format-free in the sense that each module 
defines and orders its own local parameter set internally. Thus each module is 
independent of common data formatting by any other module. 

No other constraints, except those imposed by the resident compilers and operating systems, 
are required for functional modules. 

1,1.2 Program Organization 

Because of the very large size of the NASTRAN program (more than 750 decks and 300 individual 
overlay segments), execution as one physical program was not possible. However, to meet the 
stated design objectives, it was required that NASTRAN appear to the resident operating system as 
one program. 



1.1-3 



NASTRAN PROGRAMMING FUNDAMENTALS 

A program structure evolved which is basically computer independent, although the way in 
which the code structure is supported varies across the computers. 

The NASTRAN program is divided into a series of logical pieces called links. Each link con- 
tains its own root segment (the set of subprograms which is always core resident for that link) 
and its own complete overlay structure. Each link is capable of performing a predefined subset 
of NASTRAN operations. Communication between links occurs through computer files. Control of the 
sequence of execution of the links is performed entirely by the NASTRAN program and requires no 
operator intervention. As a result of this approach, a NASTRAN program execution appears to the 
resident operating system as a normal batch job to be processed in the batch stream. Detailed 
descriptions of the way in which the link structure is implemented on each computer are given 
in section 5. 



1.1-4 



NASTRAM EXECUTIVE SYSTEM 

1.2 NASTRAN EXECUTIVE SYSTEM 
1.2.1 Introduction 

The essential functions of the Executive System are: 

1. Establish and control the sequence of module executions according to options specified 
by the user. 

2. Establish, protect, and communicate values of parameters for each module. 

3. Allocate system files to all data blocks (a data block designates a set of data, matrix 
or table, occupying a file) generated during program execution. A file is "allocated" to a 
data block, and a data block is "assigned" to a file. The general data block I/j) routine 
(GIN0) and the data card conversion routines (XRCARD and RCARD) are considered Input/Output 
utilities and are discussed separately in section 1.6. 

4. Maintain a full restart capability for restoring a program execution after either a 
scheduled or unscheduled interruption. 

The Executive System is open-ended in the sense that it can accommodate an essentially 
unlimited number of functional modules, files, and parameters. Modification of the Executive 
System necessary for change, addition, or extension of functional modules is restricted to 
changes in entries in control tables stored within the Executive routines. 

Program execution is divided into two phases: 1) the Preface, in which modules XCSA, IFPl, 
XS0RT, IFP and XGPI are executed to: a) process the NASTRAN input data deck and b) perform 
general problem initialization; and 2) the program body itself, in which the sequence of program 
operations is controlled by the Operation Sequence Control Array (0SCAR) Executive table, which 
was developed in the XGPI module of the Preface. A diagram of a sample NASTRAN input data deck 
is shown in Figure 1. Note that a NASTRAN input data deck consists of 3 separate decks: 1) the 
Executive Control Deck, 2) the Case Control Deck and 3) the Bulk Data Deck. A detailed descrip- 
tion of the contents of the NASTRAN data deck is given in section 2 of the User's Manual. The 
flow of operations during the Preface is presented in Figure 2. The numbers in the blocks in 
Figure 2 refer to section numbers where more detailed explanations of the subroutines and modules 
can be found. 



1.2-1 



NASTRAN PROGKAMHING FUNDAMENTALS 




Figure 1. Sample NASTRAN input data deck. 



1.2-2 



NASTRAN EXECUTIVE SYSTEM 



(^ ENTER j 


^' 


Generate the Initial File Allocation 
Tables (GNFIAT-3.3.4) 



I 



Read and Analyze the Executive 
Control Deck (XCSA-4.2) 



Process the Case Control Deck 
(IFPl-4.3) 



Sort the Bulk Data Deck 
(XS0RT-4.4) 



Process the Bulk Data Deck 
(IFP-4.5 ) 




Further Process Data Specific to the 
Conical Shell Problem (IFP3-4.6) 



Perform General Problem 
Initialization (XGPI-4.7 ) 



Figure 2. Flow of operations during the Preface. 



1.2-3 



NASTRAN PROGRAMMING FUNDAMENTALS 

1.2.2 Executive Operations During the Preface 

The sequence of Preface operations shown in Figure 2 is controlled by the Sequence Monitor 
Initialization subroutine, SEMINT (see section 3.3.3). Each routine called by SEMINT is dis- 
cussed in the following sections. The numbers in the section headings refer to section numbers 
where more detailed information on the subroutine or module can be found. 

1.2.2.1 Generation of the Initial File Allocation Tables (GNFIAT section 3.3.4) 

Two file allocation tables are maintained by the NASTRAN Executive System. One table, FIAT, 
(see section 2.4) defines the files to which data blocks generated during solution of the problem 
win be allocated. The second table, XFIAT, (see section 2.4) includes files to which permanent 
Executive data blocks, such as the New Problem Tape, the Old Problem Tape, plot tapes, and the 
User's Master File are assigned. 

The New Problem Tape will contain those data blocks generated during the solution that are 
necessary for restarting the problem at any point. The Old Problem Tape contains the data blocks 
saved from some previous execution that may serve to bypass steps in the solution of the new 
problem. The User's Master File is a permanent collection of useful information, such as material 
properties, that may be used to generate input data. 

The generation of the XFIAT and FIAT tables is a computer dependent operation since direct 
Interface with the operating system of the computer must be made. The GNFIAT routine, which 
accomplishes this function, interrogates file tables In the nucleus of the operating system. 
Files which are available for use by the NASTRAN program are reserved, and the unit numbers for 
these files are stored in the NASTRAN file allocation tables. An indication of which units are 
physical tapes is also stored. If the number of files available is insufficient to run the pro- 
blem, an error message Is generated, and the run is aborted. 

1.2.2.2 Analysis of the Executive Control Deck (XCSA Section 4.2) 

The Executive Control Deck Is processed and analyzed by the XCSA Executive Preface module. 
The Executive Control Deck includes cards which describe the nature and type of solution to be 
performed. This Includes an identification of the problem, an estimated time for solution of the 
problem, the approach, a selection of the Rigid Format to be executed or an alternative sequence 
of NASTRAN operations (DMAP) to control the solution, a restart deck from a previous run if the 



1.2-4 



NASTRAN EXECUTIVE SYSTEM 

solution is to be restarted, an indication of any diagnos<Jc printout to be made, a specification 
of whether the problem is to be checkpointed or not, and, if a Rigid Format is selected, any 
desired alterations to that format. Section 2 of the User's Manual should be consulted for the 
formats of, and restrictions on, each of the cards in the Executive Control Deck. The approach 
(APP) card, and the solution (S0L) card, which selects a particular solution (Rigid Format) to be 
executed, are worthy of special note. However, first some introductory definitions are required. 

The sequence of operations to be executed during the program body is written in a data block 
oriented language called DMAP, an acronym for "Direct Matrix Abstraction Program". A DMAP instruc- 
tion is a statement in the DMAP language, a DMAP sequence is a set of DMAP instructions, and a DMAP 
loop is a DMAP sequence to be repeated. A DMAP module is one which is "called" by means of a 
DMAP instruction. 

A Rigid Format consists of: a) a fixed pre-stored DMAP sequence and b) its associated 
restart tables. A Rigid Format performs a specific (structural) problem solution. Section 3 of 
the User's Manual presents the DMAP sequence and the associated restart tables for each Rigid 
Format. 

The APP card of the Executive Control Deck defines the problem solution approach. The APP 
card is required, and there are two options on the APP card: DISPLACEMENT or DMAP. The 501 card 
has the form 

S0L n,m 
where n = Rigid Format number, and m = a subset of the Rigid Format. The S0L card is required if 
the DISPLACEMENT option is chosen on the APP card. The S0L card must not be present in the deck 
if the DMAP option is chosen. 

In addition to using the Rigid Formats provided automatically by NASTRAN, the user may wish 
either to execute a series of modules in a manner different from that provided by the Rigid 
Format, or to perform a series of matrix operations which are not contained in any existing Rigid 
Format. If the modifications to an existing Rigid Format are minor, the ALTER feature described 
in Section 2 of the User's Manual may be employed. Otherwise, a user-written Direct Matrix 
Abstraction Program (DMAP) should be used, in which case the card 

APP DMAP 

must be used. Chapter 5 of the User's Manual discusses DMAP. 



1.2-5 



NASTRAN PROGRAMMING FUNDAMENTALS 

Each of the cards comprising the Executive Control Deck is read via XRCARD (3.4.19) and 
analyzed. Depending on the card. Information is either stored in various Executive tables main- 
tained in core storage or written in the Executive Control Table (2.4.2.5) on the New Problem 
Tape for further processing during the general problem initialization phase (XGPI-4.7) of the 
Preface. Figure 3 presents the format of the Problem Tape. The formats of the New and the Old 
Problem Tapes are identical; only chronology defines their separate functions. 

1.2.2.3 Processing of the Case Control Deck (IFPl Section 4.3) 

The Case Control Deck includes the following classes of cards: selection of specific sets 
of data from the Bulk Data Deck, selection of printed or punched output, definition of subcases, 
definition of structural plots to be made, and definition of XY plots to be made. Section 2 of 
the User's Manual discusses in detail all cards of the Case Control Deck. 

This deck is read via XRCARD (3.4.19) and processed. Information defining set selection, 
output selection and subcase definition is written into the Case Control data block, CASECC. 
Information defining plot requests is written in the Plot Control (PCDB) and XY Control (XYCDB) 
data blocks. 

If the problem is a restart, a comparison with the Case Control Deck from the previous run 
is made. Differences are noted in an Executive restart table, which is used 1n the general pro- 
blem initialization phase (XGPI-4.7) of the Preface. 

1.2.2.4 Sorting of the Bulk Data Deck (XS0RT Section 4.4) 

The function of the XS0RT routine is to prepare a file on the New Problem Tape (see section 
1.2.2.1) which contains the sorted Bulk Data Deck (bulk data). Operation of the routine is 
influenced by the type of run. If the run is a cold start, the bulk data is read from the system 
input file (e.g. card reader) or the User's Master File, sorted, and written on the New Problem 
Tape. If the run is an unmodified restart, (restarts are discussed In section 1.10), the bulk 
data is copied from the Old Problem Tape (see section 1.2.2.1) to the New Problem Tape. If the 
run is a modified restart, the bulk data is read from the Old Problem Tape, and cards are deleted 
and/or added in accordance with cards in the system input stream. The modified bulk data is 
sorted and written on the New Problem Tape. Additionally, any changes in the data are noted in 
the Executive restart table. 

A printed list of the unsorted bulk data is given if requested by an ECH0 card in the Case 
Control Deck. Similarly, the sorted bulk data is echoed on request. 

1.2-6 



NASTRAN EXECUTIVE SYSTEM 



All files begin with an 

eight character (2 word) '' 

BCD header record. 



PROBLEM ID FILE 
(always present) 



ALTER FILE 
(only if ALTER 
cards are present) 



;> 



M0NTH I DAY YEAR 

L^ai 2I9 

REEL # 



E|3F^ 



2^ 



XALTER (header) 



EXECUTIVE C0NTROL TABLE FILE 
(always present) 



^^^^^^^^^^E0F^^^^;>^^ 



_ XCSA (header) _ 



CASE C(3NTR0L FILE 
(always present) 



_ CASECC (header) _ 



BULK DATA CARD FILE 
(always present) 



^EgF 



- BULKDATA (header) - 



first and second fields 
from ID card (BCD) 

-problem date 
-reel sequence no. 



(see section 2.4.2.6) 
ijote : ^denotes BCD blank 

(see section 2.4.2.5) 



(see section 2.3.1 .1) 



PARAMETER VALUE FILE 
(only if PARAM cards ' 
are present) 



CHECKP0INT FILES 
(only if CHKP.JT or 
RESTART card is present) 



PR(JB. TAPE DICT. FILE 
(only if CHECKP0IiiT 
FILES are present) 




_ XPTDIC (header) _ 



bulk data card images 



(see section 2.4.2.4) 



-all checkpointed data blocks 
separated by E0F's 



-always the last file 
(see section 2.4,2.3) 



Figure 3. Problem tape format (same format for Hew Problem Tape and Old Problem Tape), 



1.2-7 



NASTRAN PROGRAMMING FUNDAMENTALS 

Since the collating sequence of alphanumeric characters varies from computer to computer, the 
sort routine converts all characters to an internal code prior to sorting. Following the sort, 
the characters are reconverted. In this way, the collating sequence is computer independent. 

The algorithm used by the sort routine is biased toward the case where the data are in sort 
or nearly in sort. Consequently, Bulk Data Decks which are nearly in sort will be processed 
efficiently by the routine. 

1.2.2.5 Processing of the Bulk Data Deck (IFP Section 4.5) 

The sorted Bulk Data Deck is read card-by-card from the New Problem Tape by the Input File 
Processor (IFP) and converted to internal binary form by RCARD (3.4.20). Each of the cards is 
checked for correctness of format. If any data errors are detected, a message is written, and a 
switch is set to terminate the run at the conclusion of the Preface. Section 2 of the User's 
Manual presents a detailed description of all cards of the Bulk Data Deck. 

Processing of each bulk data card depends on the type of card. All bulk data cards of the 
same type are written into the logical record to which the card type has been assigned. These 
records are organized into data blocks classified according to general categories of use and 
written on prescribed preallocated files. 

1.2.2.6 Processing of Conical Shell Data (IFP3 Section 4.6) 

If the problem is a conical shell problem, further processing of the bulk data specific to the 
conical shell problem is accomplished. The nature of this processing is to convert data for 
the conical shell model into formats of a conventional statics problem. The result is that the 
conical shell problem can be described in a format convenient to the analyst and processed by 
NASTRAN in a format convenient to the program. 

1.2.2.7 General Problem Initialization (XGPI Section 4.7) 

The Executive General Problem Initialization (XGPI) module is the heart of the Preface. Its 
principal function is to generate the Operation Sequence Control Array (0SCAR-2.4.2.1) , which 
defines the problem solution sequence. The 0SCAR consists of a sequence of entries, with each 
entry containing all of the information needed to execute one step of the problem solution. The 
0SCAR is generated from information supplied by the user through his entries in the Executive 
Control Deck, This information is supplied by the S0L card, which points to a Rigid Format, or 
by a user supplied DMAP sequence. 



1,2-8 



NASTRAN EXECUTIVE SYSTEM 

The initial sequence of instructions was written in the Executive Control Table (2.4.2.5) 
on the Mew Problem Tape by the XCSA Preface module. This table is read to initiate assembly of 
the 0SCAR. 

If the problem is a restart, the restart dictionary (contained in the Executive Control 
Table) and the Executive restart table are analyzed to determine which data blocks are needed to 
restart the solution and which operations in the 0SCAR need to be executed to complete the 
solution. Entries in the 0SCAR for operations not required for the current solution are flagged 
for no operation. 

To aid in efficient assignment of data blocks to files, two attributes are computed and 
included with each data block in each entry of the 0SCAR. These attributes are: a) the 0SCAR 
sequence number when the data block is next used (NTU) and b) the 0SCAR sequence number when the 
data block is last used (LTU), Details of the file allocation are discussed in section 1.2.3.3. 

When generation of the 0SCAR is complete, it is written on the Data Pool File (P00L). If 
the problem is a restart, data blocks needed for the current solution are copied from the Old 
Problem Tape to the Data Pool File. 

1.2.3 Executive Operations During Problem Solution 

1.2.3.1 Sequence Monitor (XSEMi Section 3.3.7) 

When the Preface has been completed, solution of the problem is initiated. This solution 
is controlled by the sequence monitor. Figure 4 shows the flow for the sequence monitor. Note 
that there are i copies of XSEMi within NASTRAN, one controlling each link's operation. Section 
1.1.2 defined the necessity for these divisions. 

The sequence monitor reads an entry from the 0SCAR (2.4.2.1) which defines one step in the 
problem solution in terms of: the operation to be performed, data blocks required for input, 
data blocks to be output, scratch files required and parameters used. The File Status Table 
(FIST-2.4.1 .3) , which relates the internal data block reference numbers (see section 1.6.4) to 
the file position in the File Allocation Table (FIAT-2.4.1 .2) , is created by the FIST generator, 
subroutine GNFIST. When the status table is complete, XSEMi moves the parameters required for 
the operation into blank common and calls the requested module (if within the current link) to 
begin the operation. If the requested module is not within the current link, ENDSYS (see section 
3.3.5) is called and the Sequence Monitor within the new link is executed. 

1.2-9 



NASTRAN PROGRAMMING FUNDAMENTALS 



c 



ENTER 



J 



Call SEMINT 
(Preface Only) 



Read next 
0SCAR entry 




Generate FIST for 

Input, 0utput, 
Scratch Data Blocks 



Move Parameters 

from VPS 
to Blank Common 



Call module 



No 



Functional 

or ^ "° 
Output Module? 




No 




Yes 



Call EXEC Routine 
(XCEI, CHKPNT, PURGE 
EQUIV, SAVE) 



Call 
ENDSYS 



Call Message 
Writer 
MSGWRT 



3 



Figure 4. Flow diagram for the sequence monitor, XSEMi, 

1.2-10 



NASTRAN EXECUTIVE SYSTEM 

With the exception of XSFA, the seven routines described in the following subsections are 
Executive modules called directly by XSEMi to perform their specified functions. 

1.2.3.2 FIST Generator (GNFIST Section 3.3.9) 

The FIST generator, subroutine GNFIST, creates the File Status Table (FIST), which contains 
the linkage between the internal data block reference numbers and the actual system files listed 
in the File Allocation Table (FIAT). Each input, output and scratch data block required by the 
forthcoming module is assigned an internal reference number if found to be active in FIAT. A 
data block found to be inactive, that is purged or not generated, will not be assigned a reference 
number. This missing reference number will cause the accessing module to be signaled regarding 
the inactive status. If, during the generation of the FIST, a data block is not found in the 
FIAT, active or inactive, the Executive Segment File Allocator (XSFA) module is called by GNFIST 
to make a file available to the subject data block. 

1.2.3.3 Segment File Allocator (XSFA Section 4.9) 

The Executive Segment File Allocator (XSFA) module, which is called exclusively by GNFIST, 
is the administrative manager of data blocks for NASTRAN. Since, in general, the number of data 
blocks required for solution of a problem far exceeds the number of files available, assignment 
of data blocks to files is a critical operation for efficient execution of NASTRAN. 

The Executive Segment File Allocator module is called whenever a data block is required for 
execution of an operation but is not currently assigned to a file, (i.e., does not appear in the 
FIAT). When the Segment File Allocator is called, it attempts to allocate not just for the data 
block initiating the call, but for as much of the remaining problem solution as possible. This 
allocation depends on the type of problem, the number of files available, and the range of use of 
the remaining data blocks. 

The Segment File Allocator reads entries from the 0SCAR from the point of current operation 
to the end of the problem solution. The FIAT table entries are created in which attributes of 
the data blocks. Including their next use (NTU) and last use (LTU), are stored. Data blocks which 
are currently assigned to files but are no longer required for problem solution are released. 
In certain cases, when the range of use of a data block is large, it may not be possible to 
allocate a file to the data block throughout its range of use. In this case, pooling of the 

1.2-11 



NASTRAN PROGRAMMING FUNDAMENTALS 

data block is required so that the file to which the data block was assigned may be freed for 
another allocation. The next time used (NTU) attribute for a data block is used to efficiently 
pool data blocks. In general, the data block whose next use is the furthest from the current 
point is pooled, that is, copied onto the Data Pool File (POOL). The format of the Data Pool 
File is shown in Figure 5. 

One additional check is made with regard to pooling. The operation of the Segment File 
Allocator itself is less expensive than a pooling operation. Therefore, pooling occurs only 
when the module for which the allocation was required cannot be allocated without pooling. 

When the Segment File Allocator is complete, a new File Allocation Table (FIAT) has been 
generated. This table is used until the solution again reaches a point where a data block is 
required to execute an operation but is not assigned to a file. 

1.2.3.4 Interpretation of Executive Control Entries (XCEI Sections 4.11, 4.12, 4.13, 4.14) 

Executive control entries include the DMAP instructions: REPT, JUMP, C(JND and EXIT. 
Executive control entries in the (8SCAR are processed by the Executive Control Entry Interpreter 
(XCEI). When such an entry is encountered in the 0SCAR, the Control Entry Interpreter Is called 
by XSEMi. If the operation is a jump, conditional jump or repeat, the OSCAR is repositioned 
accordingly. If the operation is an exit, the NASTRAN termination routine PEXIT (3.4.22) is 
called. 

1.2.3.5 Checkpointing Data Blocks (CHKPNT Section 4.10) 

The checkpoint module (DMAP name: CHKPNT; entry point name: XCHK) copies specified data 
blocks required for problem restart onto the New Problem Tape and makes appropriate entries 
in the restart dictionary. This dictionary is also punched onto cards as each new entry is made. 
Thus, in the event of any unscheduled problem interruption, a restart from the last checkpoint 
can be made using the Problem Tape and the restart dictionary from the interrupted run. 

1.2.3.6 Purging a Data Block (PURGE Section 4.16) 

The purge routine (DMAP name: PURGE; entry point name: XPURGE) flags data blocks so that 
they will not be assigned to physical files. This special status provides a means for logically 

suppressing a segment of processing steps requiring the data block. Thus, if the function of a 



1.2-12 



NASTRAN EXECUTIVE SYSTEM 



All files begin with an 
eight character (2 word) 
BCD header record. 




0SCAR FILE 
(always present) ' 



v/////////Amy////m^. 



X0SCAR (header) 



^ - - - 



z 




data blocks from DMI'sandDTI's 
(if present) separated by E0F's 

iiote: ^denotes BCD blank 



(see section 2.4.2.1) 



-*-data blocks pooled by XSFA 
(if necessary) separated by 
E0F's 



Figure 5. Format of the Data Pool File. 



1.2-13 



NASTRAN PROGRAMING FUNDAMENTALS 

module 1s to multiply two matrices and add a third matrix to the product, the addition step might 
be deleted by purging the data block corresponding to the third matrix. 

1.2.3.7 Equlvalencing Data Blocks (EQUIV Section 4.17) 

The equivalence routine (DMAP name: EQUIV; entry point name: XEQUIV) attaches one or more 
equivalent data block names to an existing data block. This special status provides a means of 
logically removing a module function by making a data block input to the module equivalent to a 
data block output from the module. Thus an entire module could be skipped, and an input data 
block "copied" to an output data block without physically moving the data from one file to another. 

1.2.3.8 Saving Parameters (SAVE Section 4.15) 

The save routine (DMAP name: SAVE; entry point name: XSAVE) provides a protection feature 
for the parameters conmunicated between, and used by, the functional modules. All variable para- 
meters are stored within the VPS Executive table (see section 2.4). Prior to each module's 
operation, the subset of parameters required by the module Is moved to blank coinnon. The module 
may use or modify this subset of parameters as desired. When the module terminates operation, 
only those parameters within the subset designated to be saved are restored to the Executive 
table. 



1.2-14 



WORD SIZE AND COMPUTER HARDWARE CONSIDERATIONS 

1.3 WORD SIZE AND COMPUTER HARDWARE CONSIDERATIONS 
1.3.1 Introduct-(on 

Although NASTRAN 1s a F0RTRAN oriented system, considerable effort was required to develop 
programming and word handling techniques applicable to four separate computer configurations. 
These computers exhibit wide differences In their binary word sizes and integer representation 
method. The current computer configurations considered and their significant differences follow: 

1. Computer - IBM 7094/7040 DCS 
Word Size - 36 Bits 

Character Capacity - 6 bits/character and 6 characters/word 
Integer Representation - Sign and Magnitude 

2. Computer - IBM System/360 series 
Word Size - 32 Bits 

Character Capacity - 8 bits/character and 4 characters/word (character 5 byte) 
Integer Representation - Twos complement for negative Integers 

3. Computer - UNIVAC 1108 
Word Size - 36 Bits 

Character Capacity - 6 bits/character and 6 characters/word 
Integer Representation - Ones complement for negative integers 

4. Computer - CDC 6600 
Word Size - 60 Bits 

Character Capacity - 6 bits/character and 10 characters/word. 
Integer Representation - Ones complement for negative integers 

Various Executive routines (e.g., XS0RT (4.4), XRCARD (3.4.19)) that deal directly with 
character strings from the input stream require scirs method of obtaining the above computer 
dependent information. Within the NASTRAN Preface, subroutine BTSTRP (3.3.2) solves an algorithm 
that determines which of the four computers Is currently operating. This algorithm functions by 
Inspecting the word length (by means of shifting and testing) and by checking the negative Integer 
representation method. As a result of these tests, a word (MACH) within the SYSTEM Executive 
table (see section 2.4) is set to indicate the computer type. Since data within BTSTRP defines 
the number of bits-per-word (NBPW), the number cf characters-per-word (NCPW), and the number of 

1.3-1 



NASTRAN PROGRAMMING FUNDAMENTALS 

bits-per-character (NBPC) for each computer type, the correct values for these parameters are also 
stored into the SYSTEM table. This table resides within the NASTRAN root segment and is thus 
accessable to any module or subroutine. 

1.3.2 Alphanumeric Data 

Data stored within a computer as binary-coded-decimal (BCD) characters must be represented 
by the proper hardware defined bit codes. These character codes (and in the case of the IBM 
System/360, the number of bits representing the code) vary among the NASTRAN computer types. 
Although the number of characters-per-word could have been obtained from the SYSTEM table, 
various data blocks and buffers within NASTRAN required firm entry sizes, regardless of computer 
type, to facilitate indexing. For these reasons, the minimum number of characters-per-word (4) 
among the four computer types was chosen as a program design standard. Computer types with a 
word capacity of greater than four characters will have the unused low order character positions 
filled with BCD blanks. 

1.3.3 Word Packing 

Standard FORTRAN compilers do not provide the capability for storing or retrieving data that 
occupies less than a full computer word. Through the Machine Word Functions (MAPFNS, 3.4.1) 
routine some limited word packing (not to be confused with matrix packing) is performed within 
the Executive System and a few utility subroutines. Packing provides an efficient use of memory 
space at the expense of the additional operating time needed to contine or separate the elements 
of the packed words. The Machine Word Function 0RF is generally used for combining elements, 
while ANDF with a suitable mask Is used for separating them. 

1.3.3.1 Examples of Machine Word Functions (MAPFNS) Usage 

Assume three 10-b1t Items of data occupy the low order 10 bits of three separate 30-bit 
computer words (A, B, and C). To pack these three items Into a single 30-b1t word (X), perform 
the following steps using the individual functions available within MAPFNS: 

a) Left shift (LSHIFT) word A, twenty bits 

b) Left shift (LSHIFT) word B, ten bits 

c) Logically add (URF) words A and B; store Into X 



1.3-2 



WORD SIZE AND COMPUTER HARDWARE CONSIDERATIONS 

d)' Logically add {0RF) words X and C; store into X. 

Assume two 8-bit items of data are packed into the left and right halves of a 16-bit word (X). 
To unpack these two items into the low order 8 bits of two separate 16-bit words (A and B), per- 
form the following steps using the individual functions available within MAPFNS: 

a) Create MASK containing 8 low order bits equal to 1 and the 8 high order bits equal to 

b) Right shift (RSHIFT) word X, eight bits; store into A 

c) Logically multiply (ANDF) word X by MASK; store into B. 

In the preceding example, the word X remains unchanged since the functions return the 
requested modified result in a computer register. 



1.3-3 



SYSTEM BLOCK DATA SUBPROGRAM (SEHDBD) 
1.4 SYSTEM BLOCK DATA SUBPROGRAM (SEMDBD) 

NASTRAN contains a master block data program (SEMDBD) which is responsible for defining and 
initializing (root segment) common blocks. The common blocks referenced in SEMDBD are either 
Executive common blocks (XFIAT. XXFIAT, XFIST. etc.) which require initial values, or general 
information common blocks (SYSTEM, NAMES. TYPE, etc.) which are referenced by many modules. The 
source listing for SEMDBD identifies the common blocks, and it docurents the data which are 
initialized, via comments. In aodition, the Executive common blocks are documented in section 2.4 
and the non-Executive common blocks in section 2.5. Certain parameters in these coninon blocks 
contain machine dependent values such as word size, number of BCD characters per word, etc. 
These values are set by subroutine BTSTRP (section 3.3.2) by identifying the machine on which 
the fWSTRAN program is currently operating and setting the values accordingly. 



1.4-1 



THE OPEN CORE CONCEPT 

1.5 THE OPEN CORE CONCEPT 

1.5.1 Introduction 

The design philosophy of the NASTRAN system dictated a completely open ended design whenever 
possible. NASTRAN was to have the flexibility to operate on a second generation machine with a 
32K core (the IBM 7094/7040 DCS) as well as the largest of the IBM S/360 series of computers, and 
take complete advantage of the additional core storage without major program changes. The use of 
a fixed dimension for large arrays was outlawed since this automatically restricted the size of 
a problem that could be solved. Instead, modules were to be programmed to allocate space as 
required and to use spill logic to transfer data to scratch files if complete core allocation was 
impossible. In this manner, a problem might cause spill logic to be used on a computer with 
limited core storage, but not on a computer with a larger core storage capacity. 

1.5.2 Definition of Open Core 

The definition of open core is: a contiguous block of working storage defined by a labeled 
common block whose length 1s a variable determined by the NASTRAN Executive function C0RSZ. The 
implementation of this definition by the module writer consists of the origining of a labeled 
common block at the end of his overlay segment. This labeled coranon block contains a dimensioned 
variable of length 1. C^SRSZ returns the number of words of core available between his open core 
origin and the end of core. The module writer can now write his program as if he had dimensioned 
his array by that number. In actuality, he is extending beyond the area reserved for the array 
into an area reserved for the job but not currently used by the segment. When implementing this 
concept, care must be taken to assure that the system does not use this area. 

1.5.3 Example of an Application of Open Core 

Figure 1 demonstrates the use of open core by two subroutines, A and B. By some means, 
which are machine dependent and are discussed in section 5, an end point is established for open 
core. The length of open core is then the difference between this end point and the labeled 
common block. In the example shown, subroutine A will have more open core available to it than 
B does. 



1.5-1 



NASTRAN PROGKAMMING FUNDAMENTALS 



SUBR0UTINE A 
C0MH(3N // XX 
CiWWP /AX/ Z(l) 
INTEGER C0RSZ 
NZ = C0RSZ(Z(1),XX) 
DO 10 I = 1, NZ 
10 Z(I) = I 
RETURN 
END 



SUBRI8UTINE 3 
C0MM0N // XX 
C0MM0N /BX/ Z(l) 
INTEGER C0RSZ 
NZ = C0RSZ(Z(1).XX) 
D0 10 I = l.NZ 
10 Z(I) = I 
• 
• 

RETURN 
END 



Open core for SUB. A 



Blank common 
establishes the end of 
open core for some 
machines (see section 5) 




Open core for SUB. B 



End of open core 
available for this 
job. 



Figure 1. A example of the use of open core. 



1.5-2 



NASTRAN INPUT/OUTPUT 
1.6 NASTRAN INPUT/OUTPUT 

1.6.1 Introduction 

The particular (IBM 7094. IBM S/360, Univac 1108, CDC 6600) operating systen input and out- 
put files provide the required data connection between NASTRAN. the input data decks and the 
printed output. Utility subroutines XRCARD (section 3.4.19) and RCARD (section 3.4.20) convert 
special NASTRAN input card formats to standard F0RTRAN data words easily handled by all NASTRAN 
input processors. Printed output is generated through F0RTRAN formatted write statements. All 
internal data block input/output is handled by GIN0, the system of NASTRAN general purpose input/ 
output routines. GIN(8 provides the required manipulation to tailor the variable length logical 
data records needed by most NASTRAN modules to fixed length records available on all direct access 
mass storage hardware. 

1.6.2 Use of the Operating System Input File 

The system input file is read only by the following routines within the NASTRAN Preface: 

1. SEMINT (see section 3.3.3) reads the first card and processes it using utility 
XRCARD if it is the NASTRAN card (see section 6.3.1). 

2. The Executive Control Deck containing free-field cards is read and processed by XCSA 
(section 4.2) using the XRCARD utility. 

3. The Case Control Deck containing free-field cards is read and processed by IFPl 
(section 4.3) using the XRCARD utility. 

4. The Bulk Data Deck containing fixed-field cards is read by XS0RT (section 4.4). This 
data is subsequently processed by IFP (section 4.5) using the RCARD utility. 

These card conversion utilities (XRCARD and RCARD) provide respectively all the free-field 
and fixed-field data card processing required by NASTRAN. 

1.6.2.1 Use of the Subroutine XRCARD (See Section 3.4.19) 

XRCARD interprets NASTRAN free-field data cards and processes the fields into a sequential 
buffer that can be easily handled by subsequent modules. Free-field data consist of series of 
data items separated by suitable delimiters and punched in non-specific card columns. Data 
items may include alphanumeric, integer, and various types of real variables. Field delimiters 

1.6-1 (12-1-69) 



NASTRAN PROGRAMMING FUNDAMENTALS 

may include the comma, slash, parenthesis, and blanks. For details regarding data and delimiter 
usage and the format of the sequential output buffer, see the XRCARD subroutine description in 
section 3.4.19. 

1.6.2.2 Use of the Subroutine RCARD (See Section 3.4.20) 

RCARD interprets NASTRAM fixed-field data cards and processes the fields into a sequential 
buffer that can be easily handled by subsequent modules. Fixed-field data consist of data items 
punched within specific card fields. Each eighty-column card is divided into an eight-column 
ID field (for the card mnemonic) followed by either eight eight-column data fields or four 
sixteen-column data fields. A special character (asterisk or plus) within the ID field determines 
when the card is to be interpreted as containing sixteen-column fields. The last eight columns 
of the card are for continuation mnemonics used by XS0RT and are not processed by RCARD. The 
data item within the ID field must be alphanumeric. The data items within all other fields may 
include alphanumeric, integer, and various types of real variables. For c'etails regarding data 
and the format of the sequential output buffer, see the RCARD subroutine description in 
section 3,4.20. 

1.6,3 Use of the Operating Svsten Output File 

Although NASTRAN printed output is formed and placed onto the system output file through 
use of standard F0RTRAN formatted write statements, two basic NASTRAN design concepts prohibit 
every operating module from generating printed output. Firstly, since the F0RTRAN 1/0 package for 
output generation occupies a sizable block of computer memory, this package is generally positioned 
by loader directives within specific output oriented segments, rather than within the root segment 
of the overlay, to reduce the total memory requirement. Secondly, because many functional modules 
generate the same or similar diagnostic and information messages, a NASTRAN message writer (MSGWRT) 
was developed to centralize message text and thus prevent duplications within many separate modules. 

For the reasons previously discussed. NASTRAN output generation is restricted to a specific 
class of modules which can reside within an output oriented segment below the link root segment. 
These segments will contain the output producing modules such as the Output File Processor (i»FP- 
section 4.70). the Message Writer (MSGWRT - section 3.4.26). and the various table and matrix 
printers (TABPT - section 3,4.29, HATPRT - section 4.71, etc.) along with the output titling 
(PAGE - section 3.4,24) and necessary F0RTRAN 1/0 packages. 

1.6-2 



NASTRAN INPUT/OUTPUT 
1.6.4 GINg 

GIN0 is a collection of subroutines which provide for all input and output operations within 
NASTRAN except reading data from the resident system input file and writing data on the resident 
system output and punch files. These latter operations are accomplished through F0RTRAN formatted 
read/write statements. NASTRAN programs perform input/output operations by making the following 
calls to GIN0 entry points: 

1. 0PEN (see section 3.4.2) 

0PEN initiates activity for a file (unless the data block assigned to the file is purged, in 
which case an alternate return is given). A working storage area (GIN(3 buffer), for use by 
GIN0, is assigned (allocated) by the calling program thus providing optimum allocation of 
storage by the calling program. This working storage area is reserved for use by GIN0 until 
activity on the file is terminated by a call to CL0SE (see paragraph 4 below). On each of 
the NASTRAN computers, the working storage area allocated by the calling program is separate 
from the actual physical 1/0 buffer. 

2. WRITE (see section 3.4.3) 

WRITE writes a specified (by the calling program) number of words on a file. The block of 
words to be written may comprise an entire logical record or portion of a logical record. 

3. READ (see section 3.4.5) 

READ returns to the calling program a specified (by the calling program) number of words from 
the logical record at which the file is currently positioned. READ may be used to trans- 
mit an entire logical record or portion of a logical record. 

4. CL0SE (see section 3.4.4) 

CL0SE terminates activity for a file. The working storage area assigned at 0PEN is released. 
The file is repositioned to the load point if requested. 

5. REWIND (see section 3.4.8) 

REWIND repositions the requested file to the load point. The file must be "open", i.e. a 
REWIND operation is requested subsequent to a call to 0PEN and prior to a call to CL0SE. 

6. FWDREC (see section 3.4.6) 

FWDREC repositions the requested file one logical record forward. 

1.6-3 



NASTRAN PROGRAMMING FUNDAMENTALS 

7. BCKREC (see section 3.4.7) 

BCKREC repositions the requested file one logical record backwards. 

8. SKPFIL (see section 3.4.10) 

SKPFIL repositions the requested file forward or backward N logical files where N is specified 
by the calling program. 

9. E0F (see section 3.4.9) 

E0F writes a logical end-of-file on the requested file. 

The basic unit of 1/0 in NASTRAN is a logical record. The length of a logical record is 
completely variable and may range from one word to an arbitrarily large number of words. For 
NASTRAN matrix data blocks, the convention was adopted that each column of the matrix would com- 
prise one logical record. For NASTRAN data blocks containing tables, no rigid convention exists. 
Typically each logical record contains one table of a specific type. 

The logical record concept provides greatest ease in programming. However, since these 
records must be stored on a physical device such as a drum, disk or tape, the characteristics of the 
device must be taken into consideration. The bulk of NASTRAN data is stored on drums or disks. 
For both these devices the common unit of organization is a track, which stores a fixed number 
of words. Thus, there is a conflict between the variable length GIN0 records and the fixed 
length tracks. 

This conflict is resolved by blocking. G:N0 acts as the interface between the device and 
the ilASTRAN program. Using this technique, the program itself need not be concerned with device 
considerations (which would create machine dependent code). GIN0 has been parameterized so that 
different devices may be easily accommodated. 

Basically, blocking provides for the reading and writing of fixed-length blocks. The length 
of a block is a function of the device. It may be one track, one-half track or other integral 
division of a track (but never more than one track). Because of the relatively large time to 
access a given position on a track (due to the rotational speed of the device and/or mechanical 
movement of the head to the track), a block size equal to one full track is the most desirable. 
However, limitations in the amount of storage available to hold the blocks in core is a second 
consideration. 



1.6-4 



NASTRAN INPUT/OUTPUT 

Since logical record lengths are variable but the length of records physically read or 
written is fixed, logic must be provided to accommodate this situation. This logic is provided 
in the GIN0 routine, which allows for the following cases: 

1. Multiple logical records per block 

2. Multiple blocks per logical record 

The method by which physical input and output of blocks is accomplished by GIiM0 is machine 
dependent. On the IBi'l 7094, I0EX is used. On the IBM S/360, F0RTRAN binary read/write statements 
are used. On the Univac 1108, NTRAN is used. On the CDC 6600, SC0PE macros are used. These 
implementation differences are transparent to the NASTRAN applications programmer (functional 
module writer). The systems programmer who is interested in implementation details on the various 
machines is referred to section 5. 

1.6.4.1 GIN0 File Names 

The names of files input as arguments to the GIN0 routines listed above may be alphabetic 
(BCD, of the form 4HXXXX ) or integer. 

A GIN0 file name is BCD if the file contains permanent Executive tables or data blocks. A 

list of these files for a particular NASTRAN run resides in the permanent portion of the FIST 

Executive table. The following list presents all current Executive files with their BCD file 
names: 

Oli BCD File Name 

Data Pool File P|30L 

New Problerr, Tape fjpXP 

Old Problem Tape jjpyp 

BCD Plot Tape PLjl 

Binary Plot Tape PLT2 

User's Master File UUF 

New User's Master File NUMF 

User Input File Ifjpj . 



1.6-5 



NASTRAN PROGRAMMING FUNDAMENTALS 

Functional modules should not access these permanent Executive files. Functional modules 
access the files on which their input, output and scratch data blocks reside by internal integer 
6IN0 file names. Prior to calling a functional module, the link driver routine, XSEMi , calls 
subroutine GNFIST (6NFIST is called exclusively by XSEMi) to generate the FIST Executive table. 
For each input, output or scratch data block required for operation of a module (this information 
being contained in the 0SCAR entry), GNFIST searches the FIAT to find the data block. If the data 
block is in the FIAT and a file has been assigned to it, an internal GIN0 file number denoting the 
data block and a pointer (index) to the entry in the FIAT is placed in the FIST. The following 
convention is used for internal GINi3 file numbers: input data blocks -- 100 + position in the 
USCAR entry; output data blocks -- 200 + position in the 0SCAR entry; scratch data blocks -- 301 
through 300 + n where n = number of scratch data blocks as defined in the MPL. (The position in 
the (JSCAR entry is the position in the DMAP instruction). If the data block is in the FIAT and is 
purged, no entry is placed in the FIST. For example, consider the following DMAP calling sequence 
for functional module XYZ: 

XYZ A,B,C/D,E,F,G/V,N,PARM1/V,N,PARM2 $ 

The data blocks input to the module are A, 3 and C; the data blocks output from the module are 
D, E, F and G; the module's parameters are PARMl and PARM2. Note that internal scratch files are 
not mentioned in the DMAP calling sequence. The number of scratch files for a module is defined 
in the Module Property List (MPL) Executive table (see section 2.4) and is communicated to the 
Executive System via the jJSCAR. Details on the syntactical rules of DMAP are given in section 5 of 
the User's Manual. 

In order to read the input data block B, the GIN0 file number internal to XYZ is 102; in 
order to write data block D, the GIN0 file number is 201. The third of, say, five scratch data 
blocks is referenced by XYZ through the GIN0 file number 303. 



1.6-6 



NASTRAN MATRIX ROUTINES 

1.7 NASTRAN MATRIX ROUTINES 

1.7.1 Introduction 

The requirement that NASTRAN handle large structural analysis problems implies that NASTRAN 
should be able to manipulate and store large matrices efficiently and effectively. In general, 
the matrices generated in the displacement approach tend to be sparse (i.e., the number of non- 
zero terms in any column of a matrix is small compared to the order of the matrix). The NASTRAN 
matrix routines, ADD, MPYAD, DEC0MP, etc., which are described in section 3.5, are optimized as 
much as possible to take advantage of matrix sparsity and thus eliminate many unnecessary operation 
on zero elements. In order to aid in these operations and to make effective use of auxiliary 
storage, a packing scheme was devised to store only the non-zero terms in a column. 

1.7.2 Matrix Packing and Unpacking 

The need for a matrix packing routine can be seen by computing the auxiliary storage required 
to hold a 10,000 order matrix which is 1% dense (i.e., the average number of non-zero terms in 
a column is 100). With no packing technique, 10 words of storage are required to hold the 
matrix. Using the NASTRAN packing routines, a maximum of 2 x 10^ words of storage are required 
if the terms are scattered, and 10 words are required if the terms occur in a band. 

The subroutines BLDPK, INTPK, PACK, and UNPACK, along with their additional entry points, 
provide the matrix packing/unpacking capability of NASTRAN. The user should refer to the des- 
criptions of these subroutines in sections 3.5.1 through 3.5.4 for a detailed description of the 
packing logic. 

Matrices are stored by columns, and subroutines PACK/UNPACK provide the ability to pack/ 
unpack a complete column. The capability is also provided to pack/unpacK a column from the first 
non-zero element to the last. 

An added feature of the packing routines is that subroutines BLDPK and INTPK provide the 
capability of packing/unpacking one element at a time. By use of INTPK, a matrix can be read 
element-by-element, such that an entire matrix can be processed without any appreciable core 
storage requirements. Likewise, by using BLDPK, a matrix can be built one element at a time. This 
is an extremely important feature to routines that must process matrices when storage is limited. 



1.7-1 (12-1-69) 



NASTRAN PROGRAMMING FUNDAMENTALS 
1.7.3 The Nested Vector Set Concept Used to Represent Componen ts of Displacement 

In constructing the matrices used in the Displacement Approach, each row and/or column of a 
matrix is associated closely with a grid point, a scalar point or an extra point. Every grid point 
has 6 degrees of freedom associated with it, and hence 6 rows and/or columns of the matrix. Scalar 
and extra points only have one degree of freedom. At each point (grid, scalar, extra) these degrees 
of freedom can be further classified into subsets, depending on the constraints or handling 
required for particular degrees of freedom. (For example in a two-dimensional problem all "z" 
degrees of freedom are constrained and hence belongs to the s (single-point constraint) set). 
Each degree of freedom can be considered as a "point", and the entire model is the collection of 
these one-dimensional points. 

Nearly all of the matrix operations in displacement analysis are concerned with partitioning, 
merging, and transforming matrix arrays from one subset of displacement components to another. 
All the components of displacement of a given type (such as all points constrained by single-point 
constraints) form a vector set that is distinguished by a subscript from other sets. A given 
component of displacement can belong to several vector sets. The mutually exclusive vector sets, 
the sum of whose members are the set of all physical components of displacements, are as follows: 

u points eliminated by multipoint constraints, 
m "^ 

u points eliminated by single- point constraints, 

u points omitted by structural matrix partitioning, 
"^ 

u points to which determinate reactions are applied in static analysis, 
r 
u the remaining structural points used in static analysis (points left over) . 

u extra degrees of freedom introduced in dynamic analysis to describe control systems etc. 

The vector sets obtained by combining two or more of the above sets are (+ sign indicates 

the union of two sets): 

u = u + u„. the set used in real eigenvalue analysis , 
a r a 

u . = u + u , the set used in dynamic analysis by the direct method. 

u d 6 

u, = u + u , unconstrained ( free ) structural points, 

T 3 

u = u- + u , all structural points net, constrained by multipoint constraints, 
n f s 

u = u + u , all structural (grid) points including scalar points, 
g n m 



1.7-2 



NASTRAN MATRIX ROUTINES 

u - Ug + Ug. all physical points. 

In dynamic analysis, additional vector sets are obtained by a modal transformation derived 
from real eigenvalue analysis of the set u^. These are: 

C rigid body ( zero frequency) modal coordinates, 

5f finite frequency modal coordinates, 

5. = 5 + 5,, the set of all modal coordinates. 

One vector set is defined that combines physical and modal coordinates. That set is 
Uh = Cj + u . the set used In dynamic analysis by the modal method. 

The nesting of vector sets Is depicted by the following diagram: 




The data block USET (USETD In dynamics) is central to this set classification. Each word of 
USET corresponds to a degree of freedom in the problem. Each set is assigned a bit in the word. 
If a degree of freedom belongs to a given set, the corresponding bit is on. Every degree of free- 
dom can then be classified by analysis of USET. The common block /BITP0S/ relates the sets to bit 
numbers. 



1.7-3 



NASTRAN PROGRAMMING FUNDAMENTALS 

Two types of operations occur repeatedly. The first is the partitioning or sort operation. 
Examples are: 




(1) 



and 



nn 



=> 



^f f i hi 
"S'fi'^ss 



(2) 



The second is the recombining (or merge) operation: 



h) ^ -:-: 



(3) 



These operations can be completely described by a "partitioning" vector whose length corresponds 
to the length of the major set (the u set in Equation 1) and whose elements are zeros or ones 
depending on whether a degree of freedom belongs to the upper (the u set in Equation 1) subset 
or the lower (the u set in Equation 1) subset. Such a partitioning vector can be constructed 
by subroutine CALCV, which is described in section 3.5.5. This operation is described throughout 
the documentation by the notation USET (UG.UN.UM) where UG (u ) is the major set, UN (u ) is 
the zero set, and UM (u ) is the one set. The partitioning vector generated by subroutine CALCV 
is input to the matrix routine PARTN (section 3.5.6) to perform operations similar to those in 
Equations 1 and 2 and is input to the matrix routine MERGE (section 3.5,6) to perform operations 
similar to that in Equation 3. 



1.7-4 



GENERATION OF MATRICES 

1.8 GENERATION OF MATRICES 

The Structural Matrix Assembler (SMA) modules generate the stiffness, structural damping, 

mass and damping matrices for the structural model. SMAl generates the stiffness matrix exclusive 

X 4 

of general elements, [Kg^], and the structural damping matrix, [K ]; SMA2 generates the mass 

matrix, [M ], and the damping matrix, [B „]; and SMA3 generates the final stiffness matrix, 

[K ], by generating a matrix for each general element in the model, and successively adding 

these matrices to [K^ ]. Other matrix generation modules are: 1) DSMGl, which generates the 

differential stiffness matrix, [Kg ], for use in the Static Analysis with Differential Stiffness 

Rigid Format and in the Buckling Analysis Rigid Format; 2) PLAl , which generates the stiffness 

matrix for linear elements, [!<„„]. for use in the Pieceivise Linear Analysis Rigid Format; 3) 

n£ 
PLA4, which generates the stiffness matrix for nonlinear elements, [K ], for use in the Piecewise 

Linear Analysis Rigid Format; 4) MTRXIN, which provides a two-fold capability: a) to provide 

for direct input matrices such as control systems in the dynamics Rigid Formats, and b) to provide 

the DMAP user a capability of converting matrices input on DMIG bulk data cards to NASTRAN 

matrix format; and 5) the IFP module which provides the user the capability of converting 

matrices input on DMI bulk data cards to NASTRAN matrix format. Detailed information on each 

of these modules can be found in section 4, Module Functional Descriptions. The central role 

that the ECPT data block plays in the formation of the structural matrices generated in modules 

SI1A1, SMA2, DSMGl, PLAT and PLA4 is explained in the following subsections. 

1.8.1 The ECPT Data Block 

NASTRAN embodies a lumped element approach, i.e., the distributed physical properties of a 
structure are represented by a model consisting of a finite number of idealized substructures 
or elements that are interconnected at a finite number of points. An element will affect terms 
in the matrices only in rows and columns related to its interconnected points. Hence each 
column of these matrices may be formed using only elements connected to the grid or scalar point 
associated with that column. 

The Table Assembler (TAl) module constructs the Element Connection and Properties Table 
(ECPT) data block for use in the generation of these structural matrices. Each record of the 
ECPT corresponds to a grid point or a scalar point of the model, and, conversely, every grid 
point or scalar point of the model corresponds to a record of the ECPT. The point to which a 



1.8-1 



NASTRAN PROGRAMMING FUNDAMENTALS 

record of the ECPT corresponds Is called the pivot point of the record. Each record contains the 
connection and properties data for all elements connected to the pivot point. Hence data for an 
element will appear n times, where n is the number of points defining the element. 

1.8.2 Structural Elements 

The basis for the structural matrices in NASTRAN are the finite structural and scalar elements. 
Each element generates matrix terms connecting and connected to the grid and scalar points given 
on its input connection card (e.g., CR0D) . A structural element generates 6 by 6 matrix parti- 
tions related to the six degrees of freedom of each connecting grid point. A scalar element 
generates one term for each connection. 

The stiffness matrix, [K], for a structural element consists of a 6 by 6 partition for each 
combination of the connected grid points. For example, a BAR or R0D element is connected to two 
grid points, "a" and "b". The stiffness matrix partitions are: [K^^], [K^;^], [Ki^^] and [K^^'j. 
A triangular element (e.g., TRMEM) is connected to three points. It will generate nine partitions: 
t^aa^' t^ab^' ^^ac^' ^K,^,]. [K,,], [K,^], [K^,], [K,,] and [K^^]. 

Although the actual equations for the element stiffness, mass and damping matrices are 
different for each element, the solutions follow a definite pattern. The element connection, 
orientation and property data are given in the ECPT data block. The coordinate system data for 
orienting the global coordinates at each grid point are given in the CSTH data block. The 
material properties are given in the MPT and DIT data blocks. A utility routine, PRETRD, is 
available to fetch coordinate system data, and a utility routine, PREMAT, is available to fetch 
material properties. 

1. An element coordinate system is calculated using the locations of the grid points. 
Using these data a matrix, [E], is formed, which transforms displacements from element 
coordinates to basic coordinates. 

2. The stiffness matrix may be formed in element coordinates using many methods. For the 
simple elements (e.g., R0D) the terms are direct functions of the geometry, properties and 
material coefficients of the element. For some elements the matrix is first formulated in 
terms of generalized coordinates, {q}, usually the coefficients of a power series. In 
general coordinates, the matrix is [K 1. Transformation matrices, [H^], are generated to 



1.8-2 



GENERATIOfJ OF I4ATRICES 

transform the displacements at the grid points in element coordinates {u}, to the general 
coordinates {q}. 

3. The global coordinate system orientation matrix, [T], for each grid point is calculated. 

4. The stiffness matrix partition for the columns related to point j and the rows related to 
point i is [K^ J. In general it is formed by the equation 

[K^j] = [T.f[E][H.f[Kq][Hj][Ef[Tj]. (1) 

In order to generate a particular partition, [K. .], it is often necessary to generate [K]. 

' J 

Only those partitions [l^^,-]> where i is the pivot point and j = 1,2 n (n being the number of 

grid points associated with the element), are useful for the current ECPT record being processed. 
The unused partitions are recalculated and used when j f i appears as a pivot point in a sub- 
sequent ECPT record. An alternate procedure for matrix generation, which is not used, would be 
to calculate all of the element matrices once and store them on an auxiliary file for future use 
when needed. The alternate procedure is less efficient for large problems, where efficiency 
really counts, because the recalculation time is less than the time required to recover element 
matrices from the auxiliary file. 



1.8-3 



TERMINATION PHILOSOPHY AND DIAGNOSTIC MESSAGES 

1,9 TERMINATION PHILOSOPHY AND DIAGNOSTIC MESSAGES 

Certain restrictions are placed upon the functional module writer with regard to run 
termination and error diagnostics. This is necessary in order to complete certain functions 
upon terminating and to maintain uniformity with regard to diagnostic messages. 

A functional module writer is required to utilize a message writer (MSGWRT, section 3.4.26) 
to print all of his messages. In this manner similar message formats do not have to be duplicated 
in each module. Also, in order to avoid placing the 1/0 conversion routines and the lengthy 
format statements in the root segment, the message writer is restricted to its own overlay segment, 
Communication between the module and the message writer is via a queued message concept. 
Subroutine MESAGE (section 3.4,25) is called to store the message parameters. In the case of a 
fatal message, a dump is taken if a DIAG 1 card is present in the Executive Control Deck, and 
PEXIT (section 3.4.22) is called. For non-fatal messages, the message is queued and control 
given back to the user. The message queue is printed after each module is executed. 

In order for any routine to terminate the current execution, a call to PEXIT must be made. 
PEXIT handles all the functions necessary to wrap up the run: flushing output buffers, printing 
queued messages, and punching the last card of the checkpoint dictionary. 



1.9-1 



RESTARTS IN NASTRAN 

1.10 RESTARTS IN NASTRAN 

NASTRAN is designed to run large problems with long running times. Even with the best of 
computer systems, a hardware, operator, or system failure is not uncommon for long running jobs. 
At the same time, the large volumes of data and the complexity of the structures that can be 
modeled and analyzed using NASTRAN make it highly likely that user input data errors will occur. 
Many of these errors are of a subtle type, meaning that they cannot be immediately detected in 
the NASTRAN Preface by the modules which process the data decks. To deal with these problems, and 
to save machine time on runs which abort because of data or system errors, NASTRAN has a sophisti- 
cated checkpoint and restart capability (see section 3 of the User's Manual for a discussion of 
restarts from the user point of view). The overall design philosophy for restart is twofold. A 
restart selectively executes only the modules necessary to accomplish a user-input data change. 
The user is able to change any part of his problem including structural model changes, additional 
cases, or more output requests. At the same time restarts are automatic as far as user interference 
is concerned. The user need only checkpoint (see section 1.2.3.5) his original run and submit 
changes to the original run on subsequent runs. The user does not have to analyze the effect of 
his changes. In addition the selective nature of restart allows the program to proceed with 
implicit errors (errors present in the data but not yet identified) until no further valid progress 
can be made. The work accomplished to this point is not lost, but rather only the table or matrix 
data block in error must be corrected to allow the program to proceed. Much error checking can be 
deferred until the actual module using the data is in control. The remainder of this section will 
explain the program mechanics by which restart is accomplished. 

In NASTRAN there are four general types of restarts. Unmodified Restart (UMR), Psuedo Modified 
Restart (PMR), Modified Restart (MR), and Rigid Format Switch (RFS). Note that in the User's Manual 
UMR's and PMR's are described together as Unmodifed Restarts. These classifications are for des- 
criptive and internal purposes. The user need not know anything about which type is which. The 
basic characteristics of each type will be described below. An Unmodified Restart results when the 
user simply resubmits a problem with no data changes. It is used to continue a solution from the 
point of interruption. Presumably the problem aborted previously due to time expiring, machine 
error, system error, etc. The restart dictionary (created while checkpointing) is processed, and 
the solution is started again at the last re-entry point (after the last successful checkpoint). 
A Psuedo Modified Restart occurs when the user requests additional output from the program which 
simply requires the re-execution of an output module such as the Structure Plotter, the Grid Point 

1.10-1 



NASTRAN PROGRAMMING FUNDAMENTALS 

Weight Generator, or the Stress Data Recovery module etc. The numerical solution is not affected 
by these modules; only output is generated. Note that a PMR is the common case since printer out- 
put, plotter output, etc. is usually requested. A true UMR is rare. On a PMR, output modules are 
re-executed to display requested output, and then the problem is continued at the re-entry point. 
A true Modified Restart occurs when some numerically significant data change. The modules which 
process this type of data must be re-executed. These modules are re-executed to regenerate their 
output data blocks based on the new data, and the problem is continued at the re-entry point. A 
Rigid Format Switch is a special form of Modified Restart in which a problem changes from one 
solution type to another. One example would be: a user has solved for the static solution on 
Rigid Format 1 and now wants to find the normal modes by using Rigid Format 3. This may or may 
not require data changes. The key difference here is that the re-entry point cannot be used to 
determine the proper place to restart. The technique by which a RFS is accomplished is to re- 
execute the final modules on the new Rigid Format and let the File Name Table chain the solution 
back to the proper restart point. 

To understand, in general, how the above types of restart are implemented, it is necessary to 
consider the Module Execution Decision Table (HEDT), which is associated with each Rigid Format. 
The Module Execution Decision Table is a table which has one entry for every DMAP instruction in the 
Rigid Format. Each entry is 5 words long; each word contains 31 bits. For convenience, these bits 
are numbered sequentially from left to right with the numbers 1 through 155. If the entry in the 
MEDT for a module has, say, bit 55 turned on, this module will be executed whenever a card or data 
block change associated with bit 55 occurs on a restart. The Card Name Table associates bits of 
the MEDT with selected bulk data card names. Case Control selections and parameter names. The File 
Name Table associates bits of the MEDT with selected data block names. For consistency, bits 1 
through 62 for each entry in the MEDT are reserved for the Card Name Table, and bits 94 through 
155 are reserved for the File Name Table. The following example illustrates the use of these tables 
in determining the effects of changing a bulk data card on a Modified Restart. Suppose the F0RCE 
bulk data card is to be changed when executing Rigid Format 1, The table in section 3.2.3.1 of 
the User's Manual associates bit 60 with the F0RCE card. The decision table for bits 1 through 62 
is shown in section 3.2.3.3 of the User's Manual. DMAP modules BEGIN, FILE, FILE, GP3, SAVE, PARAt-1, 
PURGE, CHKPNT, SSGl , CHKPNT, EQUIV, etc., will be executed since bit 60 is on for each. 

There is one more table, the Rigid Format Switch Table, which is constant for all Rigid 
Formats, and hence resides in Preface module XCSA. The Rigid Format Switch Table associates with 

1.10-2 



RESTARTS IN NASTRAN 

each Rigid Format a bit for each entry 1n the MEDT: bit 63 is associated with Rigid Format 1, bit 
64 is associated with Rigid Format 2, etc. If the restart involves a Rigid Format change, the bit 
in the decision table which is set is the bit corresponding to the Rigid Format of the previous 
execution. 

Each part of the NASTRAN Preface contributes to processing the information for a restart. 
XCSA extracts and stores the Card Name Table, the File Name Table, the Module Execution Decision 
Table, the DMAP sequence and the Rigid Format Switch bit if any. These are written in the XCSA 
Executive Control Table (see section 2.4.2.5) on the New Problem Tape for later use by module XGPI. 
IFF! compares the current CASECC data block with the one submitted on the previous run (a copy of 
CASECC is stored on the Old Problem Tape for this purpose). Three types of changes are noted by 
IFPl: 

1. Changes in data set selection such as Load set, SPC set, etc.; 

2. The occurence of output requests for printer, plotter, etc.; 

3. Changes in the looping structure of the problem. 

The results of this analysis are stored in common block /IFPXO/. Each bit in /IFPXO/ is associ- 
ated with a key name. These names will appear in some Rigid Format's Card Name Table. /IFPXO/ 
contains one bit for every unique entry in the Card Name Table. /IFPXl/ contains these names 
in order given by /IFPXO/. Thus, bit 135 in /IFPXO/ corresponds to the key word, LiaAD$. If bit 
135 is on (non-zero), the status of L0AD$ has changed on this restart. XS0RT analyzes the bulk 
data card changes in a similar manner, setting the proper bits in /IFPXO/. IFP applies certain 
logical rules to combinations of the bits. XGPI then analyzes this information in the following 
manner. For each bit in /IFPXO/ the BCD equivalent is extracted from /IFPXl/. This mnemonic 
is searched for a match in the Card Name Table. If a match occurs, the appropriate bit in a master 
module execution mask is turned on. After all changes have been processed, the master mask is 
logically multiplied (logical and) with each module execution entry. A non-zero results indicates 
that this mcdule is to be executed. 

All bits in /IFPXO/ are classified as either significant to the solution or as only reflecting 
output requests. If only output request bits are on, a PMR is indicated. If the restart is a 
Modified Restart, one further table look-up may be necessary: the resulting DMAP sequence deter- 
mined from the execution flags of the modules may not have the required input data blocks. (All 

1.10-3 (12-1-69) 



NASTRAN PROGRAMMING FUNDAMENTALS 

input data blocks must first appear as output data blocks). If this should be the case (most often 
caused by switching rigid formats), the File Name Table is consulted to determine which bits are on 
and hence which modules should be re-executed to generate the missing data blocks. The resulting 
DMAP sequence causes the selective execution of only those modules necessary to reflect the data 
changes and complete the requested solution. 



1.10-4 



lUTRODUCTION 

2.1 INTRODUCTION 

This section contains descriptions of a) those NASTRAN data blocks which appear in one or 
more Rigid Formats (section 2.3), b) Executive tables maintained by the NASTRAN Executive System 
(section 2.4), and c) Miscellaneous tables used by more than one module (section 2.5). 

Data blocks that appear in Rigid Formats are structural problem oriented and reside on 
physical files. A file is "allocated" to a data block, and a data block is "assigned" to a file. 
The Executive Segment File Allocator (XSFA) Module is the "administrative manager" of files for 
NASTRAN. 

Executive Tables have true executive functions in the sense that they are not oriented to a 
particular problem solution or even to structural analysis in general. They may be core resident 
or may reside on physical files. 

Miscellaneous tables are common blocks which are used by the Executive System and/or a 
particular class of modules (e.g., /GPTAl/ is used only by modules GPl , GP2, GPS and TAl). 
Common blocks that are used for intra-module communications are documented in section 4, Module 
Functional Descriptions, 

Section 2.2.1 contains an index for data block descriptions sorted on data block names, and 
section 2.2.2 contains an index for data block descriptions sorted on the names of modules from 
which they are output. Alphabetical indexes are given for Executive table descriptions and 
miscellaneous table descriptions at the beginning of sections 2.4 and 2.5 respectively. 



2.1-1 



DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 

2.2 DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 

Data block descriptions have been organized so that all data blocks output from the same 
module are grouped together. The name of each data block 1s given, and the data block is 
classified as a matrix or a table. A data block 1s classified as a matrix only if it Is in 
NASTRAN matrix form, that is, generated by one of the NASTRAN matrix packing routines, PACK or 
BLDPK, the latter having secondary entry points BLDPKI, ZBLPKI and BLDPKN. All other data blocks 
are classified as tebles. 

Following a data block's name and classification is a brief description of its contents, 
followed by its format If it is a table. Since all matrices are In standard [WSTRAN packed 
format a repeated description of the format is unnecessary for matrices. Each data block has a 
header record (consisting in general of two BCD words) which is the alphanumeric name of the data 
block as it appears in a Rigid Format, and this header record 1s designated "Record 0" in table 
formats. For those few data block which contain more than these two BCD words in their header 
record, e.g., SLT, GPTT, DLT, the contents are described explicitly. The conventions used for 
describing the types of words in records of tables are: R Implies real; I implies integer; B 
Implies BCD, four characters per computer word left adjusted with the remaining characters, if 
any, filled with BCD blanks; and L implies a "logical" — not in the F|i)RTRAN sense -- word which 
is a mask of bits, right adjusted. 

There is associated with each data block a six word control block called a trailer. Trailer 
information is "written" by the module which outputs the corresponding data block and can be 
"read" by any module accessing the corresponding data block as Input. If a module "writes" a 
zero trailer for a data block, this implies no data was written In the data block. If a module 
"writes" a non-zero trailer, this implies data was written in the data block. Non-zero trailer 
Information is often used by modules to allocate core storage before reading the corresponding 
data block. Trailer information for each data block is stored in and retrieved from the FIAT 
Executive table (see section 2.4.1.2) by the utility routines WRTTRL (write trailer) and RDTRL 
(read trailer), which are described In section 3.4.16. While residing in the FIAT, a trailer 
is stored in 6 half-words; each half-word consists of 16 binary digits. 

Trailer information is standardized for matrix data blocks, not standardized for table data 
blocks. The format of a matrix trailer is as follows: 



2.2-1 



DATA BLOCK AND TABLE DESCRIPTIONS 

Word 1 » number of columns - N 
Word 2 " number of rows » M 
Word 3 » form » 1 square matrix 

2 rectangular matrix 

3 diagonal matrix |U : l^^^ ^f ^^^ 

4 lower triangular matrix 

5 upper triangular matrix 

6 symmetric matrix 

7 row vector |[| : l^^^^ ^^ ^^^ 

8 Identity matrix 

Word 4 - type - 1 elements of the matrix are real single 
precision 

2 elements of the matrix are real double 
precision 

3 elements of the matrix are complex single 
precision 

4 elements of the matrix are complex double 
precision. 

Word 5 = maximum number of non-zero words (rather than non- 
zero matrix elements) In any one column (e.g., If a real 
double precision matrix Is diagonal and non-zero word 5 • 2) 
Word 6 - not defined 

Word 5 Is dependent upon the structural model and the user's grid point sequencing rather than on 
any Intrinsic property of the matrix and is therefore not described In this report. 

The lower case letters, e.g., g, n, m, s, o. A, etc., used as subscripts designate the sub- 
sets of displacement to which the root symbol (e.g., [K], for a stiffness matrix) applies. The 
reader Is referred to section 3 of the Theoretical Manual and to section 1.7 of the Prograimer's 
Manual for further details. 



2.2-2 



DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 



2.2.1 Index for Data Block Descriptions Sorted on Data Block Names 



Section Number 


Data Block Name 


Output From Module 


Page Number 


2.3.47.2 


AUTU 


RAND0M 


2.3-180 


2.3.2.11 


AXIC 


IFP 


2.3-29 


2.3.18.9 


BAA 


SMPl 


2.3-72 


2.3.41.2 


BDD 


GKAD 


2,3-143 


2.3.17.8 


BFF 


SCEl 


2.3-68 


2.3.10.2 


BGG 


SMA2 


2.3-58 


2.3.3.5 


BGPDT 


GPl 


2.3-34 


2.3.49.2 


BHH 


GKAM 


2.3-183 


2.3.16.4 


BNN 


MCE2 


2.3-66 


2.3.27.7 


BQG 


SDRl 


2.3-85 


2.3.41.8 


B2D0 


GKAD 


2.3-145 


2.3.40.3 


B2PP 


MTRXIN 


2.3-142 


2.3.1.1 


CASECC 


IFPl 


2.3-1 


2.3.39.1 


CASEXX 


CASE 


2.3-141 


2.3.42.2 


CLAMA 


CEAD 


2.3-146 


2.3.50.1 


CPHID 


DDR 


2.3-184 


2.3.27.11 


CPHIP 


SORl 


2.3-86 


2.3.3.4 


CSTM 


GPl 


2.3-33 


2.3.27.9 


DELTAPG 


SDRl 


2.3-86 


2.3.27.10 


DELTAQG 


SDRl 


2.3-86 


2.3.27.8 


DELTAUGV 


SDRl 


2.3-85 


2.3.2.7 


DIT 


IFP 


2.3-21 


2.3.29.7 


DLT 


OPD 


2.3-119 


2.3.21.1 


DM 


RBMG3 


2.3-77 


2.3.2.9 


DYNAMICS 


IFP 


2.3-25 


2.3.8.3 


ECPT 


TAl 


2.3-53 


2.3.34.4 


ECPTNL 


PLAl 


2.3-135 


2.3.38.2 


ECPTNLl 


PLA4 


2.3-140 


2.3.4.1 


ECT 


GP2 


2.3-36 



2.2-3 



DATA BLOCK AND TABLE DESCRIPTIONS 



Section Number 


Data Block Name 


Output From Module 


Page Number 


2.3.2.8 


EDT 


IFP 


2.3-24 


2.3.29.4 


EED 


DPD 


2.3-116 


2.3.5.4 


ELSETS 


PLTSET 


2.3-38 


2.3.2.5 


EPT 


IFP 


2.3-16 


2.3.29.5 


EQDYN 


DPD 


2.3-118 


2.3.3.2 


EQEXIN 


GPl 


2,3-31 


2.3.8.1 


EST 


TA1 


2.3-45 


2.3.34.2 


ESTL 


PLA1 


2.3-132 


2.3.34.3 


ESTNL 


PLA1 


2.3-133 


2.3.37.2 


ESTNL1 


PLA3 


2.3-139 


2.3.2.12 


F0RCE 


IFP 


2.3-30 


2.3.29.9 


FRL 


DPD 


2.3-122 


2.3.8.2 


GEI 


TA1 


2.3-53 


2.3.2.1 


GEjlMl 


IFP 


2.3-7 


2.3.2.2 


GEI9M2 


IFP 


2.3-8 


2.3.2.3 


GE(IM3 


IFP 


2.3-13 


2.3.2.4 


GEI3M4 


IFP 


2.3-15 


2.3.15.1 


GM 


MCE1 


2.3-64 


2.3.41.4 


6MD 


GKAD 


2.3-144 


2.3.18.1 


G0 


SMP1 


2.3-70 


2.3.41.5 


G0D 


GKAD 


2.3-144 


2.3.8.4 


GPCT 


TAl 


2.3-54 


2.3.3.3 


GPDT 


GPl 


2.3-32 


2.3.3.1 


GPL 


GPl 


2.3-31 


2.3.29.1 


GPLD 


DPD 


2.3-114 


2.3.5.3 


GPSETS 


PLTSET 


2.3-37 


2.3.9.3 


GPST 


SMAl 


2.3-56 


2.3.7.2 


GPTT 


GP3 


2.3-44 


2.3.18.2 


KAA 


SMPl 


2.3-70 


2.3.33.2 


KBFS 


DSMG2 


2.3-130 


2.3.33.1 


KBLL 


DSMG2 


2.3-130 


2.3.33.3 


KBSS 


DSMG2 


2.3-130 



2.2-4 



DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 



Section Number 


Data Block Name 


Output From Module 


Page Number 


2.3.32.1 


KDAA 


SMP2 


2.3-129 


2.3.35,3 


KDAAM 


ADD 


2.3-137 


2.3.41.1 


KDD 


GKAD 


2.3-143 


2.3.17.5 


KDFF 


SCEl 


2.3-68 


2.3.17.6 


KDFS 


SCEl 


2.3-68 


2.3.31.1 


KDGG 


DSMGl 


2.3-128 


2.3.16.3 


KDNN 


MCE2 


2.3-65 


2.3.17.7 


KDSS 


SCEl 


2.3-68 


2.3.17.1 


KFF 


SCEl 


2.3-67 


2.3.17.2 


KFS 


SCEl 


2.3-67 


2.3.12.1 


KGG 


SMA3 


2.3-60 


2.3.12.2 


KGGL 


SfW3 


2.3-60 


2.3.38.1 


KGGNL 


PLA4 


2.3-140 


2.3.35.1 


KGGSUM 


ADD 


2.3-137 


2,3.9.1 


KGGX 


SMAl 


2.3-56 


2.3.34.1 


KGGXL 


PLAl 


2.3-132 


2.3.49.3 


KHH 


GKAM 


2.3-183 


2.3.19.1 


KLL 


RBMGl 


2.3-73 


2,3.19.2 


KLR 


RBMGl 


2.3-73 


2.3.16.1 


KNN 


MCE2 


2.3-65 


2.3.18.3 


KI9I3B 


SMPl 


2.3-70 


2.3.19.3 


KRR 


RBMGl 


2.3-73 


2.3.17.3 


KSS 


SCEl 


2.3-67 


2.3.41.6 


K2DD 


GKAD 


2.3-144 


2.3.40,1 


K2PP 


MTRXIN 


2.3-142 


2,3,18.10 


K4AA 


SMPl 


2.3-72 


2.3.17.9 


K4FF 


SCEl 


2.3-69 


2.3.9.2 


K4GG 


SMAl 


2,3-56 


2.3.16.5 


K4NN 


MCE2 


2.3-66 


2,3.30.1 


LAMA 


READ 


2.3-125 


2.3.20,3 


LBLL 


RBMG2 


2.3-75 


2.3.20.1 


LLL 


RBMG2 


2.3-75 



2.2-5 



DATA BLOCK AND TABLE DESCRIPTIONS 



Section Number 


Data Block Name 


Output From Module 


Page Number 


2.3.18.4 


L00 


SHPl 


2.3-70 


2.3.18.6 


MAA 


SHPl 


2.3-71 


2.3.2.10 


MATP00L 


IFP 


2.3-28 


2.3.41.3 


MOD 


GKAD 


2.3-143 


2.3.5.5 


MESSAGE 


PL0T 


2.3-39 


2.3.17.4 


MFF 


SCEl 


2.3-67 


2.3.10.1 


MGG 


SMA2 


2.3-58 


2.3.49.1 


MHH 


GKAM 


2.3-183 


2.3.30.3 


MI 


READ 


2.3-126 


2.3.19.4 


MLL 


RBMGl 


2.3-73 


2.3.19.5 


MLR 


RBMGl 


2.3-74 


2.3.16.2 


MNN 


MCE2 


2.3-65 


2.3.18.8 


M0AB 


SMPl 


2.3-72 


2.3.18.7 


M00B 


SMPl 


2.3-71 


2.3.2.6 


MPT 


IFP 


2.3-20 


2.3.22.1 


MR 


RBMG4 


2.3-78 


2.3.19.6 


MRR 


RBMGl 


2.3-74 


2.3.41.7 


M2DD 


GKAD 


2.3-144 


2.3.40.2 


M2PP 


MTRXIN 


2.3-142 


2.3.29.10 


NLFT 


DPD 


2.3-122 


2.3.28.21 


0BEF1 


SDR2 


2.3-108 


2.3.28.17 


0BES1 


SDR2 


2.3-104 


2.3.28.10 


0BQG1 


SDR2 


2.3-97 


2.3.42.3 


0CEIGS 


CEAD 


2.3-147 


2.3,28.14 


0CPHIP 


SDR2 


2.3-101 


2.3.28.20 


0EFB1 


SDR2 


2.3-107 


2.3.28.22 


0EFC1 


SDR2 


2.3-109 


2.3.45.13 


0EFC2 


SDR3 


2.3-172 


2.3.28.19 


0En 


SDR2 


2.3-106 


2.3.45.5 


0EF2 


SDR3 


2.3-164 


2.3.30.4 


0EIGS 


READ 


2.3-126 



2.2-6 



DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 



Section Number 


Data Block Names 


Output From Module 


Page Number 


2.3.28.16 


0ESB1 


SDR2 


2.3-103 


2.3.28.18 


0ESC1 


SDR2 


2.3-105 


2.3.45.12 


0ESC2 


SDR3 


2.3-171 


2.3.28.15 


0ES1 


SDR2 


2.3-102 


2.3.45.4 


0ES2 


SDR3 


2.3-163 


2.3.14.1 


0GPST 


GPSP 


2.3-63 


2.3.11.1 


0GPUG 


GPMG 


2.3-59 


2.3.37.1 


0NLES 


PLA3 


2.3-139 


2.3.28.5 


0PG1 


SDR2 


2.3-92 


2.3.43.1 


0PHID 


VDR 


2.3-149 


2.3.28.13 


0PHIG 


SDR2 


2.3-100 


2.3.43.5 


0PHIH 


VDR 


2.3-153 


2.3.43.4 


0PNL1 


VDR 


2.3-152 


2.3.45.6 


0PNL2 


SDR3 


2.3-154 


2.3.28.7 


0PPC1 


SDR2 


2.3-94 


2.3.45.9 


0PPC2 


SDR3 


2.3-168 


2.3.28.6 


0PP1 


SDR2 


2.3-93 


2.3.45.1 


0PP2 


SDR3 


2.3-160 


2.3.28.9 


0QBG1 


SDR2 


2.3-96 


2.3.28.8 


0QG1 


SDR2 


2.3-95 


2.3.28.12 


0QPC1 


SDR2 


2.3-99 


2.3.45.10 


0QPC2 


SDR3 


2.3-169 


2.3.28.11 


0QP1 


SDR2 


2.3-98 


2.3.45.2 


0QP2 


SDR3 


2.3-161 


2.3.28.2 


0UBGV1 


SDRl 


2.3-89 


2.3.43.2 


0UDVC1 


VDR 


2.3-150 


2.3.45.14 


0UDVC2 


SDR3 


2.3-173 


2.3.43.3 


0UDV1 


VDR 


2.3-151 


2.3.45.7 


0UDV2 


SDR3 


2.3-166 


2.3.28.1 


0UGV1 


SDR2 


2.3-88 


2.3.43.6 


0UHVC1 


VDR 


2.3-154 



2.2-7 



DATA BLOCK AND TABLE DESCRIPTIONS 



Section Number 


Data Block Name 
0UHVC2 


Output From Module 
SDR3 


Page Number 


2.3.45.15 


2.3-174 


2.3.43.7 


0UHV1 


VDR 


2.3-156 


2.3.45.8 


i3UHV2 


SDR3 


2.3-167 


2.3.28.4 


0UPVC1 


SDR2 


2.3-91 


2.3.45.11 


J3UPVC2 


SDR3 


2,3-170 


2.3.28.3 


0UPV1 


SDR2 


2.3-90 


2.3.45.3 


0UPV2 


SDR3 


2.3-162 


2.3.53.2 


PAF 


DDR2 


2.3-192 


2.3.53.5 


PAT 


DDR2 


2.3-193 


2.3.33.4 


PBL 


DSMG2 


2.3-131 


2.3.33.5 


PBS 


DSMG2 


2.3-131 


2.3.1.2 


PCDB 


IFPl 


2.3-3 


2.3.44.3 


PDF 


FRRD 


2.3-158 


2.3.48.2 


PDT 


TRD 


2,3-181 


2.3.23,1 . 2.3.35.2 PG 


SSGl . AOD 


2,3-79, 2.3-137 


2.3.27.2 


PGG 


SDPl 


2.3-84 


2.3.23,2 


PGl 


SSGl 


2.3-79 


2.3.36.2 


PGVl 


PLA2 


2.3-138 


2.3.30.2 


PHIA 


READ 


2.3-125 


2.3.42.1 


PHID 


CEAD 


2.3-146 


2.3,49.4 


PHIDH 


GKAM 


2,3-183 


2.3.27.4 


PHIG 


SDRl 


2.3-84 


2.3.42.4 


PHIH 


CEAD 


2,3-148 


2.3.24.4 


PL 


SSG2 


2.3-80 


2.3.26.1 


PLI 


SS64 


2.3-83 


2.3.6.1 


PL0TX1 


PL0T 


2.3-40 


2.3.6,2 


PL0TX2 


PL0T 


2.3-40 


2.3,5,2 


PLTPAR 


PLTSET 


2.3-37 


2.3.5.1 


PLTSETX 


PLTSET 


2.3-37 


2.3.48.5 


PNLD 


TRD 


2.3-182 


2.3.48.7 


PNLH 


THD 


2.3-182 


2,3.24.2 


P0 


SSG2 


2,3-80 



2.2-8 



DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 



Section Number 
2.3.26.2 
2.3.44.4 

2.3.28.25 

2.3.48.4 

2.3.24.3 

2,3.47.1 

2.3.29.8 

2.3.44.2 

2.3.48.3 

2.3.28.24 

2.3,28.26 

2.3.28.23 

2.3.27.6 

2.3.27.3 

2.3.36.3 

2.3.27.15 

2.3.27.12 

2.3.24.1 

2,3.13.1 

2.3.25.6 

2.3.25,3 

2.3.25.4 

2.3.3.6 

2.3.29.2 

2.3.7.1 

2,3.29.6 

2.3.29.11 

2.3.27.5 

2.3,20,4 

2.3,25,5 

2,3.33.7 

2.3.53,4 



Data Block Name 
P(3I 
PPF 

PPHIG 

PPT 

PS 

PSDF 

PSDL 

PSF 

PST 

PUBGV1 

PUGV 

PUGV1 

QBG 

QG 

QG1 

QP 

QPC 

QR 

RG 

RUBLV 

RULV 

RU0V 

SIL 

SILD 

SLT 

TFP00L 

TRL 

UBGV 

UBLL 

UBLV 

UB00V 

UEVT 



Output From Module 


Page Number 


SS64 


2.3-83 


FRRD 


2.3-158 


SDR2 


2.3-112 


TRD 


2.3-182 


SSG2 


2.3-80 


RAND0M 


2.3-179 


DPD 


2.3-121 


FRRD 


2.3-158 


TRD 


2.3-181 


SDR2 


2.3-111 


SDR2 


2.3-113 


SDR2 


2.3-110 


SDR1 


2.3-85 


SDR1 


2.3-84 


PLA2 


2.3-138 


SDR1 


2.3-87 


SDR1 


2.3-86 


SSG2 


2.3-80 


GP4 


2.3-61 


SSG3 


2.3-82 


SSG3 


2.3-81 


SSG3 


2.3-81 


GP1 


2.3-35 


DPD 


2.3-11^ 


GP3 


2.3-41 


DPD 


2.3-119 


DPD 


2.3-124 


SDR1 


2.3-85 


RBMG2 


2,3-76 


SSG3 


2,3-82 


DSMG2 


2.3-131 


DDR2 


2.3-192 



2.2-9 



DATA BLOCK AND TABLE DESCRIPTIONS 



Section Number 


Data Block Name 


Output From Module 


Paqe Number 


2.3.44.1 


UDVF 


FRRD 


2.3-158 


2.3.50.2 


UDVIF 


DDRl 


2.3-184 


2.3.53.3 


UDV2F 


DDR2 


2.3-192 


2.3.48.1 


UDVT 


TRD 


2.3-181 


2.3,50.3 


UDVIT 


DDRl 


2.3-184 


2.3.53.6 


UDV2T 


DDR2 


2.3-193 


2.3.53.1 


UEVF 


DDR2 


2.3-192 


2.3.27.1 


UGV 


SDRl 


2.3-84 


2.3.36.1 


UGVl 


PLA2 


2.3-138 


2.3.44.5 


UHVF 


FRRD 


2.3-159 


2.3.48.6 


UHVT 


TRD 


2.3-182 


2.3.20,2 


ULL 


RBMG2 


2,3-75 


2.3.25.1 


ULV 


SSG3 


2.3-81 


2.3.27.14 


UPV 


SDRl 


2.3-87 


2.3.27.13 


UPVC 


SDRl 


2.3-87 


2.3.18.5 


U00 


SHPl 


2.3-71 


2.3.25.2 


U00V 


SSG3 


2.3-81 


2.3.13.3 


USET 


GP4 


2.3-61 


2.3.29.3 


USETD 


DPD 


2.3-115 


2.3.1.3 


XYCDB 


IFPl 


2.3-4 


2.3.46,2 


XYPLTFA 


XYTRAN 


2.3-178 


2.3.46.3 


XYPLTF 


XYTRAN 


2.3-178 


2.3.46.4 


XYPLTR 


XYTRAN 


2.3-178 


2.3.46.1 


XYPLTT 


XYTRAN 


2.3-175 


2.3.46.5 


XYPLTTA 


XYTRAN 


2.3-178 


2.3.33.6 


YBS 


DSMG2 


2,3-131 


2.3.13.2 


YS 


GP4 


2.3-61 



2.2-10 



DATA BLOCK DESCRIPTIONS - GENERAL COMMENTS AND INDEXES 



2.2.2 Index for Data Block Descriptions Sorted Alphabeticany by Module 



Section Number 


Module 


Page Number 


Section Number 


Module 


Page Number 


2.3.35 


ADD 


2,3-137 


2.3.38 


PLA4 


2.3-140 


2.3.39 


CASE 


2.3-141 


2.3.6 


PL0T 


2.3-40 


2.3.42 


CEAD 


2.3-146 


2.3.5 


PLTSET 


2.3-37 


2.3.50 


DDRl 


2.3-184 


2.3.47 


RAND0M 


2.3-179 


2.3.53 


DDR2 


2.3-192 


2.3.19 


RBMGl 


2.3-73 


2.3.29 


DPD 


2.3-114 


2.3.20 


RBMG2 


2.3-75 


2.3.31 


DSMG1 


2.3-128 


2.3.21 


RBMG3 


2.3-77 


2.3.33 


DSM62 


2.3-130 


2.3.22 


RBMG4 


2.3-78 


2.3.44 


FRRD 


2.3-158 


2.3.30 


READ 


2.3-125 


2.3.41 


GKAD 


2.3-143 


2,3.17 


SCEl 


2.3-67 


2.3.49 


GKAM 


2.3-183 


2.3.27 


SDRl 


2.3-84 


2.3.3 


GP1 


2.3-31 


2.3.28 


SDR2 


2.3-88 


2.3.4 


GP2 


2.3-36 


2.3.45 


SDR3 


2.3-160 


2.3.7 


GP3 


2.3-41 


2.3.9 


SMAl 


2.3-56 


2.3.13 


GP4 


2.3-61 


2.3.10 


SMA2 


2.3-58 


2.3.14 


6PSP 


2.3-63 


2.3.12 


SMA3 


2.3-60 


2.3.11 


GPWG 


2.3-59 


2.3.18 


SMPl 


2.3-70 


2.3.2 


IFP 


2.3-5 


2.3.32 


SMP2 


2.3-129 


2.3.1 


IFPl 


2.3-1 


2.3.23 


SSGl 


2.3-79 


2.3.15 


MCEl 


2.3-64 


2.3.24 


SSG2 


2.3-80 


2.3.16 


MCE2 


2.3-65 


2.3.25 


SSG3 


2.3-81 


2.3.40 


MTRXIN 


2.3-142 


2.3.26 


SSG4 


2.3-83 


2.3.34 


PLAl 


2.3-132 


2.3.8 


TAl 


2.3-45 


2.3.36 


PLA2 


2.3-138 


2.3.48 


TRD 


2.3-181 


2.3.37 


PLA3 


2.3-139 


2.3.43 


VDR 


2.3-149 








2.3.46 


XYTRAN 


2.3-175 



2.2-11 



DATA BLOCK DESCRIPTIONS 



2.3 DATA BL0CK DESCRIPTIONS 

2.3.1 Data Blocks Output From Module IFP1 

2.3.1,1 CASECC (TABLE) 
Description 

Case Control Data Table 
Table Format 



Record 

1 



Word 



9 

10 
11 

12 



13 

14 

15 

16 

17 

18 

19 

20 

21 

22 

23 

24 

25 

26 

27 

28 

29 

30 

31 

32 

33 

34 

35 

36 

37 

38 

39 



70 



Type 



Item 



Header record 



Subcase number 

Multipoint constraint set 

Single-point constraint set 

External static load set 

Real eigenvalue extraction set 

Element deformation set 

Thermal load set 

Thermal material set 

Transient initial conditions 

Non-linear load output set 

Output media selection - 1 = print, 4 = punch 

Format of output - 1 = real 

2 = real/imag 

3 = mag/phase 
If word 12 <0, S0RT2 is requested 
Dynamic load set 

Frequency response set 
Transfer function set 
Symmetry flag 

Same as 10-12 for load output 



Same as 10-12 for displacement output 

Same as 10-12 for stress output 

Same as 10-12 for force output 

Same as 10-12 for acceleration output 

Same as 10-12 for velocity output 

Same as 10-12 for forces of constraint output 
Time step set selection for transient problem 

32 words of TITLE 



2.3-1 



DATA BLOCK AND TABLE DESCRIPTIONS 



Record 



Word 
71 



102 
103 



134 
135 
136 

137 

138 

139 

140 

141 

142 

143 

144 

145 

146 

147 

148 

149 

150 

151 

152 

153 

154 

155 

156 

157 

158 

159 

160 

161 

162 

163 

164 

165 

166 

167 



166+LSEM 
167+LSEM 
168+LSEM 
169+LSEM 



169+LSEM+LSET 



Type 

B 

B 

8 
B 

B 

P 
I 
I 

I 
I 
B 
B 



B 

I 



Item 



32 words of SUBTITLE 



32 words of LABEL 

Structure plotter flag 
Axisymmetric set - 2 = COSINE 

1 = SINE 
Number of harmonics to output 
Differential stiffness coefficient set 

Name of K2PP matrix 



} 

\ Name of M2PP matrix 

I Name of B2PP matrix 
OUTPUT frequency set selection 
Not defined 
Not defined 

Complex eigenvalue extraction set 
Structural damping table set 
Inertia relief set (Force method only) 

( Same as 10-12 for solution set displacements 
\ Same as 10-12 for solution set velocities 

Same as 10-12 for solution set accelerations 

Non-linear load set in transient problems 

Delete set (Force method only) 

Not defined 

Random analysis set 

Piecewise linear coefficient set 

Not defined 

Length of symmetry sequence (LSEM) 

Coefficients for symmetry sequence 



Set ID 

Length of the set (LSET) 



Set members 



Note 



The above record is repeated for each subcase and symmetry combination. 



2.3-2 



DATA BLOCK DESCRIPTIONS 



Tab! 


e Trai 


ile 


r 






Word 


1 







Word 


2 


= 


7 




Word 


3 


= 







Word 


4 


= 


7 




Word 


5 


= 







Word 


6 


= 


7 



2.3.1.2 PCDB (TABLE) 
Description 

Plot Control Data Table for the structure plotter. 
Table Format 

Record Item 

Header record 

1 The data here is the XRCARD translation of the Structure Plotter 

Packet cards in the Case Control Deck (See Subroutine Description 
for XRCARD). There is one record for each physical card, 

N 
N+1 End-of-file 

Table Trailer 

Words 1 through 3 are zero 

Word 4 = 7777 

Word 5 and Word 6 are zero 



2.3-3 



DATA BLOCK AND TABLE. DESCRIPTIONS 



2.3.1.3 XYCDB (TABLE) 
Description 

XY Output Control Data Block. 

Record one contains the subroutine IFPIXY interpretations of the XY plot output request 
case control data cards. Record two contains an N by 6 matrix stored by rows and sorted such that 
the columns are in sort left to right. N is the total number of combinations specified by the 
XY-plot-request case control data cards. 



Table Format 
Record 



Word 



Type 










1 


1-Last 


Mi) 


2 


1 






2 






3 






4 






5 






6 





Item 



Header record 



IFPIXY interpretations of the XY-output-requests, 
translated for rapid processing by the XYTRAN 
module. 



Subcase number (0 implies all) 

Vector request type 

Point or element ID 

Component 

XY output type 

Destination code 



repeats 
.for all 
rows 



Notes 



3. 





/ 1 = Displacement 






/ 2 = Velocity 






I 3 = Acceleration 






\ 4 = Single-point forces 


of constraint 




) 5 = Load 




Vector request type = 


( 6 = Stress 
] 7 = Force 
/ 8 = Adisplacement 
I 9 = Avelocity 
\ 10 = Aacceleration 
Ml = Nonlinear Force 

( 1 = Response 




XY output type 


< 2 = PSDF 
{ 3 = AUT0 

/ 1 = Print 
\ 2 = Plot 
3 = Print, plot 




Destination code 


' 4 = Punch 

5 = Print, punch 

6 = Plot, punch 

7 = Print, plot, ounch 





4. Either of records 1 and 2 may be null, however they will always exist. 



Table Trailer 



Words 1-5 
Word 6 



nonzero 
one 



2.3-4 



DATA BLOCK DESCRIPTIONS 

2.3.2 Data Blocks Output From Module IFP . 

Module IFP (Input File Processor, part of the NASTRAN Preface) processes the Bulk Data Deck 
sorted by module XS0RT and writes the following data blocks that appear in one or more Rigid 
Formats: GE0M1, GE0M2. GE0M3, GE0M4, EPT, MPT, DIT, EDT, DYNAMICS, MATP00L. Each one of these 
data blocks has the usual 2-word BCD header record. 

Each of these data blocks contains bulk data card images or modified card images of a subset 
of bulk data card types. Each logical record of each of the above data blocks contains all the 
data of a particular card type. If a card type is not present in the Bulk Data Deck, there is no 
record. For each card type present, 3 words are written as header information for the record. 
Then for every logical bulk data card of that type in the Bulk Data Deck, a card image or a 
modified card image is written sequentially in the record. 

The first two words of the header information of each record are used by entry point L0CATE 
of subroutine PREL0C. The third word of the header information is the card number used by the IFP 
programmer to reference tables internal to the IFP module. 

LflCATE is used by routines that wish to read data blocks outout by the IFP. The second word 
of the header information portion of each record corresponds to a bit position in a 96-bit, 
6-word data block trailer, each word containing 16 bits. If a routine requests L0CATE to locate 
(position the file to) a particular card type, L0CATE will determine i^ the card type is oresent 
by interrogating the corresponding bit in the trailer, the bit number having been supplied through 
the calling sequence to L0CATE. If the bit is zero, the card type is not present and L0CATE 
executes a non-standard RETURN. If the bit is one, the card type is present and L0CATE uses the 
first word of the header information, also supplied through the calling sequence, to find the 
proper logical record (card type). 

Since the Bulk Data Deck is sorted alphabetically before IFP processes it, and since IFP 
processes the deck sequentially, the order of the card types in each data block is alphabetical. 
It should be noted that when two trailer bit numbers are given in the description for a card type, 
this implies that: (1) the card is a "multi-entry" card type (more than one logical card on one 
physical card, e.g., CELAS3, CELAS4, CR0D, CTUBE); (2) these card types may or may not be sorted 
with respect to the primary field, in the above examples element identification; and (3) a module 
accessing these card types must know whether or not they are in sort. If they are in sort, the 
second bit number is set to 0; if they are not in sort, the second bit number is set to 1. 

2.3-5 



DATA BLOCK AND TABLE DESCRIPTIONS 

Card type formats correspond to a typical card entry in the logical record allocated to a 
card type. A number (literal) in a card type format implies that the IFP has placed this number 
in its output buffer before writing the information on the file and that this number is not on the 
bulk data card itself. The mnemonics used in the card type formats correspond to the mnemonics 
in the bulk data card section of the NASTRAN User's Manual. It is advised that anyone using the 
information on the following pages secure a copy of this section of the User's Manual for cross 
reference purposes. 

IFP also generates the AXIC and F0RCE data blocks, the Parameter Value Table (PVT) and writes 
Direct Matrix Input (DMI) and Direct Table Input (DTI) cards on the Data Pool File. The AXIC data 
block, whose presence implies a conical shell (a unique structural element) problem solution, is 
processed by the Preface module IFP3. The F0RCE data block is used in the force method only. The 
PVT, which is an Executive Table and is documented in section 2.4, contains the names and values 
of all parameters input by means of the PARAM bulk data card. The PVT is written on the Problem 
Tape. Each DMI in the Bulk Data Deck is output on the Data Pool File in NASTRAN oacked matrix 
format and is indistinguishable from any matrix data block pooled by the XSFA, that is, a matrix 
trailer is written as the last logical record of the data block. IFP also stores the name o^ each 
DMI in the DPL (see section 2,4). Similarly, each DTI is output on the Data Pool File, a table 
trailer is written, and the name of the DTI is stored in the DPL. 



2.3-6 



DATA BLOCK DESCRIPTIONS 



2.3,2.1 GE0M1 (TABLE) 

Card Types and Header Information : 



Card Type 

C0RD1C 

C0RD1R 

C0RD1S 

C0RD2C 

C0RD2R 

C!3RD2S 

GRID 

SEQGP 



card Type 


Trailer 


■ h't 


Position 


Internal 


Card Number 


1701 




17 






6 


1801 




18 






5 


1901 




19 






7 


2001 




20 






9 


2101 




21 






8 


2201 




22 






10 


4501 




45 






1 


5301 




53 






4 



Card Type Formats : 



C0RD1C (6 words) 


CID 
Gl 


C(JRD1R (6 words) 


CID 
Gl 


C0RD1S (6 words) 


CID 
Gl 


C0RD2C (13 words) 


CID 

RID 

A3 

83 

C3 


C0RD2R (13 words) 


CID 

RID 

A3 

B3 

C3 


CpRD2S (13 words) 


CID 

RID 

A3 

83 

C3 


GRID (8 words) 


ID 
X2 
PS 



2 


1 


G2 


G3 


1 


1 


G2 


G3 


3 


1 


G2 


G3 


2 


2 


Al 


A2 


81 


82 


CI 


C2 


1 


2 


Al 


A2 


Bl 


82 


CI 


C2 


3 


2 


Al 


A2 


81 


82 


CI 


C2 


CP 


XI 


X3 


CD 


F0 





If a GRDSET card is present, and if any of fields 3, 7, 8, 9 of any GRID card are blank, 
IFP will insert corresponding data fields from the GRDSET card. Only one GRDSET card may appear 
in the Bulk Data Deck. 



SEQGP (2 words) 



ID 



SEQID 



2.3-7 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.2.2 GE0M2 (TABLE) 

Card Types and Header Information : 

Card Type 

CBAR 

CDAMPl 

CDAMP2 

CDAMP3 

CDAMP4 

CELAS1 

CELAS2 

C EL AS 3 

CELAS4 

CGENEL 

CMASSl 

CMASS2 

CMASS3 

CMASS4 

C0NM1 

C0NM2 

C0NR0D 

CQDMEM 

CQDPLT 

CQUADl 

CQUAD2 

CQUAD3 

CR0D 

CSHEAR 

CT(3RDRG 

CTRAPRG 

CTRBSC 

CTRIAl 

CTRIA2 

CTRIA3 

CTRIARG 

CTRMEM 

CTRPLT 

CTUBE 

CTWIST 

CVISC 

GENEL 

PLjITEL 

QDSEP 

REACT 

SECL 

SECP 

SEQD 

SEQDBFE 

SETR 

SETRBFE 

SP0INT 



Header Word 1 


Header Word 2 


Header Word 3 


Card Type 


Trailer Bit Position 


Internal Card Number 


2408 


24 


180 


201 


2 


69 


301 


3 


70 


401 


4,92 


71 


501 


5,89 


72 


601 


6 


73 


701 


7 


74 


801 


8,91 


75 


901 


9,88 


76 


2008 


20 


186 


1001 


10 


65 


1101 


11 


66 


1201 


12,93 


67 


1301 


13,90 


68 


1401 


14 


63 


1501 


15 


64 


1601 


16 


47 


2601 


26 


60 


2701 


27 


59 


2801 


28 


57 


2901 


29 


58 


2958 


40 


167 


3001 


30,96 


48 


3101 


31 


61 


1908 


19 


104 


1808 


18 


80 


3201 


32 


54 


3301 


33 


52 


3401 


34 


53 


3458 


41 


114 


1708 


17 


79 


3501 


35 


56 


3601 


36 


55 


3701 


37.95 


49 


3801 


38 


62 


3901 


39,94 


50 


4301 


43 


28 


5201 


52,87 


11 


4808 


48 


108 


5251 


62 


88 


7308 


73 


176 


7408 


74 


177 


7508 


75 


106 


4608 


46 


107 


7608 


76 


170 


4708 


47 


116 


5551 


49 


105 



2.3-8 



DATA BLOCK DESCRIPTIONS 



Card Type Formats : 
CBAR (16 words) 



EID 

GB 

X3 

PB 

Z3A 

Z3B 



PID 

XI 

F 

ZlA 

ZIB 



GA 

X2 

PA 

Z2A 

Z2B 



If a BARIilR card is present in the Bulk Data Deck, and if any of the fields 3, 6, 7, 8, 9 of 
any CBAR card are blank, IFP will insert the corresponding data fields from the BAR0R card. Only 
one BARjIR card may appear in the Bulk Data Deck. 



CDAMPl 


(6 words) 


CDAMP2 


(6 words) 


CDAMP3 


(4 words) 


CDAMP4 


(4 words) 


CELASl 


(6 words) 


CELAS2 


(8 words) 


CELAS3 


(4 words) 


CELAS4 


(4 words) 


CGENEL 




CMASSl 


(6 words) 


CMASS2 


(6 words) 


CMASS3 


(4 words) 


CMASS4 


(4 words) 



EID 
G2 


PID 
CI 


EID 
G2 


B 
CI 


EID 
S2 


PID 


EID 
S2 


B 


EID 
G2 


PID 

CI 


EID 

G2 

GE 


K 

CI 

S 


EID 
S2 


PID 


EID 
S2 


K 


Not available. 




EID 
G2 


PID 
CI 


EID 
G2 


M 
CI 


EID 
S2 


PID 


EID 
32 


M 



Gl 
C2 

Gl 
C2 

SI 



SI 



Gl 
C2 

Gl 
C2 



SI 



SI 



Gl 
C2 

Gl 
C2 

SI 



SI 



2.3-9 



Card Type Formats Cont'd.: 



DATA BLOCK AND TABLE DESCRIPTIONS 



C0NM1 (24 words) 


EID 
Mil 
M31 
M41 
M44 
M53 
M61 
M64 


C0NM2 (13 words) 


EID 

M 

X3 

122 

133 


Ci3NR0D (8 words) 


EID 
MID 
C 


CQDMEM (7 words) 


EID 
G2 

TH 


CQDPLT (7 words) 


EID 

G2 

TH 


CQUAD1 (7 words) 


EID 

G2 

TH 


CQUAD2 (7 words) 


EID 

G2 

TH 


CQUAD3 (7 words) 


EID 

G2 

TH 


CR0D (4 words) 


EID 
G2 


CSHEAR (6 words) 


EID 
G2 


CT0RDRG (7 words) 


EID 

G2 




CTRAPRG (7 words) 


EID 

63 

MID 


CTRBSC (6 words) 


EID 
G2 


CTRIAl (6 words) 


EID 
62 


CTRIA2 (6 words) 


EID 
62 



6 


CID 


M21 


M22 


M32 


M33 


M42 


M43 


M51 


M52 


M54 


M55 


M62 


M63 


M65 


M66 


6 


CID 


XI 


X2 


m 


121 


131 


132 


61 


62 


A 


J 


NSM 




PID 


61 


63 


64 


PID 


61 


63 


64 


PID 


61 


63 


64 


PID 


61 


63 


64 


PID 


Gl 


63 


64 



PID 



61 



PID 
63 


Gl 
64 


PID 
Al 


61 
A2 


61 

G4 


62 
TH 


PID 
63 


Gl 

TH 


PID 
63 


61 
TH 


PID 
63 


61 
TH 



2.3-10 (12-1-69) 



Card Type Formats Cont'd.: 



DATA BLOCK DESCRIPTIONS 



CTRIA3 


1 (6 words) 


EID 
G2 


CTRIARG (6 words) 


EID 






63 


CTRMEM (6 words) 


EID 






G2 


CTRPLT (6 words) 


EID 






G2 


CTUBE 


(4 words) 


EID 
G2 


CTWIST 


(6 words) 


EID 
G2 


CVISC 


(4 words) 


EID 
G2 


GENEL 


(open ended) 


EID 

UI2 

UIM 

M 

UD2 

UDN 

N 

Z22 

Z33 

N 



RID 


Gl 


G3 


TH 


Gl 


G2 


TH 


MID 


PID 


Gl 


G3 


TH 


PID 


Gl 


G3 


TH 



PID 



PID 
G3 

PID 



Gl 



Gl 
G4 

Gl 



S22 



UIl 


CIl 


CI2 


• • • 


CIM 


-1 


UDl 


CDl 


CD2 


• * • 


CDN 


-1 


zn 


Z21 


Z31 


Z32 


• ■ • 


ZMM 


Sll 


S12 


SIN 


S21 


• • ■ 


S2N 


SMI 


SM2 


SMN 





PL0TEL (3 words) 


EID 




Gl 


G2 


QDSEP (3 words) 


SEID 




G 


SPID 


REACT (19 words) 


EID 




G 


FE 




LS 




RID 


VTY 




VID 




Zll 


Z22 




Z33 




Z44 


Z55 




Z66 




SFl 


SF2 




SF3 




SM4 


SMS 




SM6 








SECL 


Not aval 


Table. 






SECP 


Not aval 


lable. 






SEQD (open ended) 


QDTYPE (2 words) 


SEID 


AB 




ABID 




BFE 


TVS 




FE 







EIDl 




EID2 




• • ■ 


EIDN 




-1 









SEQDBFE (3 words) 



SEID 



BFE 



2.3-11 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 



Card Type Formats Cont'd.: 

SETR Not available. 

SETRBFE Not available. 

SP(ilINT (1 word) ID 



2.3-12 



DATA BLOCK DESCRIPTIONS 



2.3.2.3 GE0M3 (TABLE) 

Card Types and Header Information : 
Card Type 



F0RCE 

F0RCE1 

F0RCE2 

GRAV 

L0AD 

M0MENT 

M0MENT1 

M0MENT2 

PL0AD 

PL0AD2 

RF0RCE 

SL0AD 

TEMP 

TEMPO 



Header Word 1 


Header Word 


2 


Header Word 3 


Card Type 


Trailer 


BU 


Position 


Internal Card Number 


4201 




42 






18 


4001 




40 






20 


4101 




41 






22 


4401 




44 






26 


4551 




61 






84 


4801 




48 






19 


4601 




46 






21 


4701 




47 






23 


5101 




51 






24 


6802 




68 






199 


5509 




55 






190 


5401 




54 






25 


5701 




57 






27 


5641 




65 






98 



Card Type Formats : 



F0RCE (7 words) 


SID 

F 

N3 


F0RCE1 (5 words) 


SID 
Gl 


F0RCE2 (7 words) 


SID 

Gl 

G4 


GRAV (6 words) 


SID 

Nl 


LjlAD (open ended) 


SID 
LI 



-1 



M0MENT (7 words) 


SID 

M 

N3 


M0MENT1 (5 words) 


SID 
Gl 


M0MENT2 (7 words) 


SID 

Gl 

G4 


PL0AD (6 words) 


SID 
G2 


PL0AD2 (3 words) 


SID 


RF0RCE (7 words) 


SID 

A 

N3 



G 
Nl 


CID 

N2 


G 
G2 


F 


G 
G2 


F 
G3 


CID 
N2 


G 

N3 


S 
S2 

-1 


SI 
L2 


G 

Nl 


CID 

N2 


G 
G2 


M 


G 
G2 


M 
G3 


P 
G3 


Gl 
G4 


P 


EID 


G 

Nl 


CID 
N2 



2.3-13 



DATA BLOCK AND TABLE DESCRIPTIONS 



Card Type Formats Cont'd.: 

SLI8AD (3 words) 
TEMP (3 words) 
TEMPO (2 words) 



SID 
SID 
SID 



2.3-14 



DATA BLOCK DESCRIPTIONS 



2.3.2.4 GEJIM4 (TABLE) 

Card Types and Header Information : 

Card Type 



MPC 

MPCADD 

0MIT 

|2IMm 

SPC 

SPCl 

SPCADD 

SUPfJRT 



Header Word 1 


h 


leader Word 2 


Header Word 3 


Card Type 


Trai 


ler Bit Position 


Internal Card Number 


4901 




49 


17 


4891 




60 


83 


5001 




50 


15 


4951 




63 


92 


5501 




55 


16 


5481 




58 


12 


5491 




59 


13 


5601 




56 


14 



Card Type Formats : 
MPC (open ended) 



MPCADD (open ended) 
0MIT (2 words) 



SID 

A 

A 

C 

-1 



SID 



ID 



SI 
S_ 



S2 
-1 



Components can be input in any unique combination of digits 1-6. Output format will be ID 
and one digit, the digits for any one entry being in sort. 



Example: 
Output as: 



0MIT1 (open ended) 
SPC (4 words) 
SPCl (open ended) 

SPCADD (open ended) 
SUP0RT (2 words) 



ID 
12 

12 

3 

12 



SID 
D 

SID 
G2 

-1 

SID 



ID 



c 

3516 




1 
12 

6 


12 
5 


G 
G 


G 
-1 


G 


C 


C 


Gl 


SI 
S„ 


S2 
-1 



The note above concerning the 0MIT card applies to the SUP0RT card as well. 



2.3-15 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.2.5 EPT (TABLE) 

Card Types and Header Informati on: 



Card Type 

PBAR 

PC(3NEAX 

PDAMP 

PELAS 

PGENEL 

PMASS 

PQDMEM 

PQDPLT 

PQUADl 

PQUAD2 

PQUAD3 

PR0D 

PSHEAR 

PT0RDRG 

PTRBSC 

PTRIA1 

PTRIA2 

PTRIA3 

PTRMEM 

PTRPLT 

PTUBE 

PTWIST 

PVISC 

SPQDMEM 

SPQDPLT 

SPQUAD1 

SPQUAD2 

SPQUAD3 

SPTRBSC 

SPTRIAl 

SPTRIA2 

SPTRIA3 

SPTRMEM 

SPTRPLT 



Header Word 1 


Header Word 2 


Header Uord 3 


Card Type 


Trailer Bit 


1=051 tion 


Internal Card Number 


52 


20 




181 


152 


19 




147 


202 


2 




45 


302 


3 




46 


352 


26 




187 


402 


4 




44 


502 


5 




41 


602 


6 




40 


702 


7 




38 


802 


8 




39 


852 


49 




168 


902 


9 




29 


1002 


10 




42 


2102 


21 




121 


1102 


11 




35 


1202 


12 




33 


1302 


13 




34 


1352 


24 




115 


1402 


14 




37 


1502 


15 




36 


1602 


16 




30 


1702 


17 




43 


1802 


18 




31 


6302 


63 




111 


6402 


64 




112 


6502 


65 




109 


6602 


66 




110 


6702 


67 




169 


7302 


73 




174 


7402 


74 




171 


7502 


75 




172 


7602 


76 




178 


7702 


77 




173 


7802 


78 




175 



Card Type Formats : 
PBAR (19 words) 



PC0NEAX (24 words) 



PID 


MID 


A 


11 


12 


J 


NSM 


FE 


CI 


C2 


Dl 


02 


El 


E2 


Fl 


F2 


K1 


K2 


112 






ID 


MIDI 


Tl 


MID2 


I 


MID3 


T2 


NSM 


Z1 


Z2 


PHI1 


PHI2 


PHI3 


PHI4 


PHI5 


PHI6 


PHI7 


PHIS 


PHI9 


PHIIO 


PHIll 


PHI12 


PHI13 


PHI14 



PDAMP (2 words) 



PID 



2.3-16 



DATA BLOCK DESCRIPTIONS 



Type Formats Cont'd.: 








PELAS (4 words) 


PID 
S 


K 


GE 


PGENEL 


Not available. 






PMASS (2 words) 


PID 


M 




PQDMEM (4 words) 


PID 
NSM 


MID 


T 


PQDPLT (8 words) 


PID 


MIDI 


I 




MID2 


T 


NSM 




Zl 


Z2 




PQUADl (10 words) 


PID 


MIDI 


Tl 




MID2 


I 


MID3 




T3 


NSM 


Zl 




Z2 






PQUAD2 (4 words) 


PID 
NSM 


MID 


T 


PQUAD3 (62 words) 


SPID 


RA 


TO 




ZAA 


ZBB 


ZAB 




HS 


Z 


All 




A21 


A31 


A41 




A51 


A61 


A12 




A22 


A32 


A42 




A52 


A62 


Zll 




Z22 


Z33 


Z44 




Z55 


Z66 


Z34 




Z12 


Z13 


Z23 




Z45 


Z46 


Z56 




Z35 


Z14 


Z15 




Z16 


Z24 


Z25 




Z26 


Z36 


sun 




SU14 


SU22 


SU25 




SU33 


SU36 


STA 




STB 


SLll 


SL14 




SL22 


SL25 


SL33 




SL36 


SAT 


SBT 




SAC 


SBC 


TAB 




TAN 


TBN 




PR0D (6 words) 


PID 


MID 


A 




J 


C 


NSM 


PSHEAR (4 words) 


PID 

NSM 


MID 


T 


PT0RDRG (4 words) 


PID 
TF 


MID 


TM 


PTRBSC (8 words) 


PID 


MIDI 


I 




MID2 


T 


NSM 




Zl 


Z2 





2.3-17 



DATA BLOCK AND TABLE DESCRIPTIONS 



Card Type Formats Cont'd.: 








PTRIAl (10 words) 


PID 


MIDI 


Tl 




MID2 


I 


MID3 




T3 


NSM 


Zl 




Z2 






PTRIA2 (4 words) 


PID 
NSM 


MID 


T 


PTRIA3 


Not available. 






PTRMEM (4 words) 


PID 
NSM 


MID 


T 


PTRPLT (8 words) 


PID 


MIDI 


I 




MID2 


T2 


NSM 




Zl 


Z2 




PTUBE (5 words) 


PID 


MID 


(JD 




T 


NSM 




PTWIST (4 words) 


PID 
NSM 


MID 


T 


PVISC (3 words) 


PID 


CI 


C2 


SPQDMEM (4 words) 


SPID 
NSM 


MID 


H 


SPQDPLT (8 words) 


SPID 


MIDI 


I 




MID2 


HS 


NSM 




Zl 


Z2 




SPqUADl (10 words) 


SPID 


MIDI 


HI 




MID2 


I 


MID3 




HS 


NSM 


Zl 




Z2 






SPQUAD2 (4 words) 


SPID 
NSM 


MIDI 


H 


SPQUAD3 (62 words) 


SPID 


RA 


TO 




ZAA 


ZBB 


ZAB 




HS 


Z 


All 




A21 


A31 


A41 




A51 


A61 


A12 




A22 


A32 


A42 




A52 


A62 


Zll 




Z22 


Z33 


Z44 




Z55 


Z66 


Z34 




Z12 


Z13 


Z23 




Z45 


Z46 


Z56 




Z35 


Z14 


Z15 




Z16 


Z24 


Z25 




Z26 


Z36 


sun 




SU14 


SU22 


SU25 




SU33 


SU36 


STA 




STB 


SLIT 


SL14 




SL22 


SL25 


SL33 




SL36 


SAT 


SBT 




SAC 


SBC 


TAB 




TAN 


TBN 






2.3-18 (12-1-69) 







DATA BLOCK DESCRIPTIONS 



Card Type Formats Cont'd.: 

SPTRBSC 
SPTRIAl 
SPTRIA2 
SPTRIA3 
SPTRMEM 
SPTRPLT 



Not available. 
Not available. 
Not available. 
Not available. 
Not available. 
Not available. 



2.3-19 



DATA BLOCK AND TABLE DESCRIPTIONS 



Header Word 1 


Header Word 2 


Header Word 3 


Card Type 


Trailer 


Bit Position 


Internal Card Number 


53 




10, 


143 


103 




1 


77 


203 




2 


78 


1403 




14 


122 


503 




5 


90 


703 




7 


91 


803 




8 


102 


1503 




15 


189 


1103 




11 


185 



2.3.2.6 MPT (TABLE) 

Card Types and Header Information : 

Card Type 

DSFACT 

MAT1 

MAT2 

MAT3 

MATS1 

MATTl 

MATT2 

MATT3 

PLFACT 

Card Type Formats : 

DSFACT (open ended) 

MATl (11 words) 



If any one of E, G or NU is blank, it will be computed to satisfy the identity E = 2 (1+NU)G; 
otherwise, values supplied by the user will be used. 

MAT2 (16 words) 



SID 


81 


B2 




B 


-1 




n 




MID 


E 


G 


NU 


RH0 


A 


TREF 


GE 


ST 


SC 


SS 





MAT3 (16 words) 



MATS1 (11 words) 
MATTl (11 words) 
MATT2 (16 words) 
MATT3 (16 words) 
PLFACT (open ended) 



MID 


Gil 


G12 


G13 


G22 


G23 


G33 


m 


A1 


A2 


A12 


TO 


GE 


ST 


SC 


SS 






MID 


EX 


EY 


EZ 


NUXY 


NUYZ 


NUZX 


RHO 


GXY 


GYZ 


GZX 


AX 


AY 


AZ 


TREF 


GE 






MID 


Rl 


R2 


R3 


R4 




RIO 






MID 


Rl 


R2 


R3 


R4 


• • ■ 


RIO 






MID 


Rl 


R2 


R3 


R4 


. . . 


R15 






MID 


Rl 


R2 


R3 


R4 




R15 






SID 


B1 


B2 




B. 


-1 



2.3-20 



DATA BLOCK DESCRIPTIONS 



2.3.2.7 DIT (TABLE) 

Card Types and Header Infonnation : 

Card Type 

TABDMPl 
TABDMP2 
TABDMP3 
TABDMP4 
TABLEDl 
TABLED2 
TABLED3 
TABLED4 
TABLEMl 
TABLEM2 
TABLEM3 
TABLEM4 
TABLES! 
TABRNDl 
TABRND2 
TABRND3 
TABRND4 

Card Type Formats : 

TABDMPl (open ended) 



Header Word 1 


Header Word 2 


Header Mord 3 


Card Type 


Trailer 


Bit Position 


Internal card Number 


15 




21 


162 


25 




22 


163 


35 




23 


164 


45 




24 


165 


no5 




n 


133 


1205 




12 


134 


1305 




13 


140 


1405 




14 


141 


105 




1 


93 


205 




2 


94 


305 




3 


95 


405 




4 


96 


3105 




31 


97 


55 




25 


191 


65 




26 


192 


75 




27 


193 


85 




28 


194 



TABDMP2 (open ended) 



TABDMP3 (open ended) 



TABDMP4 (open ended) 



ID 























fi 


91 


f2 


92 




^ 


9n 


-1 


-1 




ID 


XI 




















fl 


91 


fa 


92 


... 


% 


% 


-1 


-1 




ID 


XI 


X2 

















f. 


9i 


f2 


92 


... 


^ 


% 


-1 


-1 




ID 


XI 


X2 


X3 


X4 











Ao 


Ai 
A„ 


A2 

-1 





2.3-21 



DATA BLOCK AND TABLE DESCRIPTIONS 



Card Type Formats Cont'd.: 

TABLEDl (open ended) 



TABLED2 (open ended) 



TABLED3 (open ended) 



TABLED4 (open ended) 



TABLEMl (open ended) 



TABLEM2 (open ended) 



TABLEM3 (open ended) 



TABLEM4 (open ended) 



ID 























Xi 


yi 


X2 


yz 


... 


\ 


^n 


-1 


-1 




ID 


XI 




















Xi 


yi 


Xa 


y2 


... 


'^n 


yn 


-1 


-1 




ID 


XI 


X2 

















Xl 


yi 


X2 


y2 


... 


''n 


^n 


-1 


-1 




ID 


XI 


X2 


X3 


X4 











Ao 


Ai 


Az 


• • . 


A 


-1 




n 






ID 























Xl 


yi 


X2 


y2 


... 


'^n 


^n 


-1 


-1 




ID 


XI 




















Xl 


yi 


X2 


yz 


... 


'^n 


^n 


-1 


-1 




ID 


XI 


X2 

















Xl 


yi 


X2 


y2 


... 


^n 


^n 


-1 


-1 




ID 


XI 


X2 


X3 


X4 











Ao 


Ai 


A2 


, , 


A„ 


-1 





2.3-22 



DATA BLOCK DESCRIPTIONS 



Card Type Formats Cont'd.: 



TABLESl (open ended) ID 




yi 



-1 



TABRNDl (open ended) ID 






TABRND2 (open ended) ID 




gi 



TABRND3 (open ended) ID 




gi 



TABRND4 (open ended) ID 

X3 

A, 
A_ 


















Xi 


Xi 


ya 


''n 


^n 


-1 



















fl 


f2 


52 


^ 


% 


-1 




XT 














fl 


f2 


92 


^ 


% 


-1 




XI 


X2 











fl 


f2 


92 


f 


9n 


n 


-1 




XI 


X2 


X4 








Ao 


A2 




-1 





2.3-23 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.2.8 EOT (TABLE) 

Card Types and Header Information ; 

Header Word 1 Header Word 2 Header Word 3 

^^^° 'yP^ Card T ype ' Traner&U Position Irternarcard Number 

DEFURM 104 1 8] 

DF^RM 204 2 161 

Card Type Formats : 

DEF0RM (3 words) SID EID D 

DFSIRM (4 words) SID EID FE 

D 



2.3-24 



DATA BLOCK DESCRIPTIONS 



2.3.2.9 DYNAMICS (TABLE) 

Card Types and Header Information : 



Card Type 


Header Word 1 
Card Type 


Header Word 2 
Trailer Bit Position 


Header Word 3 
Internal Card Number 


DAREA 


27 




17 


182 


DELAY 


37 




18 


183 


DLUAD 


57 




5 


123 


DPHASE 


77 




19 


184 


EIGB 


107 




1 


86 


EIGC 


207 




2 


87 


EIGP 


257 




4 


158 


EIGR 


307 




3 


85 


EP0INT 


707 




7 


124 


FREQ 


1307 




13 


126 


FREQl 


1007 




10 


125 


FREQ2 


1107 




11 


166 


N0LIN1 


3107 




31 


127 


N0LIN2 


3207 




32 


128 


N0LIN3 


3307 




33 


129 


N0LIN4 


3407 




34 


130 


RANDPS 


2107 




21 


195 


RANDTl 


2207 




22 


196 


RL0AD1 


5107 




51 


131 


RL0AD2 


5207 




52 


132 


SEQEP 


5707 




57 


135 


TF 


6207 




62 


136 


TIC 


6607 




66 


137 


TL0AD1 


7107 




71 


138 


TL0AD2 


7207 




72 


139 


TSTEP 


8307 




83 


142 


Card Type Formats: 











DAREA {4 words) 

DELAY (4 words) 
DL0AD (open ended) 



DPHASE (4 words) 
EIGB (18 words) 



SID 


P 


C 


A 






SID 


P 


c 


T 






SID 


s 


SI 


LI 


S2 


L2 


■ • • 


s„ 


L 




n 


n 


-1 


-1 




SID 


P 


c 


TH 






SID 


METHOD (2 words) 


LI 


L2 


NEP 


NOP 


NDN 


E 


N0RM (2 words) 


G 


C 






















2.3-25 



DATA BLOCK AND TABLE DESCRIPTIONS 



Card Type Formats Cont'd.: 
EIGC (open ended) 



EIGP (4 words) 
EIGR (18 words) 



EP0INT (1 word) 
FREQ (open ended) 

FREQl (4 words) 
FREQ2 (4 words) 
NULINl (8 words) 

N0LIN2 (8 words) 

N0LIN3 (8 words) 

N0LIN4 (8 words) 



SID 
G 

"'ai 

'%! 
^d> 

%z 
^e. 
«an 
"bn 



METH0D (2 words) N0RM (2 words) 
C E 



ai 



az 

an 

^n 
-1 



a 2 



"bn 

^en 
-1 



"dn 






-1 


-1 


-1 


-1 


-1 




SID 


a 


OJ 


M 






SID 


METH(JD (2 words) 


Fl 


F2 


NE 


ND 


NZ 


E 


N0RM (2 words) 


G 


C 





















ID 






SID 


F 


F 


F 


• • ■ 


F 


-1 






SID 


Fl 


DF 


NDF 






SID 


Fl 


F2 


NF 






SID 


GI 


CI 


S 


GJ 


CJ 


T 







SID 


GI 


CI 


S 


GJ 


CJ 


GK 


CK 




SID 


GI 


CI 


S 


GJ 


CJ 


A 







SID 


GI 


CI 


S 


GJ 


CJ 


A 








2.3-26 



data block descriptions 



Card Type Formats Cont'd.: 








RANDPS (6 words) 


SID 
X 


J 
Y 


K 
TID 


RANDTl (4 words) 


SID 
TMAX 


N 


TO 


RLCIADI (6 words) 


SID 

N 


L 
TC 


M 
TD 


RL0AD2 (6 words) 


SID 
N 


L 
TB 


M 
TP 


SEQEP (2 words) 


ID 


SEQID 




TF (open ended) 


SID 

BO 

G(l) 

Aid) 

C(2) 

A2(2) 

C(N) 

A2(N) 

-1 


GD 
Bl 

c(i) 

A2(l) 
A0(2) 

A0(N) 

-1 

-1 


CD 

B2 

A0(1) 

G(2) 

A1(2) 

G(N) 

A1(N) 

-1 

-1 


TIC (5 words) 


SID 
UO 


G 
VO 


C 


TL0AD1 (5 words) 


SID 




L 
TF 


M 


TLCIAD2 (10 words) 


SID 



F 

B 


L 
Tl 

P 


M 

T2 

C 


TSTEP (open ended) 


SID 
N!3(l) 
N0 2 
DT(N) 
-1 


N(l) 
N(2) 

N0(N) 
-1 


DT(1) 
DT(2) 
N(N) 
-1 



2.3-27 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.2.10 MATP130L (TABLE) 

Card Types and Header Information : 



Card Type 
DMIG 



Header Vjord 1 
Card Type" 

114 



Header Word 2 
Trailer Bit Positi on 



Header Word 3 
Internal Card Number 

120 



Card Type Formats : 

DMIG (open ended) 

GJ 



GJ 



CJ 



CJ 



NAME (2 words) 


GI 
GI 



GI 
-1 

GI 
GI 



GI 
-1 



CI 
CI 



CI 

-1 

CI 
CI 



CI 

-1 



IF0 




TffliiT ) Header Information 
TIN T0UT Uq^ ^^g ^3^^.^ 



V* 
V* 



V* 
V* 



) (9 words) 



Non-zero terms 
• of the first 
non-zero column 

End of column indicators 



Non-zero terms 
>of the second 
non-zero column 

End of column indicators 



GJ 



CJ 



GI 
GI 



GI 
-1 



CI 
CI 



CI 
-1 



V* 
V* 



V* 



-1 



No n- zero terms 
of the last 
non-zero column 

End of column indicators 
End of matrix indicators 



*V may be 1, 2, or 4 words depending on TIN. 



2.3-28 



DATA BLOCK DESCRIPTIONS 



2.3.2.11 AXIC (TABLE) 

Card Types and Header Information : 



Card Type 

AXIC 

CC0NEAX 

FURCEAX 

M0MAX 

MPCAX 

0MITAX 

P0INTAX 

PRESAX 

RINGAX 

SECT AX 

SPCAX 

SUPAX 

TEMPAX 



Header Word 1 
Card Type' 

515 
2315 
2115 
3815 
4015 
4315 
4915 
5215 
5615 
6015 
6215 
6415 
6815 



Header Hord 2 
Trailer Bit Position 

5 

23 
21 
38 
40 
43 
49 
52 
56 
60 
62 
54 
68 



Header Word 3 
Internal Card Number 

144 
146 
156 
157 
149 
150 
152 
154 
145 
153 
148 
151 
155 



Card Type Formats : 



AXIC (2 words) 


H 







CC0NEAX (4 words) 


ID 
RB 


PID 


RA 


F0RCEAX (7 words) 


SID 

S 

FZ 


RID 

FR 


HID 
FP 


M!3MAX (7 words) 


SID 

S 

MZ 


RID 
MR 


HID 
MP 


MPCAX (open ended) 


SID 

C 

HID 

c" 

-1 


RID 

A 

C 

RID 

A 

-1 


HID 

RID 

A 

HID 

-1 

-1 


i3MITAX (3 words) 


RID 


HID 


C 


PJIINTAX (3 words) 


ID 


RID 


PHI 


PRESAX (6 words) 


SID 
RID2 


P 
PHIl 


RIDl 
PHI2 


RINGAX (4 words) 


ID 
C 


R 


Z 


SECTAX (5 words) 


ID 

PHIl 


RID 
PHI2 


R 


SPCAX (5 words) 


SID 
C 


RID 
V 


HID 


SUPAX (3 words) 


RID 


HID 


C 


TEMPAX (4 words) 


SID 
TEMP 


RID 


PHI 



2.3-29 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.2.12 F0RCE (TABLE) 

Card Types and Header Information : 

Card Type 

EDFIR 

ELDELE 

MASSC 

VECDN 

VECGP 

ZI 



Header Word 1 


Header Word 2 


Header Word 3 


Card Type 


Trailer 


BU Position 


Internal Card l^lumber 


1513 




15 


160 


1913 




19 


188 


3313 




33 


159 


8313 




83 


117 


8413 




84 


118 


8913 




89 


113 



Card Type Formats : 



EDFIR (7 words) 


SID 
EID 
FE 


EID 
FE 


FE 
EID 


ELDELE (7 words) 


SID 
EID 
FE 


EID 
FE 


FE 
EID 


MASSC (8 words) 


GPl 
DF 


DF 
MASS 


GP2 
GP3 




DF 


MASS 




VECDN (5 words) 


VID 
B 


GID 
C 


A 


VECGP (5 words) 


VID 
G3 


Gl 
G4 


G2 


ZI (5 words) 


EIDl 
FE 


FE 
Z 


EI02 



2.3-30 



DATA BLOCK DESCRIPTIONS 



2.3.3 Data Blocks Output From Module GP1 

2.3.3.1 GPL (TABLE) 

Description 

Grid Point List. 

First logical record contains a list of external grid and scalar numbers in internal sort. 
Second logical record contains pairs of external grid and scalar numbers and sequence 
numbers in internal sort. 

Table Format 



Record 



Word 



Item 



Header record 



) repeated for each 
External grid or scalar number > grid or scalar point 

j in model 

External grid or scalar number ) '■epeated for each 
Sequence number (9^'^^ or scalar point 

) in model 



End-of-file 



Notes 

1. Internal is implied by word position in record one. 

2. Sequence number = 1000 * external number unless replaced by a new sequence number 
on a SEQGP card. 

3. All data words are integers. 
Table Trailer 



Word 1 
Word 2-6 



number of external grid points + number of scalar points, 
zero. 



2.3.3.2 EQEXIN (TABLE) 
Description 

Equivalence between external grid or scalar numbers and internal numbers. 

First record contains pairs of external grid and scalar numbers and internal numbers in 
external sort. Second logical record contains pairs of external grid and scalar numbers 
and coded SIL numbers in external sort. 



2.3-31 



DATA BLOCK AND TABLE DESCRIPTIONS 



Table Format 
Record 


1 



Word 



Item 
Header record 

External grid or scalar number 
Internal number 



External arid or scalar number 
10*SIL number + code 

End-of-file 



repeated for each 
qrid or scalar point 

in model 

repeated for each 
grid or scalar point 
in model 



Motes 

1. All data words are integers. 

r H - /^ ^°'" 9'^''"^ point 
i. Lode - <^2 for scalar point 

Table Trailer 

Word 1 = number of grid points + number of scalar points. 

Word 2-6 = zero. 

2.3.3.3 GPDT (TABLE) 

Description 

Grid Point Definition Table. 

One logical record contains list of all grid and scalar points with associated coordinate 
system and constraint information. List is in internal sort. 



Table Format 
Record 

1 



Word 



Item 

Header record 

Internal number 

Coordinate system ID that defines x, y, z 

x\ /R\ /P\ depending on f reoea ted for each 

y or e or 9 defining coordinated ^.^^f/.S'^^f ^' 
,z/ \z/ \<t>/ system I 

Coordinate system ID for displacements 
Constraint code 

End-of-file 



Notes 



1. Words 3-5 are single precision floating point; all other words are intener. 

2. Scalar points are identified by coordinate system ID = -1, and words 3-7 are all zero. 

3. See description of the GRID bulk data card in the User's Manual for a definition of the 
constraint code. 



2.3-32 



DATA BLOCK DESCRIPTIONS 



Table Trailer 

Word 1 = number of grid points + number of scalar points. 
Word 2-6 = zero. 

2.3.3,4 CSTM (TABLE) 

Description 

Coordinate System Transformation Matrices. 

One logical record contains all coordinate system transformations. Transformation is from 
global to basic by the following formulation: 

(1) rectangular 

21 
'B \'"31 

(2) cylindrical 

^22 
"32 










(3) spherical 






Table Format 
Record 



Word 

1 

2 

3-5 
6-14 



Item 
Header record 

Coordinate system ID 

n = rectangular 

Coordinate system type < 2 = cylindrical 

( 3 = spherical 

*1 • *2' *3 

•"ll* '"l2' '"13' '"2T '^22* ''23' ''31* '^32' ""33 

End-of-file 



repeated 
, for each 
coordinate 
system 



2.3-33 



DATA BLOCK AND TABLE DESCRIPTIONS 

Notes 

1. Coordinate system ID and coordinate system type are integers. 

2. t- and r.. are single precision floating point. 

Table Trailer 

Word 1 = number of grid points + number of scalar points. 

Word 2 = number of coordinate systems. 

Word 3-6 = zero. 



2.3.3.5 BGPDT (TABLE) 

Description 

Basic Grid Point Definition Table. 

One logical record contains a list of all grid and scalar points in internal sort, with 
(for grid points) their x, y. z coordinates in the basic system along with a coordinate 
system ID for displacement computations. 



Table Format 
Record 

1 



Word 



1 

2-4 



Item 
Header record 

1 ren 
X, y, z in basic system /qri 

End-of-file 



Coordinate system ID ^reneated for each 

d or scalar point 



Notes 



1. Coordinate system ID is integer; x. y, z are single precision, floating point. 

2. Scalar points are identified by coordinate system ID = -1 , and x, y, z = 0. 



Table Trailer 



Word 1 = number of grid points + number of scalar points. 
Word 2-6 = zero. 



2.3-34 



DATA BLOCK DESCRIPTIONS 



2.3.3.6 SIL (TABLE) 

Description 

Scalar Index List. 



One logical record that contains a list of SIL numbers for each grid or scalar ooint 
The list is in internal sort, therefore, internal number is implied by word position' 
in the record. Definition of SIL numbers is as follows: 



Let i = 


= internal n 


umb( 


ir, then 




SIL^ 


= 


1. 




S^Li.i 


= 


/SIL. + 6 if i 
ISIL: +1 if i 


Table Format 








Record 


Word 




Item 









Header record 


1 


1 




SIL^ 




n 




SILp 


2 






End-of-file 



grid point 



Notes 

SIL numbers are integers. 

Table Trailer 

Word 1 = number of grid points + number of scalar points. 

Word 2 = degrees of freedom in the g-displacement set. 

Word 3-6 = zero. 



2.3-35 



DATA BLOCK AND TABLE DESCRIPTIONS 

2,3.4 Data Blocks Output From Module GP2 

2.3.4.1 ECT (TABLE) 

Description 

Element Connection Table. 

The ECT contains one logical record for each element connection card type that has been 
input. Additionally, the ECT contains one logical record for GENEL elements if they have 
been input. 



Table Format 



The ECT is identical in format to data block GE0M2, output from module IFP. All 
external grid or scalar numbers are replaced by internal numbers. SP0INT data Is 
not copied on the ECT. 



Table Trailer 

Identical to trailer on GE(JM2 data block. 



2.3-36 



DATA BLOCK DESCRIPTIONS 

2.3.5 Data Blocks Outrut From Module PLTSET 

2.3.5.1 PLTSETX (TABLE) 
Descrintion 

User error n;es5oges related tc the definition of element nlot sets for the structure plotter. 
Table Format 

See the descriotion of the ''ESSAGE table, section 2.3.5.5. 
;<ote 

PLTSETX is generated in subroutine SETIiJP. 

Table Trai 1er 

►Jord 1-5 = 
Word 6 = 1 

2.3.5.2 PLTPAR (TAiiLE) 
^description 

Plot parameters and plot control table. 
Table Format 

Record '.Jord I tem 

header record 

1 junlicate of the nlot control data block 

2 (PCDB) created in the IFPl module except 

3 that all plot set definitions have been 
etc. deleted. 

Last End-of-file 

fiote 

PLTPAR is generated in subroutine SETINP. 

Table Trailer 

Word 1-5 = 
Aora 6 = 1 

2.3.5.3 GPSETS (TABLE) 
Description 

Grid ncint sets related to the element nlot sets. 



2.3-37 



DATA BLOCK AND TABLE DESCRIPTIONS 



Table Fonnat 

Record 



1 

2-(rjSETS+l) 



iJSETS+2 



Word Item 

Header record 

1-NSETS Element plot set ID's (integer) 

1 Number of orid points in an element set 

2-(iinf'+l) Pointers to the grid points in this element set (inteoers) 

1 If = 0, the grid noint is not in this set 

2 If ^ 0, this is an internal index relative to only the grid 

noints in this elerent set (if negative, this nrid 
point is to be excluded when used to draw deformed 
Shanes and vectors) 

End-of-file 



Notes 



1. WSETS = number of element sets 

2. iJGP = total number of structural grid points 

3. GPSETS is Generated in subroutines SETINP and CNSTPX 



Table irailer 



Word 1-5=0 
Word 6 = 1 



2.3.5.4 LLSETS (TABLE) 
Description 

Element nlot set connection tables. 
Table Format 

Word 



Record 


1-NSETS 



jroup 



1-NTYPS 



2-(M+l) 
i^+2 



Item 



Header record 



iiSETS+l 



.'lumber of grid noints r^er elen'ent of a given 
element type (integer) Mote: If less than 3 or 
negative, this element type does not define a 
closed area. 

Grid point indices relative to all grid points 
defining each element of this type (integers) 
Integer zero 

End-of-file 



Notes 



1. USETS = number of element plot sets 

2. UTYPS = number of element types represented in an element plot set 

3. N = number of connection grid points for all elements of a given type in an element 

plot set 
= (number of grid points per element of a given type) X 
(number of elements of a given type in an element set) 

4. ELSETS is generated in subroutine CNSTRC 



2.3-38 



DATA BLOCK DESCRIPTIONS 



Table Trailer 



Word 1-5 = 
IJord 6 = 1 



2.3,5.5 MESSAGE (TABLE) 
Description 



llessages to be processed by the message writer module (PRTMSR). Each message may either be a 
physical or logical record. This data block is never really created as such, but is included 
so as tc exnlain other data blocks such as PLj^TXl, PL53TX2, etc., and is referenced in the 
Table Formats of these data blocks. 

Table Format 

Record Word Item 

Header record 

A given logical record in a given physical record can be of tv;o alternate forms 

A. Record Hord Item 

i j If = -1, -2, -3, -4, -5, or -6, then the next 32 words is a nev; 

title for the 1st, 2nd, 3rd, 4th, 5th, or 6th lines on all 
printed pages to follow from this message table (inteaer) 
(.J+1)-(.i+32) The 32 4-character BCD words for this title 

B. Record Word I ten 

i j "JLIST = number of list itei"S (integer) 

(j+l)-(.i+f^LIST) List items (mixed mode) 

j+NLIST+l NF = size of format to be used to print these list items 

(integer) 
(j+iNLIST+2)- 

(j+ULIST+HF+1) Format to be used to print this list (series of consecutive BCD 
characters) 



2.3-39 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.6 Data Blocks Output From Mo d ule PLjZIT 

2.3.6.1 PL2ITX1 (TABLE) 
Cdscription 

User messages from the plot module relative to the undcfomied structural shapes 
Table Format 

See the description of the "lESSAnE table, section 2.3.b.5 

Table Trailer 

IJord 1-5 = 
Word G = 1 

2.3.6.2 PL0TX2 (TABLE) 
Description 

User messaqes from the plot module relative to the defonned structural shares oenerated in the 
statics analysis 

Table Format 

See the description of the fCSSAGE table, section 2.3.5.5 

Table Trailer 

Word 1-5=0 
Word C = 1 



2.3-40 



DATA BLOCK DESCRIPTIONS 



2,3.7 Data Blocks Output From Module GP3 

2.3.7.1 SLT (TABLE) 

Description 

Static Loads Table. 

The header record of the SLT contains a sorted list of all unique load set ID's contained 
on static load cards except the L0AD card itself. The n logical records that follow the 
header record comprise all static loads data belonging to each of the n load sets, one 
logical record per load set. The (n+l)st logical record contains all L0AD cards (if any). 



Table Format 








Record 


Word 


Type 


Item 





1-2 
3 


B 

I 


Data block name 

Load set ID 

1 




2+n 


I 


Load set ID^ 


1 


1.2 


I 


Load card type, m 




n 




Load data as function 
of load card type. . 
repeated m times 



2+g, 



repeated for each 
different load card 
type belonging to 
load set number 1 



n+1 



n+2 



Same format as record 1 

Data belongs to load set number n 



1.2 
3-4 


I.R 
I.R 


Load set ID, scale factor " 
Load set ID, scale factor / 

1 


f repeated 
> for each 
i L0AD card 


2k+3,2k+4 


I 


-1,-1 
End-of-file 


) 



Notes 



The SLT is generated in subroutine GP3A. 

Card type ID's and format for data for each bulk data card type are as follows: 

3 = FURCEl 

Word Type Item 



1 
2 
3-4 



Internal grid number 
Signed magnitude of applied load 
Internal grid numbers of grid points 
that define direction 



2.3-41 



FgfRCE2 



1 = FjJRCE 



DATA BLOCK AND TABLE DESCRIPTIONS 



Word Type Item 

1 I Internal grid number 

2 R Signed magnitude of applied load 
3-6 I Internal grid numbers of grid points 

that define direction 



Word Type Item 

1 I Internal grid number 

2 I Coordinate system ID 

3 R Signed scale factor for applied force 
4-6 R Force components 



8 = GRAV 



Word Type Item 

1 I Coordinate system ID 

2 R Gravity vector scale fact 
3-5 R Gravity vector components 



4 = M0MENT1 

See F0RCE1 , substituting "moment" for "force". 

6 = M0MENT2 

See F0RCE2, substituting "moment" for "force". 

2 = M0MENT 

See F0RCE, substituting "moment" for "force". 



9 = PLpAD 



7 = SL0AD 



Word Type Item 

1 R Pressure 

2-5 I Internal grid numbers 



Word Type Item 

1 I Internal scalar number 

2 R Applied load 



2.3-42 



DATA BLOCK DESCRIPTIONS 



10 = RF(3RCE 



Word 



Ml 



1 


I 


2 


I 


3 


R 


4-6 


R 



Item 

Internal grid number 

Coordinate system ID 

Scale factor 

Components of rotation direction vector 



11 = PRESAX 



Word 

1 

2-3 
4-5 
6 



R 
I 
R 
I 



Item 

Pressure value 
Ring ID's 
Azimuthal angles 
Number of harmonics 



3. With the exception of GRAV and PL0AD card types, data of a given card type within a 
logical record is in sort on internal grid (or scalar) number at which the load is 
applied. 

4. If no L0AD cards have been input, the (n+l)st record does not exist. 

Table Trailer 

Word 1 = number of load sets. 
Word 2-6 = zero. 



2.3-43 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.7.2 GPTT (TABLE) 



Description 



Grid Point Temperature Table. 

The header record of the GPTT contains sorted triples of temperature set ID, default 
temperature, and flag. For each temperature set for which temperature data is defined at the 
grid points, a logical record in the GPTT is present. 



Table Format 




Record 


Word 





1-2 
3 




4 




5 


1 


1 
2 



Item 

Data block name (BCD) 

Temperature set ID, (integer) 

(Default temperature (floating point) 

(-1 if no default temperature defined (integer) 

(0 if only default temperature for set (integer) 

<>0 record number of temperature data for set 

( (integer) 



I repeated 

for each 
' temperature 

set 



Internal grid number (integer)) repeated for every grid point at 
Temperature (floating point) (which a temperature Is defined 



k 
k+1 



Same format as record 1 
End-of-file 



Notes 

1. The GPTT is generated in subroutine GP3B. 

2. A temperature set may be defined as consisting only of a default temperature that 
applies to all grid points. 

3. A default temperature (if defined) Is to apply to all grid points for which a 
temperature has not been defined. 

4. Each data record is in sort on internal grid number. 
Table Trailer 



Word 1 
Word 2-6 



undefined. 



2.3-44 



DATA BLOCK DESCRIPTIONS 



2.3.8 Data Blocks Output From Module TAl 

2.3.8.1 EST (TABLE) 

Description 

Element Summary Table. 

The EST is a collection of data for all elements of the structural model. It contains one 
logical record for each element type. For each element: connection data, properties data, 
basic grid point data and the element temperature are grouped. General elements and elements 
that belong to super elements are not included in the EST. 

Table Format 



Record 

1 



Word 



1 



Tv£e 



Item 



2-i+l 

i+2-i+,i+l 

i+j+2-i+j+k+l 

i+j+k+2 



tieader record 

Element type 

ECT section 

EPT section 1 

BGPDT section | 

Element temperature ^ 


1 repeated 
' for 
each 
I element 


\ repeated 
/ for 
V each 
t element 

; type 



n+1 



End-of-file 



Notes 



1. i = number of words in ECT section, 
j = number of words in EPT section. 

k = number of words in BGPDT section. 

2. The number of records in the EST corresponds to the number of separate element types in 
the model . 

3. The EST ii generated in subroutine TAIA. 



Summary of EST Formats 







ECT Section 


EPT Section 


BGPDT Section 


Element 


Total 
Words 


Element 




hu{iiber 


number 


Number 


Temper- 


Per 


Tvoe 


Mnemonic 


of Words 


of Words 


of Words 


ature 


Element 


1 


n!?r 


3 


D 


8 


Yes 


17 


2 


BEAfI 


19 


19 


8 


Yes 


47 


3 


TIBE 


3 


4 


8 


Yes 


16 


4 


SHEAR 


5 


3 


16 


Yes 


25 


5 


TWIST 


5 


3 


16 


Yes 


25 


6 


TRIAl 


5 


9 


12 


Yes 


27 


7 


TRBSC 


5 


7 


12 


Yes 


25 


8 


TRPLT 


5 


7 


12 


Yes 


25 


9 


TRHEM 


5 


3 


12 


Yes 


21 


10 


cdrndd 


8 





8 


Yes 


17 


11 


ELASl 


5 


3 





No 


8 


12 


ELAS2 


8 








No 


8 


13 


ELAS3 


3 


3 





No 


6 


14 


ELAS4 


4 








No 


4 


15 


QDPLT 


6 


7 


16 


Yes 


30 


16 


QDMEH 


6 


3 


16 


Yes 


26 


17 


TRIA2 


5 


3 


12 


Yes 


21 



2.3-45 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 



ECT Section EPT Section BGPDT Section 















Total 












Element 


Words 


Element 




Number 


Number 


Number 


Temper- 


Per 


Type 


Mnemonic 


of Words 


of Words 


of Words 


ature 


Element 


18 


QUAD2 


6 


3 


16 


Yes 


26 


19 


QUADl 


6 


9 


16 


Yes 


32 


20 


DAMPl 


5 


1 





No 


6 


21 


DAMP2 


6 








No 


6 


22 


DAMP3 


3 


1 





No 


4 


23 


DAMP4 


4 








No 


4 


24 


Vise 


3 


2 


8 


Yes 


14 


25 


MASSl 


5 


1 





No 


6 


26 


riA5S2 


6 








No 


6 


27 


MASS 3 


3 


1 





No 


4 


28 


MASS4 


4 








No 


4 


29 


C0NM1 


24 





4 


Yes 


29 


30 


C0NM2 


13 





4 


Yes 


18 


31 


PL0TEL 


3 





8 


Yes 


12 


32 


REACT 


19 





4 


Yes 


24 


33 


QUAD3 


7 


1 


16 


Yes 


24 


34 


BAR 


15 


18 


8 


Yes 


42 


35 


CONEAX 


3 


23 


3 


Yes 


35 


36 


TRIARG 


6 





12 


Yes 


19 


37 


TRAPRG 


7 





16 


Yes 


24 


38 


T0RDRG 


6 


3 


2 


Yes 


18 


Detailed EST 


Formats 













ECT section for element type = 2: 



Word 

1 

2-3 
4-6 
7 
8-9 

10-12 

13-15 
16-19 



Type 

I 
I 
R 
I 
I 



Item 



Element ID 

SIL numbers for grid points 1, 2 
X, y, z (orientation vector) 
Coordinate system ID for x, y, z 

Pa. Pb 

1 2 3 



h' h' h 



g . g . g 

2 3') 



ECT Section for element type = 1, 3, 24, 31: 

Word Type Item 



1 
2-3 



Element ID 

SIL numbers for grid points 1, 2 



ECT section for element type = 4, 5: 
Word Type 



Item 



1 
2-5 



Element ID 

SIL numbers for grid points 1, 2, 3, 4 



2.3-46 



DATA BLOCK DESCRIPTIONS 

EOT section for element type = 6, 7, 8, 9, 17: 

Word Type Item 

1 I Element ID 

2-4 I SIL numbers for grid points 1 , 2, 3 

5 Re (degrees) 

EOT section for element type = 15, 16, 18, 19: 

Word Type Item 

1 I Element ID 

2-5 I SIL numbers for grid points 1, 2, 3, 4 

6 Re (degrees) 

ECT section for element type = 10: 

Word Type Item 

1 I Element ID 

2-3 I SIL numbers for grid points 1, 2 

4 I Material ID 

5 R A 

6 R J 

7 R C 

8 R non-structural mass (nsm) 

ECT section for element type = 11, 20, 25: 

Word Type Item 

Element ID 

SIL numbers for grid points 1, 2 

Component codes for grid points 1, 2 

ECT section for element type = 12: 

Word Type Item 

1 I Element ID 

2 R Value 

3-4 I SIL numbers for grid points 1, 2 

5-6 I Component codes for grid points 1, 2 

7-8 R gg, S 

ECT section for element type = 13, 22, 27: 

Word Type Item 

1 I Element ID 

2-3 I SIL numbers for scalar points 1, 2 

ECT section for element type = 14, 23, 28: 

Word Type Item 

1 I Element ID 

2 R Value 

3-4 I SIL numbers for scalar points 1, 2 



1 


I 


2-3 


I 


4-5 


I 



2.3-47 



DATA BLOCK AND TABLE DESCRIPTIONS 



ECT section for element type = 21, 26: 
Word Type Item 

1 I Element ID 

2 R Value 

3-4 I SIL numbers for grid points 1, 2 

5-5 I Component codes for grid points 1, 2 

ECT section for element type = 29: 

Word Type Item 

1 I Element ID 

2 I SIL number for grid point 

3 I Coordinate system ID 

4-24 R m , m^ , m^^, m , etc., (6x6 symmetric matrix) 

ECT section for element type = 30: 

Word Type Item 



1 


I 


Element ID 


2 


I 


SIL number for grid point 


3 


I 


Coordinate system ID 


4 


R 


m 


5-7 


R 


X , X , X 

l' 2* 3 


8-13 


R 


^l' ^21* ^22* ^31* ^32' 



ECT section for element type = 34: 

Word Type Item 

1 I Element ID 

2-3 I SIL values for grid points 1, 2 

4-6 R X^, X,. X3 

Coordinate system ID for Xj, X^, X3 



7 I 



8-9 I P^. P^ 

ECT section for element type = 35: 

Word Type Item 

1 I Element ID 

2-3 I SIL values for rings 1, 2 



2.3-48 



DATA BLOCK DESCRIPTIONS 

ECT section for element type = 36: 

Word Type Item 

1 I Element ID 

2-4 I SIL values for grid points 1, 2, 3 

5 R 6 (degrees) 

6 I Material ID 

ECT section for element type = 37: 

Word Type Item 

1 I Element ID 

2-5 I SIL values for grid points 1, 2, 3, 4 

6 Re (degrees) 

7 I Material ID 

ECT section for element type = 38: 

Word Type Item 

1 I Element ID 

2-3 I SIL values for grid points 1, 2 

4-5 R A , A 

1 ' 2 

6 Not defined 

EPT section for element type = 1: 
Word Type Item 



1. 


I 


Material ID 


2 


R 


A 


3 


R 


J 


4 


R 


C 


5 


R 


nsm 



EPT section for element type = 2: 

Word Type Item 

1 I Material ID 

2 R A 

3-4 R Ii, I2 

5 R J 

6 R nsm 

7 I Force Element Code (FE) 
8*9 R Ci f C2 

10-11 R Di, D2 

12-13 R El. Ez 

14-15 R F,. F, 

16-17 R Ki, K2 

18 R I12 

19 not defined 



2.3-49 



DATA BLOCK AND TABLE DESCRIPTIONS 



EPT section for element type = 3: 

Word Type Item 



1 


I 


Material ID 


2 


R 


CD. 


3 


R 


t 


4 


R 


nsm 



EPT section for element type = 4, 5, 9, 16, 17, 18: 
Word Type Item 

1 I Material ID 

2 R t 

3 R nsm 

EPT section for element type = 6, 19: 
Word Type Item 

1 I Material ID for membrane 

2 R t^ 

3 I Material ID for bending 

4 R I 

5 I Material ID for transverse shear 

6 R tj 

7 R nsm 
8-9 R Z,, Z^ 

EPT section for element type * 7, 8, 15: 
Word Type Item 

1 I Material ID for bending 

2 R I 

3 I Material ID for transverse shear 

4 R tz 

5 R nsm 
6-7 R l-i. I2 

EPT section for element type = 11, 13: 
Word Type Item 

1 R K 

2 R g^ 

3 R s 

EPT section for element type = 20, 22: 
Word Type Item 

1 R B„ 



2.3-50 



DATA BLOCK DESCRIPTIONS 

EPT section for element type = 24: 

Word Type Item 

1 R C^ 

2 R Cg 

EPT section for element type = 25, 27: 

Word Type Item 

1 R M„ 

e 

EPT section for element type = 33: 

Word Type Item 

1 I Super element property ID 

EPT section for element type = 34: 

Word Type Item 









1 

2 
3-4 


I 
R 
R 


Material ID 
A 


5 
6 
7 
8-9 


R 
R 

I 
R 


J 

nsm 

FE (Force Method only) 

Ci. c, 


10-11 


R 


D,. D^ 


12-13 


R 


Ei. E, 


14-15 


R 


F,. F, 


16-17 


R 


Ki. K, 


18 


R 


I., 



EPT section for element type = 35: 

Word Type Item 

1 I Material ID for membrane 

2R R Tj 

3 I 

4 R 

5 I 

6 R 

7 R 
8-9 R 

10-23 R 



Material 

I 
Material 


ID 


for 


bending 




ID 


for 


transverse 


shear 


nsm 
Zi. Za 

*i. i = 1 


1. ■ 


14 







2.3-51 



DATA BLOCK AND TABLE DESCRIPTIONS 



EPT section for element type = 38: 
Word Type Item 

1 I Material ID 

2 R TM 

3 R TF 



Table Trailer 



Word 1 = number of elements in model, 
Word 2-6 = are undefined. 



2.3-52 



DATA BLOCK DESCRIPTIONS 



2.3.8.2 GEI (TABLE) 

Description 

General Element Input. 

The GEI contains one logical record for each general element in the model 

Table Format 

Record Word Type Item 



Header record 

ID for general element 

n = number of elements in Uj list 

m = number of elements in Up. list 



SIL value for first U 



3+n 
4+n 

3+n-Hn 
4+n+m 

3+n-Hii+n' 
4+n+m+n' 



3+n+m+n ' 
+nm 



SIL value for n^"^ Uj 
SIL value for first Ur 



SIL value for m^*^ U, 



Elements of Z matrix 



Elements of S matrix 



Same format as record 1 



not present 
if m = 



k 
k+1 



Same format as record 1 
End-of-file 



Table Trailer 

Word 1 = number of general elements in the model. 
Words 2-6 = zero. 

2.3.8.3 ECPT (TABLE) 

Description 

Element Connection and Properties Table. 

The ECPT is essentially the EST 1n a different sort. The ECPT contains one logical record 
for each grid or scalar point of the model. Each logical record contains Element Summary Table 
data for each element connected to the grid or scalar point. 



2.3-53 



DATA BLOCK AND TABLE DESCRIPTIONS 



Table Format 
Record 



Word 



Item 



n+1 



Header record 

1 SIL number for "pivot" grid \ repeated 

or scalar point (integer) j for 

2 Element type \ repeated for I each 
3-i+2 ECT section /each element > grid or 

i+3-i+j+2 EPT section \ connected I scalar 

i+j+3-i+j+k+2 BGPDT section ( to the 1 in the 

i+j+k+3 Element temperature ) pivot ^ model 

End-of-file 



Notes 



1. Detailed formats are given in the EST writeup (see section 2.3,8.1). 

2. If no elements are connected to a grid or scalar point, the record contains only 
one word. 



Table Tra 


liler 






Word 


1 


= 7 




Word 


2-6 = 


are undefined 


2.3.8.4 


GPCT (TABLE) 




Description 






Grid 


Point 


Connection 


Table 



The GPCT is a condensation of the ECPT. It contains one logical record for each grid or 
scalar point of the model. Each logical record contains a list of all grid or scalar 
points that are connected (by means of structural elements) to the pivot grid or scalar 
point. 

Table Format 



Record 

1 



n+1 



Word Item 

Header record 

1 ± SIL number for pivot grid 

or scalar point (integer) 

2 m = number of connected 

points (integer) 
3-2+m Sorted list of SIL numbers 
of connected points 

End-of-file 



repeated for each 
grid or scalar 
in the model 



Notes 



1. If the SIL number for the pivot (first word)<0, then the pivot is a scalar point. 

2. If no elements are connected to the pivot (and therefore no other grid or scalar 
points), the record contains only one word. 



2.3-54 (12-1-69) 



DATA BLOCK DESCRIPTIONS 



Table Trailer 

Word 1 = 7 

Word 2-6 = are undefined 



2.3-55 



DATA 6L0CK AND TABLE DESCRIPTIONS 



2.3.9 Data Blocks Output From Module SMA1 

2.3.9.1 KGGX (MATRIX) 
Description 

[k'^ ] - Partition of stiffness matrix exclusive of qeneral elements - n set. 
gg 

Matrix Trailer 

Number of columns = q 

Number of rows = q 

Form = symmetric 

Type = real double precision 

2.3.9.2 K4GG (MATRIX) 
Description 

TK^ ] - Partition of structural damping matrix - q set. 

gg 

Watrix Trailer 

Number of columns = n 

Number of rows = n 

Form = symmetric 

Type = real double precision 

2.3.9.3 GPST (TABLE) 
Description 

Grid Point Singularity Table 
Table Format 



Record 

1 



Word 



Item 



Header record 



Order of singularity (1, 2, or 3) 

tj = number of SIL numbers that follow 

SIL, 

sil; 



Hereated for each 
sinqularity 



2+N 



End-of-file 



Note 



All entries are integers. 



2.3-56 



DATA BLOCK DESCRIPTIONS 



Table Trailer 




Word 1 - 


undefined 


Word 2 = 





Word 3 = 


1 


Word 4 = 


2 


Word 5 = 


1 


Word 6 = 






2.3-57 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.10 Data Blocks Output From Module SHA2 

2.3.10.1 MGG (MATRIX) 

Description 

fM ] - Partition of mass matrix - g set. 
«■ gg 

Matrix Trailer 

Number of columns = g 

Number of rows = g 

Form = symmetric 

Type = real double precision 

2.3.10.2 BGG (MATRIX) 
Description 

[B ] - Partition of damping matrix - g set. 

Matrix Trailer 

Number of columns = g 

Number of rows = g 

Form = symmetric 

Type = real double precision 



2.3-58 



DATA BLOCK DESCRIPTIONS 



2.3.11 Data Blocks Output From Module GPWG . 

2.3.11.1 0GPWG (TABLE) 

Description 

Grid Point Weight Generator Uutput Table. 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 
2 
3 

4-9 
10 

n-50 
51-146 


I 
I 
I 

I 
B 


0FP ID record 

1 

13 

External ID of grid point about which moments 

and interias were calculated. If External ID 

the basic origin was used. 

Not defined. 

98 

Not defined. 

96 words of title, subtitle, and label from 

/0UTPUT/ 


2 


1-36 
37-45 
46-49 
50-53 
54-57 
58-66 
67-69 
70-78 


R 
R 
R 
R 
R 
R 
R 
R 


f)FP data record 
|M0] 6x6 moment matrix 
]S] 3x3 matrix 
Mx, Xx, Yx, Zx 
»y. Xy, Yy, Zy 
Mz, Xz, Yz, Zz 
Inertia matrix (3x3) 
Principal inertias 
Q matrix (3x3) 


3 






End-of-file 


Table Trailer 








Word 1 = 








Word 2 = nonzero 


. 






Words 3-6 = 









2.3-59 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.12 Data Blocks Output From Module SHA3 

2.3.12.1 KGG (MATRIX) 
Description 

[K ] - Partition of stiffness matrix - g set. Contains contributions from all elements 
^^ in the model, including general elements. 

Matrix Trailer 

Number of columns = g 

Number of rows = g 

Form = symmetric 

Type = real double precision 

2.3.12.2 KGGL (MATRIX) 
Description 

[K^ ] - Partition of the stiffness matrix of linear elements - g set. Contains contribu- 
99 tions from all linear elements of the model including general elements. Used only 
in Piecewise Linear Analysis. 

Matrix Trailer 

Number of columns = g 

Number of rows = g 

Form = symmetric 

Type = real double precision 



2.3-60 



DATA BLOCK DESCRIPTIONS 

2.3.13 Data Blocks Output From Module GP4 

2.3.13.1 RG (MATRIX) 

Description 

[R ] - Multipoint constraint equations matrix. 

Matrix Header 

Number of columns = g 

Number of rows = m 

Form = rectangular 

Type = real single precision 

2.3.13.2 YS (MATRIX) 

Description 

{Y^} - Constrained displacement vector - s set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = s 

Form = rectangular 

Type = real single precision 

2.3.13.3 USET (TABLE) 

Description 

Displacement set definitions table. 

USET contains one logical record. Each word corresponds to each degree of freedom in the 
g-displacement set (in internal order) and contains ones in specified bit positions indicat- 
ing the displacement sets to which the degree of freedom belongs. 



Table Format 








Record 


Word 


Type 


Item 





1-2 

3 

4 


B 
I 

I 


Data block name 
SPC set ID 
MPC set ID 



Mask for first degree of freedom 

Mask for n degree of freedom 
End-of-file 



2.3-61 



DATA BLOCK AND TABLE DESCRIPTIONS 



Notes 



1, Bit positions for the various displacement sets are defined as follows: 



22 23 24 25 26 27 28 29 30 31 32 



Table Trailer 



Word 1 = zero. 

Word 2 = degrees of freedom in the g-displacement set (LUSET). 

Word 3 = zero. 

Word 4 = logical "or" of all USET masks. 

Word 5 = zero. 

Word 6 = zero. 



2.3-62 



DATA BLOCK DESCRIPTIONS 



2.3.14 Data Blocks Output From Module GPSP . 

2.3.14.1 0GPST (TABLE) 

Description 

Unremoved Grid Point Singularities. 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 

2 

3-9 
10 

11-50 
51-146 


I 

I 

I 
B 


flFP ID record 



8 

Not defined 

12 

Not defined 

96 words of title, subtitle, and label 

/0UTPUT/ 


2 


1 
2 
3 

4-6 

7-9 

10-12 




eiFP data record 

External grid point ID 

Scalar point flag 

Singularity order 

Strongest singularity components 

Next strongest singularity components 

Weakest sinaularitv comoonents 



from 



*Note: The above 12 words are repeated in record 2 for each grid point 
with an unremoved singularity. 

End-of-file 



Table Trailer 



Word 1 
Word 2-6 



2.3-63 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3,15 Data Blocks Output From Module MCE1 

2.3.15.1 GM (MATRIX) 
Description 

[G ] - Multipoint constraint transformation matrix - m set. 

Matrix Header 

Number of columns = n 

Number of rows = m 

Form = rectangular 

Type = real double precision 



2.3-64 



DATA BLOCK DESCRIPTIONS 

2.3.16 Data Blocks Output From Module MCE2 

2.3.16.1 KNN (MATRIX) 

Description 

[K^^] - Partition of stiffness matrix - n set. 

Matrix Trailer 



Number of columns = n 

Number of rows = n 

Form = symmetric 

Type = real double precision 



2.3.16.2 MNN (MATRIX) 



Description 

[M^^] - Partition of mass matrix - n set. 

Matrix Trailer 

Number of columns = n 

Number of rows = n 

Form = symmetric 

Type = real double precision 



2.3.16.3 KDNN (MATRIX) 
Description 

[K^p] - Partition of differential stiffness matrix - n set. 

Matrix Trailer 

Number of columns = n 

Number of rows = n 

Form = symmetric 

Type = real double precision 



2.3-65 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.16.4 BNN (MATRIX) 



Description 

[B 1 - Partition of damping matrix - n set. 
■- nn-' 

Matrix Trailer 



Number of columns = n 

Number of rows = n 

Form = symmetric 

Type = real double precision 



2.3.16.5 K4NN (MATRIX) 

Description 

4 
[K 1 - Partition of the structural damping matrix - n set. 
^ nn-" 

Matrix Trailer 

Number of columns = n 

Number of rows = n 

Form = symmetric 

Type = real double precision 



2.3-66 



DATA BLOCK DESCRIPTIONS 

2.3.17 Data plocks Output From I'rdule SCtl 

2.3.17.1 KFF (MATRIX) 

Description 

[K^f] - Partition of stiffness matrix after single-point constraints have been removed - 
f set. 

Matrix Trailer 

Number of columns = f 

Number of rows = f 

Form = sytrmetric 

Type = real double precision 

2.3.17.2 KFS (MATRIX) 
Description 

[K, ] - Partition of stiffness matrix after single-point constraints have been removed. 

Matrix Trailer 

Number of columns = s 

Number of rov/s = f 

Form = rectangular 

Type = real double precision 

2.3.17.3 KSS (MATRIX) 

Description 

[K ] - Partition of stiffness matrix after single-point constraints have been removed - 
s set. 

Matrix Traile r 

Number of columns = s 

Number of rows = s 

Form = symmetric 

Type = real double precision 

2.3.17.4 MFF (MATRIX) 
Description 

[M^^] - Partition of mass matrix after single-point constraints have been removed - f set. 

Matrix Trailer 

fJumber of columns = f 

Number of rows = f 

Form = symmetric 

Type = real double precision 



2.3-67 



DATA BLOCK AND TABLE DESCRIPTIOUS 



2.3.17.5 KDFF (MATRIX) 
Description 

[K^f] - Partition of differential stiffness matrix - f set. 

Matrix Trailer 

Number of columns = f 

Number of rows = f 

Form = symmetric 

Type = real double precision 

2.3.17.6 KDFS (MATRIX) 
Description 

[Kx ] - Partition of differential stiffness matrix. 

Matrix Trailer 

Number of columns = s 

Number of rows = f 

Form = rectangular 

Type = real double precision 

2.3.17.7 KDSS (MATRIX) 
Description 

[K** ] - Partition of differential stiffness matrix - s set. 

Matrix Trailer 

Number of columns = s 

Number of rows = s 

Form = synmetric 

Type = real double precision 

2.3.17.8 BFF (MATRIX) 
Description 

[B-x] - Partition of damping matrix after single point constraints heve been removed - f set. 

'latrix Trailer 

liumber of columns = f 

liumber of rows = f 

Form = symmetric 

Tvpe = real double precision 



2.3-68 



DATA BLOCK DESCRIPTIONS 

2.3.17.9 K4FF (MATRIX) 

Description 

[Kx^] - Partition of structural damping matrix with single-point constraints remo 
^^ f set. 

Matrix Trailer 



Number of columns = f 

Number of rows = f 

Form = symmetric 

Type = real double precision 



2.3-69 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.18 Data Blocks Output From Module SMP1 

2.3.18.1 G0 (MATRIX) 

Description 

[G ] - Structural matrix partitioning transformation matrix. 

Matrix Trailer 



Number of columns = a 

Number of rows = o 

Form = rectangular 

Type = real double precision 



2.3.18.2 KAA (MATRIX) 



Description 

[K ] - Partition of stiffness matrix - a set. 
aa 

Matrix Trailer 

Number of columns = a 

Number of rows = a 

Form = symmetric 

Type = real double precision 



2.3.18.3 K00B (MATRIX) 
Description 

n< 1 - Partition of stiffness matrix - o set. 

00 

Matrix Trailer 

Number of columns = o 

Number of rows = o 

Form = symmetric 

Type = real double precision 



2.3.18.4 L00 (MATRIX) 

Description 

[LI- Lower triangular factor of K00B - o set. 
oo-" 

Matrix Trailer 

Number of columns = o 

Number of rows = o 

Form = lower triangular 

Type = real double precision 



2.3-70 



DATA BLOCK DESCRIPTIONS 



2.3.18.5 U00 (MATRIX) 

Description 

[U ] - Upper triangular factor of K00B - o set. 

Matrix Trailer 

Number of columns = o 

Number of rows = o 

Form = upper triangular 

Type = real double precision 

'lote 

This matrix is not a standard upper triangular factor. Its format is acceptable only to 
subroutine FBS. 

2.3.18.6 MAA (MATRIX) 

Description 

[M,,] - Partition of mass matrix - a set. 

Matrix Trailer 

Number of columns = a 

Number of rows = a 

Form = symmetric 

Type = real double precision 

2.3.18.7 M0?IB (MATRIX) 
Description 

[M ] - Partition of mass matrix - o set. 

Matrix Trailer 

Number of columns = o 

Number of rows = o 

Form = symmetric 

Type = real double precision 



2.3-71 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.18.8 M0AB (MATRIX) 
Description 



[M ] - Partition of mass matrix. 

'- oa 

Matrix Trailer 

Number of columns = a 

Number of rows = o 

Form = rectangular 

Type = real double precision 



2.3.18.9 BAA (MATRIX) 



Description 

[B,,] - Partition of damping matrix - a set. 
aa 

Matrix Trailer 

Number of columns = a 

Number of rows = a 

Form = symmetric 

Type = real double precision 



2,3.18.10 K4AA (MATRIX) 
Description 

[K,,] - Partition of structural damping matrix - a set. 

da 

Matrix Trailer 

Number of columns = a 

Number of rows = a 

Form = symmetric 

Type = real double precision 



2.3-72 



DATA BLOCK DESCRIPTIONS 

2.3.19 Data Blocks Output From Module RBMG1 

2.3.19.1 KLL (MATRIX) 

Description 

[K..] - Partition of stiffness matrix - i set. 

Matrix Trailer 

Number of columns = ^ 

Number of rows = ^ 

Form = symmetric 

Type = real double precision 

2.3.19.2 KLR (MATRIX) 

Description 

[K. ] - Partition of stiffness matrix 

Matrix Trailer 

Number of columns = I 

Number of rows = r 

Form = rectangular 

Type = real double precision 



2.3.19.3 KRR (MATRIX) 



Description 

[K 1 - Partition of stiffness matrix - r set. 

Matrix Trailer 

Number of columns = r 

Number of rows = r 

Form = symmetric 

Type = real double precision 



2.3.19.4 MLL (MATRIX) 



Description 

[M.,] - Partition of mass matrix - i set. 

Matrix Trailer 



Number of columns = 2. 

Number of rows = H 

Form = symmetric 

Type = real double precision 



2.3-73 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.19.5 MLR (MATRIX) 



Description 

[M„ ] - Partition of mass matrix. 

Matrix Trailer 

Number of columns = I 

Number of rows = r 

Form = rectangular 

Type = real double precision 



2.3.19.6 MRR (MATRIX) 



Description 

[M ] - Partition of mass matrix - r set. 

Matrix Trailer 

Number of columns = r 

Number of rows = r 

Form = symmetric 

Type = real double precision 



2.3-74 



DATA BLOCK DESCRIPTIONS 

2.3.20 Data Blocks Output From Module RBMG2 

2.3.20.1 LLL (MATRIX) 

Description 

[L„j] - Lower triangular factor of KLL - a set. 

Matrix Trailer 



Number of columns = I 

Number of rows = H 

Form = lower triangular 

Type = real double precision 

2.3.20.2 ULL (MATRIX) 

Description 

[UpJ - Upper triangular factor of KLL - I set. 

Matrix Trailer 

Number of columns = it 

Number of rows = H 

Form = upper triangular 

Type = real double precision 

Note 

This matrix is not a standard upper triangular factor. Its format is acceptable only to 
subroutine FBS. 

2.3.20.3 LBLL (MATRIX) 
Description 

[L^jj^] - Lower triangular factor of KBLL - i set. 

Matrix Trailer 

Number of columns = S- 

Number of rows = I 

Form = lower triangular 

Type = real double precision 



2,3-75 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.20,4 UBLL (MATRIX) 
Description 

[U.jj^] - Upper triangular factor of KBLL - I set. 

Matrix Trailer 

Number of columns = i 

Number of rows = i 

Form = upper triangular 

Type = real double precision 

Note 

This matrix is not a standard upper triangular factor. Its format is acceptable only to 
subroutine F3S. 



2.3-76 



DATA BLOCK DESCRIPTIONS 



2.3.21 Data Blocks Output From Module RBMG3 

2.3.21.1 DM (MATRIX) 
Description 

[D] - Rigid body transformation matrix. 

Matrix Trailer 

Number of columns = i 

Number of rows = r 

Form = rectangular 

Type = real double precision 



2.3-77 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.22 Data Blocks Output From Module RBMG4 

2.3.22.1 MR (MATRIX) 
Description 

[m ] - Rigid body mass matrix - r set. 

Matrix Trailer 

Number of columns * r 

Number of rows = r 

Form = symmetric 

Type = real double precision 



2.3-78 



DATA BLOCK DESCRIPTIONS 

2.3.23 Data Blocks Output From Module SSG1 . 

2.3.23.1 PG (MATRIX) 
Description 

[P ] - Static load vector matrix giving static loads - g set. 
Matrix Trailer 

Number of columns = number of subcases 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.23.2 PGl (MATRIX) 

Description 

[P ] - Static load vector giving static loads for Piecewise Linear Analysis problem 
^ g set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = g 

Form = rectangular 

Type = real single precision 



2.3-79 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.24 Data Blocks Output From Module SSG2 

2.3.24.1 QR (MATRIX) 
Description 

[q^] - Determinate support forces matrix - r set. 

Matrix Trailer 

Number of columns = number of subcases 

Number of rows = r 

Form = rectangular 

Type = real single precision 

2.3.24.2 P9 (MATRIX) 
Description 

[Pq] - Partition of the load vector matrix giving loads due to static force - o set. 

Matrix Trailer 

Number of columns = number of subcases 

Number of rows = o 

Form = rectangular 

Type = real single precision 

2.3.24.3 PS (MATRIX) 
Description 

[Pj] - Partition of load vector matrix giving loads in s set. 

Matrix Trailer 

Number of columns = number of subcases 

Number of rows = s 

Form = rectangular 

Type = real single precision 

2.3.24.4 PL (MATRIX) 
Description 

[Pj^] - Partition of the load vector matrix giving static loads on I set. 

Matrix Trailer 

Number of columns = number of subcases 

Number of rows = Jl 

Form = rectangular 

Type = real single precision 



2.3-80 



DATA BLOCK DESCRIPTIONS 

2.3.25 Data Blocks Output From Module SSG3 

2.3.25.1 ULV (MATRIX) 

Description 

[u.] - Partition of the displacement vector matrix giving displacements - I set. 

Matrix Trailer 



Number of columns = number of subcases 

Number of rows = ^ 

Form = rectangular 

Type = real double precision 

2.3.25.2 U0(3V (MATRIX) 
Description 

[u°] - Partition of the displacement vector matrix giving displacements in the o set. 

Matrix Trailer 

Number of columns = number of subcases 

I'Jumber of rows = o 

Form = rectangular 

Type = real double precision 



2.3.25.3 RULV (MATRIX) 



Description 

[6P ] - Residual vector matrix for the it set. 



Matrix Trailer 

Number of columns = number of subcases 

Number of rows = I 

Form = rectangular 

Type = real single precision 



2.3.25.4 RU0V (MATRIX) 



Description 

{5P } - Residual vector matrix for the o set. 



Matrix Trailer 

Number of columns = number of subcases 

Number of rows = o 

Form = rectangular 

Type = real single precision 



2.3-81 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.25.5 UBLV (MATRIX) 
Description 

[u.] - Partition of the differential stiffness displacement vector - Jl set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = l 

Form = rectangular 

Type = real double precision 

2.3.25.6 RUBLV (MATRIX) 
Description 

[6P.] - Differential stiffness residual vector - i set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = l 

Form = rectangular 

Type = real single precision 



2.3-82 



DATA BLOCK DESCRIPTIONS 

2.3.26 Data Blocks Output From Module SSG4 . 

2.3.26.1 PLI (MATRIX) 

Description 

[pj] - Partition of load vector for inertia relief matrix giving loads due to static + 
inertial forces on I set. 

Matrix Trailer 

Number of columns = number of subcases 

Number of rows = I 

Form = rectangular 

Type = real single precision 

2.3.26.2 P(3I (MATRIX) 

Description 

[P^] - Partition of load vector for inertia relief matrix giving loads due to inertial 
° force + static forces on o set. 

Matrix Trailer 

Number of columns = number of subcases 

Number of rows = o 

Form = rectangular 

Type = real single precision 



2.3-83 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3,27 Data Blocks Output From Module SDR1 

2.3,27.1 UGV (MATRIX) 

Description 

[u ] - Displacement vector matrix giving displacements in the g set. 

Matrix Trailer 



Number of columns = number of subcases in CASECC 

Number of rows = g 

Form = rectangular 

Type = real single precision 



2.3.27.2 PGG (MATRIX) 



Description 

[P ] - Static load vector appended to include all boundary conditions - g set. 

Matrix Trailer 

Number of columns = number of subcases in CASECC 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.27.3 QG (MATRIX) 

Description 

[Pg] - Single-point constraint forces and determinate support forces matrix - q set. 

Matrix Trailer 

Number of columns = number of subcases in CASECC 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.27.4 PHIG (MATRIX) 

Description 

[* ] - Eigenvector matrix giving eigenvectors (displacements) in the g set. 

Matrix Trailer 

Number of columns = number of eigenvalues found in READ 

Number of rows = g 

Form = rectangular 

Type = real single precision 



2.3-84 



DATA BLOCK DESCRIPTIONS 



2.3.27.5 UBGV (MATRIX) 

Description 

[u ] - Displacement vector matrix for differential stiffness giving displacements 
^ in the g set. 

Matrix Trailer 

Number of columns = number of factors on a DSFACT bulk data card 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.27.6 QBG (MATRIX) 
Description 

[q ] - Single-point forces of constraint matrix for differential stiffness - g set. 

Matrix Trailer 

Number of columns = number of factors on a DSFACT bulk data card 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.27.7 BQG (MATRIX) 
Description 

[q ] - Single-point forces of constraint matrix for a buckling analysis problem - g set. 

Matrix Trailer 

Number of columns = number of buckling modes found in READ 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.27.8 DELTAU6V (MATRIX) 

Description 

{(5u } - Incremental displacement vector in piecewise linear analysis - g set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = g 

Form = rectangular 

Type = real single precision 



2.3-85 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.27.9 DELTAPG (MATRIX) 

Description 

{6P } - Incremental load vector in piecewise linear analysis - g set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.27.10 DELTAQG (MATRIX) 

Description 

{6q } - Incremental vector of single-point forces of constraint in piecewise linear. 
^ analysis - g set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = g 

Form = rectangular 

Type = real single precision 



2.3.27.11 CPHIP (MATRIX) 
Description 



[* ] - Complex eigenvectors in p set. 



Matrix Trailer 



Number of columns = number of eigenvalues found in CEAD 

Number of rows = p 

Form = . rectangular 

Type = complex single precision 



2,3.27.12 QPC (MATRIX) 
Description 

[flp] - Complex single-point forces of constraint - p set. 

Matrix Trailer 

Number of columns = number of eigenvalues found in CEAD 

Number of rows = p 

Form = rectangular 

Type = complex single precision 



2.3-86 



DATA BLOCK DESCRIPTIONS 



2.3.27.13 UPVC (MATRIX) 
Description 

[Uq] - Frequency response solution vectors - p set. 

Matrix Trailer 

Number of columns = the product of the number of frequencies and number of loads 

Number of rows = p 

Form = rectangular 

Type = complex single precision 

2.3.27.14 UPV (MATRIX) 

Description 

[u ] - Transient solution vectors - p set. 

Matrix Trailer 

Number of columns = the number of output times multiplied by 3 

Number of rows = p 

Form = rectangular 

Type = real single precision 

2.3.27.15 QP (MATRIX) 

Description 

[Qp] - Transient single-point forces of constraint - p set. 

Matrix Trailer 

Number of columns = the number of output times multiplied by 3. 

Number of rows = p 

Form = rectangular 

Type = real single precision 



2.3-87 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.28 Data Blocks Output From Module SDR2 . 

2.3.28.1 filUGVl (TABLE) 

Description 

Output displacement vector requests (g set, S0RT1, real). 
Table Format 



Record 


1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 



li^e 



1 
2 
3-8 



Item 

Header record 

Device code + 10*approach code 

1 



Subcase number 

Load set ID 







Format code 

Number of words per entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code ) reoeat 

Poi nt type } for each 

R(T1), R(T2), R(T3), R{R1), R(R2), R(R3)) point 



Notes 



1 . Records 1 and 2 are repeated for each vector to be output 



Device code = 

Format code = 
Approach code 

Point type 



fO = X y output only 

)1 = print 

14 = punch 

^5 = print and punch 

fl = real 

,2 = real /imaginary 

[3 = magnitude/phase 

1. 3, 7, or 10 

'l = grid point 

1 2 = scalar point 

13 = extra point 
,4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2,3-88 



DATA BLOCK DESCRIPTIONS 

2.3.28,2 «)UBGV1 (TABLE) 
Description 

Output displacement vector requests (g set, S0RT1 , real) 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*aDDroach code 




2 




1 




3 









4 




Subcase number 




5 




Load set ID 




6 









7 









8 









9 




Format code 




10 




Number of words per entry in next record = 8 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


I 


10*point ID + device code ] repeat 




2 


I 


Point type >for each 




3-8 


R 


R{T1), R(T2). R(T3). R(R1), R(R2), R(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 



Format code = 



fo = X y output only 

)l = print 

|4 = punch 

's = print and punch 

p = real 

Iz = real /imaginary 

(3 = magnitude/phase 



4. Approach code = 4 



5. Point type 



fl = grid point 

)2 = scalar point 

j3 = extra point 

'4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-89 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.28.3 giUPVl (TABLE) 
Description 

Output displacement vector requests (p set, S0RT1 , real). 
Table Format 



Record 


Word 


Type 


Item 











Header record 


1 


1 




I 


Device code + 10*approach code 
( 1 = Displacement 




2 




I 


<10 = Velocity 
(ll = Acceleration 




3 




I 







4 




I 


Subcase number 




5 




R 


Time 




6 




I 







7 




I 







8 




I 


Load set ID 




9 




I 


Format code 




10 




I 


Number of words per entry in next record = 8 




11- 


50 




Not defined 




51- 


82 


B 


Title 




83- 


114 


B 


Subtitle 




115- 


■146 


B 


Label 


2 


1 




I 


10*point ID + device code ] repeat 




2 




I 


Point type >for eai 




3- 


•8 


R 


R(T1), R(T2), R(T3). R(Rl), R(R2), R(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 

5. Point type 



fO = X y output only 

)l = print 

j4 = punch 

(5 = print and punch 

(1 = real 

(2 = real /imaginary 

(3 = magnitude/phase 



ll = grid point 

;2 = scalar point 

i3 = extra point 

(4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-90 



DATA BLOCK DESCRIPTIONS 

2.3.28.4 0UPVC1 (TABLE). 
Description 

Output displacement vector requests (p set, S0RT1 , complex), 
Table Format 



Record 



Word 



Type 



Item 



3 

4 

5 

6 

7 

8 

9 
10 

n-50 

51-82 

83-114 

115-145 

1 
2 

3-8 
9-14 



Header record 



Device code + 10*approach code 
'1001 = Displacement 

1010 = Velocity 

1011 = Acceleration 


Subcase number 

Frequency 





Load set ID 

Format code 

Number of words per entry in next record = 14 

Not defined 

Title 

Subtitle 

Label 



10*point ID + device code ) repeat 

Point type (for 

R(T1), R(T2), R(T3), R(R1), R(R2), R(R3)reach 

I(T1). I(T2), I(T3), I(R1), I(R2), I(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code 



Format code = 



4. Approach code 



5. Point type 



lO = X y output only 

)l = print 

U = punch 

(,5 = print and punch 

(1 = real 

<2 = real/imaginary 

(3 = magnitude/phase 



n = grid point 

)2 = scalar point 

J3 = extra point 

'4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-91 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.28.5 0PG1 (TABLE) . 
Description 

Output load vector requests (g set, S0RT1 , real) 



Table Format 








Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*aDproach code 




2 




2 




3 









4 




Subcase number 




5 




Load set ID 




6 









7 









8 









9 




Format code 




10 




Number of words per entry in next record = 8 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


I 


10*point ID + device code ^Repeat 




2 


I 


Point type >for each 




3-8 


R 


R(T1), R(T2), R{T3). R(R1), R(R2), R(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be cutout. 

2. Device code = 



!0 = X y output only 
1 = print 
4 = punch 
5 = print and punch 



3. Format code = 



(1 = real 

\2 = real /imaginary 

(3 = magnitude/phase 



4. Approach code = 1, 3, 7, or 10 

5. Point type 



1 = grid point 

2 = scalar point 

3 = extra point 

4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-92 



DATA BLOCK DESCRIPTIONS 

2.3.28.6 0PP1 (TABLE). 
Description 

Output load vector requests (p set, S(3RT1 , real). 
Table Format 



Record 

1 



Notes 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 



Type 



Item 



1 
2 
3-8 



Header record 

Device code + 10*approach code 

2 



Subcase number 

Time 





Load set ID 

Format code 

Number of words per entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code ) repeat 

Point type I for each 

R(T1). R(T2), R(T3). R(R1), R(R2), R(R3)jpoint 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code = 

5. Point type = 



(O = X y output only 

jI = print 

J4 = punch 

(.5 = print and punch 

p = real 

<2 = real /imaginary 

(3 = magnitude/phase 



1 = grid point 

12 = scalar point 

13 = extra point 
[4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-93 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.28.7 0PPC1 (TABLE). 
Description 

Output load vector requests (p set, SfJRTl , complex). 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 

1 
2 

3-8 
9-14 



Type 



Item 



Header record 



Device code + 10*approach code 

1002 



Subcase number 

Frequency 





Load set ID 

Format code 

Number of words per entry in next record = 14 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code ^reoeat 

Point type (-For 

R(T1 . R(T2), R(T3), R(R1), R(R2), R(R3)(each 
I(T1), I(T2), I(T3), I(R1), I{R2), I(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 

5. Point type 



fO = X y output only 

)1 = print 

j4 = punch 

(.5 = print and punch 

(1 = real 

^2 = real/imaginary 

(3 = magnitude/phase 



h = grid point 

)2 = scalar point 

)3 = extra point 

'4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-94 



DATA BLOCK DESCRIPTIONS 

2.3.28,8 0QG1 (TABLE) 
Description 

Output forces of single-point constraint requests (g set, S0RT1 , real). 
Table Format 



Record 

1 



Notes 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11-50 

51-82 

83-114 

115-146 

1 
2 
3-8 



Jl21 



Item 



Header record 



Device code + 10*approach code 

3 



Subcase number 

Load set ID 







Format code 

Number of words per entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code )reneat 

Point type Wor each 

R(T1), R(T2). R(T3), R(R1), R(R2), R(R3)inoint 



1. Records 1 and 2 are repeated for each vector to be output. 



Device code = 



Format code 



ro = X y output only 

'l = print 

)4 = punch 

(.5 = print and punch 

(1 = real 

(2 = real /imaginary 

(3 = magnitude/phase 



4. Approach code = 1, 2, 3, 7, or 10 

5. Point type = 



M = grid point 

)2 = scalar point 

)3 = extra point 

U = modal point 



Table Tra i 1 er 



Words 1-6 contain no significant values. 



2.3-95 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.28.9 0QBG1 (TABLE) 
Description 

Output forces of single-point constraint requests (g set, S0RT1 , real). 



Table Format 



Record 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11-50 

51-82 

83-114 

115-146 

1 
2 
3-8 



Type 



Item 



Header record 



Device code + n*anDroach code 

3 



Subcase number 

Load set ID 







Format code 

Number of words oer entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code | repeat 

Point type Kor each 

R(T1). R(T2), R(T3), R(R1), R(R2), R(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code = 

5. Point type 



iO = X y output only 

1 = print 

4 = punch 

5 = print and punch 

(1 = real 

<2 = real/imaginary 

(3 = magnitude/phase 



C] = grid point 

12 = scalar point 

J3 = extra point 

(4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-96 



DATA BLOCK DESCRIPTIONS 

2.3,28.10 0BQG1 (TABLE) . 
Description 

Output forces of single-point constraint requests (g set, S0RT1, real). 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*approach code 




2 




3 




3 









4 




Subcase number 




5 




Mode number 




6 




Eigenvalue 




7 









8 









9 




Format code 




10 




Number of words ner entry in next record = 8 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


I 


10*point ID + device code ) ren 




2 


I 


Point type Wor 




3-8 


R 


R(T1). R(T2). R(T3). R(Rl). R(R2). RfR3) noi 



each 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 



3. Format code 



ro = X y output only 

11 = print 

j4 = punch 

(5 = print and punch 

1 = real 

2 = real/imaginary 

3 = magnitude/phase 



4. Approach code = 8 

5. Point type 



1 = grid point 

2 = scalar point 

3 = extra point 

4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2,3-97 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.28.n 0QP1 (TABLE). 
Description 

Output forces of single-point constraint requests (p set, S0RT1 , real). 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*aDnroach code 




2 




3 




3 









4 




Subcase number 




5 




Time 




6 









7 




C 




8 




Load set ID 




9 




Format code 




10 




Number of words per entry in next record = 8 




n-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


I 


10*point ID + device code ) repeat 




2 


I 


Point type >for each 




3-8 


R 


R(T1), R(T2), R(T3), R(R1), R(R2), R(R3)jpoint 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 

2. Device code = 



!0 = X y output only 
1 = print 
4 = punch 
5 = print and punch 



3. Format code = 

4. Approach code 

5. Point type 



n = real 

<2 = real/imaginary 

(3 = magnitude/ohase 



(] = grid point 

12 = scalar point 

J3 = extra point 

(4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-98 



DATA BLOCK DESCRIPTIONS 

2.3.28.12 0QPC1 (TABLE). 
Description 

Output forces of single-point constraint requests (p set, S0RT1 , complex), 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 

1 

2 

3-8 

9-14 



Iffie 



R/I 
/R 
/R 



Item 

Header record 

Device code + 10*approach code 

1003 



Subcase number 

Frequency or mode number 

or eigenvalue (real part) 

or eigenvalue (real part) 

Load set ID 

Format code 

Number of words per entry in next record = 14 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code )reneat 

Point type (for 

R(T1), R(T2), R(T3). R(R1), R(R2), R(R3)(each 

I(T1), I(T2), I(T3), I(R1), I(R2), I(R3))Doint 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



Device code 



Format code 



fO = X y output only 

}1 = print 

]4 = punch 

(5 = print and punch 

1 = real 

2 = real /imaginary 
.3 = magnitude/phase 



Approach code = 5, or 9 
Point type = 



1 = grid point 

2 = scalar point 

3 = extra point 

4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-99 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.28.13 0PHIG (TABLE). 
Description 

Output eigenvector requests (g set, S(?RT1 , real), 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

n-50 

51-82 

83-114 

115-146 

1 
2 
3-8 



Tj^ 



Item 



B 
B 
B 

I 
I 
R 



Header record 



Device code + 10*apDroach code 

7 



Subcase number 

Mode number 

Eigenvalue 





Format code 

Number of words per entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code ^repeat 

Point type >for each 

R(T1), R(T2), R(T3), R(R1). R(R2), R(R3))point 



iNotes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 



5. Point type 



!0 = X y output only 
1 = print 
4 = punch 
,5 = print and punch 



3, Format code = 

4. Approach code = 2, or 8 



1 = real 

2 = real /imaginary 

3 = magnitude/phase 



(] = grid point 
j2 = scalar point 
J3 = extra point 
(4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-100 



DATA BLOCK DESCRIPTIONS 

2.3.28.14 i^CPHIP (TABLE). 
Description 

Output eigenvector requests (p set, S0RT1 , complex). 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 

1 
2 

3-8 
9-14 



Type 



Item 



Header record 



Device code + 10*approach code 

1007 



Subcase number 

Mode number 

Eigenvalue (real part) 

Eigenvalue (imaginary part) 



Format code 

Number of words per entry in next record = 14 

Not defined 

Title 

Subtitle 

Label 

10*point ID + device code ^repeat 

Point type (for 

R(T1), R(T2). R(T3), R(R1), R(R2), R(R3)feach 

I(T1), I(T2), I(T3), I(R1). I(R2), I(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 

5. Point type = 



fO = X y output only 

U = print 

i4 = punch 

[p = print and punch 

p = real 

(2 = real /imaginary 

(3 = magnitude/phase 



n = grid point 

)2 = scalar point 

J3 = extra point 

(.4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-101 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.28.15 0ES1 (TABLE). 
Description 

Output element stress requests {S(JRT1 , real). 
Table Format 



Record 


Word 


Type 


Item 











Header record 


1 


1 
2 
3 
4 






Device code + 10*approach code 

5 

Element type 

Subcase number 




5 




I/R 


Time, Load set ID, or mode number 




6 




R/I 


Eigenvalue or 




7 











8 






Load set ID or 




9 






Format code 




10 






Number of words per entry in next record = NWDS 




11- 


50 




Not defined 




51- 


82 


B 


Title 




83- 


114 


B 


Subtitle 




115- 


146 


B 


Label 


2 


1 




I 


10*element ID + device code ) reoeat 




2- 


NWDS 


Mixed 


Element stress data >for each 



See 2.3.51 for details ) element 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 
'0 = X y output only 



Device code = 



ll = print 
1 4 = punch 
.5 = print and punch 



(1 = real 
3. Format code = <2 = real/imaginary 
(3 = magnitude/phase 



4. Approach code 
Table Trailer 



1, 2, 3, 5, 7, or 10 



Words 1-6 contain no significant values. 



2.3-102 



DATA BLOCK DESCRIPTIONS 



2.3.28.15 0ESB1 (TABLE). 
Description 

Output element stress requests (S0RT1 , real). 



Table Format 










Record 


Word 


Type, 


Item 











Header record 




1 


1 
2 
3 
4 
5 
6 
7 
8 
9 




Device code + 10*aDDroach code 

5 

Element type 

Subcase number 

Load set ID 







Format code 






10 




Number of words ner entry in next record 


= NWDS 




n-50 




Not defined 






51-82 


8 


Title 






83-114 


B 


Subtitle 






115-145 


B 


Label 




2 


1 


I 


10*element ID + device code ) repeat 






2-NWDS 


Mixed 


Element stress data >for each 
See 2.3.51 for details element 





Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



fO = X y output only 

11 = print 

j4 = punch 

[5 = print and punch 

(1 = real 

;2 = real /imaginary 

(3 = magnitude/phase 



2. Device code = 

3. Format code = 

4. Approach code = 4 
Table Trailer 

Words 1-6 contain no significant values. 



2.3-103 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.28.17 laBESl (TABLE). 
Description 

Output element stress requests {S0RT1 , real) 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*approach code 




2 




5 




3 




Element type 




4 




Subcase number 




5 




Mode number 




5 




Eigenvalue 




7 









8 









9 




Format code 




10 




Number of words per entry in next record = NMns 




n-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


I 


10*element ID + device code ) repeat 




2-rJWDS 


Mixed 


Element stress data >for each 
See 2.3.51 for details ) element 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code 



lO = X y output only 

)l = print 

|4 = punch 

(.5 = print and punch 



3. Format code = <2 

(3 

4. Approach code = 8 



real 

real/imaginary 

magnitude/phase 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-104 



DATA BLOCK DESCRIPTIONS 



2,3.28.18 0ESC1 (TABLE). 
Description 

Output element stress requests (S0RT1 , complex), 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-145 

1 

2-NWDS 



mi 



Item 



R/I 
/R 
/R 



B 
B 
B 

I 

Mi xed 



Header record 



Device code + 10*approach code 

1005 

Element type 

Subcase number 

Frequency or mode number 

or eigenvalue (real part) 

or eigenvalue (imaginary part) 

Load set ID 

Format code 

Number of words per entry in next record = NV/DS 

Not defined 

Title 

Subtitle 

Label 

10*element ID + device code ] reoeat 
Element stress data >for each 
See 2.3.51 for details ) element 



Notes 



1. Records 1 and 2 are repeated for each vector to be outout. 



2. Device code = 

3. Format code = 

4. Approach code 
Table Trailer 



(O = X y output only 

11 = print 

J4 = punch 

(5 = print and punch 

(1 = real 

<2 = real /imaginary 

(3 = magnitude/phase 

5, or 9 



Words 1-6 contain no significant values. 



2.3-105 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.28.19 0EF1 (TABLE). 
Description 

Output element force requests (S0RT1 , real). 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*apDroach code 




2 




4 




3 




Element type 




4 




Subcase number 




5 


I/R 


Time, load set ID, or mode number 




6 


I/R 


or eigenvalue 




7 









8 




Load set ID or 




9 




Format code 




10 




Number of words oer entry in next record = MWDS 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


I 


10*element ID + device code ) repeat 




2-NWDS 


Mixed 


Element force data >for each 
See 2.3.52 for details (element 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 

2. Device code = 



(0 = X y output only 

11 = print 

J4 = punch 

'5 = print and punch 



3. Format code 



p = real 

\2 = real /imaginary 

(3 = magnitude/phase 



4. Approach code = 1, 2, 3, 6, 7, or 10 
Table Trailer 

Words 1-5 contain no significant values. 



2.3-106 



DATA BLOCK DESCRIPTIONS 



2.3.28.20 0EFB1 (TA3LE) . 
Description 

Output element force requests (S0RT1 , real] 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-145 



Tffie 



Item 



NWDS 



B 
B 
B 

I 
Mixed 



Header record 



Device code + 10*approach code 

4 

Element type 

Subcase number 

Load set ID 







Format code 

Number of words per entry in next record = NWDS 

Not defined 

Title 

Subtitle 

Label 



10*element ID + device code 
Element force data 
See 2.3.52 for details 



reneat 
for each 
element 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code 



fO = X y output only 

)1 = print 

|4 = punch 

[5 = print and punch 



(1 = real 

3. Format code = <2 = real/imaginary 

(3 = magnitude/phase 

4. Approach code = 4 
Table Trailer 

Words 1-6 contain no significant values. 



2.3-107 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.28.21 0BEF1 (TABLE). 
Description 

Output element force requests (S0RT1 , real). 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*anDroach code 




2 




4 




3 




Element type 




4 




Subcase number 




5 




Mode number 




5 


R 


Eigenvalue 




7 









8 









9 




Format code 




10 




Number of words per entry in next record = N'.ilDS 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


I 


10*element ID + device code ) repeat 




2-NWDS 


Mixed 


Element force data >for each 
See 2.3.52 for details ) element 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 



fO = X y outout only 

11 = print 

j4 = punch 

(5 = print and punch 

(1 = real 

y. = real /imaginary 

(3 = magnitude/phase 

8 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-108 



DATA BLOCK DESCRIPTIONS 

2.3.28.22 0EFC1 (TABLE). 
Description 

Output element force requests (S0RT1 , complex). 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

5 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-145 

1 

2-NUDS 



IZEi 



Item 



R/I 
/R 
/R 



I 
Mixed 



Header record 



Device code + 10*approach code 

1004 

Element type 

Subcase number 

Frequency or mode number 

or eigenvalue [real part) 

or eigenvalue (imaginary part) 

Load set ID or 

Format code 

Number of words oer entry in next record = N'-IDS 

Not defined 

Title 

Subtitle 

Label 



10*element ID + device code 
Element force data 
See 2.3.52 for details 



reoeat 
for each 
element 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 
Table Trailer 



= X y output only 
1 1 = print 

1 4 = punch 

,5 = print and punch 

1 = real 

2 = real /imaginary 

3 = magnitude/phase 

5, or 9 



Words 1-6 contain no significant values. 



2.3-109 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.28.23 PUGVl (matrix - see note below) 

Description 

PUGVl contains the translation components of UGVl rotated to the basic coordinate system. 

Note 

The first four words of each logical record (column) contain identification data for the 
column. These words must be read prior to calling the appropriate unpacking routine. 

Word 1 = subcase number 
Word 2 = 1 

Word 3 = static load set ID 
Word 4=0 

Matrix Trailer 

Trailer is same as that for UGVl except word 1 = 0, and word 6=0 (see section 2.3.36.1). 



2.3-110 



DATA BLOCK DESCRIPTIONS 

2.3.28.24 PUBGVl (matrix - see note below) 

Description 

PUBGVl contains the translation components of UBGV rotated to the basic coordinate system. 

Note 

The first four words of each logical record Ccolumn) contain identification data for the 
column. These words must be read prior to calling the appropriate unpacking routine. 

Word 1 = subcase number 
Word 2 = 1 

Word 3 = static load set ID 
Word 4=0 

Matrix Trailer 

Trailer is same as that for UBGV with word 1 =0, and word 6=0. 



2.3-ni 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3,28,25 PPHIG (matrix - see note below) 

Description 

PPHIG contains the translation components of PHIG rotated to the basic coordinate system. 

Note 

The first four words of each logical record (column) contain identification data for the 
column. These words must be read prior to calling the appropriate unpacking routine. 

Word 1 = subcase number 
Word 2=2 

Word 3 = mode number 
Word 4 = eigenvalue (A) 

Matrix Trailer 

Trailer is same as that for PHIG with word 1 = 0, and word 6=0, (see section 2.3.27.4). 



2.3-112 



DATA BLOCK DESCRIPTIONS 



2.3.28.25 PUGV (matrix - see note below) 
Description 

PUGV contains the translation components of UPV (excluding extra ooints) rotated to the hasic 
coordinate system. 

Note 

The first four words of each logical record (column) contain identification data for the 
column. These words must be read prior to calling the appropriate unpacking routine. 

■Jord 1 = subcase number 
'Aord 2 = 3 
Word 3=0 
Word 4 = time 

Matrix Trailer 

Trailer is same as that for UGV with word 1 = 0, and word 6=0, (see section 2.3.27,1). 



2.3-113 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.29 Data Blocks Output From Module DPD 

2.3.29.1 GPLD (TABLE) 

Description 

Grid Point List Dynamics. 

One logical record which contains a list of all grid points, scalar points and extra points 
in the model in internal sort. 



Table Format 








Record 


Word 


Type 


Item 









Header record 


1 


1 


I 


ID for first point 



n I ID for n**^ point 

2 End-of-file 

Table Trailer 

Word 1 = number of grid points + number of scalar points + number of extra points. 
Word 2-6 = zero. 

2.3.29.2 SILD (TABLE) 

Description 

Scalar Index List Dynamics. 

Two logical records. First logical record contains scalar index values in the p-displace- 
ment set for each point in the dynamics model (internal order). These values are defined 
as follows: 

SILD^ = 1 

5jl_Q _ 'LD^. + 6 if i corresponds to a grid point 

i+1 ~ '-D^ + 1 if i corresponds to a scalar or an extra point 

The second logical record contains an equivalence between scalar index values in the 
g-displacement set and scalar index values in the p-displacement set. 



2.3-114 



DATA BLOCK DESCRIPTIONS 



Table Format 



Record 



Word 



n 
1. 2 



1121 



Item 
Header record 
Scalar index for first point 

Scalar index for n point 
SIL value, SILD value 



Tabl 


e Tra 


ler 




Word 


1 




Word 


2 




Word 


3-6 



2m- 1,2m 



SIL value, SILD value 
End-of-file 



degrees of freedom in the p-displacement set (LUSETD). 

number of extra points. 

zero. 



2.3.29.3 USETD (TABLE) 

Description 

Displacement set definitions table dynamics. 

USETD contains one logical record. Each word corresponds to each degree of freedom in the 
p-displacement set (in internal order) and contains ones in specified bit positions indicat- 
ing the displacement sets to which the point belongs. 



Table Format 



Record 



Word 



Ty£e 



Item 
Header record 
Mask for first degree of freedom 

Mask for n degree of freedom 
End-of-file 



Notes 



Bit positions for the various displacement sets are defined as follows: 



d 


^e 


"e 


P 


e 


^b 


^g 


i 


a 


f 


n 




9 


r 





s 


m 



17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 



2.3-115 



DATA BLOCK AND TABLE DESCRIPTIONS 



Table Trailer 



Word 1 = degrees of freedom in the p-displacement set (LUSETD). 

Word 2 = number of extra points. 

Word 3 = zero. 

Word 4 = logical "or" of all USETD masks. 

Word 5 = zero. 

Word 6 = zero. 



2.3.29.4 EED (TABLE) 

Description 

Eigenvalue Extraction Data. 

The EED contains one logical record for each eigenvalue extraction card type (EIGS, EIRC, 
EIGP, EIGR). Each logical record contains data from all cards of a given type. 



Table Format 



Record 



Word 




1 
2 
3 
4 
5 
Detailed format for EIGB data: 



Word 

1-3 
4 

5-6 
7-8 

9-n 

12 

13-14 

15 

16-21 



Ml 

1 
I 
B 
R 

I 

R 



Item 
Header record 

EIGB data (if EIGB cards in bulk data) 
EIGC data (if EIGC cards in bulk data) 
EIGP data (if EIGP cards in bulk data) 
EIGR data (if EIGR cards in bulk data) 
End-of-file 

Item 



107 
Set 


, 1. 

ID 





Method 




^• 


F 

2 




%' 


^d' 


h 



E 

Norm 

If norm = "Pj^INT", SIL value in 

a-set of normalization point 

Not defined 



repeated 
for each 
EIGB card 
in bulk data 



2.3-116 (7/1/70) 



DATA BLOCK DESCRIPTIONS 



Detailed format for EIGC card: 



Word Type 

1-3 I 

4 I 

5-6 B 

7-8 B 

9 I 

10 

11 R 

12-13 

14-15 R 

16-17 R 

18 R 

19-20 I 

21 

14+8k-21+8k I 

Detailed format for EIGP card: 



Item 

207, 2, 

Set ID 

Method 

Norm 

If Norm = "POINT", SIL value in analysis 

set of normalization point 
Not defined 



Not defi 


ned 




a w 






a a 




repeated 
for each 






region 
definition 


Not defi 
-1 (k = 


ned ) 

number of regions 



repeated 
for each 
EIRC card 
in bulk data 



Word 



Iffii 



Item 



1-3 


I 


257, 4, 


D 


I 


Set ID 1 repeated for 


6-7 


R 


a, to >each EIGP card 


8 


I 


M ) in bulk data 



Detailed format for EIGR card: 



Word 



Type 



Item 



1-3 
4 

5-6 
7-8 






I 
I 
B 
R 




307, 3, 

Set ID ^ 

Method 

F^. F^ 


1 


9-11 

12 

13-14 

15 

16-21 






I 

R 
B 

I 




Ne. N,. N^ 1 

E 

Norm 

If norm = "P(3INT", SIL value in 

a-set of normalization point 

Not defined 

J 


1 repeated 
1 for each 
/ EIGR card 
in bulk data 

I 


Table Trailer 














Word 1 


= 












bit 17 = 

18 = 

19 = 

20 = 


1 

1 
1 
1 


if 
if 
if 

if 


EIGB 
EIGC 
EIGP 
EIGR 


record 
record 
record 
record 


exists 
exists 
exists 
exists 





other bits = 
Word 2-6 = zero. 



2.3-117 (7/1/70) 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.29.5 EQDYN (TABLE) 

Description 

Equivalence between external points and scalar index values - dynamics. 

EQDYN contains two logical records. The first record contains pairs of external point 
numbers and scalar index values in the p-displacement set for the points in external order. 
The second record is essentially the same as the first except that the type of point (grid, 
scalar, extra) is coded in the second word of the pair. 



Table Format 
Record 

1 



Word 



1.2 



IZEi 



Item 
Header record 
ID for first point, scalar index for first point 



2n-l,2n 



ID for n point, scalar index for n point 



1,2 



ID for first point, 10*scalar index + type 



2n-l,2n 



ID for n point, 10*scalar index + type 
End-of-file 



Note 



p for grid point 
Type = \Z for scalar point 
(3 for extra point 



Table Trailer 



Word 1 = number of grid points + number of scalar points + number of extra points 
in dynamics model . 

Word 2 = number of extra points. 

Word 3-6 = zero. 



2.3-118 



DATA BLOCK DESCRIPTIONS 



2,3.29.6 TFP00L (TABLE). 

Description 

Transfer Function Fool. 

The TFP00L data block contains one logical record for each transfer function set defined in 
the bulk data on a TF bulk data card. Point and component values are converted to row and 
column numbers in the p-displacement set. 

Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 
2 
3-5 


I 
I 
R 


Set ID 

65536*column number + row m 

Coefficients 


n 






Same format as first record 


n+1 






End-of-file 


Table Trailer 









each set of 
non-zero terms 



Word 1 = number of transfer function sets. 
Word 2-6 = zero. 

2.3.29.7 DLT (TABLE). 

Description 

Dynamic Loads Table. 

The header record of the DLT contains a summary of all dynamic load sets defined in the 
problem. The first record of the DLT contains all DL0AD cards (if DLjiiAD cards have been input), 
Each succeeding record contains all data for one dynamic load set. 



Table Format 



Record 



Word 



4+£,5+Jl 



Tyge 



1-2 


B 


3 


I 


4-3+m 


I 


4-Hn-3+m+n • 


I 


1 


I 


2 


R 


3-4 


R.I 



Item 

Data block name 

m = number of DL0AD set ID's 

Set id's on OL0AD cards 

Set id's on RL(5AD1 , 2 and TL0AD1 , 2 cards 



Set ID 

Scale factor 

Scale factor, set ID 



repeated 
for each 
DL0AD 
card 



_i 



2.3-119 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 



Record Word T ype Item 

k 1 I Dynamic load card tyoe 

P y (= no time delays 

^ \?« time delays 

3-8 See Notes 

9 I SIL number \ repeated for each 

10-12 R A, T, 9 I dynamic load set 

n+2 End-of-file 

Notes 

1. If no DL0AD cards have been input, the third word of the header record is zero and the 
DL0AD record does not exist. Therefore, record 1 of the DLT corresponds to the load 
set defined in word 4 of the header record. 

2. DL0AD-set ID'S are in sort by set ID. In record 1, set ID's within a DL0AD card are 
in sort. 

3. Within other records, data is in sort by SIL number. 

4. Formats by dynamic load card type are as follows: 



1 = RL0AD1 



RL8IAD2 



3 = TL0AD1 



Word Type Item 

3 I Table ID for C(f) 

4 I Table ID for D(f) 
5-8 Not defined 



Word Type Item 

3 I Table ID for B(f) 

4 I Table ID for ())(f) 
5-8 Not defined 



Word Type Item 

3 I Table ID for F(t) 

4-8 Not defined 



TL0AD2 





Word 


Type 


Item 




3-4 


R 


^Kl' ^K2 




5-6 


R 


\' H 




7-8 


R 


"k* "k 


Table Trailer 









Word 1 = GIN0 file name of DLT. 
Word 2-6 = undefined. 



2.3-120 



DATA BLOCK DESCRIPTIONS 



2.3.29.8 PSDL (TABLE) 



Description 



Power Spectral Density List. 

The first logical record of the PSDL contains RANDPS data. Subsequent logical records 
contain RANDT data, one set per logical record. Each RANDT logical record contains a 
sorted list of unique time lags defined in the set. 



Table Format 










Record 


Word 


Type 




Item 





1.2 
3 


B 

I 


Data block name 

RANDT set ID 

1 






2+n 


I 


RANDT set ID 
n 




1 


1 

2 

3 

4.5 

6 


I 
I 
I 
R 
I 


RANDPS set ID ] 
Load set ID / 
Load set ID / 
Compl ex number \ 
Table ID J 


1 repeated 
'for each 
.RANDPS 
card in 
'bulk data 



1-m 



Time lags 



n+1 
n+2 



Same format as record 2 
Data belongs to RANDT set ID 

End-of-file 



Notes 



1. RANDPS cards must be present for data block to exist. Therefore, record one always 
contains RANDPS data. 

2. If no RANDTl or RANDT2 cards are present in the bulk data, the header record will 
contain exactly two words and record two will be an end-of-file. 



Table Trailer 



Word 1 

Word 2-6 = zero. 



number of RANDT sets, or 
65535 if no RANDT sets exist. 



2.3-121 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.29.9 FRL (TABLE) 

Description 

Frequency Response List. 

The FRL contains one logical record for each different frequency set defined in the bulk 
data. Each record contains a sorted list of the unique frequencies defined in the set. 



Table Format 








Record 


Word 


Type 


Item 





1,2 
3 


B 

I 


Data block name 

Set ID 

1 




2+n 


I 


Set ID^ 


1 


1-m 


R 


Frequencies beli 



1-k 



Frequencies belonging to set ID 



n+1 

Table Trailer 
Word 1 
Word 2-6 



number of frequency sets, 
zero. 



End-of-file 



2.3.29.10 NLFT (TABLE) 

Description 

Non-Linear Forcing Table. 

The header record of the NLFT contains a sorted list of set identification numbers for all 
N0LIN sets defined in the bulk data. Each logical record of the NLFT contains all data for 
a single set. Point and component numbers on the N0LIN cards are converted to scalar index 
values in both the d- and e-displacement sets. 



Table Format 








Record 


Word 


Type 


Item 





1.2 
3 


B 

I 


Data block name 

Set ID 

1 



2+n 



Set ID, 



n 



2.3-122 



DATA BLOCK DESCRIPTIONS 



Record Word Type Item 

1 1 I Type of nonlinear load (lstype=4) 

2 I SIL value in d-set 

3 I SIL value in e-set 

4 R Scale factor 

5 I SIL value in d-set 

6 I SIL value in e-set , ^ . ^ 
type = 1 = Table ID (integer) V '"^"u^^/^!"'" 
type = 2 = SIL value in d-set (integer) /^^^] ^'"'-IN 
type = 3 = Scale factor (real) ( "'''^ ''" set 
type = 4 = Scale factor (real) 
type = 1 = Not defined 

I type = 2 = SIL value in e-set (integer) 

I type = 3 = Not defined 

type = 4 = Not defined 



n Same format as record 1. 

Data belongs to set ID . 

n+1 End-of-file 

Note 

Within each record, the data is sorted on word 2 of each 8-word entry in the record. 
Table Trailer 

Word 1 = number of Nj>LIN sets. 

Word 2-6 = zero. 



2.3-123 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.29.11 TRL (TABLE). 
Description 

Transient Response List. 

The header record of the TRL contains a list of all transient initial condition set 
identifications in the bulk data. Subsequent logical records contain TIC data for each 
set (one set per logical record). If TSTEP cards are oresent in the bulk data, this data 

follows the TIC data, one logical record for each TSTEP set. 



Table Format 








Record 


Word 


Type 


Item 





1,2 

3 
4 


B 


Data block name 
Number of TIC sets 

Set ID 

1 




3+n 




Set 10^ 




4+n 




Degrees of freedom 


1 


1 
2,3 


R 


SIL value in d-set 



J condition in set 



Same format as record 1 
Data belongs to set ID 



n+1 



TSTEP set ID 
N ) repeated for 
At > each interval 
NO 1 in set 



n+m 
n+m+1 



Same format as record n+1 
End-of-file 



Kotes 



1. Data within each TIC record is sorted on word 1 of each 3-word entry. 

2. If word 3 of the header record = 0, then the first logical record of the TRL contains 
TSTEP data. 

3. If TSTEP data is not present in the bulk data, and end-of-file will follow the last 
TIC record. 



Table Trailer 



Word 1 = number of TIC sets. 
Word 2 = number of TSTEP sets. 
Word 3-6 = zero. 



2.3-124 



DATA BLOCK DESCRIPTIONS 



2.3.30 Data Blocks Output From Module READ 



2.3.30,1 LAMA 


(TABLE) 








Description 














\ 

a 


Re 


■a1 


Eigenvalue 


Table 






Table Format 














Record 






'vord 




Tvne 


Item 















Header record 


1 






1 
2 
3 

4-9 
10 

11-50 
51-146 




I 

I 
I 

I 
I 

b 


OFF ID record 

21 

9 



7 

Not defined 

Title, subtitle, and label from /OUTrt'T/ 


2 






1 
-? 

3 

4 
5 
6 
7 




I 
I 
R 

R 
R 
R 
R 


OFP data record 
■''ode number 
Extraction order 
A - eigenvalue 

f =^i|X| 

w = i/Z-n 
Generalized mass 
Generalized stiffness 


3 












End-of-file 



rj ctes 

1. The seven data v^ords in record 2 repeat for each eigenvalue found in READ. 

Table Trailer 

iion-zero trailer 

2.3.30.2 PHIA (MATRIX) 
Description 

[* ] - Eigenvectors matrix giving the eigpnvectcrs (displaceirents) in the a set. 
a 

Matrix Trailer 



number of columns = number of eigenvalues found in READ 

I J umber of rov;s = a 

Form = rectangular 

Type = real single precision 



2.3-125 (3/1/70) 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.30.3 MI (MATRIX) 

Description 

[m.] - Modal Mass Matrix 

Matrix Trailer 

Number of columns = number of eigenvalues found in READ 

Number of rows = number of eigenvalues found in READ 

Form = generc.1 

Type = real single precision 

2.3.30.4 0EIGS (TABLE) 

Description 

Real Eigenvalue Summary Table 



Table Format 








Record 


Word 


T^pe 


Item 









Header record 


1 


1 
2 
3 


I 

I 

I 


21 

9 

2 If Inverse Power Method 

1 If Determinant Method 

4 if Givens Method 




4 
5 
6 
7 
8 
9 
10 


I 

I 
I 
I 
I 
I 












Words 11-17 depend on the method used. 



Determinant Method: 



11 1 


Number 


12 ] 


Number 


13 


Number 


14 


Number 


15 


[ Number 


16 


Number 


17 


Reason 




1 




2 




3 




4 



of eigenvalues extracted 

of passes through starting points 

of criteria changes 

cf starting point moves 

of triangular decompositions 

of failures to iterate to a root 

for termination 

- All requested roots formed 

- Out of region predictions from every 
starting point 

- Insufficient time to extract another 
root 

- Everywhere singular matrix 



2.3-126 (12-1-69) 



DATA BLOCK DESCRIPTIONS 



Record 



Word 



Im. 



Inverse Power Method: 




n I 


Number 


12 I 


Number 


12 I 


Number 


14 I 


Number 


15 I 


Number 


16 I 


Dummy 


17 I 


Reasons 




1 




2 




3 




4 




5 




6 




7 



Item 



of eigenvalues extracted 
of starting points used 
of starting points moved 
of triangular decompositions 
of vector iterations 

for termination 

- 2 Singularities encountered in a row 

- 4 Shifts while tracking one root 

Regions completed 
-3* Number of estimated roots were found 
All roots of problem found 
Number desired roots found 
X outside maximum range 
Insufficient time to extract another 
root 

200 iterations and 1 shift point move 
before locating a root 



Givens Method: 



11 
12 
13 

14 
15 
16 
17 



18 

19 
20 

21 



22-50 
51-146 



Number of eigenvalues extracted 

Number of eigenvectors computed 

Number of failures to converge to an eigenvalue 

Number of failures to converge to an eigenvector 

Dummy 

Dummy 

Reason for terminiition 

- Normal termination 

3 - Insufficient time to evaluate eigenvectors 
Value of off-diagonal element of modal mass matrix 
having largest magnitude (zero where not applicable) 
Column of 18 in MI 
Row cf 18 in MI 

Number of off-diagonal elements of modal mass 
matrix that fail to meet error criterion 
Not used 
Title, subtitle, label 



Records 2 and 3 exist only when the Determinant Method is used. 



1 
2 
3 
4 
5 
6 

-! 
I 

8 

9 
10 

11-50 
51-146 

1 
2 

3 

4 



21 

9 

3 













6 

Not used 

Title, subtitle, label 

Starting point ID 
X - Starting point 

oj = JT - Starting point 
f = aj/2TT - Starting point 
Determinant at X 



Words 1-6 are repeated 
for each starting point 



2.3-127 (12-1-69) 



DATA BLOCK DESCRIPTIONS 



Record Word Type Iti£ 

6 R Scale factor (power of 10) \ 

of determinant ' 

n End-of-file 



Table Trailer 



Nonzero 



2.3-127a (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.31 Data Blocks Output From "odule DSMG1 

2.3.31."! KDGG (MATRIX) 
Descript ion 

[K ] - Partition of differential stiffness matrix - g set. 
gg 

Matrix Trailer 



Number of columns = n 

Jiumber of rows = n 

Form = symmetric 

Type = rsal double precision 



2.3-128 



DATA BLOCK DESCRIPTIONS 



2.3.32 Data Blocks Output From Module SMP2 

2.3.32.1 KDAA (MATRIX) 
Description 

[K^^] - Partition of differential stiffness matrix - a set. 

ad 

Matrix Trailer 

Number of columns = a 

Number of rows = a 

Form = symmetric 

Type = real double precision 



2.3-129 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.33 Data Blocks Output From Module DSMG2 

2.3.33.1 KBLL (MATRIX) 
Description 

large displacements - I set. 



[k'' ] - Partition of the stiffness matrix of the first order aoproximation to 



Matrix Trailer 

Number of columns = S- 

Number of rows = 2. 

Form = symmetric 

Type = real double precision 

2.3.33.2 KEFS (MATRIX) 
Description 

[k'' ] - Partition of the stiffness matrix of the first order approximation to 
large displacements. 

Matrix Trailer 



Number of columns = s 

Number of rows = f 

Form = rectanqular 

Type = real double precision 

2.3.33.3 KBSS (MATRIX) 
Description 

[K^ ] - Partition of the stiffness matrix of the first order approximation to 
^^ larqe displacements - s set. 

Matrix Trailer 

Number of columns = s 

Number of rows = s 

Form = symmetric 

Type = real double precision 



2.3-130 



DATA BLOCK DESCRIPTIONS 



2.3.33.4 PBL (MATRIX) 

Description 

\P(^\ - Partition of the load vector of the first order approximation to the 
' large displacements - i set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = ^ 

Form = rectangular 

Type = real single precision 

2.3.33.5 PBS (MATRIX) 

Description 

j P ?■ - Partition of the load vector of the first order anoroximation to the 
large displacement problem - s set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = s 

Form = rectangular 

Type = real single precision 

2.3.33.0 YBS (MATRIX) 
Description 

rsl " P^i^tition of the constrained displacement vector of the first order 
approximation to the large displacement vector - s set. 

Matrix Trailer 

Number of columns = 1 

Number of rows = s 

Form = rectangular 

Type = real single precision 

2.3.33.7 UB00V (MATRIX) 

Description 

{u f - Partition of the displacement vector of the first order approximation to the 
large displacement problem - o set. 

Matrix Trailer 



Number of columns = 1 

Number of rows = o 

Form = rectangular 

Type = real single precision 



2.3-131 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.34 Data Blocks Output From Module PLAl . 

2.3.34.1 KGGXL (MATRIX). 
Description 

Tk'^^I - Stiffness matrix of linear elements exclusive of general elements - g set. 

gg 

Matrix Trailer 

Number of columns = g 

Number of rows = g 

Form = syrmetric 

Type = real double precision 

2.3.34.2 ESTL (TABLE). 
Description 

Element Summary Table for Linear Elements. 

The ESTL contains data copied from the EST data block. An element's EST data resides in 
the ESTL only if it is a linear element of the model. 

Table Format 

Same format as the EST data block output from module TAl . 

Table Trailer 

Word 1 = number of element entries in ESTL. 
Words 2-6 = zero. 



2.3-132 



DATA BLOCK DESCRIPTIONS 



2.3.34.3 ESTNL (TABLE). 
Description 

Element Summary Table for Non-Linear Elements. 

The ESTNL, used only in the Piecewise Linear Analysis Rigid Format, is constructed from the 
Element Summary Table (EST). It contains one logical record for each element type for which at 
least one element of that type is non-linear (an element is defined to be non-linear if its 
modulus of elasticity is defined as the first derivative of a stress-strain tabular function 
input on a TABLESl bulk data card) and for which a request for stress output is found. The con- 
struction of the ESTNL is as follows: the EST data block is read and each element is tested for 
possible non-linearity. If the element is non-linear and the user has requested element stress 
data to be output, its element data is copied onto the ESTNL data block and then initial stress 
data is appended. The only elements admissible to the ESTNL are: R0D, TUBE, C0NR0D, BAR, TRMEM, 
TRIAl, TRIA2, QDMEM, QUADl , QUAD2. 

Table Format 



Record 



Word 



Item 



2 to N+1 
N+2 to N+M+1 



Header record 

Element type (integer) 1 repeated for 

Element EST data ^repeated for each >each admissible 
Element stress data/non-linear element ) element tyne 



Notes 



1. N is the number of words in the EST data section. 
M is the number of stress words appended. 

2. The number of records in the ESTNL corresponds to the number of separate admissible 
element types for which at least one element is non-linear. 



Table Trailer 

Word 1 = total number of elements in the ESTNL. 
Words 2-6 = zero. 

Detailed ESTNL Formats 



RQID. C0NR0D: 



Word 



Item 



1-17 
18 
19 

20 

21 



EST data 

* 
Co, previous strain value once removed, initially zero 

* 
£ , previous strain value, initially zero 

* 

E , the previously calculated modulus of elasticity, initially 
the value of E given a MATl card. 

T , the previously calculated torsional moment, initially zero 



2.3-133 



TUBE: 



DATA BLOCK AND TABLE DESCRIPTIONS 



BAR: 



TRMEM: 



TRIAl; 



Word 

1-16 
17-20 



Item 

EST data 

Same as words 18-21 for the RjiD. 



Word 



1-42 


EST 


43 


* 


44 


* 


45 


* 




the 


46 


* 

Vi 


47 


* 


48 


* 

T 


49 


* 



Item 

data 

previous strain value once removed, initially zero 

previous strain value, initially zero 

the previously calculated modulus of elasticity, initially 
value of E given on a MATl card 



The previous element forces, initially zero 



50 



la 
* 



Word 

1-21 
22 
23 
24 

25 
26 
27 



Item 

EST data 

* 
Co, previous strain value once removed, initially zero 

* 
e , previous strain value, initially zero 

* 

E , the previously calculated modulus of elasticity, initially the 
value of E given on a MATl card 

* 

* 
a ) The current membrane stresses, initially zero 

* 

°xy 



Word 

1-27 
28-33 



Item 

EST data 

Same as words 22-27 for the TRMEM 



2.3-134 (12-1-69) 



TRIA2: 



QDMEM: 



QUADl ; 



QUAD2: 



DATA BLOCK AND TABLE DESCRIPTIONS 



Word 





* 


34 


\ 




* 


35 


M 




y 




* 


36 


M 




XX 




* 


37 


V 




X 




* 


38 


v„ 



Item 



The previous element forces, initially zero 



Word 

1-27 
28-32 



Item 

Same as words 1-27 for the TRMEM 
Same as words 34-38 for the TRIAl 



Word 

1-26 
27-32 



Item 

EST data 

Same as words 22-27 for the TRMEM 



Word 



Item 



1-32 
33-38 
39-43 



EST data 

Same as words 22-27 for the TRMEM 

Same as words 34-38 for the TRIAl 



Word 

1-26 
27-32 
33-37 



Item 

EST data 

Same as words 22-27 for the TRMEM 

Same as words 34-38 for the TRIAl 



2.3-134a (12-1-69) 



DATA BLOCK DESCRIPTIONS 



2.3.34.4 ECPTNL (TABLE). 
Description 

Element Connection and Properties Table for Non-Linear Elements. 

The ECPTNL, used only in the Piecewise Linear Analysis Rigid Format, is constructed from the 
ECPT data block. The ECPTNL contains one logical record for each grid point or scalar point of 
the model. Each logical record contains Element Summary Table (EST) data plus initial element 
stress data appended to this data for each non-linear element connected to the pivot point. (An 
element is defined to be non-linear if its modulus of elasticity is defined as the first derivative 
of a stress-strain tabular function input on a TABLESl card). The only elements admissible to the 
ECPTNL are: R0D, TUBE, C!3NR0D, BAR, TRMEM, TRIAl , TRIA2, QDMEM, QUADl , QUAD2. 

Table Format 



Record 



Word 



Item 



n+1 



Header record 

1 SIL number for "pivot" arid ^repeated 

or scalar point (integer) f for each arid 

2 Element type ( integer Jl repeated for each >or scalar 

3 to N+2 Element EST data >non-linear element ^noint in the 
N+3 to N+M+2 Element stress data jconnected to the pivot jmodel 

End-of-file 



Notes 



1. N is the number of words in the EST data section. 

M is the number of stress words appended. The number of stress words appended in 
generating the ECPTNL data block is not the same as in generating the ESTNL data block. 

2. n is the total number of grid and scalar points in the model. 

3. If all elements connected to a pivot point are linear, then the record contains only 
one word, the pivot point set negative. 

Table Trailer 

Word 1 = total number of element entries in the ECPTNL. 
Words 2-6 = zero. 

Detailed ECPTNL Formats 



R0D, C0NR0D: 



Word 



Item 



1-20 



Same as ESTNL data. Note word 21 of the ESTNL 

is not present in the ECPTNL data for the R(ZID, C0NR0D. 



2.3-135 



DATA BLOCK AND TABLE DESCRIPTIONS 

TUBE: 

Word Item 

1-19 Same as ESTNL data. Note word 20 of the ESTNL is not 
present in the ECPTNL data for the TUBE. 

BAR: 

Word Item 

1-45 Same as ESTNL data. Note words 46-50 of the ESTNL are not 
present in the ECPTNL data for the BAR. 

TRMEM: 

Word Item 

1-27 Same as ESTNL data. 

TRIAl : 

Word Item 

1-33 Same as ESTNL data. Note words 34-38 of the ESTNL are not 
present in the ECPTNL data for the TRIAl. 

TRIA2: 

Word Item 

1-27 Same as ESTNL data. Note words 28-32 of the ESTNL are not 
present in the ECPTNL data for the TRIA2. 

QDMEM: 

Item 
Same as ESTNL data. 

QUAD! : 

Word Item 

1-38 Same as ESTNL data. Note words 39-43 of the ESTNL are not 
present in the ECPTNL data for the QUAD!. 



2.3-136 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 

QUAD2 : 

Word Item 

1-32 Same as ESTNL data. Note words 33-37 of the ESTNL are not 
present in the ECPTNL data for the QUAD2. 



2.3-136a (12-1-69) 



DATA BLOCK DESCRIPTIONS 



2.3.35 Data Blocks Output From Module ADD 

2.3.35.1 KGGSUM (MATRIX) 
Description 

Sum of [Kjg] and [kJJ]. 

Used only in the Piecewise Linear Analysis Rigid Format and is equivalent to [Kgq^' 

Matrix Trailer 

Number of columns = g 

Number of rows = g 

Form = symmetric 

Type = real double precision 

2.3.35.2 PG (MATRIX) 
Description 

P ( - Incremental load vector used in Piecewise Linear Analysis. 

Matrix Trailer 

Number of columns = 1 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.35.3 KDAAM (MATRIX) 
Description 

[K^'!'] - The negative of [K^ J (see section 2.3.32). 

aa da 

Used only in the Buckling Analysis Rigid Format. 

Matrix Trailer 

Number of columns = a 

Number of rows = a 

Form = symmetric 

Type = real double precision 



2.3-137 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.36 Data Blocks Output From Module PLA2 

2.3.36.1 UGVl (MATRIX) 

Description 

[u ] - Matrix of successive sums of incremental displacement vectors - g set. 
^ Used only in the Piecewise Linear Analysis Rigid Format. 

Matrix Trailer 

Number of columns = number of factors on a PLFACT bulk data card 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.36.2 PGVl (MATRIX) 

Description 

[P ] - Matrix of successive sums of incremental load vectors - q set. Used 
^ only in the Piecewise Linear Analysis Rigid Format. 

Matrix Trailer 

Number of columns = number of factors on a PLFACT bulk data card 

Number of rows = g 

Form = rectangular 

Type = real single precision 

2.3.36.3 QGl (MATRIX) 

Description 

[q ] - Matrix of successive sums of incremental vectors of single point constraint 
^ forces - g set. Used in the Piecewise Linear Analysis Rigid Format only. 

Matrix Trailer 

Number of columns = number of factors on a PLFACT bulk data card 

Number of rows = g 

Form = symmetric 

Type = real single precision 



2.3-138 



DATA BLOCK DESCRIPTIONS 

2.3.37 Data Blocks Output From Module PLA3 . 

2.3.37.1 0NLES (TABLE). 
Description 

Output table for nonlinear element stresses. 
Format 

Same format as 0ES1 table output from module SDR2. 
Note 

0NLES is written in subroutine PLA32 of module PLA3. 

Table Trailer 

Word 1 = total number of element entries in 0NLES. 
Word 2-6 = zero. 

2.3.37.2 ESTNLl (TABLE). 
Description 

Element summary table for nonlinear elements - updated. 

Used only in the Piecewise Linear Analysis Rigid Format, the ESTNLl data block is the same 
as the ESTNL data block except that the appended stress information is undated. See data block 
description for ESTNL for further details. 

Table Format 

Same format as the ESTNL data block. 

Table Trailer 

Word 1 = number of element entries in ESTNLl. 
Word 2-6 = zero. 



2.3-139 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.38 Data Blocks Output From Module PLA4 . 

2.3.38.1 KGGNL (MATRIX). 
Description 

[k"^] - Stiffness matrix of nonlinear elements - g set. 

gg 

Used only in the Piecewise Linear Analysis Rigid Format. 
Matrix Trailer 

Number of columns = g 

Number of rows = g 

Form = synmetric 

Type = real double precision 

2.3.38.2 ECPTNLl (TABLE). 
Description 

Element Connection and Properties Table for Non-Linear Elements - undated. 

Used only in the Piecewise Linear Analysis Rigid Format, the ECPTNLl data block is the 
same as the ECPTNL data block except that the appended stress information is updated. See 
description for ECPTNL for further details. 

Table Format 

Same format as the ECPTNL data block. 

Table Trailer 

Word 1 = total number of element entries in ECPTNLl. 
Word 2-6 = zero. 



2.3-140 



DATA BLOCK DESCRIPTIONS 

2.3.39 Data Blocks Output From Module CASE . 

2.3.39.1 CASEXX (TABLE). 

Description 

Case Control data table for dynamics problems. 

Table Format 

The format of the records is exactly like CASECC, (see section 2.3,1.1) with dynamic 
looping records deleted. 

Table Trailer 

Word 1 = number of records in CASEXX. 
Word 2-6 = zero. 



2.3-141 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.40 Data Blocks Output From Module MTRXIN 

2.3.40.1 K2PP (MATRIX) 

Description 

2 
[K ] - Direct input stiffness matrix - p set. 
PP 

Matrix Trailer 

Number of columns = p 

Number of rows = p 

Form = square 

Type = depends on input 

2.3.40.2 M2PP (MATRIX) 



Description 

2 

[M ] - Direct input mass matrix - p set. 
PP 

Matrix Trailer 

Number of columns = p 

Number of rows = p 

Form = square 

Type = depends on input 



2.3.40.3 B2PP (MATRIX) 



Description 

2 
[B ] - Direct input damping matrix - p set. 

Matrix Trailer 

Number of columns = p 

Number of rows = p 

Form = square 

Type = depends on input 



2.3-142 



DATA BLOCK DESCRIPTIONS 

2.3.41 Data Blocks Output From Module GKAD 

2.3.41.1 KDD (MATRIX) 

Description 

[K, ,] - Dynamic stiffness matrix - d set. 

Matrix Trailer 

Number of columns = d 

Number of rows = d 

Form = square 

Type = complex double precision 

- frequency response/complex eigenvalue 
= real double precision 

- transient 

2.3.41.2 BDD (MATRIX) 

Description 

[B.j] - Dynamic damping matrix - d set. 

Matrix Trailer 

Number of columns = d 

Number of rows = d 

Form = square 

Type = complex double precision 

- frequency response/complex eignevalue 
= real double precision 

- transient 

2.3.41.3 MDD (MATRIX) 
Description 



[M. ,] - Dynamic mass matrix - d set. 



Matrix Trailer 




Number of columns 


= d 


Number of rows 


= d 


Form 


= Si 


Type 


= o 



square 
= complex double precision 

- frequency response/complex eigenvalue 
= real double precision 

- transient 



2.3-143 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.41.4 G^fl (MATRIX) 
Description 

[g''] - Multipoint constraint transformation matrix - dynamics, 
m 

Matrix Trailer 

Number of columns = d 

Number of rows = m 

Form = rectangular 

Type = complex double precision 

2.3.41.5 G0D (MATRIX) 
Description 

[G^l - Omitted coordinate transformation matrix - dynamics. 



Matrix Trailer 

Number of columns = d 

Number of rows = o 

Form = rectangular 

Type = complex double precision 

2.3.41.6 K2DD(MATRIX) 
Description 

[kL] - Direct input stiffness matrix - d set. 

Matrix Trailer 

Number of columns = d 

Number of rows = d 

Form = square 

Type = complex double precision 

2.3.41.7 M2DD (MATRIX) 

Description 

2 

[Mjj] - Direct input mass matrix - d set. 

Matrix Trailer 

Number of columns = d 

Number of rows = d 

Form = square 

Type = complex double precision 



2.3-144 



DATA BLOCK DESCRIPTIONS 



2.3.41.8 B2DD (MATRIX) 

Description 

2 
[B . .] - Direct input dampinq matrix - d set. 

Matrix Trailer 

Number of columns = d 

Number of rows = d 

Form = square 

Type = complex double precision 



2.3-145 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.42 Data Blocks Output From Module CEAD 



2.3,42.1 PHID (MATRIX) 



Description 



[$j] - Complex eigenvectors in the d set. 



Matrix Trailer 

Number of columns = number of eigenvalues found in CEAD 

Number of rows = d 

Form = rectangular 

Type = complex single precision 



2.3.42.2 CLAMA (TABLE) 



Description 












X - 


Compl ex 


eigenvalue 


tab' 


le. 




Table Format 












Record 




Word 




Type 


Item 













Header record 


1 




1 
2 
3-9 

10 

n-50 

51-146 




I 
I 
I 
I 

B 


0FP ID record 

90 

1006 



6 

Not defined 

Title, subtitle, and label from /OUTPUT/ 


2 




1 
2 
3 
4 
5 
6 




I 
I 
R 
R 
R 
R 


0FP data record 

Mode number 

Extraction order 

Real part of eigenvalue 

Imaginary part of einenvalue 

Im (X)|/2n 
-2*Re (X)/|Im (x) | 



Note: The 6 data words are repeated in record 2 for each 
eigenvalue found in CEAD. 

End-of-file 



Tabl 


e Trai 


le 


r 






Word 


1 


1006 




Word 


2 


= 







Word 


3 


= 







Word 


4 


= 







Word 


5 


= 


6 




Word 


6 


= 






2.3-146 



DATA BLOCK DESCRIPTIONS 



2.3.42.3 0CEIGS (TABLE). 
Description 

Complex eigenvalue summary table. 
Table Format 



Record 


1 



Word 



1 
2 
3 

4-10 

n 

12-18 



i^ 



Determinant 



12 
13 
14 
15 
16 
17 
18 



Inverse Power 



12-18 



19-50 
51-146 



B 



Item 

Header record 


1009 

1 if determinant 

2 if inverse power 


Number of eigenvalues extracted 
Depend on the method used 



Number of passes through starting points 

Number of criteria changes 

Number of starting point moves 

Number of decompositions 

Number of failures to iterate to a root 

Number of predictions outside the region 

Reason for termination 

1 - all requested roots found 

2 - out of region prediction from every 

starting point 

3 - insufficient time to extract another root 

4 - everywhere singular matrix 



Identical to words 12-18 for Inverse Power Method 

section of the 0EIGS data block output from the 

READ module (see section 2.3.30.4). 

Not defined 

Title, subtitle, label 



Record 1 will be repeated for each region for Inverse Power. 
Records 2+3 exist only when METHOD = DETM. 



1 







2 




1009 


3 




3 


4-9 







10 




6 


11-50 




Not defined 


51-146 


B 


Title, subtitle, label 



2.3-147 



DATA BLOCK AND TABLE DESCRIPTIONS 



Record Word Type Item 

Starting point number in region 

Real part of starting point 

Imaginary part of starting point 

Magnitude of startina point 

Phase of startinn point 

Scale factor (power of 10) of maanitude 

Words 1-6 are repeated for each startina point in each reqion. 

End-of-file 



1 


I 


2 


R 


3 


R 


4 


R 


5 


R 


6 


I 



Table Trailer 



Non-zero. 



2.3.42.4 PHIH (MATRIX) 

Description 

[f, ] - Complex eigenvectors in the h set. 

Matrix Trailer 

Number of columns = number of eigenvalues found in CEAD 

Number of rows = h 

Form = rectangular 

Type = complex single precision 



2.3-148 



DATA BLOCK DESCRIPTIONS 

2.3.43 Data Blocks Output From Module VDR 

2.3.43.1 0PHID (TABLE) 

Description 

Output complex eigenvectors requests (solution set, S0RT1 , complex), 

Table Format 



Record 



Notes 



Word 

1-2 

3-5 

6 

7 

1 

2 

3 

4 

5 

6-7 

8 

9 

10 

11-50 

51-82 

83-114 

115-146 

1 
2 

3-8 
9-14 



Tyge 
B 



Item 

Data block name 
Month, day, year 
Time 
1 

Device code + 10 * approach code 

1014 



Subcase number 

Mode number 

Complex eigenvalue 



Format code 

Number of words per entry in record 2 = 14. 

Not defined 

Title 

Subtitle 

Label 

10 * point ID + device code ^repeated 

Point type (for 

R(T1). R(T2), R(T3), R(R1). R(R2). R(R3)reach 

I(T1), I(T2), I(T3). I(R1). I(R2), I(R3))Doint 



Records 1 and 2 are repeated for each vector to be output. 
Device code = 



= X y output only 

)l = print 

|4 = punch 

[5 = print and punch 



Format code = 
Approach code 

Point type 



11 = real 

\2 = real /imaginary 

l3 = magnitude/phase 



(1 = grid point 

)Z = scalar point 

)3 = extra point 

(4 = modal point 



Components (words 3-14 of even numbered records) which are not in the solution set are 
replaced by an integer 1. 



2.3-149 



DATA BLOCK AND TABLE DESCRIPTIONS 



Table Trailer 
Word 1 
Word 2 
Word 3-6 



(sum of all words in even numbered records)/65536 

remainder from division above 

zero. 



2.3.43.2 (3UDVC1 (TABLE) 

Description 

Output displacement requests (solution set, S0RT1 , complex) 



Table Format 










Record 


Word 


Type 


Item 







1-2 
3-5 
6 

7 


B 


Data block name 
Month, day, year 
Time 

1 




1 


1 

2 

3 
4 
5 
6 
7 
8 
9 




Device code + 10 * approach code 

(1015 = displacement 

<1016 = velocity 

U017 = acceleration 



Subcase number 

Frequency 





Dynamic load set ID 

Format code 






10 




Number of words per entry in record 2 = 


14 




11-50 




Not defined 






51-82 


B 


Title 






83-114 


B 


Subtitle 






115-146 


B 


Label 





1 

2 

3-8 

9-14 



10 * point ID + divice code ^repeated 

Point type (for 

R(T1). R(T2), R(T3). R(R1), R(R2), R(R3)(each 

I(T1), I(T2). I(T3), I(R1), I(R2). I(R3))point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 



'0 = X y output only 

h = print 

1 4 = punch 

^5 = print and punch 

il = real 

,2 = real/imaginery 

[3 = magnitude/phase 



2.3-150 



DATA BLOCK DESCRIPTIONS 



!iotes cont'd. 



(l = grid point 

5. Point type = {l = ^"^^^ P°i"<^ 

•'^ 13 = extra point 

(4 = modal point 

6. Components (words 3-14 of even numbered records) which are not in the solution set 
are replaced by an integer 1. 

Table Trailer 

Word 1 = (sum of all words in even numbered records )/65536. 

Word 2 = remainder from division above. 

Word 3-6 = zero. 

2.3.43.3 0UDV1 (TABLE) 

Description 

Output displacement requests (solution set, SflRTl , real). 



Table Format 




Record 


Word 





1-2 
3-5 
6 
7 



3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 

1 
2 
3-8 



h£i 



Item 

Data block name 
Month, day, year 
Time 
1 

Device code + 10 * approach code 

15 = displacement 

16 = velocity 

17 = acceleration 


Subcase number 

Time 





Dynamic load set ID 

Format code = 1 

Number of words per entry in record 2 

Not defined 

Title 

Subtitle 

Label 

10 * point ID + device code ) repeated 
Point type > for each 

Tl, T2, T3, Rl, R2. R3 } noint 



2,3-151 



DATA BLOCK AND TABLE DESCRIPTIONS 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



Device code = 



3. Format code = 



'0 = X y output only 

h = print 

|4 = punch 

[5 = print and punch 

[1 = real 

j2 = real/imaqinary 

u = magnitude/phase 



4. Approach code = 7 

n = grid point 

n • 4. 4. ;2 = scalar point 

5. Point type = ^3 ^ ^^^^^ p^^^^ 

(4 = modal point 

6. Components (words 3-8 of even numbered records) which are not in the solution set 
are replaced by an integer 1. 

Table Trailer 

Word 1 = (sum of all words in even numbered records)/65536. 

Word 2 = remainder from division above. 

Word 3-6 = zero. 

2,3.43.4 (JPNLl (TABLE) 

Description 

Output nonlinear load requests (solution set, S0RT1 , real) 



Table Format 








Record 


Word 


Type 


Item 





1-2 


B 


Data block name 




3-5 




Month, day, year 




6 




Time 




7 




1 


1 


1 




Device code + 10 * approach code 




2 




12 




3 









4 




Subcase number 




5 


R 


Time 




6 









7 









8 




Dynamic load set ID 




9 




Format code 




10 




Number of words per entry in record 2 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 



2.3-152 



DATA BLOCK DESCRIPTIONS 



Record 



Word 

1 
2 
3-8 



Jl21 

I 
I 
R 



rtem+ 

10 * point ID + device code] repeated 
Point type > for each 

Tl, T2, T3, R1, R2. R3 ) point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 

2. Device code = 



10 = X y output only 

)l = print 

j4 = punch 

V5 = print and punch 



Format code = 
Approach code 



5. Point type 



(1 = real 

^2 = real/imaginary 

(3 = magnitude/phase 



il = qrid point 

)2 = scalar point 

13 = extra point 

U = modal point 



6. Components (words 3-8 in even numbered records) which are not in the solution set 
are replaced by an integer 1. 



Table Trailer 



Word 1 = (sum of all words in even numbered records )/65536. 
Word 2 = remainder from division above. 
Word 3-6 = zero. 



2.3.43.5 0PHIH (TABLE) 

Description 

Output complex eigenvector requests (solution set, SpRTl , complex) 

Table Format 

Record Word Type 







1-2 
3-5 
6 
7 
1 
2 
3 
4 
5 

6-7 
8 
9 
10 



B 



Item 

Data block name 

Month, day, year 

Time 

1 

Device code + 10 * approach code 

1014 



Subcase number 

Mode number 

Complex eigenvalue 



Format code 

Number of words per entry in record 2 = 14 



2,3-153 



DATA BLOCK AND TABLE DESCRIPTIONS 



Record 



Word 

n-50 

51-82 

83-114 

115-146 

1 
2 

3-8 
9-14 



Tffie 



Item 

Not defined 
Title 
Subtitle 
Label 

10 * point ID + device code Jrepeated 

Point type (for 

R(T1), R(T2), R(T3), R(R1), R(R2), R(R3)/each 

I(T1). I(T2), I(T3), I(R1). I(R2). I(R3)\point 



Notes 



1 . Records 1 and 2 are repeated for each vactor to be output 



Device code 



3. Format code 



fO = X y output only 

11 = print 

U = punch 

[s = print and punch 

(1 = real 

Iz = real/imaqinary 

(3 = magnitude/phase 



4. Approach code = 9 

5. Point type 



1 = grid point 

2 = scalar point 

3 = extra point 
,4 = modal point 



6. Components (words 3-14 of even numbered records) which are not in the solution set 
are replaced by an integer 1. 

Table Trailer 

Word 1 = (sum of all words in even numbered records )/65536. 

Word 2 = remainder from division above. 

Word 3-6 = zero. 

2.3.43.6 0UHVC1 (TABLE) 

Description 

Output displacement requests (solution set, S0RT1 , complex). 



2.3-154 



DATA BLOCK DESCRIPTIONS 



Table Format 



Record 



Notes 



Word 

1-2 

3-5 

6 

7 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11-50 

51-82 

83-114 

115-146 

1 
2 

3-8 
9-14 



B 



Item 

Data block name 
Month, day, year 
Time 
1 

Device code + 10 * approach code 
'1015 = displacement 

1016 = velocity 

1017 = acceleration 


Subcase number 

Frequency 





Dynamic load set ID 

Format code 

Number of words per entry in record 2=14 

Not defined 

Title 

Subtitle 

Label 

10 * point ID + device code ^repeated 

Point type (for 

R(T1). R(T2), R(T3). R(R1). R(R2), R(R3)^each 

I(T1). I(T2), I(T3). I(R1). I(R2), I(R3))point 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code = 

5. Point type 



= X y output only 

1 = print 
I 4 = punch 

,5 = print and punch 

'1 = real 

2 = real/imaginary 
.3 = magnitude/phase 



1 = qrid point 

12 = scalar point 

13 = extra point 
,4 = modal point 



Components (words 3-14 of even numbered records) which are not in the solution set 
are replaced by an integer 1. 



Table Trailer 
Word 1 
Word 2 
Word 3-6 = 



(sum of all words in even numbered records )/65536. 

remainder from division above. 

zero. 



2.3-155 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.43.7 0UHV1 (TABLE) 

Description 

Output displacement requests (solution set, S^RTl , real). 



Table Format 



Record 



Word 

1-2 
3-5 
6 
7 

1 



3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 

1 
2 
3-8 



IZEl 



Item 

Data block name 
Month, day, year 
Time 
1 



Device code + 10 * approach code 

15 = displacement 

16 = velocity 

17 = acceleration 


Subcase number 

Time 





Dynamic load set ID 

Format code = 1 

Number of words ner entrv in record 2 

Not defined 

Title 

Subtitle 

Label 



10 * point ID + device code f repeated 
point type { for each 

Tl, T2, T3, Rl, R2, R3 (point 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



Device code 



Format code = 



'0 = X y output only 

h = print 

1 4 = punch 

5 = print and punch 

(1 = real 

1 2 = real /imaginary 

(3 = maqnitude/phase 



Approach code = 7 



5. Point type 



il = grid point 

)2 = scalar point 

)3 = extra point 

[4 = modal point 



5. Components (words 3-8 of even numbered records) which are not in the solution set 
are replaced by an integer 1 . 



2.3-156 



DATA BLOCK DESCRIPTIONS 



Table Trailer 



Word 1 = (sum of all words in even numbered records)/65536. 
Word 2 = remainder from division above. 
Word 3-6 = zero. 



2.3-157 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.44 Data Blocks Output From Module FRRD 

2.3.44.1 UDVF (MATRIX) 
Description 

[Uj] - Displacement vector matrix in a frequency response problem - d set. 
Matrix Trailer 



Number of columns = number of frequencies multiplied by the number of loads 

Number of rows = d 

Form = rectangular 

Type = complex sinqle precision 

2.3.44.2 PSF (MATRIX) 
Description 

[P ] - Load vector for frequency response - s set. 

Matrix Trailer 

Number of columns = number of frequencies multiplied by the number of loads 

Number of rows = s 

Form = rectangular 

Type = complex single precision 

2.3.44.3 PDF (MATRIX) 
Description 

{Pj} - Dynamic load matrix for frequency analysis - d set. 

Matrix Trailer 

Number of columns = number of frequencies multiplied by the number of loads 

Number of rows = d 

Form = rectangular 

Type = complex sinqle precision 

2.3.44.4 PPF (MATRIX) 
Description 

[P ] - Dynamic loads for frequency response - p set. 

Matrix Trailer 

Number of columns = number of frequencies multiplied by the number of loads 

Number of rows = p 

Form = rectangular 

Type = complex single precision 



2.3-158 



DATA BLOCK DESCRIPTIONS 

Note 

The header record contains the list of frequencies. 

2.3.44.5 UHVF (MATRIX) 
Description 

[u, ] - Modal frequency response solution vectors - h set. 

Matrix Trailer 

Number of columns = number of frequencies multiplied by the number of loads 

Number of rows = h 

Form = rectangular 

Type = complex single precision 



2,3-159 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.45 Data Blocks Output From Module SDR3 . 

2.3.45.1 0PP2 (TABLE) 

Description 

Output load vector requests (p set, S0RT2, real), 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

11-50 

51-82 

83-114 

115-146 

1 
2 
3-8 



Type 



Item 



Header record 



Device code + 10*approach code 

2002 



Subcase number 

10*point ID + device code 





Dynamic load set ID 

Format code = 1 

Number of words per entry in next record = 8 

Hot defined 

Title 

Subtitle 

Label 

Time ) repeat 

Point tyoe >for each 

R(T1), R(T2), R(T3), ^(Rl), R(R2), R(R3))t1me step 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 

2. Device code = 



fO = X y output only 
)l = print 
)4 = punch 



Format code = 



(5 = print and punch 

(1 = real 

2 = real/imaginary 

(3 = magnitude/phase 



4. Approach code = 6 

5. Point type 



1 = grid point 

2 = scalar point 

3 = extra point 

4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-160 



DATA BLOCK DESCRIPTIOUS 

2.3.45.2 0QP2 (TABLE). 
Description 

Output forces of single-point constraint (p set, S0RT2, real). 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11- 

51- 

83- 

115- 



I/Ei 



Item 



50 
82 
114 

145 



1 
2 
3-8 



Header record 



Device code + 10*approach code 

2003 



Subcase number 

10*point ID + device code 





Dynamic load set ID 

Format code = 1 

Number of words oer entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 

Time ^repeat 

Point type >for each 

R(T1), R(T2), R(T3), R(R1), R(R2), R(R3)) time step 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 

5. Point type = 



fo = X y output only 

)1 = print 

)4 = punch 

[5 = print and punch 

1 = real 

2 = real /imaginary 

3 = magnitude/phase 



il = grid point 
2 = scalar point 
3 = extra point 
4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-161 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.45.3 0UPV2 (TABLE). 
Description 

Output displacement vector requests (p set, S!?RT2, real). 
Table Format 



Record 


Word 


Type 


Item 











Header record 


1 


1 




I 


Device code + 10*approach code 
(2001 = Displacement 




2 




I 


^2010 = Velocity 
(2011 = Acceleration 




3 




I 







4 




I 


Subcase number 




5 




I 


10*point ID + device code 




6 




I 







7 




I 







8 




I 


Dynamic load set ID 




9 




I 


Format code = 1 




10 




I 


Number of words per entry in next record = 8 




11- 


50 




Not defined 




51- 


82 


B 


Title 




83- 


114 


B 


Subtitle 




115- 


145 


B 


Label 


2 


1 




R 


Time ^reoeat 




2 




I 


Point tyoe Uor each 




3- 


8 


R 


R(T1), R(T2), R(T3), R(R1), R{R2), R(R3)) time steo 



Notes 



1 . Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 

5. Point type 



fO = X y output only 

)1 = print 

1 4 = punch 

,5 = print and punch 

(1 = real 

2 = real /imaginary 

(3 = magnitude/phase 



h = grid point 

)2 = scalar point 

)3 = extra point 

'4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-162 



DATA BLOCK DESCRIPTIONS 



2.3.45.4 i3ES2 (TABLE). 
Description 

Output element stress requests (S0RT2, real). 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*approach code 




2 




2005 




3 




Element type 




4 




Subcase number 




5 




10*element ID + device code 




6 









7 









8 




Dynamic load set ID 




9 




Format code = 1 




10 




Number of words per entry in next record = NMDS 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-146 


B 


Label 


2 


1 


R 


Time ) repeat 




2-NWDS 


Mixed 


Element stress data >for each 



See section 2.3.51 for details) time step 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



Device code = 



Format code = 



[0 = X y output only 

h = print 

1 4 = punch 

^5 = print and punch 

(1 = real 

<2 = real /imaginary 

(3 = magnitude/phase 



4. Approach code = 6 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-163 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.45.5 0EF2 (TABLE). 






Description 






Output element force reqi 


jests 


(S0RT2, real) 


Table Format 






Record Word 




Type 









1 1 






2 






3 






4 






b 






5 






7 






8 






9 






10 






11-50 






51-82 




B 


83-114 




B 


115-146 




B 



Item 



Header record 



Device code + 10*approach code 

2004 

Element type 

Subcase number 

10*element ID + device code 





Dynamic load set ID 

Format code = 1 

Number of words per entry in next record = NWDS 

Not defined 

Title 

Subtitle 

Label 



Notes 



1 R Time ) reoeat 

2-NWDS Mixed Element force data >for each 

See section 2.3.52 for details) time step 



1. Records 1 and 2 are repeated for each vector to be output. 



Device code = 



3. Format code = 



(O = \ y output only 

) 1 = print 

)4 = punch 

^5 = print and punch 



1 = real 

2 = real /imaginary 

3 = magnitude/phase 



4. Approach code = 6 
Table Trailer 

Words 1-6 contain no significant values. 



2.3-164 



DATA BLOCK DESCRIPTIONS 

2.3.45.6 0PNL2 (TABLE). 
Description 

Output nonlinear load requests (solution set, S0RT2, real] 
Table Format 



Record 

1 



Word 



1 




2 




3 




4 




5 




5 




7 




8 




9 




10 




11- 


50 


51- 


82 


83- 


114 


115- 


146 


1 




2 




3- 


8 



IZ£e 



Item 



Header record 



Device code + 10*apnroach code 

2012 



Subcase number 

10*Doint ID + device code 





Dynamic load set ID 

Format code = 1 

Number of v/ords per entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 

Time ^repeat 

Point type Vfor each 

R(T1), R(T2), R(T3). R(R1), R(R2), R(R3)) time step 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code 



Format code 



|0 = X y output only 

1 = print 

1 4 = punch 

^5 = print and punch 

[1 = real 

,2 = real /imaginary 

[3 = magnitude/phase 



4. Approach code = 6 

5. Point type 



1 = grid point 

2 = scalar point 

3 = extra point 
.4 = modal point 



6. Components (words 3-8 in even numbered records) which are not in the solution set are 
replaced by integer 1 . 



Table Trailer 



Words 1-5 contain no significant values. 



2.3-165 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.45,7 0UDV2 (TABLE). 
Description 

Output displacement vector requests (solution set, S0RT2, real). 
Table Format 



Record 


Word 


I^ 









1 


1 


I 




2 


I 




3 


I 




4 


I 




5 


I 




6 


I 




7 


I 




8 


I 




9 


I 




10 


I 




11-50 






51-82 


B 




83-114 


B 




115-146 


B 


2 


1 


R 




2 


I 




3-8 


R 



Item 



Header record 



Device code + 10*approach code 
'2015 = Displacement 

2016 = Velocity 

2017 = Acceleration 


Subcase number 

10*point ID + device code 





Dynamic load set ID 

Format code = 1 

Number of words per entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 



Time ) repeat 

Point type Vfor each 

R(T1), R(T2), R(T3), R(R1), R(R2), R(R3)I time steo 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 

iO = X y output only 
J : KnS 
5 = print and punch 

(l = real 
3. Format code = s2 = real /imaginary 
(3 = magnitude/phase 



4. Approach code = 6 

5. Point type = 



1 = grid point 

2 = scalar point 

3 = extra point 

4 = modal point 



6. Components (words 3-8 of even numbered records) which are not in the solution set are 
replaced by integer 1. 



Table Trailer 



Words 1-5 contain no significant values. 



2.3-166 



DATA BLOCK DESCRIPTIONS 

2.3.45.8 0UHV2 (TABLE). 
Description 

Output displacement vector requests (solution set, S!3RT2, real). 
Table Format 



Record 

1 



Word 



1 




2 




3 




4 




5 




6 




7 




8 




9 




ID 




n- 


■50 


51- 


■82 


83- 


■114 


115- 


■146 


1 




2 




3- 


■8 



I 

I 

I 
I 
I 
I 
I 
I 
I 



Item 



Header record 



Device code + 10*anDroach code 

2015 = DisDlacement 

2016 = Velocity 

2017 = Acceleration 


Subcase number 

10*point ID + device code 





Dynamic load set ID 

Format code = l 

Number of words per entry in next record = 8 

Not defined 

Title 

Subtitle 

Label 



Time ^repeat 

Point type >for each 

R(T1), R(T2), R(T3), R(R1), R(R2), R(R3))time sten 



Notes 



1. Records 1 and 2 are repeated for each vector to be cutout. 



2. Device code = 

3. Format code = 

4. Approach code 

5. Point type 



(0 = X y output only 

h = print 

|4 = punch 

^5 = print and punch 

(1 = real 

(2 = real/imaginary 

(3 = magnitude/phase 



n = grid point 

12 = scalar point 

J3 = extra point 

(.4 = modal point 



6. Components (words 3-8 of even numbered records) which are not in the solution set are 
replaced by an integer 1. 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-167 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.45.9 0PPC2 (TABLE). 
Description 

Output load vector requests (p set, S0RT2, complex). 
Table Format 



Record 


Word 


Type 


Item 









Header record 


1 


1 




Device code + 10*approach code 




2 




3002 




3 









4 




Subcase number 




5 




10*point ID + device code 




6 









7 









8 









9 




Format code 




10 




Number of words per entry in next record = 14 




11-50 




Not defined 




51-82 


B 


Title 




83-114 


B 


Subtitle 




115-145 


B 


Label 


2 


1 


R 


Frequency ^reoe 




2 


I 


Point type (for 




3-8 


R 


R(T1), R(T2). R{T3), R(R1), R(R2), R(R3)?each 




9-14 


R 


I(T1). I(T2). I{T3). I(Rl). I{R2). IfR3)Jfrea 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code = 

5. Point type = 



'0 = X y output only 

' 1 = print 

1 4 = punch 

,5 = print and punch 

(1 = real 

2 = real/imaginary 

(3 = magnitude/phase 



p = grid point 

|2 = scalar point 

k3 = extra point 

(4 = modal point 



Table Trailer 



Words 1-G contain no significant values. 



2,3-168 



DATA BLOCK DESCRIPTIONS 

2.3.45.10 0QPC2 (TABLE). 
Description 

Output forces of single-point constraint requests (p set, S0RT2, complex). 
Table Format 



Record 

1 



Word 



1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

n-50 

51-82 

83-114 

115-146 

1 

2 

3-8 

9-14 



L^e 



Item 



Header record 



Device code + 10*approach code 

3003 



Subcase number 

10*point ID + device code 





Load set ID 

Format code 

Number of words per entry in next record = 14 

Not defined 

Title 

Subtitle 

Label 

Frequency ^ repeat 

Point type (for 

R(T1), R(T2), R(T3), R(R1), R(R2), R(R3)?each 

I(T1), I(T2). I(T3), I(R1), I(R2), I{R3))frequency 



Notes 



1. Records 1 and 2 are repeated for each vector to be outnut. 



2. Device code = 



Format code = 



5. Point type 



fO = X y output only 

'] = print 

|4 = punch 

[s = print and punch 

p = real 

2 = real /imaginary 

'3 = magnitude/phase 



4. Approach code = 5 



n = grid point 

'2 = scalar point 

|3 = extra point 

'4 = modal point 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-169 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.45.n 0UPVC2 (TABLE). 
Description 

Output displacement vector requests (p set, S(3RT2, complex). 
Table Format 



Record 



Word 



Tj^ 



Item 



Header record 



3 




4 




5 




6 




7 




8 




9 




10 




11-50 




51-82 


B 


83-114 


B 


115-146 


B 


1 


R 


2 


I 


3-8 


R 


9-14 


R 



Device code + 10*approach code 
3001 = Displacement 

3010 = Velocity 

3011 = Acceleration 


Subcase number 

10*point ID + device code 





Load set ID 

Format code 

Number of words per entry in next record = 14 

Not defined 

Ti tl e 

Subtitle 

Label 



Frequency \repeat 

Point type (for 

R(T1), R(T2), R(T3), R(R1), R(R2), R(R3)reach 

I{T1), I(T2). I(T3). I(R1), I{R2). I(R3))frequency 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 



2. Device code = 

3. Format code = 

4. Approach code 

5. Point type 



= X y output only 

1 1 = print 

I 4 = punch 

^5 = print and punch 

p = real 

J 2 = real /imaginary 

(3 = magnitude/phase 



' 1 = grid point 

12 

13 

U = modal point 



= 

)2 = scalar point 

)3 = extra point 

U = 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-170 



DATA BLOCK DESCRIPTIONS 



2.3.45.12 0ESC2 (TABLE). 
Description 

Output element stress requests (S0RT2, complex), 
Table Format 



Record 


Word 


Type 


Item 











Header record 




1 


1 
2 
3 
4 
5 
6 
7 
8 
9 




Device code + 10*approach code 

3005 

Element type 

Subcase number 

10*Element ID + device code 





Load set ID 

Format code 






10 




Number of words per entry in next record = 


= NWDS 




11-50 




Not defined 






51-82 


B 


Title 






83-114 


B 


Subtitle 






115-146 


B 


Label 




2 


1 


R 


Frequency ] repeat 






2-NWDS 


Mixed 


Element stress data >for each 





See 2.3.51 for details ) frequency 



Notes 



1. Records 1 and 2 are repeated for each vector to be outout. 



Device code = 



Format code 



fO = X y output only 

1 1 = print 

14 = punch 

^5 = print and punch 

(l = real 

\2 = real /imaginary 

(.3 = magnitude/phase 



4. Approach code = 5 
Table Trailer 

Words 1-6 contain no significant values. 



2.3-171 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.45.13 0EFC2 (TABLE). 
Description 

Output element force requests (Sj>RT2, complex). 
Table Format 



Record 


Word 


Type 


Item 











Header record 




1 


1 
2 
3 
4 
5 
6 
7 
8 
9 




Device code + 10*aDnroach code 

3004 

Element type 

Subcase number 

10*element ID + device code 





Load set ID 

Format code 






10 




Number of words per entry in next record = 


= NMDS 




n-50 




Not defined 






51-82 


B 


Title 






83-114 


B 


Subtitle 






115-146 


B 


Label 




2 


1 
2-NWDS 


R 
Mixed 


Frequency ) repeat 
Element force data >for each 





See 2.3.52 for details ) frequency 



Notes 



Records 1 and 2 are repeated for each vector to be output. 
2. Device code = 



[0 = X y output only 

M = print 

I 4 = punch 

' 5 = print and punch 



(1 = real 

3. Format code = <2 = real /imaginary 

(3 = magnitude/phase 

4. Approach code = 5 
Table Trailer 

Words 1-6 contain no significant values. 



2.3-172 



DATA BLOCK DESCRIPTIONS 

2.3.45.14 0UDVC2 (TABLE). 
Description 

Output displacement vector requests (solution set, S0RT2, complex). 
Table Format 



Record 

1 



Word 



J^l£e 



Item 



3 




4 




5 




5 




7 




8 




9 




10 




11-50 




51-82 


B 


83-114 


B 


115-146 


B 


1 


R 


2 


I 


3-8 


R 


9-14 


R 



Header record 



Device code + 10*approach code 
'3015 = Displacement 

3016 = Velocity 

3017 = Acceleration 


Subcase Number 

10*point ID + device code 





Dynamic load set ID 

Format code 

Number of words per entry in next record = 14 

Not defined 

Title 

Subtitle 

Label 



Frequency \ repeat 

Point type (for 

R(T1), R(T2). R(T3), R(R1), R(R2), R(R3)(each 

I(T1), I(T2), I(T3), I(R1), I(R2), I(R3))frequency 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 

10 = X y output only 

I = EuicJ 

5 = print and punch 

(l = real 

3. Format code = V = real/imaginary 

(3 = magnitude/phase 



4. Approach code = 5 

5. Point type 



rl = grid point 

\2 = scalar point 

1 3 = extra point 

1 4 = modal point 



6. Components (words 3-14 of even numbered records) which are not in the solution set are 
replaced by integer 1 . 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-173 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.45.15 i3UHVC2 (TABLE). 
Description 

Output displacement vector requests (solution set, Si8RT2, complex). 
Table Format 



Record 


Word 


liJ 









1 


1 


I 




2 


I 




3 


I 




4 


I 




5 


I 




6 


I 




7 


I 




8 


I 




9 


I 




10 


I 




n-50 






51-82 


B 




83-114 


B 




115-146 


B 


2 


1 


R 




2 


I 




3-8 


R 




9-14 


R 



Item 



Header record 



Device code + 10*approach code 
'3015 = DisDlacement 

3016 = Velocity 

3017 = Acceleration 


Subcase number 

10*point ID + device code 





Dynamic load set ID 

Format code 

Number of words per entry in next record = 14 

Not defined 

Title 

Subtitle 

Label 

Frequency v repeat 

Point type (for 

R(T1). R(T2), R(T3), R(R1), R(R2), R(R3)(each 

I(T1). I(T2), I(T3), I(R1), I(R2), I (R3)) frequency 



Notes 



1. Records 1 and 2 are repeated for each vector to be output. 

!0 = X y output only 

1 : JInS 

5 = print and punch 

(1 = real 

3. Format code = \Z = real /imaginary 

(3 = magnitude/ phase 



4. Approach code = 5 

5. Point type = 



1 = grid point 

2 = scalar point 

3 = extra point 

4 = modal point 



6. Components (words 3-14 of even numbered records) which are not in the solution set are 
replaced by an integer 1. 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-174 



DATA BLOCK DESCRIPTIONS 

2.3.46 Data Blocks Output From Module XYTRAN . 

2.3.46.1 XYPLTT (TABLE). 

Description 

Output plot request data in form for direct plotting of S0RT2 Transient Response output. 
Table Format 



Record 


1 



Word 



10 

11 

12 

13 

14 

15 

16 

17 



1121 



I-R 



Item 



R 
R 
R 
R 
R 
R 



19 


I 


20 


I 


21 


I 


22 


I 


23 


R 


24 


R 


25 


I 


26 


I 


27 


I 


28 


I 


29 


I 


30 


I 



Header record 



Subcase ID or if a Random Response problem, 

the Mean Response 

Frame number 

Curve number 

Point ID or element ID 

Component number 

Vector number (1, 2, ... 11) 
1 --Graph uses top half of frame 
0--Graph uses full frame 

-1--Graph uses lower half of frame 

0--Axis, tics, labels, values, etc. have been 
drawn and this curve is to be scaled and 
plotted identically as last except for curve 
symbol s . 

1--Axis, tics, labels, scaling, etc. are to be 
performed or computed and if word 7 of this 
record = or 1 , a skio to new frame is to be 
made. 

Number of blank frames between frames (frame- 
skip) 

Not used 

XMIN ) 

XMAN ( Define exact corners of this 

YMIN ( uoper, lower, or full frame graoh 

YMAX ) 

Actual value of first tic 

Actual increment ':o succ? 

tics 

Integer value to be printed on 

first tic 

Maximum number of digits in 

any print- value 

+ or - power for print values 

Total number of tics to nrint 

this edge 

Value print skio 0,1,2,3 — 

Delta integer print value to 

successive tics 



Same as 15 through 22 
But for y-direction tics 



:S'V 



x-di recti on 
tics 



2.3-175 



31 




32 




33 




34 




35 





38 


R 


39 


I 


40 


R 


41 


I 



DATA BLOCK AND TABLE DESCRIPTIONS 



Record Word Type Item 

Top edge tics ^each of 31-34 may be less 
Bottom edge ticsfthan 0--tics without values 
Left edge tics ^equal to 0— no tics here 
Right edge tics 'greater 0--tics with values 
0--x-di recti on is linear 

Greater than 0— number o^ cycles and x-direction 
is logarithmic 

36 I 0--y-direction is linear 

Greater than 0--number of cycles and y-direction 
is logarithmic 

37 I 0--no X-axis 

l--draw X-axis 
X-axis y-intercept 
0--no y-axis 
l--draw y-axis 
y-axis x-intercept 
Less than — plot symbol for each curve point. 

Select symbol corresponding to 
curve number in word 3 of this 
record. 
Equal to -- connect points by lines where 
points are continuous i.e., (no 
integer 1 pairs) . 
Greater than -- do both of above. 
42 \ 

/Not used 

50 ^ 

51 B Title (32 words) 
B Subtitle (32 words) 
B Label (32 words) 
8 Curve Title (32 words) 
B X-axis Title (32 words) 

242 B y-axis Title (32 words) 

243 ^ 

>Not used 

282 ) 

283 I Pensize 

284 I Plotter 1 = SC4020, 2 = EAI3500 

285 R Inches paper x-direction 

286 R Inches paper y-direction 

287 I Camera for SC4020 less than = 35mm, = F80, 

Greater = Both 

288 I Print flag ) 

289 I Plot flag > = no, 1 = yes 

290 I Punch flag ) 

291 R x-min of all data 

292 R x-max of all data 

293 R y-min within x-limits of graph 

294 R x- value at this y-min 

295 R y-max within x-limits of graph 

296 R x-value at this y-max 

297 R y-min for all data 

298 R x-value at this y-min 

299 R y-max for all data 

300 R x-value at this y-max 



2.3-176 



DATA BLOCK DESCRIPTIONS 



Record 



Word 

1 
2 
3 
4 



Type 

I 
I 
R 
R 



Item 



1 [ Always is present 

x-value ) coordinate pair 

y-value / repeats for all pairs plotted 



Notes 



1. Records 1 and 2 repeat for each curve plotted. 

2. Even numbered records will contain integer 1 pairs to indicate where curve has moved 
outside of graph limits. 



Table Trailer 



Words 1-6 contain no significant values. 



2.3-177 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.45.2 XYPLTFA (TABLE). 
Description 

Identical to XYPLTT, for Frequency Response plots (solution set). 

2.3.46.3 XYPLTF (TABLE). 
Description 

Identical to XYPLTT, for Frequency Response plots. 

2.3.46.4 XYPLTR (TABLE). 
Description 

Identical to XYPLTT, for Random Response plots. 

2.3.46.5 XYPLTTA (TABLE). 
Description 

Identical to XYPLTT, for Transient Response plots (solution set). 



2.3-178 



DATA BLOCK DESCRIPTIONS 



2.3.47 Data Blocks Output From Module RAND0M 

2.3.47.1 PSDF (TABLE) 

Description 

Power Spectral Density Table. 



Table Format 








Record 


Word 


Type 


Item 









Header record 


1 


1 


I 


50 




2 


I 


Code for data type 
DISP = 2001 
VELi? = 2010 
ACCE = 2011 
LS3AD = 2002 
SPCF = 2003 
ELF0 = 2004 
STRE = 2005 




3 




4001 




4 









5 




Point or element ID times 10 




6 




Component ID + 2 




7 









8 


R 


Mean response 




9 









10 




2 




11-50 









51-146 


B 


Title, subtitle, label 


2 


1 


R 


Frequency 




2 


R 


Power spectral dens it v 



Notes 

1. Words 1 and 2 of record 2 are repeated for each frequency. 

2. Records 1 and 2 are repeated for each power spectral density request. 

Table Trailer 

Words 1-5 = zero. 

Word 6 = number of requests. 



2.3-179 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.47.2 AUTI9 (TABLE). 








Description 












Autocorrel 


ation 


function 


table. 






Table Format 












Record 




Word 


Type 


Item 













Header record 




1 




1 


I 


50 








2 


I 


Code for data type 










DISP = 2001 












VEL0 = 2010 












ACCE = 2011 












L0AD = 2002 












SPCF = 2003 












ELF0 = 2004 












STRE = 2005 








3 




4002 








4 













5 




Point or element 


ID times 10 






6 




Component ID + 2 








7 













8 




Mean response 








9 













10 




2 








11-50 













51-146 


B 


Title, subtitle. 


label 


2 




1 


R 


TAU 








2 


R 


Auto correlation 


function 



Notes 



1. Words 1 and 2 of record 2 are repeated for each TAU. 

2. Records 1 and 2 are repeated for each autocorrelation request. 



Table Trailer 



Words 1-5 = zero. 

Word 6 = number of requests. 



2.3-180 



DATA BLOCK DESCRIPTIONS 

2.3.48 Data Blocks Output From Module TRD . 

2.3.48.1 UDVT (MATRIX) 
Description 

[Uj] - Displacement, velocity, and acceleration vector matrix in a transient analysis 
problem - d set. 

Matrix Trailer 

Number of columns = three times the number of output time steps 

Number of rows = d 

Form = rectangular 

Type = real single precision 

2.3.48.2 PDT (MATRIX) 
Description 

[Pj] - Linear dynamic load matrix for transient analysis - d set. 

Matrix Trailer 

Number of columns = number of output times 

Number of rows = d 

Form = rectangular 

Type = real single precision 

2.3.48.3 PST (MATRIX) 
Description 

[Pj] - Linear load vector for transient analysis - s set. 

Matrix Trailer 

Number of columns = number of output times 

Number of rows = s 

Form = rectangular 

Type = real single precision 



2.3-181 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.3.48.4 PPT (MATRIX) 
Description 

[P^] - Linear dynamic loads for transient analysis - p set. 

Matrix Trailer 

Number of columns = number of output times 

Number of rows = p 

Form = rectangular 

Type = real single precision 

*Note: The header record contains the list of output times. 

2.3.48.5 PNLD (MATRIX) 
Description 

Matrix Trailer 



[p"^] - Nonlinear loads in transient problem - d set. 



Number of columns = number of output times 

Number of rows = d 

Form = rectangular 

Type = real single precision 



2.3.48.6 UHVT (MATRIX) 
Description 

[uu] - Modal transient solution vectors - h set. 

Matrix Trailer 

Number of columns = three times the number of output times 

Number of rows = h 

Form = rectangular 

Type = real single precision 



2.3.48.7 PNLH (MATRIX) 
Description 

[Pu'''] - Nonlinear loads in modal transient problem - h set. 

Matrix Trailer 

Number of columns = number of output times 

Number of rows = h 

Form = rectangular 

Type = real single precision 



2.3-182 



DATA BLOCK DESCRIPTIONS 



2.3.49 Data Blocks Output From Module GKAH 

2.3.49.1 MHH (MATRIX) 

Description 

[iHuu] - Modal mass matrix - h set. 

Matrix Trailer 

Number of columns = h 

Number of rows = h 

Form = symmetric 

Type = real double precision 

2.3.49.2 BHH (MATRIX) 

Description 

[b, , ] - Modal damping matrix - h set. 

Matrix Trailer 

Number of columns = h 

Number of rows = h 

Form = symmetric 

Type = real double precision 

2.3.49.3 KHH (MATRIX) 

Description 

[k^^] - Modal stiffness matrix - h set. 

Matrix Trailer 

Number of columns = h 

Number of rows = h 

Form = synmetric 

Type = real double precision 

2.3.49.4 PHIDH (MATRIX) 

Description 

[*(jl,] - Transformation matrix from d set to modal coordinates. 

Matrix Trailer 

Number of columns = h 

Number of rows = d 

Form = rectangular 

Type = real single precision 



2.3-183 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.50 Data Blocks Output From Module DDR1 

2.3.50.1 CPHID (MATRIX) 

Description 

[$.] - Complex eigenvector matrix transformed from modal to physical coordinates. 

Matrix Trailer 

Number of columns = number of eigenvectors 

Number of rows = d 

Form = rectangular 

Type = complex single precision 

2.3.50.2 UDVIF (MATRIX) 
Description 

[ut] - Displacement vectors matrix in a frequency response problem - d set. 

Matrix Trailer 

Number of columns = number of frequencies times number of loads 

Number of rows = d 

Form = rectangular 

Type = complex single precision 

2.3.50.3 UDV2F (MATRIX) 



Description 

[Uj] - Displacement vectors matrix in a transient response problem - d set. 

Matrix Trailer 

Number of columns = number of output times multiplied by 3 

Number of rows = d 

Form = rectangular 

Type = real single precision 



2.3-184 



DATA BLOCK DESCRIPTIONS 



2.3.51 Element Stress Output Data Description . 

Note particular data block liescription (e.g., 0ES1, 0ESB1) for contents of word 1 for each element. 



Element 
Type Name 



1 



CR0D 



CBEAM 



CTUBE 
CSHEAR 

CTWIST 

CTRIAl 



Real Element Stresses 
Word or 
Component Item 



2 
3 

4 
5 

2 
3 
4 
5 
6 
7 
8 
9 
10 

n 

12 
13 
14 



2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

16 

17 



Axial 

Axial Safety Margin * 

Torsional 

Torsional Safety Margin* 

SAl 

SA2 

SA3 

Axial 

SA-maximum 

SA-minimum 

Safety Margin in Tension* 

SBl 

SB2 

SB3 

SB-maximum 

SB-minimum 

Safety Margin in Comp* 

Same as CR0D 

Maximum Shear 
Average Shear 
Safety Margin* 



Maximum 
Average 
Safety Margin* 



Zl = Fibre Distance 1 

Normal -x at Zl 

Normal -y at Zl 

Shear-xy at Zl 

0-Shear Angle at Zl 

Major-Principal at Zl 

Minor-Principal at Zl 

Max-Shear at Zl 
Z2 = Fibre Distance 2 

Normal -X at Z2 

Normal -y at Z2 

Shear-xy at Z2 

0-Shear Angle at Z2 

Major-Principal at Z2 

Minor-Principal at Z2 

Maximum-Shear at Z2 



Complex Element Stresses 
Word or Real 

Component Item Imag. 



2 
3 

4 
5 

2 
3 
4 
5 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 



Axial 
Axial 
Torsional 
Torsional 

Undefined 



Same as CR0D 

Maximum Shear 
Maximum Shear 
Average Shear 
Average Shear 

Maximum 
Maximum 
Average 
Average 

Zl = Fibre Distance 1 
Normal-x at 1 



Normal .. 

Normal-x 

Normal -y 

Normal -y 

Shear-xy 

Shear-xy at i 

Z2 = Fibre Distance 2 

Normal-x at 2 

Normal-x at 2 

Normal -y at 2 

Normal -y at 2 

Shear-xy at 2 

Shear-xy at 2 



at 1 
at 1 
at 1 
at 1 
at 1 



R 
I 
R 
I 
R 
I 

R 
I 
R 
I 
R 
I 



2.3-185 



DATA BLOCK AND TABLE DESCRIPTIONS 



Element 
Tvoe Name 


Real 
Word or 
Component 


Element Stresses 
Item 


Compl 
Word or 
ComDonent 


ex Element Stresses 
Item 


Real 
Imaq. 


' jr^ 

7 


CTRBSC 




Note CTRIAl 




Note CTRIAl 




8 


CTRPLT 




Note CTRIAl 




Note CTRIAl 




9 


CTRMEM 


2 

3 
4 
5 
5 
7 
8 


Normal -X 
Norma 1-y 
Shear-xy 
0-Shear Angle 
Major-Principal 
Minor-Principal 
Maximum Shear 


2 
3 
4 

5 
6 
7 


Normal -X 
Normal -X 
Normal -y 
Normal -y 
Shear-xy 
Shear-xy 


R 

I 
R 

I 
R 

I 


10 


C0NR0D 




Note CR0D 




Note CR0D 




11 


CELASl 


2 


Stress 


2 
3 


Stress 
Stress 


R 

I 


12 


CELAS2 


2 


Stress 


2 
3 


Stress 
Stress 


R 

I 


13 


CELAS3 


2 


Stress 


2 
3 


Stress 
Stress 


R 
I 


14 


CELAS4 




Undefined 




Undefined 




15 


CQDPLT 




Note CTRIAl 




Note CTRIAl 




16 


CQDMEM 




Note CTRMEM 




Note CTRMEM 




17 


CTRIA2 




Note CTRIAl 




Note CTRIAl 




18 


CQUAD2 




Note CTRIAl 




Note CTRIAl 




19 


CQUADl 




Note CTRIAl 




Note CTRIAl 




20 


CDAMPl 




Undefined 




Undefined 




21 


CDAMP2 




Undefined 




Undefined 




22 


CDAMP3 




Undefined 




Undefined 




23 


CDAMP4 




Undefined 




Undefined 




24 


CVISC 




Undefined 




Undefined 




25 


CMASSl 




Undefined 




Undefined 




2G 


CMASS2 




Undefined 




Undefined 




27 


CMASS3 




Undefined 




Undefined 




28 


CMASS4 




Undefined 




Undefined 




29 


C51NM1 




Undefined 




Undefined 




30 


CeiNMZ 




Undefined 




Undefined 




31 


CPL0TEL 




Undefined 




Undefined 




32 


CREACT 




Undefined 




Undefined 





2,3-186 







DATA BLOCK DESCRIPTIONS 




Element 


Rea 


1 Element Stresses 




Complex Element 




Word or 






Word or 




Type Name 


Component 


Item 




Component 


Item 


33 CQUAD3 




Undefined 






Undefined 


34 CBAR 


2 


SAl 




2 


SAl 




3 


SA2 




3 


SA2 




4 


SA3 




4 


SA3 




5 


SA4 




5 


SA4 




6 


Axial 




5 


Axial 




7 


SA-maximum 




7 


SAl 




8 


SA-minimum 




8 


SA2 




9 


Safety Margin in 


Tension* 


9 


SA3 




10 


SBl 




10 


SA4 




n 


SB2 




11 


Axial 




12 


SB3 




12 


SBl 




13 


SB4 




13 


SB2 




14 


SB -maximum 




14 


SB3 




15 


SB-minimum 




15 


SB4 




16 


Safety Margin ir 


Comp* 


1G 

17 
18 
19 


SBl 
SB2 
SB3 
SB4 


35 CC0NEAX 


2 
3 


Harmonic or point angle 
Zl = Fibre Distance 1 




Undefined 




4 


Normal -u 


at 1 








5 


Normal -V 


at 1 








6 


Shear-uv 


at 1 








7 


0-Shear Angle 


at 1 








8 


Major-Principal 


at 1 








9 


Mi nor- Principal 


at 1 








10 


Maximum Shear 


at 1 








11 


Z2 = Fibre Dista 


nee 2 








12 


Normal -u 


at 2 








13 


Normal -V 


at 2 








14 


Shear-uv 


at 2 








15 


0-Shear Angle 


at 2 








16 


Major-Principal 


at 2 








17 


Minor-Principal 


at 2 








18 


Maximum-Shear 


at 2 






36 CTRIARG 


2 
3 
4 
5 


Radial (x) 
Circum (Theta) 
Axial (z) 
Shear (zx) 






Undefined 


37 CTRAPRG 


2 


Radial (x) 


at 1 




Undefined 




3 


Circum (Theta) 


at 1 








4 


Axial (z) 


at 1 








5 


Shear (zx) 


at 1 








6 


Radial (x) 


at 2 








7 


Circum (Theta) 


at 2 








8 


Axial (z) 


at 2 








9 


Shear (zx) 


at 2 








10 


Radial (x) 


at 3 








11 


Circum (Theta) 


at 3 








12 


Axial (z) 


at 3 








13 


Shear (zx) 


at 3 








14 


Radial (x) 


at 4 








15 


Circum (Theta) 


at 4 








16 


Axial (z) 


at 4 








17 


Shear (zx) 


at 4 








18 


Radial (x) 


at 5 







Real 
Imag. 



2.3-187 



DATA BLOCK AND TABLE DESCRIPTIONS 



Element 


Real 
Word or 


Element Stresses 






Complex Element Stresses 
Word or 


Real 


Type Name 


Component 


Item 






Comoonent Item 


Imaa. 


37 cont'd. 


19 


Circum(Theta) 


at 


5 








20 


Axial (z) 


at 


5 








21 


Shear (zx) 


at 


5 






38 CT(3RDRG 


2 


Mem.-Tagen. 


at 




Undefined 






3 


Mem. -C ire urn. 


at 










4 


Flex.-Tangen. 


at 










5 


Flex.-Circum. 


at 










G 


Shear-Force 


at 










7 


Mem.-Tangen. 


at 


2 








8 


Mem.-Circum. 


at 


2 








9 


Flex.-Tangen. 


at 


2 








10 


Flex.-Circum. 


at 


2 








11 


Shear-Force 


at 


2 








12 


Mem.-Tangen. 


at 


3 








13 


Mem.-Circum. 


at 


3 








14 


Flex.-Tangen. 


at 


3 








15 


Flex.-Circum. 


at 


3 








16 


Shear-Force 


at 


3 







* If not equal to integer 1. 

Note 

If output is magnitude/phase the magnitude replaces the real oart and the Phase renlaces 
the imaginary part. 



2.3-188 



DATA BLOCK DESCRIPTIONS 



2.3.52 Element Force Output Data Description . 



Note particular data block description (e.g., 0EF1 , I3EF61) for contents word 1 for each element. 



Element 
Type Name 



1 



CR0D 



CBEAM 



Real Element Forces 
Word or 
Component Item 



CTUBE 
CSHEAR 



5 CTIJIST 



6 CTRIAl 



Axial Force 
Torque 



Bend-Mom 

Bend-Mom 

Bend-Mom 

Bend-Mom 

Shear-1 

Shear-2 

Axial Force 

Torque 

Same as CR0D 

Force Pts 1 ,3 
Force Pts 2,4 



Moment Pts 1 ,3 
Moment Pts 2,4 



Bend-Mom-x 

Bend-Mom-y 

Twist-Moment 

Shear-x 

Shear-y 



7 


CTRBSC 




Same as CTRIAl 


8 


CTRPLT 




Same as CTRIAl 


9 


CTRMEM 




Undefined 


10 


C0NR(ilD 




Same as CR0D 


11 


CELASl 


2 


Force 


12 


CELAS2 


2 


Force 


13 


CELAS3 


2 


Force 



Al 
A2 
Bl 
B2 



Complex Element Forces 
Word or 
Component Item 



Axial Force 
Axial Force 
Torque 
Torque 

Undefined 



Real 
Imaq. 





Same as CR0D 




2 
3 
4 
5 


Force Pts 1,3 
Force Pts 1,3 
Force Pts 2,4 
Force Pts 2,4 


R 

I 
R 

I 


2 
3 
4 
5 


Moment Pts 1 ,3 
Moment Pts 1,3 
Moment Pts 2,4 
Moment Pts 2,4 


R 

I 
R 

I 


2 
3 
4 
5 
6 
7 
8 
9 
10 

n 


3end-Mom-x 

Bend-Mom-y 

Twist-Moment 

Shear-x 

Shear-y 

Bend-Mom-x 

Bend-Mom-y 

Twist-Moment 

Shear-x 

Shear-y 

Same as CTRIAl 

Same as CTRIAl 

Undefined 

Same as CR0D 


R 
R 

D 

R 
R 


2 
3 


Force 
Force 


R 
I 


2 

3 


Force 
Force 


R 

I 


2 
3 


Force 
Force 


R 

I 



2.3-189 



DATA BLOCK AND TABLE DESCRIPTIONS 



Element 


Real El 






Word or 


Type 


Name 


Component 


14 


CELAS4 


2 


15 


CQDPLT 




16 


CQDMEM 




17 


CTRIA2 





Item 



18 

19 

20 

21 

22 

23 

24 

25 

26 

27 

28 

29 

30 

31 

32 

33 

34 



CQUAD2 

CQUADl 

CD AMP 1 

CDAMP2 

CDAMP3 

CDAMP4 

CVISC 

CMASSl 

CMASS2 

CMASS3 

CMASS4 

C0NM1 

C0NM2 

CPL0TEL 

CREACT 

CQUAD3 

CBAR 



2 
3 
4 
5 
6 
7 
8 
9 



Force 

Note CTRIAl 

Undefined 

Note CTRIAl 

Note CTRIAl 

Note CTRIAl 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undef i ned 

Undefined 

Undefined 

Undefined 

Undefined 

Bend-Mom Al 
Bend-Mom A2 
Bend-Mom Bl 
Bend-Mom B2 
Shear-1 
Shear-2 
Axial Force 
Torque 



Complex Element Forces 




Word or 
Component 


Item 




Real 
Imag. 


2 
3 


Force 
Force 

Note CTRIAl 

Undefined 

Note CTRIAl 

Note CTRIAl 

Note CTRIAl 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 

Undefined 




R 

I 


2 
3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

16 

17 


Bend-Mom 

Bend-Mom 

Bend-Mom 

Bend-Mom 

Shear-1 

Shear-2 

Axial Force 

Torque 

Bend-Mom 

Bend-Mom 

Bend-Mom 

Bend-Mom 

Shear-1 

Shear-2 

Axial Force 

Torque 


Al 
A2 
Bl 
B2 

Al 
A2 
Bl 
B2 


R 
R 
R 
R 
R 
R 
R 
R 



2.3-190 (12-1-69) 



DATA BLOCK DESCRIPTIONS 



Element 



Type 



Name 



35 



CC0NEAX 



36 



CTRIARG 



37 



CTRAPRG 



Word or 
Component 



Real Element Forces 



Item 



38 



CT0RDRG 



2 
3 
4 
5 
6 
7 

2 
3 
4 
5 
6 
7 
8 
9 
10 

2 
3 
4 
5 
6 
7 
8 
9 
10 

n 

12 
13 

2 

3 

4 

5 

6 

7 

8 

9 
10 
11 
12 
13 



Harmonic or point angle 

Bend-Mom u 

Bend-Mom v 

Twist-Moment 

Sheer u 

Shear v 



Radial (x) 


at 1 


Circum (Theta) 


at 1 


Axial (z) 


at 1 


Radial (x) 
Circum (Theta) 


at 2 


at 2 


Axial (z) 


at 2 


Radial (x) 


at 3 


Circum (Theta) 


at 3 


Axial (z) 


at 3 


Radial (x) 


at 1 


Circum (Theta) 


at 1 


Axial (z) 


at 1 


Radial (x) 


at 2 


Circum (Theta) 


at 2 


Axial (z) 


at 2 


Radial (x) 


at 3 


Circum (Theta) 


at 3 


Axial (z) 


at 3 


Radial (x) 


at 4 


Circum (Theta) 


at 4 


Axial (z) 


at 4 


Radial (x) 


at 1 


Circum (Theta) 


at 1 


Axial (z) 


at 1 


Moment (zx) 


at 1 


Direct Strain 


at 1 


Curvature 


at 1 


Radial (x) 
Circum (Theta) 


at 2 


at 2 


Axial (z) 


at 2 


Moment (zx) 


at 2 


Direct Strain 


at 2 


Curvature 


at 2 



Comp''ex Element Forces 

Word or 
Component Item 



Real 
Imag. 



Undefined 



Undefined 



Undefined 



Undefined 



2.3-191 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.3.53 Data Blocks Output From Module DDR2 

2.3,53.1 UEVF (MATRIX) 

Description 

[u^] - Displacements at the extra points for a frequency response problem. 

Matrix Trailer 

Number of columns = number of frequencies times number of loads 

Number of rows = e 

Form = rectangular 

Type = single precision 

2.3.53.2 PAF (MATRIX) 

Description 

[P ] - Equivalent load vector for mode acceleration computations in a frequency response 
* problem - a set. 

Matrix Trailer 

Number of columns = number of frequencies times number of loads 

Number of rows = d 

Form = rectangular 

Type = single precision 

2.3.53.3 UDV2F (MATRIX) 
Description 

[Uj^] - Mode accelerated displacement vectors for a frequency response problem. 

Ma trix Trailer 

Number of columns = number of frequencies times number of loads 

Number of rows = d 

Form = rectangular 

Type = complex single precision 

2.3.53.4 UEVT ( MATRIX) 

Description 

[u ] - Displacement at the extra points for a transient analysis problem. 



2.3-192 



DATA BLOCK DESCRIPTIONS 



Matrix Trailer 

Number of columns = number of output times multiplied by 3 

Number of rows = e 

Form = rectangular 

Type = real single precision 



2.3.53.5 PAT (MATRIX) 

Description 

[Pg] - Equivalent load vector for mode acceleration in a transient analysis probl 

Matrix Trailer 

Number of columns - number of output times multiplied by 3 

Number of rows - d 

Form - rectangular 

Type - real single precision 

2.3.53.6 UDV2T (MATRIX) 

Description 

[u^ ] - Mode accelerated displacement vectors for a transient analysis problem. 

Matrix Trailer 

Number of columns = number of output times multiplied by 3 

Number of rows = d 

Form = rectangular 

Type = real single precision 



em. 



2.3-193 



EXECUTIVE TABLE DESCRIPTIONS 

2.4 EXECUTIVE TABLE DESCRIPTIONS 

The following is an alphabetical index of Executive table descriptions. 



Section Number 


Executive Table Name 
CEITBL 


Where Stored 


Page Number 


2.4.1.5 


/XCEITB/ 


2.4-9 


2.4.1.4 


DPL 


/XDPL/ 


2.4-7 


2.4.1.2 


FIAT 


/XFIAT/ 


2.4-3 


2.4.1.3 


FIST 


/XFIST/ and /XPFIST/ 


2.4-5 


2.4.2.7 


LNKSPC 


/XLKSPC/ 


2.4-29 


2.4.2.2 


MPL 


/XGPI2/ 


2.4-21 


2.4.2.1 


0SCAR 


Data Pool File 


2.4-15 


2.4.2.4 


PVT 


/XPVT/ 


2.4-26 


2.4.1.8 


SYSTEM 


/SYSTEM/ 


2.4-13 


2.4.1.7 


TAP ID 


/STAPID/ 


2.4-12 


2.4.1.6 


VPS 


/XVPS/ 


2.4-10 


2.4.2.6 


XALTER 


Problem Tape 


2.4-28 


2.4.2.5 


XCSA 


Problem Tape 


2.4-27 


2.4.1.1 


XFIAT 


/XXFIAT/ 


2.4-2 


2.4.1.9 


XLINK 


/XLINK/ 


2.4-14 


2.4.2.3 


XPTDIC 


Problem Tape 


2.4-24 



2.4-1 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.4.1 Executive Tables Which are Permanently Core Resident 

2.4.1.1 XFIAT (Permanent File Allocation Table) 

Description 

A NASTRAN resident memory table containing the physical file identification for the 
permanent files (P00L, 0PTP, etc.). 

Created in Module 

The physical file identifications are output by GNFIAT (generate FIAT). 

Table Format 



Word 1 
2 

3 



s 


NOT 
USED 


1 7| 1 5 


FILE 

1 5 


s 


NOT 
USEJ 


1 7| 16 


FILE 

1 5 


s 


NjT 
USED 


If 

1 7| 16 


FILE 

1 5 


s 


riOT 
USED 


17| 16 


FILE 

15 


^ 


-^^ 


^ 





Word 
1-N 



Notes 



Item 
TP 

FILE 



Description 

Tape Flag (1 bit) - set if physical file (FILE) is a 
magnetic tape. 

File ID (15 bits) - unique integer identification for 
a physical file. 



1. The number of entries (N) is dictated by the integer value in PFIST (see FIST 
Executive Table Description - 2.4.1.3) 

2. The XFIAT table is located in the named common block /XXFIAT/. 



2.4-2 



EXECUTIVE TABLE DESCRIPTIONS 



2.4.1.2 FIAT (File Allocation Table). 

Description 

A NASTRAN resident memory table containing the data block name vs. physical file ID. for 
a segment of DMAP modules. 

Created in Module 

The physical files available for the system/computer confiquration are outnut by f^^lFIAT 
(generate FIAT). The data block names and other data block information are outnut by XSFA, 
Executive Segment File Allocator. 

Table Format 



Word 1 
2 
3 



6 
7 
8 
9 
10 



UFA 



MXE 



CAE 



A 
P 

3 1|3 



LTU 



|T I 
IP I 
I I 

1 7 16,1 5 



FILE 



DATA BLOCK 
NAME 



DATA BLOCK 
TRAILER 



I I 



FIAT Header 



Entry #1 (sample) 



Entry #2 through CAE 



2.4-3 



DATA BLOCK AND TABLE DESCRIPTIONS 



Word Item Description 

1 UFA Unique files available - this integer indicates the number of 

unique file entries in the FIAT. 

2 MXE Maximum entries - this integer shows the total entry size of 

the dimensioned FIAT table; the amount of memory reserved 
(N) = 6 X MXE + 3. 

3 CAE Current active entries - this integer designates the portion of 

FIAT currently containing valid data; UFA^^ CAE« ItXE. 

Words 4 through 9 describe a sample 6-word entry: 

Equivalence flag (1 bit) - bit, file not equivalence^. 

1 bit, file equivalenced. 

Append flag (1 bit) - set if aopend is soecified for data 
block in DMAP sequence by a FILE DMAP instruction. 

Last time used (14 bit integer) - record number of 0SCAR 
entry for last use of data block. 

Tape flag (1 bit) - set if physical file (FILE) is a magnetic 
tape. 

File ID (15 bits) - unique identification for a physical file. 

Data block name - 8 characters (4 characters/word). 

Data block trailer - storage for 6-16 bit data block trailer 
words. 

Words 10 through N contain repeated 6-word entries. 

Trailer Information 

Trailer information for each data block is stored in and received from the FIAT by WRTTRL 
(write trailer) and RDTRL (read trailer). 

Note 

The FIAT table is located in the named common block /XFIAT/. 



4 


EQ 




AP 




LTU 




TP 




FILE 


5.5 


NAME 


7,8,9 


TRAILER 



2.4-4 



EXECUTIVE TABLE DESCRIPTIONS 



2.4.1.3 FIST (File Status Table) 

Description 

A NASTRAN resident memory table containing the internal data block reference (IDBR) 
numbers vs. FIAT table pointers for a particular module; also, the permanent file reference 
names vs. XFIAT table pointers. 

Created in Module 

The module entries are generated prior to each module execution by subroutines GNFIST 
(Generate FIST). The permanent entries are initialized at system assembly. 

Table Format 



PFIST 



Word 1 



21+2+1 



+2 



+3 

+4 

N 



MXE 



CAE 



Perm Name 



XF Point 



Perm Name^ 



XF Point 



IDSR, 



F Point 



IDBR. 



F Point 



FIST Header 



Sample Permanent Entry 



Sample Module Entry 



2.4-5 



DATA BLOCK AND TABLE DESCRIPTIONS 

Word Item Description 

PFIST I Integer number of permanent FIST entries. 

1 MXE Maximum entries - this integer shows the total entry size of the 

dimensioned FIST table; the amount of memory reserved 
(N) = 2 * MXE + 2. 

2 CAE Current active entries - this integer designates the portion of 

FIST currently containing valid data; I ^ CAE s MXE. 

Words 3 and 4 describe a sample 2-word permanent entry: 

3 Perm Name A permanent file reference name - 4 characters BCD (e.g., P00L, 

0PTP, PLTl, etc.). 

4 XF Point Points to the XFIAT position containing the file ID for this 

permanent file. 

Words 21+2+1 and +2 describe a sample 2-word module entry. 

+1 IDBR An internal data block reference number (GIN0 file number) - 

integer (e.g., 104, 206, 301, etc.). 

+2 F Point Points to the FIAT position containing the file ID for this 

module entry. 



Notes 



1. XFIAT pointer values contain an S bit equal to 1, while FIAT pointer values contain an 
S bit equal to 0. 

2. Permanent entries remain static throughout a run, while module entries are changed by 
GNFIST prior to each module call. 

3. FIAT and XFIAT position pointers are indexes into the respective tables considering 
the first word of the table as position 0. 

4. The FIST table is located in the named common block /XFIST/. 
The PFIST entry is located in the named common block /XPFIST/. 



2.4-6 



EXECUTIVE TABLE DESCRIPTIONS 

2.4.1.4 DPL (Data Pool Dictionary) 

Description 

A NASTRAN resident memory table describing the current contents and status of the Data Pool. 

Created in Module 

Data Pool, and therefore Dictionary entries, are created by pooling from SFA (Segment File 
Allocator), housekeeping operations by DPH (Data Pool Housekeeper) and restart initialization bv 
GPI (General Problem Initialization), and IFP (Input File Processor) when writing DMI and DTI 
information (see section 2.3.2). 



Table Format 



Word 1 



"eT 



Slai 



NFA 



MXE 



CAE 



DATA BLOCK 
NAME 



DPL Header 



SIZE 



I FILE # 



1 7|1 6 



Entry #1 (sample) 



Entry #2 



2.4-7 



DATA BLOCK AND TABLE DESCRIPTIONS 



Word Item Description 

1 NFA Next file available - the next Data Pool File number (inteqer) 

available for output. 

2 MXE Maximum entries - this integer shows the total entry size o^' 

the dimensioned DPL table; the amount of memory reserved 
(N) = 3 * MXE + 3. 

3 CAE Current active entries - this integer designates the portion of 

the DPL currently containing valid data; 0^ CAE s MXE. 

Words 4 through 5 describe a sample 3-word entry. 

4,5 NAME Data block name - 8 characters (4 characters/word). 

6 EQ Equivalence flag (1 bit) - bit, file not equivalenced. 

1 bit, file equivalenced. 

SIZE Size of the pooled data block - number of words/10. 

FILE# The file number (integer) showing the relative position of the 
data block file of the pool. 

Note 

The DPL table is located in the labeled common block /XDPL/. 



2.4-8 



EXECUTIVE TABLE DESCRIPTIONS 

2.4.1.5 CEITBL (Control Entry Information Table) 
Description 

CEITBL controls the REPT and EXIT DMAP module execution. 
Created In Module 

XGPI. 
Table Format 



Word 1 

2 

3 

4 

5 
6 
7 

8 

9 

10 



--\ 



m 


QH 


31 


BL 

1 7 


1 6 


EL 


1 


.3i . 


ML 

1 7 


16 


CL 


.i 




LN 






Not 


used ^, 


1 6 


ERN 


1 


31 


MC ., 


16 


CC 


1 


Not used 


Not used 








■ 



Sample entry for REPT control 
(4 words) 



Sample entry for EXIT control 
(4 words) 



Word 



Item 



1 


MN 


2 


CN 


3 


BL 
EL 


4 


ML 
CL 


5,6 


LN 


7 


ERN 


8 


MC 
CC 



9.10 



Description 

Maximum number of words in table (integer). 

Current number of words being used (integer). 

0SCAR record number where loop begins (integer). 
0SCAR record number where loop ends (integer). 

Maximum loop count as specified in REPT instruction (integer). 
Current loop count, that is, the number of times loop has been 
repeated (integer). 

Location name specified in REPT instruction (BCD). 

EXIT 0SCAR record number (integer). 

Maximum count specified in EXIT instruction. 

Current count of number of times EXIT instruction not executed. 

These two words are zeroed. 



Notes 



CEITBL is located in named common block /XCEITB/. 



2.4-9 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.4.1.6 VPS (Variable Parameter Set Table) 

Description 

The VPS table contains the values of all variable parameters referenced by DMAP modules in a 
DMAP program. It is the means for transferring variable parameter values from one module to 
another. 

Created in Module 

XGPI. 

Table Format 



Word 1 
2 
3 
4 



6 
5+L 



Word 



30 



m 



Item 



1 


MN 


2 


CN 


3.4 


Name 


5 


A 



6 thru 5+L 



T 
L 
V 



CN 



Parameter 
Name 



I Sample entry 
{variable length) 



Description 

Maximum number of words in VPS (integer). 

Current number of words being used (integer). 

BCD name of variable parameter. 

Assigned flag. A = 1 indicates value from DMAP instruction 
has been entered in VPS. 

Modified flag. M = 1 indicates parameter was modified by bulk 
data PARAM card on restart. 

Type code for parameter (integer). 

Length in words of item V (integer). 

Value of parameter. 



2.4-10 



EXECUTIVE TABLE DESCRIPTIONS 



Notes 



1. Items A, M and T (word 5 of sample entry) are used only by the XGPI module and are 
cleared prior to exiting XGPI. 

2. Type code and corresponding word length. 



1 = integer 


1 


2 = real, S.P. 


1 


3 = BCD 


2 


4 = real , D.P. 


2 


5 = complex, S.P. 


2 


6 = complex, D.P. 


4 



3. The VPS table is located in the named common block /XVPS/. 



2.4-11 



DATA BLOCK AND TABLE CESCF'.IPTIONS 

2.4.1.7 TAPID (Problem Tape Identification Table) 
Description 

TAPID contains Problem Tape identification information. 
Created in Module 

XCSA. 

Table Format 

Word 1 

2 

3 

4 

5 
5 



— 


ID^ 










ID2 







M 




D 






Y 


3 1 


1 5 


1 ■) 


9 


8 


1 


R 



Word 



Item 



Description 
First BCD field on ID Executive Control card. 
Second BCD field on ID Executive Control card. 
The date - integers - month, day, year. 
Reel number of Problem Tape (integer). 



1. TAPID is written on Problem Tape as single record field. It is always the first file 
on the Problem Tape. 

2. 0TAPID has same format as TAPID. (ilTAPID is the ID information from an Old Problem Tape 
being used for restarting problem. 

3. TAPID and pTAPID are located in named common block /STAPID/. 



1.2 


ID, 


3.4 


ID2 


5 


M.D.Y 


6 


R 


Notes 





2.4-12 



EXECUTIVE TABLE DESCRIPTIONS 



2.4.1.8 SYSTEM (NASTRAN System Parameters). 



Description 



A NASTRAN resident memory table containing various machine dependent, operating system and 
NASTRAN parameters. The length of the table is defined by one of the table items. 

Created in Module 



Most items are initialized by the NASTRAN block data program, SEMDBD. 
dependent items are set by subroutine BTSTRP, 



Several machine 



Table Format 



The sequential teble description follows: 

Word Symbol Description 



1 


SYSBUF 


2 


0UTTAP 


3 


N0G(9 


4 


INTP 


5 


MPC 


6 


SPC 


7 


METH0D 


8 


L0AD 


9 


NLPP 


10 


MTEMP 


11 


NPAGES 


12 


NLINES 


13 


TLINES 


14 


MXLINS 


15 


DATE(l) 


16 


DATE (2 


17 


DATE (3) 


18 


TIMEZ 


19 


ECH0F 


20 


PL0TF 


2"! 


APPRCH 


22 


MACH 


23 


LSYSTM 


24 


EDTUMF 


25 


SWITCH 


26 


CPPGCT 


27 


MN 



28 



IC0NFG 



29 


MAXFIL 


30 


MAX0PN 


31 


K0N36O 



32 



TIMEW 



Number of words in a GIN0 buffer 

F0RTRAN logical unit for output 

Flag defining status during Preface 

F0RTRAN logical unit for input 

Multipoint constraint set ID 

Single-point constraint set ID 

Eigenvalue extraction method 

First record pointer in Case Control data block 

Number of lines per page of printed output 

Material temperature set ID 

Current page count 

Number of lines on current page 

Total number of lines printed for problem 

Maximum number of printed lines permitted 

Today's date - integer month 1-12 

Today's date - integer day 1-31 

Today's date - integer year (XX) 

Time of problem start - seconds after midnite 

Bulk data output request type 

Structural plot request flag 

Approach type flag (1 = F0RCE, 2 = DISPL, 

3 = DMAP) 
Computing machine code number (1 = 7094, 

2 = 360, 3 = 1108, 4 = 6600) 
Length of this table 
User master file edit flag 
Logical sense switch bits set by a DIAG 

Executive Control Deck card 
XCHK module page count 
Used only in a conical shell problem. The lower 

order 16 bits contain N, the number of 

harmonics; the next higher order 16 bits 

contain M, the number of rings. 
Machine configuration - subset of MACH code 

number 
Maximum number of files to be added to FIAT 
Maximum number of files to be opened simultaneously 
Number of memory words to be released for OS 

(360 only) 
Initial problem start time (integer seconds after 

midnite) 



Initially 
Set by 

BTSTRP 
BTSTRP 
SEMDBD 
BTSTRP 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
BTSTRP 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 
SEMDBD 

SEMDBD 

BTSTRP 
SEMDBD 
SEMDBD 

SEMDBD 
SEMDBD 



SEMDBD 

SEMDBD 
SEMDBD 
SEMDBD 

SEMDBD 

SEMDBD 



2.4-13 (12-1-69) 



EXECUTIVE TABLE DESCRIPTIONS 



Word Symbol Description Initially 
Set by 

0FP operate flag - set nonzero when 0FP operates SEMDBD 

Length of FET + circular buffer (CDC 6600 only) SEMDBD 

Length of master index (CDC 6600 only) SEMDBD 

Length of subindex (CDC 6600 only) SEMDBD 
Not used 

Number of bits per character BTSTRP 

Number of bits per word BTSTRP 

Number of characters per word BTSTRP 



33 


0FPFLG 


34 


NBRCBU 


35 


NBRMST 


36 


NBRSUB 


37-38 




39 


NBPC 


40 


NBPW 


41 


NCPW 



2.4-13a (12-1-69) 



DATA BLOCK AhD TABLE DESCRIPTIONS 



2.4.1.9 XLINK (Link Specification Table - Non-resident Edit) 
Description 

This Link Specification Table (see also 2.4.2.7) contains an entry corresponding to each 
DMAP module within the MPL (2.4.2.2) table. These entries are indexed by MPL position and 
are thus ordered the same as the MPL entries. Each entry contains a key indicating the 
links in which the module resides. 

Created in Module 

XLINK data is created from the LNKSPC (2.4.2.7) and MPL (2.4.2.2) tables by the XGPIBS 
subroutine within the XGPI (4.7) module. 

Table Format 



Word 1 

2 
3 



LXLINK 



MAXLNK 



Key 



Key 



Key 



Entry #1 (sample) 
Entry #2 
Entry #3 



Word 

1 
2 

3,N 



Item 

LXLINK 
MAXLNK 
Key 



Description 

Length of table (number of entries) 

Maximum permissable link number 

Link residence key for the corresponding MPL entry 



The content of this Key word is identical to the Key word within LNKSPC (2.4.2.7) for the 
machine type currently operating. See section 2.4.2.7 for an explanation of the content. 



Notes 



1. The XLINK table must contain an entry in the same order for each module that is 
in the MPL (2.4.2.2) table. 

2. XLINK table is located in /XLINK/. 



2.4-14 



EXECUTIVE TABLE DESCRIPTIONS 

2A.2 Executive Tables Not Permanently Core Resident 
2.4.2.1 0SCAR (Operation Sequence Control Array) 
Description 

The Operation Sequence Control Array (0SCAR) controls the sequence of modules executed and 
aids in communicating data between modules. 

The (3SCAR is generated from a DMAP instruction sequence supplied by the user or selected 
from the Rigid Format library. In general, an 0SCAR entry is a DMAP statement which has been 
translated to a more readily usable form for internal use. 

The four 0SCAR entry format types are: 

1. Type 1 or F (functional) format is used for all functional modules exceot outnut 
processors. 

2. Type 2 or (output) format is used for output processors. 

3. Type 3 or C (control) format is used for REPT, JUMP, C0ND and END DMAP instructions. 

4. Type 4 or E (executive) format is used for SAVE, CHKPNT, PURGE and EQUIV DMAP 
instructions. 

Created in Module 

XGPI. 

Table Format 



Word 1 


N 


2 




RU 




3 






MI 


T 




s 


3 1 


17 16 


1 


4 




Module 






— — 







5 




Name 




6 


EX 
s 


3 1 


DIN 


1 


7 


Format of this 


< 


• i 


section is dependent i 


N 


on 


value of T 





Entry Header Section 



Entry Data Section 



2.4-15 



DATA BLOCK AND TABLE DESCRIPTIONS 



Word 



Item 



1 


N 


2 


RN 


3 


MI 



4,5 
6 



Name 



EX 
DIN 



Description 

Integer - number of words in entry. 

Integer - record number of entry in laSCAR table. 

Integer - module index number assigned according to module's 
position in MPL and used to access the module's link specifica- 
tions in /XLINK/. 

Integer - format type code (1, 2, 3, or 4) for data section 
of entry. 

BCD - module name is same as DMAP instruction name except when 
T = 4. 

Execute flag. EX = 1 indicates module is to be executed. 
Integer - DMAP instruction number which generated this entry. 



Data Section Format for Type 1 or F Format: 



Word 7 
8 
9 

10 



8+NIP*3 

9+NIP*3 

10+NIP*3 

11+NIP*3 



NIP 



AP 



DATA BLOCK 
NAME 

TP 

LTU 

30 17 



NTU 

15 1 



NpP 



DATA BLOCK 
NAME 



AP 



LTU 

30 17 



TP 



NTU 



9+NIP*3+N0P*3 
10+NIP*3+N0P*3 
11+NIP*3+N0P*3 



NS 



NP 



CV 

S|3 1 



IL 



•Sample entry 



■Sample entry 



Input 

Data Block 
Subsection 



Output 
Data Block 
Subsection 



Sample entry I Parameter 

j (variable length)/ Subsection 



(Not used) 



2.4-16 



Uord Item 



7 


NIP 


8.9 


NAME 


10 


AP 




LTU 




TP 




NTU 


8 + NIP*3 


N0P 


9 + NIP*3, 
10 + NIP*3 


NAf4E 


11 + NIP*3 


AP.LTU, 
TP.NTU 


9 + NIP*3 + 
NCfP*3 


NS 


10 + NIP*3 + 

mp*3 


NP 


11 + NIP*3 + 
N0P*3 


CV 

IL 



EXECUTIVE TABLE DESCRIPTIONS 



Description 

Integer - number of data blocks input to module as specified 
in MPL. 

BCD - name of first input data block specified in DMAP instruc- 
tion or zero if none specified. 

Append flag used by subroutine XSFA and set by X0SGEN if APPEND 

is specified for data block in a FILE OMAP instruction. 

Integer - last time used. (?SCAR record number of entry a^ter 

which data block will no longer be saved. 

Tape flag used by subroutine XSFA and set by X'3SREM if tane is 

specified for data block in a FILE DMAP instruction. 

Integer - next time used. !3SCAR record number o^ entry where 

data block is next referenced. 

Integer - number of data blocks outout from module as sneci^ied 
in MPL. 

BCD - name of first output data block specified in DMAP instruc- 
tion or zero if none specified. 

Same descriptions as word 10. 



Integer - number of scratch data blocks used by module as 
specified in MPL. 

Integer - number of parameters used by module as specified in 
MPL. 

Constant/variable flag. Flag indicates meaning of IL. 

Integer - VPS index/length of constant. If CV = the parameter 
is a constant whose value is stored in the next IL words (i.e 
words 12 + MIP*3 + N0P*3 through 11 + NIP*3 + N0P*3 + IL). 
If CV = 1 the parameter is a variable whose value is stored in 
the VPS table. IL points to the value in VPS. 



2.4-17 



DATA BLOCK AND TABLE DESCRIPTIONS 



Data Section Format for Type 2 or Format: 



Word 7 
8 
9 

10 



8+NIP*3 
9+NIP*3 

10+NIP*3 



AP 



C\ 



NIP 



DATA BLOCK 
NAME 



LTU 

30 17 



TP 



NTU 

IS 1 



NS 



NP 



IL 



> Sample entry 



^ Input Data Block 
Subsection 



►Sample entry 

I (variable length) 



■Parameter 
'Subsection 



Type 1 format description is applicable to type 2 format above. 
Data Section Format for Type 3 or C Format: 



Word 7 = N 





RRN ,, 

31 17 


le I 1 



Word 

N 



Item 
RRN 



Description 

Integer - re-entry record number. Indicates (JSCAR record to 
jump to for JUMP, REPT and C0ND DMAP instructions. Not 
applicable for EXIT so RRN = 0. 

Integer - index into XCEITBL for REPT or EXIT DMAP instruction, 
Pointer to oarameter value in XVPS table if C0ND DMAP 
instruction. Not applicable for JUMP so I =0. 



2,4-18 



EXECUTIVE TABLE DESCRIPTIONS 



Data Section Formats for Type 4 or E Forma ts : 



Word 7 



NP 



IV 
IB 



> Sample entry 



Format for 
SAVE DMAP 
instruction 



iJord 



Item 
NP 

IV 
IB 



Description 

Integer - number of parameter values to be saved (i.e. number 
of entries). 

Integer - pointer to parameter value in VPS. 

Integer - pointer to parameter value in blank common. 



Word 7 



N-1 



NDB 



FIRST DATA 
BLOCK NAME 



LAST DATA 
BLOCK NAME 



Format for CHKPr!T 
DMAP instruction 



Word 



S thru N 



Item 

NDB 

NAMES 



Description 
Integer - number of data blocks names in list. 
BCD - list of data blocks to be checkpointed. 



2.4-19 



DATA BLOCK AND TABLE DESCRIPTIONS 



Word 7 
8 
9 





NDB 




-- 


DATA BLOCK 
NAME 


V- 


f 


\ 


IV 



, Format for PURGE or EQUIV 
DMAP instruction 



Description 

Integer - number of data block names in first qroun. There 
may be one or more grouos . 

BCD - name of first data block in first group. 

Integer - pointer to parameter value in VPS table. 



1. (3SCAR is located in named common block /XGPIl/ while module XGPI is generating it. 

2 After generating 0SCAR and prior to exiting XGPI the 0SCAR is written on the Data Pool 
File. The OSCAR file header ID is XjJSCAR. 



Word 


Item 


7 


NDB 


8,9 


NAi^E 


N 


IV 


Notes 





2.4-20 



EXECUTIVE TABLE DESCRIPTIONS 



2.4.2.2 MPL (Module Property List) 
Description 

The Module Properties List contains information needed by the module XGPI to correctly 
generate (JSCAR table entries for executable DMAP instructions and/or to determine whether or 
not the DMAP instructions adhere to the calling sequence described in section 4. Module 
Functional Descriptions. 

Created in Module 

XGPI (Block Data Program XMPLBD). 

Table Format 

There are two formats used in the MPL, one for Declarative (FILE, BEGIN, LABEL) Executive 

(CHKPNT, EQUiy, PURGE, SAVE) and Control (REPT, JUMP, CQW, EXU. END) DMAP ^dules and Se o?her 

for functional modules. All entries in the MPL are integer except for module names which are 
BCD and BCD parameter values. 

Format for Declarative, Executive and Control Modules: 



Word 1 
2 
3 

4 




Word 



Item 



1 


N 


2.3 


Name 


4 


F 



Description 
Number of words in entry. 
Name of DMAP module. 

0SCAR format type code 

3 = Control module (C format) 

4 = Executive module (E format) 

5 = Declarative module (D format) 



2,4-21 



Format for Functional Modules: 



DATA uLOCK AND TABLE DESCRIPTIONS 



Word 1 
2 
3 
4 
5 
6 
7 



t 



N 



Module 

Name 



IP 



0P 



Parameter List 



Variable Lenqth 



Word 
1-3 

4 



Item 



7 

8-N 



IP 
!3P 
S 



Description 

Same as format for Declarative, Executive and Control modules. 

F = 1 implies module has input and output data blocks 

F = 2 implies module has no output data blocks, e.g., 
0FP, SETVAL etc. 

Number of input data blocks. 
Number of output data blocks. 
Number of scratch data blocks. 
Parameter List (omit if no parameters). 



ThP narameter list for a module contains the types of all parameters residing in blank 

an index into another table which contains the default value. 
Type Code 

1 = integer 

2 = real, single precision 

3 = BCD 

4 = real , double precision 

5 = complex, single precision 

6 = complex, double precision 



llj.:: — ^ ^ 

1 word 


1 word 


2 words 


2 words 


2 words 


4 words 



2.4-22 (12-1-69) 



EXECUTIVE TABLE DESCRIPTIONS 

An example of all possible entries in a parameter list follows. Note that for each parameter 
only the first index word will appear in the XMPLBD Block Data subprogram. 



Word 





1 


8 




-3 


q 




-1 


10 




2 


11 




1 


12 




-2 


13 




3 


14 




A6CD 


15 




EFGH 


16 




-3 


17 




4 


18 




1 


19 




1 


20 




-4 


21 




5 


22 




2 


23 




2 


24 




-5 


25 




6 


25 




3 


27 




3 


28 




4 


29 




4 


30 




-5 


31 


Notes 







={ 



Integer type code. 

Integer default value. 

Integer type code (no default value). 

Real , S.P. type code. 

Index into table containing a real S.P. default value. 

Real, S.P. type code (no default value). 

BCD type code. 

BCD default value (2 words). 

BCD type code (no default value). 
Real , D.P. type code. 
|Index into table containing a real D.P. default value. 
(Note index is in both words. 
Real, D.P. type code (no default value). 
Complex, S.P. type code. 

jlndex into table containing a complex S.P. default value. 

Complex, S.P. type code (no default value). 
Complex, D.P. type code. 

jlndex into table containing the real part of the complex D.P. default value. 

(Index into table containing the imaginary part of the complex D.P. 
Idefault value. 
Complex, D.P. type code (no default value). 



1. MPL table is located in named common block /XGPI2/. 

2. The default value table is located in named common block /XGPI2X/. 



2.4-23 (12-1-69; 



DATA BLOCK AMD TABLE DESCRIPTIONS 

2.4.2.3 XPTDIC (Problem Tape Dictionary) 
Description 

XPTDIC is the Problem Tape Dictionary of data blocks checkpointed plus other information 
needed to restart a problem. 

Created in Modules 

XGPI, CHKPNT and XCEI. 

Table Format 



Record 



Word 
1 
2 
1 

2 
1 
2 
3 

4 
5 
6 



K 
K+1 

K+2 



EQ 



ET 



ID 





3 1 


PR 




17 


1 6 


NAF 


1 


s 



XVPS 



BCD BLANKS 



BCD BLANKS 



DIN 

31 17 



0RN 

16 1 



DBN 



ER 



3ll 30 




First entry in a 
grouo is a special 
entry 



Reoeat this entry 
for all data blocks 
referenced explicitly I This 
or implicitly in \ groun 
CHKPNT instruction ) of 

entries 

is 

repeated 

for each 

CHKPNT 

module 

executed 



2,4-24 






1,2 


ID 


1 


1 


PR 

NAF 



EXECUTIVE TABLE DESCRIPTIOHS 

Record Word Item Description 

Header record containing name XPTDIC (BCD). 

Present reel number of Problem Tape. Reels are 
numbered sequentially beginning with Reel 1. 
Next available file number on present reel. 
Files are numbered sequentially beginning with 
file 1. 

2 S Sequence number of last restart dictionary card 

punched out. 

1,2 XVPS BCD name XVPS. The file correspondina to this 

entry contains named comnon blocks /XVPS/ and 
/XCEITB/. 

3 R,F Reel number and file number where the file 

correspondinq to this entry is located. For this 
entry the reel number must be one. 

BCD blanks indicate snecial entry. 

DMAP instruction number of DMAP instruction 
following CHKPNT module (i.e., re-entry Doint). 
0SCAR record number of CHKPNT module being 
executed. 

Data block name (BCD) of data block being 
checkpointed. 

Equivalence flag. EQ = 1 indicates data block is 
equivalenced to another data block. 
End of tape flag. ET = 1 indicates that data 
block is split across two reels of problem tape. 
End of logical record flag. ER = 1 indicates 
that the comDlete logical record was written out 
prior to changing reels when ET = 1 . 

R,F Reel number and file number where the file 
corresponding to this entry is located. For 
purged or not-generated data blocks, R = and 
F = 0. 

K, K+1 XVPS BCD name XVPS. The file corresoondinn to this 

entry contains named common blocks /XVPS/, 
/XCEITB/ and /SYSTEM/. 

K+2 EQ.ET, See word 9 for descriotions . 
ER,R,F 



Notes 



4,5 


(blanks) 


6 


DIN 




0RN 


7,8 


DBN 


9 


EQ 




ET 




ER 



1. All entries are integer unless otherwise noted. 

2. The XPTDIC table is always the last file on the Problem Tape. 

3. XGPI generates records 0, 1 and the first entry of record 2. CHKPNT modules add 
entries to record 3. XCEI drops entries from record 2 when a REPT DMAP instruction 
transfers control to the top of a DMAP loon. 

4. XCS/\ also creates a XPTDIC table when problem is being restarted. This soecial XPTDIC 
table is created from the restart dictionary and its format is essentially the same as 
described above except that there are no special entries. 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.4.2.4 PVT (Parameter Value Table) 
Description 

The Parameter Value Table contains the parameter names and values of all parameters input 
by means of the PARAM bulk data card. 



Created in Module 




IFP. 




Table Format 




Record 


Word 





1.2 


1 


1.2 
3 

4 



3+L 



Item 

Header record contains name PVT (BCD). 

Name of parameter (BCD) ] repeat 
Type code for parameter value f for all 
Value of parameter. Type codes > parameters 
and corresponding lengths, L, of V on PARAM 
values are given in table below. ) cards. 



Notes 



Type Code 

1 
2 
3 

4 
5 
6 


Meaning of Code 

Integer 

Real, single precision 

BCD 

Real, double precision 

Complex, single precision 

Complex, double precision 


Corresponding 
Lenath in Words 

1 
1 
2 
2 
2 
4 



1. IFP does not create PVT if no PARAM cards exist in the Bulk Data Deck. 

2. PVT is written on the Problem Tape as 2 or more records (a header record and 1 record for 
each PARAM card). 

3. The PVT table is located in named common block /XPVT/. 



2.4-26 



EXECUTIVE TABLE DESCRIPTIOMS 



2.4.2.5 XCSA (Executive Control Table) 
Description 

Executive control table derived from the Executive Control Deck. 
Created in Module 



XCSA. 




Table Format 




Record 


Word 





1 
2,3 
4.5 
6.7 


1 


1 
2 
3,4 
5 
6 



L 
L+1 



M 
M+1 



Item 

BCD word XCSA - header ID. 

BCD word Sl3L ) Dictionary of contents of records 
BCD word Dh'lAP /■to follow. Does not need to be in 
BCD word MED 'this order, nor is MED always present. 

Approach code ^ 

Start code / 

Alter parameters ^ Spi record 

Solution number \ 

Subset number ) 



RD table (packed DMAP program) 
or user generated DMAP 
program (18 words per card 
image) . 



DMAP record 

(BCD information) 



Number of DMAP instructions 

Number of words per ISl table entry. 

ISl table (Module Extcution Decision Table), 



Number of entries in JNM table. 

JNM table (File Name Table) 

Number of entries in INM table 

INM table (Card Name Table) 

End-of-file 



MED record 
included 
only i^ 
i anoroach 
calls for 
a Riqid 
Format 



Notes 



1. Data block XCSA is written on the Problem Tape. 

2. A more detailed description of tables ISl, JNM and INM is given in the Module 
Functional Description for module XCSA, section 4.2. 



2.4-27 



DAIA BLOCK AND TABLE DESCRIPTIONS 

2.4.2.5 XALTER (Executive Alter Table) 
Description 

XALTER is generated from the ALTER data in the Executive Control Deck. 
Created in Module 

XCSA. 



Table Format 



Record 



Word 

1.2 

1.2 

1 



Item 

BCD word XALTER - header record 

Numbers of DMAP instructions 
to be altered. (Integers). 

I Zero or more of these [ Repeat 1 or 

,- J • /nrr,\ v records. Reneat until ) more times 

Card image (BCD) }^^^^ ^ word record ( until E0F 

I encountered . i encountered. 



Notes 



End-of-file 



XALTER data block is written on the Problem Tape. 



2.4-28 



EXECUTIVE TABLE DESCRIPTIONS 

2.4.2.7 LNKSPC (Link Specification Table - Resident Base) 

Description 

This Link Specification Table (see also 2.4.1.9) contains an entry for each executable 
DMAP module available within the MASTRAH system. Each entry contains: a) the DIW module 
name, b) the module's subroutine entry point name and c) a key indicating the links in which 
the module resides for each of four machine types. 

Created in Module 

LNKSPC data is stored by the XBSBD Block Data subprogram in module XGPI (4.7). 

Table Format 



Word 


1 
2 


LLINK 




DMAP Module 






3 


Name 






4 


Entry Point 






5 


ilame 






6 


Key #1 






7 


Key #2 






8 


Key #3 






9 


Key #4 





Entry #1 (Sample) 



Word 

1 

2.3 

4,5 

6 

7 

8 

9 



Item 

LLINK 

DMAP Module Name 

Entry Point Name 

Key #1 

Key #2 

Key #3 

Key #4 



Description 

Length of table in words (excluding word 1) 
DMAP name-8 characters (4 characters/word) 
Entry name-8 characters (4 characters/word) 
L-'nk residence key for machine type #1 
Link residence key for machine type #2 
Link residence key for machine type #3 
Link residence key for machine type #4 



2.4-29 



DATA BLOCK AMD TABLE DESCRIPTIONS 



The machine type code number is the same as that defined in the MACH word of the SYSTEM 
(2.4.1.8) table. Each bit within the Key word specifies a link number that is to contain that 
module. Bits are numbered from right to left; the right most (least significant) bit 
specifies that the module is to reside in link 1, etc. For example, if a particular Key 
contained 26 (binary 011010), only links 2, 4 and 5 would contain the specified module. 



fvotes 



The LilKSPC table must contain an entry for each executable module that is in the 
MPL (2,4.2.2) table. 

The LMKSPC table is located in /XLKSPC/. 



2.4-30 



MISCELLANEOUS TABLE DESCRIPTIONS 

2.5 MISCELLANEOUS TABLE DESCRIPTIONS. 

The following 1s an alphabetical index of miscellaneous table descriptions. 



Section Number 


Table Name 


Where Stored 


Page Number 


2.5.2.2 


BITP0S 


/BITP0S/ 


2.5-7 


2.5.2.4 


CHAR94 


/CHAR94/ 


2.5-10 


2.5.2.7 


CHRDRW 


/CHRDRW/ 


2.5-13 


2.5.1.6 


DESCRP 


/DESCRP/ 


2.5-3 


2.5.2.1 


GPTAl 


/GPTAl/ 


2.5-6 


2.5.1.5 


MSGX 


/MSGX/ 


2.5-3 


2.5.1.8 


NAMES 


/NAMES/ 


2.5-4 


2.5.1.1 


0SCENT 


/0SCENT/ 


2.5-2 


2.5.1.2 


I3UTPUT 


/OUTPUT/ 


2.5-2 


2.5.2.3 


PLTDAT 


/PLTDAT/ 


2.5-8 


2.5.1.3 


ST I HE 


/STIHE/ 


2.5-2 


2.5.2.6 


SYMBLS 


/SYMBLS/ 


2.5-12 


2.5.1.7 


TW0 


/TW0/ 


2.5-4 


2.5.1.9 


TYPE 


/TYPE/ 


2.5-4 


2.5.1.4 


XMDMSK 


/XMDMSK/ 


2.5-3 


2.5.2.5 


XXPARM 


/XXPARM/ 


2.5-11 



2.5-1 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 

2.5.1 itiscellaneous Tables IJhich Are Permanently Core Resident,. 

2.5.1.1 laSCENT (0SCAR Entry) 

Description 

A 200 word storage array containing the 0SCAR entry (record) currently being processed. 

Created in ilodule 

The entry is read from the 0SCAR and stored in 0SCEriT by the XSEMi (section 3.3.7) sub- 
routine. Other executive routines that require details cf the current entry will search 0SCENT. 

Table Format 

The 0SCENT format is identical to the 0SCAR (section 2.4.2.1) entry it currently contains. 

2.5.1.2 (5UTPUT (Output headings) 

Description 

A storage array containing problem title, subtitle, label and various headings required by 
the PAGE (section 3.4.24) routine to properly annotate the NASTRAN output. 

Created in Module 

The title, subtitle and label are taken from Case Control Deck cards and stored in 0UTPUT 
by IFPl (section 4.3). Other heading lines may be stored by output modules prior to calling 
PAGE. 

Table Format 

0UTPUT contains sufficient space for seven 128 character lines. The first three lines con- 
tain the title, subtitle, and label. The subsequent three lines contain local headings, and the 
final line contains the plotter ID. Since 4 characters occupy each computer word, the 0UTPUT 
array requires 224 words of storage. 

2.5.1.3 STIME (Solution Time) 

Description 

A storage cell containg the user's estimated solution time. 

Created in Module 

The estimated solution time is taken from a Executive Control Deck card and stored into 
STIME by XCSA (section 4.2) 

Table Format 

STIME consists of a single cell containing the estimated time in integer seconds. 



2.5-2 



MISCELLANEOUS TABLE DESCRIPTIOtiS 

2.5.1.4 XMDMSK (Executive Hodule Decision Mask) 

Description 

Contains the 155 bit master module execution mask (see section 1.10) and a cell indicating 
checkpoint status. 

Created in Module 

The 155 bit master module execution mask is generated and used by XGPI (section 4.7). The 
checkpoint status set on (YES) by XCSA (section 4.2) by the presence of a CHKPNT = YES card in 
the Executive Control Deck. 

Table Format 

The 155 bit mask occupies the low order ?1 bits of the first five words of XMDMSK. The 
sixth v/ord is the checkpoint status (flag). 

2.5.1.5 MSGX (Message Queue) 

Description 

A queue table to hold four word NASTRAN information and error messages between the time 
they are generated by a module and printed by the message writer, MSGWRT (section 3.4.26). 

Created in Module 

Messages may be generated by any NASTRAN module through a call to MESAGE (section 3.4.25). 

Table Format 

Word 1 - Number of messages queued. 

Word 2 - Maximum number of messages queue can hold 

Word 3-6 - Four word message entry (typical) 

Word 6-erid - Aaditional four word message entries 

2.5.1.6 DESCRP (Matrix Description) 

Description 

A storage block used by subroutine INTPK (section 3.5.3) to buffer the matrix unpacking 
procedure. This buffering reduces the number of 1/0 accesses to the particular matrix data 
block. 

Created in Module 

DESCRP is filled and used exclusively by INTPK 

Table Format 

An array with the first word defining the length of the array. 



2.5-3 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.5.1.7 TW13 (Powers of Two) 

De scription 

A 32 word array with each word (starting with 1 in the 32nd word) containing the next power 
of two. 

Created in Module 

The 32 integer values are defined within the IJASTRAN system block data program (SEMDBD). 

Table Format 



Word 32 
Word 31 
Word 30 
Word 29 
etc. 



2.5.1.8 NAMES (Symbolic Names) 



Description 



A series of symbolic names identified with their NASTRAN numeric equivalents. Defines values 
for GIN0 file options, arithmetic types and matrix forms. 

Created in Module 

The values are defined within the NASTRAN system block data program (SEMDBD). 



Table Format 
















Word 


SYMBOL 


VALUE 


Word 


SYMBOL 


VALUE 


Word 


SYMB0L VALUE 


1 


RD 


= 2 


7 


EOFNRW 


= 3 


13 


RECT = 2 


2 


RDREW 


= 


8 


RSP 


= 1 


14 


DIAG = 3 


3 


WRT 


= 3 


9 


RDP 


= 2 


15 


UPPER = 4 


4 


WRTREW 


= 1 


10 


CSP 


= 3 


16 


LOWER = 5 


5 


REW 


= 1 


11 


CDP 


= 4 


17 


SYM = 6 


6 


N0REW 


= 2 


12 


SQUARE 


= 1 


18 
19 


RPW = 7 
IDENT = 8 



2.5.1.9 TYPE (Number Types) 

Description 

A series of properties are defined as a function of a number type. The type may be Real 
Single Precision (RSP-1), Real Double Precision (RDP-2), Complex Single Precision (CSP-3), or 
Complex Double Precision (CDP-4). The properties that may be returned include precision (single, 
double), number of words, and real or complex. 

Created in Module 

The properties are defined within the NASTRAN system block data program (SEMDBD). 



2.5-4 



MISCELLAiJEOUS TABLE DESCRIPTIONS 





Tcsble Format 














Word 
1 


Property (Val 
1 


lues) 




Type 






Precision (RSP) 








2 


2 




Precision RDP) 








3 


1 




Precision (CSP) 


Words (RSP) 






4 


2 




Precision (CDP) 


Words (RDP) 






5 


2 






Words (CSP) 






6 


4 






Words (CDP) 






7 


1 








Real/Complex (RSP 




8 


i 








RDP 




9 


2 








(CSP 




10 


2 








(CDP 


Example 















Assume the number of words required to contain a Complex Single Precision (CSP-3) is desired. 
The third item in the Words array is indexed and found to contain a 2 (words). 



2.5-5 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.5.2 Miscellaneous Tables Not Permanently Core Resident . 

2.5.2.1 GPTAl 

Purpose 

To describe connection and property characteristics of each element. GPTAl is used in 
modules GPl , GP2, GP3 and TAl , and is initialized by the block data program GPTABD. 



Description 

Word 
1 
2 
3 

4-5 

6 
7-8 

9 

10-11 
12 
13 

14 

15 
16 



Lffie 
I 

1 

I 
B 

I 
I 
I 
I 
I 
I 



Item 

Number of entries (i.e., elements) in table 

Pointer to first word of last entry in table 

Number of words per entry in table 

Name of element as it appears on connection card 
(e.g., CR0D) 

Internal element identification number 

ECT record ID and trailer bit for LfJCATE 

Number of words per entry on ECT 

EPT record ID and trailer bit for LOCATE 

Number of words per entry on EPT 

Number of grid points per element 



[repeated 
[for 
(each 
[element 



'+1 : Scalar element with grid point and component code 
: Not a scalar element 
-1 : Scalar element with scalar points only 

Number of words per entry on EST 

Position of first grid point in ECT entry 



2.5-6 



MISCELLANEOUS TABLE DESCRIPTIONS 

2.5.2.2 BITP0S. 
Purpose 

To provide pointers into USET and USETD words for interpreting the nested vector sets in NASTRAN. 
Description 

Word Item 

1 

2 

3 

4 

5 

6 

7 

8 

9 
10 

n 

12 
13 
14 
15 
16 

Note 

All words are integer. 



UM 


Bit 


number 


UO 


Bit 


number 


UR 


Bit 


number 


USG 


Bit 


number 


USB 


Bit 


number 


UL 


Bit 


number 


UA 


Bit 


number 


UF 


Bit 


number 


US 


Bit 


number 


UN 


Bit 


number 


UG 


Bit 


number 


UE 


Bit 


number 


UP 


Bit 


number 


UNE 


Bit 


number 


UFE 


Bit 


number 


UD 


Bit 


number 



2.5-7 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.5.2.3 PLTDAT 

Purpose 

To define plotter-dependent parameters. 

Description 

This table is defined in the PL0TBD block data subprogram. The table is divided into N+2 
20-word sections, where N = number of plotters acceptable by the NASTRAN plotting software. 
Sections 3 to N+2 are the only sections initialized, because each contains values which are depen- 
dent upon the plotter hardware. Section 1 contains values which may vary within the limits of the 
hardware, and Section 2 is simply a duplicate of one of the last N sections corresponding to the 
plotter of interest. 

Section 2 must be filled in by the module writer. The format of Sections 2 to N+2 is as 
follows: 

Description 

Maximum x and y coordinate values acceptable by 
the plotter. 

Number of plotter counts/inch on paper. 

Number of plotter counts per character in the x 
and y directions. 

Maximum length of a line segment. 

Maximum number of pens or line density available 
on the plotter. 

8-9 R 0RIGIN For incremental plotters, the current pen position 

relative to the lower left corner of the plot. 
Otherwise , the location of the lower left corner of 
the plotter relative to its true physical origin. 

/+!, +2, or +3 if the plotter is a microfilm, table 
lor drum plotter, respectively, with typing 
1 capability. 
10 I PLTYPE -1, -2, or -3 if the plotter is a microfilm, table 

/or drum plotter, respectively, with no typing 
'capability (i.e., all characters must be drawn). 

iPLTl if an even parity plot tape is to be generated 
for this plotter. 
PLT2 if an odd parity plot tape is to be generated 
for this plotter. 

12 I PBFSIZ Plot tape physical record size (number of characters] 

!0 if an end-of-file is to be written after every 
plot. 
1 if no end-of-file is to be written on the plot 
tape. 

14-20 Undefined 



Word 


Type 


Name 


1-2 


R 


XYMAX 


3 


R 


CNTSIN 


4-5 


R 


CNTCHR 


6 


R 


MAXLEN 


7 


I 


NPENS 



2.5-8 (12-1-69) 



MISCELLANEOUS TABLE DESCRIPTIONS 



Section 1 must also be filled in by the module writer. However, unlike Section 2, some of 
the parameters may vary from plot to plot, as long as they remain within the limitations imposed 
by the plotter hardware. The format of Section 1 is as follows. 



Word 


Type 


Name 


1 


I 


M0DEL 


2 


I 


PL0TER 


3-6 


R 


REG 



7-8 
9-10 

n 



AXYMAX 

XYEDGE 
CAMNUM 



Description 
Plotter model index 
Plotter index 

Plotter region (x^.^. y^.^. x^^^, y^^^) in which 

the current picture is being drawn. These values 
must be some fraction (between and 1) of words 
7 and 8 (AXYWX). 

Size of the paper used (x,y), less the borders, in 
plotter units. 

Size of the borders (x,y) in plotter units. 

Current selected camera. This word need not be 
filled in, because it is set and used as a communi- 
cation between the SELCAM and SKPFRM subroutines. 



12-20 



Undefined 



Usage 

Sections 1 and 2 are normally setup by the FNDPLT subroutine, except for the plotter region 
values (REG). These values must be setup by the module writer himself. It is essential that both 
these sections be correctly setup, because they are referenced by the entire NASTRAN plotter soft- 
ware package. 

If Sections 1 and 2 are correctly setup by the module writer, he need not subsequently worry 
about such things as compensating for paper margins or different physical plotter origins. He 
need only assume that the plotter origin is located at the lower left corner of the paper where 
the left and bottom borders intersect. The NASTRAN plotter software will automatically compensate 
for the borders and the physical origin. 



2.5-9 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.5.2.4 CHAR94 

Purpose 

To provide a table of characters used to generate plot tapes as if the computer were always 
an IBM 7094, This table however is independent of the actual computer used. 

Description 

This is a 240 word table defined in the PL0TBD block data subprogram. It is divided into four 
equal sections of 60 words each. Each entry in each section has a parallel entry in the other 
three sections. 

Section I is a string of all the Hollerith characters acceptable by the plot modules of the 
form IHx, where x is a Hollerith character. 

Section II contains the integer equivalents of the IBM 7094 internal binary characters in the 
same order as Section I. However, near the end of this section are integers representing various 
additional characters not in Section I. These additional characters cannot be expressed in the 
form IHx and are used for special plotter commands. Each entry in this table is a right-adjusted 
two-digit integer with leading zeroes. 

Section III contains the integer equivalents of the IBM 7094 BCD characters as they would 
appear on an even parity tape written on an IBM 7094, in the same order and form as in Section II. 

Section IV contains the integer equivalents of the CDC display character codes so as to pro- 
duce an even parity BCD plot tape as if written on an IBM 7094, in the same order and form as in 
Section II. 

The sequence of characters in each section is as follows: 






1 


2 


3 


4 


5 


6 


7 


8 


9 


A 


B 


C 


D 


E 


F 


G 


H 


I 


J 


K 


L 


M 


N 





P 


Q 


R 


S 


T 


U 


V 


U 


X 


Y 


Z 


( 


) 


+ 


- 


* 


/ 


= 


, 


> 


$ 


1 


b 







character 49 = end of record mark 
character 50 = end of file mark 
characters 51-53 = special characters, 
characters 54-60 = 

Note 

In Section I, characters 49-60 = 0. 

Usage 

Section I is basically used for calculating an index into the other two sections by comparing 
an arbitrary Hollerith character with each character in Section I until a match is found. Once 
this is done, the index is used to extract the corresponding entry from either Section II or III, 
depending on whether an odd or even parity plot tape is being generated. If the computer is an 
IBM 7094, only Section II is used, and if the computer is a CDC 6600 and an even parity plot tape 
is being generated. Section IV is used instead of Section III. 

2.5-10 (12-1-69) 



MISCELLANEOUS TABLE DESCRIPTIONS 



2.5.2.5 XXPARM 

Purpose 

To define the plot tape buffer size, the camera to be used, the number of blank frames of 
film to be inserted between plots, the plotter model name, and the paper size to be used on table 
plotters. 

Description 

This table is defined as follows in the PL0TBD block data subprogram. 



Word 
1 
2 



4-5 
8-9 



h21 
I 
I 

I 

I, or B 
R 



Name Description 

BUFSIZ Plot tape buffer size 

CAMERA Plotter camera to be used (appropriate only on a 
microfilm plotter). 

BFRAMS Number of blank frames of film to be inserted 
between plots (appropriate only on a microfilm 
plotter) . 

PLTMDL Plotter model identification. 

PAPSIZ Width and height of the paper to be used (appropri- 
ate only on table plotters). 



Usage 

The initial values of these variables are as follows: 

BUFSIZ = must be set by the module writer 

CAMERA = 2 (paper output only) 

BFRAMS = 1 

PLTMDL = 4020, (integer) 

PAPSIZ = 8.5, 11.0 

This table's actual size is 152 words. The remainder of the table is initialized for the structur- 
al plotter module, PL0T, but may be used by the programmer for anything he desires in other plot- 
tincj modules. 



2.5-11 (12-1-69) 



DATA BLOCK AND TABLE DESCRIPTIONS 



2.5.2.6 SYMBLS 

Purpose 

To provide a table of indices into the CHAR94 and CHRDRW tables used to type or draw pre- 
defined plotter symbols. 

Description 

The table is defined in the PL0TBD block data subprogram. There is room for up to 20 indices 
for each plotter. However, the same number of indices must be defined for each plotter. The 
format of the table is as follows: 

Description 
Number of symbols defined for each plotter (currently = 9). 
Symbol indices for plotter 1. 
Symbol indices for plotter 2. 
Symbol indices for plotter 3. 



There are as many groups of symbol indices as there are available plotters. The symbols 
defined for each plotter are as follows: 

Symbol 1 = x 

Symbol 2 = * 

Symbol 3 = + 

Symbol 4 = - 

Symbol 5 = • (dot, not a period). 

Symbol 6 = circle 

Symbol 7 = square 

Symbol 8 = diamond 

Symbol 9 = triangle 

Should any of these symbols not be available on a plotter, a substitution of another symbol must 
be made. 

Usage 

This table is used by the SYMBOL subroutine. 



Word 


Type 





I 


1-20 


I 


21-40 


I 


41-60 


I 



2.5-12 (12-1-69) 



MISCELLANEOUS TABLE DESCRIPTIONS 



2.5.2.7 CHRDRW 

Purpose 

To define the combination of lines needed to draw alphanumeric characters and symbols. 

Description 

This table is defined in the PLJITBD block data subprogram. The table is divided into two 
sections. Section I is a list of indices into Section II, used to locate the data needed to draw 
characters. The first 48 indices in Section I correspond to the 48 characters listed in Section I 
of the CHAR94 table. The last 7 indices are used for drawing the special characters listed in the 
SYMBLS table. If an index is negative, it is an index into Section I instead of Section II. This 
occurs when a duplicate character exists (e.g., a zero, the letter "0", and the symbol for a 
circle). 

Section II of this table defines the (integer) coordinates of the starting and ending points 
of the straight lines to be drawn in order to draw a character or symbol. In general, the neces- 
sary straight lines are contiguous, so that the end point of one line is the starting point of the 
next, etc. In some cases, this is either impractical or impossible (e.g., *, +, =, etc.). In 
such a situation, the starting point of aline is negative, meaning that it is not to be connected 
to the end point of the preceding line. 



The characters defined in Section II are based upon 6x6 square characters, 
section are simply integer coordinates within a 6x6 square. 

The format of this table is as follows: 



The values in this 



Word 


Type 


Name 





I 


LSTCHR 


1-60 


I 


CHRIND 


61-760 


I 


CHR 



Description 

Name of characters and symbols referenced in 
Section I (=52). 

Section I - "LSTCHR" indices Into Section II. 

Section II = (x,y) pairs defining the lineal 
representation of 6x6 square characters. 



Usage 



This table is used by the DRWCHR subroutine. 



2.5-13 (12-1-69) 



INTRODUCTION 
3.1 INTRODUCTION 

Section 3 contains descriptions of subroutines not an integral part of a module. Those sub- 
routines which are an integral part of a module are discussed in section 4, Module Functional 
Descriptions. Section 3.2 contains an alphabetical index of entry points of routines documented 
in section 3. A similar index of entry points documented in section 4 can be found in section 
4.1.3. 

Subroutine descriptions have been partitioned into 3 classifications: executive, utility and 
matrix subroutine descriptions, documented in sections 3.3. 3.4, and 3.5 respectively. 

Descriptions of the plotting utility routines (e.g., AXIS, section 3.4.40; AXISi, section 
3.4.41) refer to plotters by number or the letter "i", and to plotter models by number only. The 
correspondence of these numbers to plotter hardware is given in Table 1. Further details can be 
found in section 4 of the User's Manual. 



3.1-1 (12-1-69) 



SUBROUTINE DESCRIPTIONS 



Table 1, Correspondence Between External and Internal Plotter and Model Names and Numbers. 



External 
plotter name 

BL 

EAI 
SC 



CALCSIMP 



DD 



NASTRAN 



External 
model name 



|STE.30 
UtE.30 

(3500,30 
{3500,45 

4020,0 

'765,205 
765,210 
765,105 
765,110 
763,205 
763,210 
763,105 
763,110 
565,205 
565,210 
565,105 
565,110 
565,305 
565,310 
563,205 
563,210 
563,105 
563,110 
563,305 

\563,310 

80, B 

M,0 
T,0 
D,0 
M,l 
T,l 
D.l 



Internal 
plotter number 



Internal 
model number 



5 
4 
5 
4 
7 
6 
7 
6 
5 
4 
5 
4 
5 
4 
7 
6 
7 
6 
7 
6 



10 
11 
11 
10 
11 
11 



1 

1 

4 
4 
5 
5 
4 
4 
5 
5 
2 
2 
3 
3 
1 
1 
2 
2 
3 
3 
1 
1 



+ 1 
+2 
+3 

-1 



where: 



BL 

EAI 

SC 



Benson Lehner 

Electronic Associates Inc. 

Stromberg Carlson 



3.1-2 (12-1-69) 



INTRODUCTION 
Table 1. Correspondence Between External and Internal Plotter and Model Names and Numbers (Cont'd) 



CALCUMP = California Computing 

DD = Data Display 

NASTRAN = NASTRAN General Purpose Plotter 



3.1-3 (12-1-69) 



ALPHABETICAL INDEX OF ENTRY POINTS FOR SUBROUTINE DESCRIPTIONS 



3.2 ALPHABETICAL INDEX OF ENTRY POINTS FOR SUBROUTINE DESCRIPTIONS. 



Section Number 


Entry Point 


Subroutine Description 


3.5.10 


ADD 




ADD 


3.4.1 


ANDF 




MAPFNS 


3.4.40 


AXIS 




AXIS 


3.4.41 


AXIS3 




AXISi 


3.4.41 


AXISIO 




AXISi 


3.4.7 


BCKREC 




BCKREC 


3.3.5 


BGNSYS 




ENDSYS 


3.5.1 


BLDPK 




BLDPK 


3.5.1 


BLDPKI 




BLDPK 


3.5.1 


BLDPKN 




BLDPK 


3.3.2 


BTSTRP 




BTSTRP 


3.5.5 


CALCV 




CALCV 


3.5.16 


CDC0MP 




CDC0MP 


3,4.4 


CL0SE 




CL0SE 


3.4.18 


CLSTAB 




CLSTAB 


3.4.1 


C0MPLF 




MAPFNS 


3.5.16 


C0M12 




CDC0MP 


3.3.12 


C0NMSG 




C0NMSG 


3.4.1 


C0RSZ 




MAPFNS 


3.4.1 


C0RWDS 




MAPFNS 


3.5.16 


CTRNSP 




CDC0MP 


3.5.15 


DEC0MP 




DEC0MP 


3.5.15 


DDL00P 




DEC0MP 


3.5.15 


DL00P 




DEC0MP 


3.5.21 


DMPY 




DMPY 


3.4.68 


DRWCHR 




DRWCHR 


3.4.62 


EJECT 




EJECT 


3.5.22 


ELIM 




ELIM 


3.3.5 


ENDSYS 




ENDSYS 


3.4.9 


E0F 




E0F 






3.2-1 (12- 


■1-69) 



Page Number 
3.5-19 
3.4-1 
3.4-70 
3.4-72 

3.4-72 
3.4-9 

3.3-6 

3.5-1 

3.5-1 

3.5-1 

3.3-2 

3.5-12 

3.5-62 

3.4-5 

3.4-26 

3.4-1 

3.5-63 

3.3-16 

3.4-1 

3.4-1 

3.5-63 

3.5-44 

3.5-60 

3.5-60 

3.5-71 

3.4-115 

3.4-105 

3.5-73 

3.3-6 

3.4-11 



SUBROUTINE DESCRIPTIONS 



Section Number 


Entry Point 


Subroutine Description 


3.5.23 


FACT0R 


FACT0R 


3.5.17 


FBS 


FBS 


3.5.15 


FINDC 


DEC0MP 


3.5.15 


FINWRT 


DEC0MP 


3.4.17 


FNAME 


FNAME 


3.4.69 


FNDPLT 


FNDPLT 


3.4.15 


FREAD 


FREAD 


3.4.6 


FWDREC 


FWDREC 


3.5.15 


GENVEC 


DEC0MP 


3.5.19 


GFBS 


GFBS 


3.4.12 


GINi3 


6IN0 


3.4.61 


GIN0I0 


GIN0I0 


3.4.32 


GMMATD 


GMMATD 


3.4.33 


GMMATS 


GMMATS 


3.3.4 


GNFIAT 


GNFIAT 


3.3.9 


GNFIST 


GNFIST 


3.4.14 


G0PEN 


G0PEN 


3.4.44 


IDPL0T 


IDPL0T 


3.4.45 


INTGPT 


INTGPX 


3.4.45 


INTGPX 


INTGPX 


3.4.46 


INTLST 


INTLST 


3.5.3 


INTPK 


INTPK 


3.5.3 


INTPKI 


INTPK 


3.4.34 


INVERD 


INVERD 


3.4.35 


INVERS 


INVERS 


3.4.47 


LINE 


LINE 


3.4.48 


LINEl 


LINEi 


3,4.48 


LINE2 


LlNEi 


3.4.48 


LINE3 


LINEi 


3.4.48 


LINE4 


LINEi 


3.4.48 


LINE9 


LINEi 


3.4.48 


LINEIO 


LINEi 
3.2-2 (12-1-69) 



Page Nun;ber 
3.5-74 
3.5-64 
3.5-57 
3.5-54 
3.4-25 
3.4-117 
3.4-23 
3.4-8 
3.5-54 
3.5-67 
3.4-15 
3.4-103 
3.4-49 
3.4-52 
3.3-5 
3.3-12 
3.4-22 
3.4-75 
3.4-76 
3.4-76 
3.4-77 
3.5-7 
3.5-7 
3.4-53 
3.4-54 
3.4-78 
3.4-79 
3.4-79 

3.4-79 
3.4-79 
3.4-79 

3.4-79 



ALPHABETICAL INDEX OF' ENTRY POINTS FOR SUBROUTINE DESCRIPTIONS 



Section Number 


Entry Point 
Li3CATE 


Subroutine Description 


Page Num; 


3.4.30 


PREL0C 




3.4-44 


3.5.14 


L00P 


SDC0MP 




3.5-42 


3.4.1 


LSHIFT 


MAPFNS 




3.4-1 


3.4.36 


MAT 


PREMAT 




3.4-55 


3.4.28 


MATDUM 


MATDUM 




3.4-42 


3.5.6 


MERGE 


PARTN - 


MERGE 


3.5-13 


3.4.25 


MESAGE 


MESAGE 




3.4-39 


3.5.9 


MPART 


UPART 




3.5-18 


3.5.12 


MPYAD 


MPYAD 




3.5-22 


3.4.26 


MSGWRT 


MSGWRT 




3.4-40 


3.5.15 


0NETW0 


DEC0MP 




3.5-54 


3.4.2 


0PEN 


0PEN 




3.4-3 


3.4.13 


0PNC0R 


0PNC0R 




3.4-20 


3.4.1 


0RF 


MAPFNS 




3.4-1 


3.5.2 


PACK 


PACK 




3.5-5 


3.4.24 


PAGE 


PAGE 




3.4-38 


3.4.24 


PAGEl 


PAGE 




3.4-38 


3.4.24 


PAGE2 


PAGE 




3.4-38 


3.5.6 


PARTN 


PARTN - 


MERGE 


3.5-13 


3.4.22 


PEXIT 


PEXIT 




3.4-36 


3.4.63 


PLAMAT 


PLAMAT 




3.4-106 


3.4.67 


PLTSET 


PLTSET 




3.4-113 


3.4.30 


PREL0C 


PREL0C 




3.4-44 


3.4.36 


PREMAT 


PREMAT 




3.4-55 


3.4.39 


PRETAB 


PRETAB 




3.4-67 


3.4.37 


PRETRD 


PRETRD 




3.4-64 


3.4.38 


PRETRS 


PRETRS 




3.4-66 


3.4.49 


PRINT 


PRINT 




3.4-81 


3.4.20 


RCARD 


RCARD 




3.4-32 


3.5.15 


RC0RE 


DEC0MP 




3.5-58 


3.4,13 


RDC0R 


0PNC0R 




3.4-20 


3.4.50 


RDM0DE 


RDM0DX 
3.2-3 (12-1-69) 




3.4-83 



SUBROUTINE DESCRIPTIONS 



Section Number 


Entry Point 


Subroutine Description 


Page Number 


3.4.50 


RDM0DX 


RDM0DX 


3.4-83 


3.4.50 


RDM0DY 


RDM0DX 


3.4-83 


3.4.16 


RDTRL 


WRT1 RL 


3.4-24 


3.4.50 


RDW0RD 


RDM0DX 


3.4-83 


3.4.5 


READ 


READ 


3.4-6 


3.4.8 


REWIND 


REWIND 


3.4-10 


3.4.1 


RSHIFT 


MAPFNS 


3.4-1 


3.5.6 


RULER 


PARTN - MERGE 


3.5-14 


3.4.51 


SCL0SE 


SGIN0 


3.4-85 


3.5.14 


SDC0MP 


SDC0MP 


3.5-30 


3.5.8 


SDRIB 


SDRIB 


3.5-17 


3.3.6 


SEARCH 


SEARCH 


3.3-8 


3.4.43 


SELCAM 


SELCAM 


3.4-74 


3.3.3 


SEMINT 


SEMINT 


3.3-3 


3.4.51 


SE0F 


SGIN0 


3.4-85 


3,4.42 


SKPFRM 


SKPFRM 


3.4-73 


3.4.10 


SKPFIL 


SKPFIL 


3.4-12 


3.5.20 


S0LVER 


S0LVER 


3.5-69 


3.4.51 


S0PEN 


SGIN0 


3.4-85 


3.4.31 


S0RT 


S0RT 


3.4-46 


3.5.7 


SSG2A 


SS62A 


3.5-16 


3.5.13 


SSG2B 


SSG2B 


3.5-29 


3.5.11 


SSG2C 


SSG2C 


3.5-20 


3.5.18 


SSG3A 


SSG3A 


3.5-66 


3.3.11 


SSWTCH 


SSWTCH 


3.3-15 


3.4.52 


STPL0T 


STPL0T 


3.4-87 


3.4.51 


SWRITE 


S6IN0 


3.4-85 


3.4.53 


SYMB0L 


SYMB0L 


3.4-88 


3.5.15 


T 


DEC0MP 


3.5-58 


3.4.39 


TAB 


PRETAB 


3.4-67 


3.4.29 


TABPRT 


TABPRT 


3.4-43 


3.4.21 


TAPBIT 


TAPBIT 
3.2-4 (12-1-69) 


3.4-35 



ALPHABETICAL INDEX OF ENTRY POINTS FOR SUBROUTINE DESCRIPTIONS 



Section Number 


Entry Point 


3.5,15 


TFIN 


3.4.54 


TIPE 


3.4.23 


TMTC(G0 


3.5.24 


TRANPl 


3.4.37 


TRANSD 


3.5.15 


TRANSP 


3.4.38 


TRANSS 


3.5.25 


TRNSP 


3.3.13 


TTLPPG 


3.4.55 


TYPEl 


3.4.55 


TYPE2 


3.4.55 


TYPE3 


3.4.55 


TYPE9 


3.4.55 


TYPEIO 


3.4.56 


TYPFLT 


3.4.57 


TYPINT 


3.5.4 


UNPACK 


3.5.9 


UPART 


3.4.27 


USRMSG 


3.4,58 


WPLTl 


3.4.59 


WPLT2 


3.4.60 


WPLT3 


3.4,64 


WPLT4 


3.4.65 


WPLT9 


3.4.66 


WPLTIO 


3.4.3 


WRITE 


3.4.13 


WRTC0R 


3.4.16 


WRTTRL 


3.3.10 


XE0T 


3.4.11 


xg:n0 



Subroutine Description 


Page Number 
3.5-58 


DEC0MP 


TIPE 


3.4-90 


TMT0Gja 


3.4-37 


TRANPl 


3.5-75 


PRETRD 


3.4-64 


DEC0MP 


3.5-53 


PRETRS 


3.4-66 


TRNSP 


3.5-76 


TTLPPG 


3.3-17 


TYPEi 


3.4-92 


TYPEl 


3.4-92 


TYPEi 


3.4-92 


TYPEi 


3.4-92 


TYPEi 


3.4-92 


TYPFLT 


3.4-94 


TYPINT 


3.4-96 


UNPACK 


3.5-10 


UPART 


3.5-18 


USRMSG 


3.4-41 


WPLTl 


3.4-98 


WPLT2 


3.4-100 


WPLT3 


3.4-102 


WPLT4 


3.4-108 


WPLT9 


3.4-110 


WPLTIO 


3.4-111 


WRITE 


3.4-4 


0PNC0R 


3.4-20 


WRTTRL 


3.4-24 


XE0T 


3.3-14 


XGIN0 


3.4-13 



3.2-5 (12-1-69) 



SUBROUTINE DESCRIPTIONS 



Section Number 


Entry Point 


3.5.15 


xLiaiap 


3.4.1 


X(3RF 


3.4.19 


XRCARD 


3.3.8 


XSEHXX 


3.3.1 


XSEMl 


3.3.7 


XSEM2 


3.3.7 


XSEM3 


3.3.7 


XSEM4 


3.3.7 


XSEM5 


3.3.7 


XSEM5 


3.3.7 


XSEM7 


3.3.7 


XSEM9 


3.3.7 


XSEMIO 


3.3.7 


XSEMl 1 


3.3.7 


XSEMl 2 


3.3.7 


XSEMl 3 


3.3.7 


XSEMl 4 


3.5.1 


ZBLPKI 


5.5.3 


ZNTPKI 



Subroutine Description 


Page Number 


DEC0MP 


3.5-60 


MAPFNS 


3.4-1 


XRCARD 


3.4-27 


XSEMXX 


3.3-11 


XSEMl 


3.3-1 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


XSEMi 


3.3-9 


BLDPK 


3.5-1 


INTPK 


3.5-7 



3.2-6 (12-1-69) 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

3.3 EXECUTIVE SUBROUTINE DESCRIPTIONS. 

3.3.1 XSEMI (Executive Sequence Monitor, Preface ) . 

3.3.1.1 Entry Point: XSEMI . 

3.3.1.2 Purpose 

To initiate the execution of the NASTRAU Preface. 

3.3.1.3 Calling Sequence 
CALL XSEM1 

3.3.1.4 Method 

Subroutine BTSTRP is called to initialize machine dependent data, and then subroutine SEMKJT 
is called to execute the program Preface (i.e. input ^^ile processors and DMAP orooram compiler). 
After initiating the problem, modules are called as directed by the 0SCAR until a module is 
encountered in the (?SCAR that does not reside in link 1 at which time XSEMI calls subroutine 
ENDSYS to load a new link. 

3.3.1.5 Design Requirements 

XSEMI must reside in the core resident portion of link 1. Link 1 is not re-entrant which 
means that once the program leaves link 1 it can never transfer control back to link 1. Functional 
DflAP modules can not reside in link 1. Open core is used for a GIN0 buffer with named conmon block 
/ESFA/ defining the beginning of open core. See the second paragraph of the design requirements 
section of the subroutine description XSEMi (see section 3.3.7) for details on files, data blocks, 
and common blocks necessary for operation. 



3.3-1 



SUBROUTINE DESCRIPTIONS 

3.3.2 BTSTRP (Bootstrap Generator) . 

3.3.2.1 Entry Point: BTSTRP. 

3.3.2.2 Purpose 

Determines the machine type and initializes the machine dependent constants and masks 
within the NASTRAN system block data program (SEMDBD). 

3.3.2.3 Calling Sequence 
CALL BTSTRP 

3.3.2.4 Method 

The machine type (IBM 7094, IBM S/360, Univac 1108, CDC 6600) is determined by inspection of 
the machine binary word length and the known methods of representing negative integers (sign 
and magnitude or ones/twos complement) using the following algorithm: 

1. If the ones complement (C0MPLF see section 3.4.1) of -1 is greater than 2, the machine 
is the IBM 7094. If not, the machine is an IBM S/360, Univac 1108 or CDC 6600. (i.e., only 
the sign and magnitude representation of -1 on the 7094 will yield a large (> 2) positive 
value when complemented.) 

2. Shift (RSHIFT see section 3.4.1) a binary machine word of all I's to the right thirty- 
two binary places. Compare the resulting value to 15. If the value is less than fifteen, 
the machine is the 32 bit IBM S/360; equal to fifteen, the 36 bit Univac 1108; and greater 
than fifteen, the 60 bit CDC 6600. 

Once the machine type is known, the proper constants and masks are selected from assembled tables. 

3.3.2.5 Design Requirements 

This subroutine must be irodified if it is to operate with other than the four machine types 
listed above. 



3.3-2 



EXECUTIVE SUBROUTINE DESCRIPTIOriS 

3.3.3 SEMINT (Sequence Monitor Initialization ). 

3.3.3.1 Entry Point: SEMINT. 

3.3.3.2 Purpose 

To execute the Preface of a NASTRAM problem solution. 

3.3.3.3 Calling Sequence 
CALL SEMINT 

3.3.3.4 Method 

The first card of the NASTRAN data deck is read from the svstem innut file and its imane 
stored in blank C0MM0N. XRCARD is called to convert the card. If the name of the card is 
NASTRAN, the card is echoed and keywords are identified and appropriate words of /SYSTEM/ are 
reset to the input values. If an unidentified keyword is detected, or the card has a format error, 
a message is printed and the N0G0 flag is turned on. The first word of blank C0MM0N is set to one 
if the card was a NASTRAN card, to zero otherwise. Then GNFIAT is called to generate the initial 
FIAT. XCSA is called to read and process the Executive Control Deck. IFPl is called to read and 
process the Case Control Deck. XS0RT is called to read and sort the Bulk Data Deck. If bulk 
data is present, IFP is called to process it. If the problem is a conical shell problem, IFP3 is 
called to further process the bulk data. If the current run is to prepare a User's Master File, 
UMFEDT is called and control is returned to XS0RT for each new problem to be written on the UMF. 
Otherwise, XGPI is called to perform General Problem Initialization and then return is made to 
XSEMl signifying completion of the Preface. 

3.3.3.5 Design Requirements 

If the NASTRAN card is present, it must be the first card of the data deck. 
3.3.3.5 Diagnostic Messages 

U^^IDENTIFIED NASTRAN KEY;J0RD . ACCEPTABLE KEYWORDS F0LL0'J-- 

BUFFSIZE 

C(3NFI6 

MAXFILES 

MAX0PEN 

SYSTEM 



3.3-3 



SUBROUTINE DESCRIPTIONS 

Self-explanatory. 

riASTRAN CARD D0ES N0T HAVE CORRECT F0RMAT. 

Typical errors include non-intoger values or continuation of the card followinq an = sign. 

See section 6.3.1 for further details on the UASTRAN card. 



3.3-4 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

3.3.4 GNFIAT (Generate FIAT) . 

3.3.4.1 Entry Point: GNFIAT. 

3.3.4.2 Purpose 

Determines the number of logical files available within the computer hardware and software 
configuration and places an entry for each into FIAT or XFIAT. 

3.3.4.3 Calling Sequence 
CALL GNFIAT 

GNFIAT must be called once and only once as the first call from the preface. 

3.3.4.4 Method 

Each computer configuration has its own independent subroutine to accomplish the necessary 
functions of GNFIAT. The subroutine interrogates unit blocks, data definition cards, file tables, 
etc. to determine the number of logical files available within the configuration. As each 
logical file is sensed, it is determined whether the file has been assigned to a ohysical magnetic 
tape or some bulk storage device such as disk or drum. Each file has a logical name and/or 
number for identification. These file ID's are stored in FIAT, XFIAT or both depending on 
several factors. As the file ID is stored, a physical tape flag is set where appropriate. The 
factors that determine FIAT vs. XFIAT storage are as follows: 1) the first PFIST (see section 
2.4 for a description of the FIST) files sensed are always entered into XFIAT, 2) except for the 
first file (always the P00L) , all of the first PFIST files without tape flags are also entered 
into FIAT, and 3) all other files are entered into FIAT only. 

3.3.4.5 Design Requirements 

Since GNFIAT routines are computer hardware/software dependent, operational requirements 
may differ at various times. See appropriate commented assembly listing if difficulties or 
error codes are encountered. 



3.3-5 



SUBROUTINE DESCRIPTIONS 

3.3.5 ENDSYS (End-of-Link) . 

3.3.5.1 Entry Points: ENDSYS, BGNSYS. 

3.3.5.2 Purpose 

For ENDSYS, to save various NASTRAN core- resident Executive Tables on a scratch file for use 
in comnunicating with the next link requested. 

For BGNSYS, to restore the NASTRAN Executive Tables saved by ENDSYS and to position the 
0SCAR at the correct entry to be executed in the resident link. 

3.3.5.3 Calling Sequences 
CALL ENDSYS(LINK,X.REWFLG) 

LINK - BCD name of the link. The naming convention is: NSOl = link 1, NS02 = link 2, 

etc. 
X - Dependent on machine type. For the IBM 7094 only, X (6 BCD characters) specifies 

the unit where the links are stored. Not used on other machines. 

REWFLG = indicates LINK is ahead of current link (i.e. we are going from link N to 
link N + K, K » 0) . IBM 7094 only; not used on other machines. 

REWFLG = 1 indicates LINK is behind current link (i.e. we are going from link N to 
link N + K, K < 0). IBM 7094 only; not used on other machines. 

CALL BGNSYS. 
3.3.5.4 Method 

For ENDSYS, a search is made for an empty file and when found the Executive Tables are 
written (saved) on it. A pointer to the save file is saved in blank common or written on a 
system file for use by BGNSYS when the new link is loaded. Subroutine SEARCH is then called to 
load the requested link. 

BGNSYS is called after a new link is loaded. The pointer to the save file containing the 
Executive Tables is obtained from either blank common or a system file, and the Executive Tables 
are reloaded into core. The 0SCAR is positioned at the correct entry to be executed, and a 
RETURN is made to the calling routine. 



3.3-6 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

3.3.5.5 Design Requirements 

Program links are usually considered to be physically seoarate nrograms, essentially 
independent of one another except for the fact that the operating system executive (not the NASTRAN 
executive) provides a means by which control can be transferred from one link to another when 
requested by the user. The means by which the operating system executive transfers control from 
one link to another is dependent upon the machine and the system being used. For some future 
machiries there may be no means for building physically separate links so the links become 
logical subsets of one huge program. 

No matter how the links are formed it is necessary, when transferring from one link to 
another, that all file assignments be preserved as well as their status (i.e. don't rewind the tapes), 

Open core is used for GIN0 buffer area and the beginning of open core is defined by named 
common block /ESFA/. 

If no save file is available or if any of the Executive Tables to be written exceeds 900 
words, the job is terminated. 



3.3-7 



SUBROUTINE DESCRIPTIONS 

3.3.0 SEA RCH (Search. Load, and Execute Link) . 

3.3.6.1 Entry Point: SEARCH. 

3.3.6.2 Purpose 

SEARCH locates (searches for) a particular link of the NASTRAN system on ths Link Storaao 
File, loads the link into the computer memory and transfers execution control to the link entry 
point XSEMi, i = 2,3 

3.3.5.3 Calling Sequence 

CALL SEARCH(LKNAM,LKFIL,REW) 

LKNAM = 4 character symbolic name of link, i.e., NSOl , NS02 for link 1, link 2, etc. 

LKFIL = symbolic name of the Link Storage File (IBM 7094 only) 

REW = set non-zero to position a sequential Link Storage File to its beginning 
(IBM 7094 only) 

3.3.6.4 Method 

SEARCH is machine dependent. It interfaces with the machine operatinn system to provide a 
multi-link capability. Each link is a somewhat arbitrary part o-^ the complete NASTRAN svstem. 
The division into links was necessary only because of the size limitation ^or program complexes 
imposed by the various operating systems. The linking technique for each machine is discussed 
in section 5 of the Programmer's Manual. 

3.3.G.5 Design Requirements 

Only the IBM 7094 system requires the Link Storage File to be named (LKFIL) and, since it is 
sequential, provides the capability of rewinding it following a SEARCH call. All other systems 
provide random access (disk, drum) Link Storage Files. 

3.3.6.5 Diagnostic Messages 

Individual SEARCH subroutines may abnormally terminate due to hardware malfunction. See 
appropriate commented assembly listing if difficulties or error codes are encountered. 



3.3-8 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

3,3.7 XSEMi (Link i Main Program, i = 2,3, ... 

3.3.7.1 Entry Point: XSEMi. 

3.3.7.2 Purpose 

To get the next module to be executed from the 0SCAR. initialize the module and call it 
if it is in link i, or transfer to the link in which module resides if it is not in link i. 

3.3.7.3 Calling Sequence 

Example: CALL XSEM2, where XSEM2 is the entry point of link 2 

3.3.7.4 Method 

Subroutine BTSTRP is called to initialize machine dependent data, and then subroutine BGNSYS 
is called to reload Executive Tables saved from the previous link. 

The next 0SCAR entry is read into core and processed. If the entry is for a functional 
module, subroutine GNFIST is called to link files with input, outnut and scratch data blocks 
needed by the module. Variable parameter values needed by the module are transferred to blank 
common from table VPS which resides in named common block /XVPS/. Constant values in the ^^SCA? 
entry parameter section are transferred to blank common. 

The link specification table in named common block /XLINK/ is examined to see i-*" the module 
resides in this link. If it does, the module is called. Upon returninn from the module, the 
diagnostic message queue is checked and message writer MSGWRT is called if there are messages 
queued. Begin and end execution times are printed out for functional modules. 

The next 0SCAR entry is read and the process is repeated until a module is encountered which 
'does not reside in this link, at which time subroutine ENDSYS is called to initiate loading of the 
link containing the module. 

3.3.7.5 Design Requirements 

XSEMi must reside in the core resident portion of link i. Link i is re-entrant which means 

program control can be transferred to this link as often as needed. Onen core is used for a 

GIN0 buffer with named common block /ESFA/ defining the beninninq o^ ooen core, ^n i/ISCA" entry 

cannot be greater than 200 words. 



3.3-9 



SUBROUTINE DESCRIPTIONS 

Files, data blocks and named common blocks needed by XSEMi are listed below, along with type 
of access required (i.e. fetch and/or store data) and reasons for use. 

1. Data Pool File - fetch. Contains X0SCAR data block. 

2. X0SCAR - fetch. Contains jJSCAR entry to be processed. 

3. Common /XLINK/ - fetch. Contains link soecification table. 

4. Common /XFIST/ - store. Initialized prior to callinn GNFIST. 

5. Common /XPFIST/ - fetch. Contains parameter needed to initialize FIST table, 
o. Common /0SCENT/ - fetch. Contains 0SCAR entry to be nrocessed. 

7. Common /ESFA/ - store. Defines beginning of open core area used by GIN0 buffer. 

8. Common /XVPS/ - fetch. Contains variable parameter values needed to initialize module 
to be executed. 

9. Common /MSGX/ - fetch. Contains diagnostic message queue. 

10. Common /SEM/ - fetch. Contains SCO names of links NSOl , NS02 

3.3.7.6 Diagnostic Messages 

A message is written if the module to be executed required more files than are available. 
The job is then terminated. 



3.3-10 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

3.3.8 XSEMXX (Sequence Monitor - Deck Generator) . 

3.3.8.1 Entry Point: XSEMXX. 

3.3.8.2 Purpose 

To provide a model from which all other XSEMi (i = link number) subroutines except XSEMl 
can be made. 

See section 6.11, which discusses how to generate a link driver subroutine. 



3.3-11 



SUBROUTINE DESCRIPTIONS 

3.3.9 GNFIST (Generate FIST ) 

3.3.9.1 Entry Point: GNFIST. 

3.3.9.2 Purpose 

To set up the proper linkage between data blocks and the files they reside on in preparation 
for executing the functional module requiring the data blocks. 

3.3.y.3 Calling Sequence 

CALL GNFIST(DBN,FISTNM,M0DN0) 

DBN - Data block name (Two word BCD array - 8 characters total) 

FISTNM - Data block identification (GIN0 file number) used by functional module 
(integer) . 

M0DN0 - 0SCAR record number of functional module to be executed (integer). M13DN0 
indicates to the calling routine what action was taken by GNFIST. 

M0DN0 ' 0, data block assigned a file or it was purged. 

M0DN0 = 0, fatal error detected. 

M0DN0 • 0, data block not assigned a file, GNFIST called Executive Segment 
File Allocator (XSFA) 

3.3.9.4 Method 

If the data block is purged, GNFIST returns to the calling routine with M0DN0 - 0. A 
data block is purged if it is an input which has not been generated or its status is purged or 
DBN =0. 

If an input data block resides on the Data Pool File and needs to be unpooled, GNFIST calls 
the file allocator (XSFA) to unpool all inputs to the module which reside on the Data Pool File 
that need to be unpooled. GHFIST then returns to the calling routine with H0DN0 < 0. The other 
condition under which XSFA is called is if a file has jiot^ been allocated to a non-purged output 
data block or scratch data block needed by the module. 

A file is allocated to a data block when the data block name apnears in the FIAT table, 
located in named common block /XFIAT/, as unpurged. Inout, outnut and scratch data blocks which 
have been assigned to a file and are required by the functional module, have their FISTNM's entered 



3.3-12 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

in the FIST table which is located in named common block /XFIST/. FIST entries are linked to 
the DBN's in the FIAT table which in turn links the data block to a file. This completes the 
linking of functional module data blocks to their files. 

Output data blocks cannot reside on the Data Pool File, so 6NFIST checks for this and if 
found, the OBN and all DBN's equivalenced to it are deleted from the DPL table located in named 
common /XDPL/. 

3.3.9.5 Design Requirements 

GNFIST resides in the core resident portion of a link. It does not use onen core and the 
only restriction is that the FIST table be large enough to hold all FISTNM's for a module. 

The named common blocks needed by GNFIST are listed below, along with type of access 
required (i.e. fetch and/or store data) and reasons for use. 

1. C(3MM0N/XFIST/ - Store. 

Used to store FISTNM's and link FISTNM's with their corresponding DBN's in FIAT. 

2. CfilMM0N/XFIAT/ - Fetch and store. 

Used to determine status of DBN's. The FIAT table is altered if unpooling of input 
data blocks is necessary. 

3. C0MM0N/XDPL/ - Fetch and store. 

Used to determine status of input DBN's and is altered if outnut DBN's appear in it. 

4. C0MM0N/0SCENT/ - Fetch. 

Contains 0SCAR entry for functional module to be executed. Used to alter FIAT when 
input DBN's need to be unpooled. 

3.3.9.6 Diagnostic Messages 

GNFIST detects overflow in FIST table and sends message to terminate job. 



3.3-13 



SUBROUTINE DESCRIPTIONS 

3.3.10 XEgT (End-of-Tape ). 

3.3.10.1 Entry Point: XE0T. 

3.3.10.2 Purpose 

To prepare and send to the computer operator, messages instructing him what to do when 
end-of-tape has been encountered on the Old Problem Tape (0PTP) or the New Problem Tape (NPTP). 

3.3.10.3 Calling Sequence 

CALL XE0T(ID,0REEL,NREEL,8UF) 

ID - BCD name NPTP or 0PTP 

0REEL - Number of reel to be dismounted - integer. 
NREEL - Number of new reel to be mounted - integer. 
BUF - GIN0 buffer used by NPTP or 0PTP. 

3.3.10.4 Method 

A check is made to see if tape has multi-reel capability. If not, a fatal message is issued 
and job is terminated. The operator messages are generated and issued and the old reel is re- 
wound and unloaded. A check is made to see if correct new reel has been mounted and then a 
return is made to calling program. 

3.3.10.5 Design Requirements 

XE(3T must be accessible to routines XGPI and XCHK. 

3.3.10.6 Diagnostic Messages 

A message is issued if tape does not have multi-reel capability. 



3.3-14 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

3.3.11 SSWTCH (Sense Switches ). 

3.3.11.1 Entry Point: SSWTCH. 

3.3.11.2 Purpose 

To indicate to the calling routine whether or not a specified sense switch is set. 

3.3.11.3 Calling Sequence 
CALL SSWTCH(SS,F) 

SS - Sense switch number - integer. 1<SS < 31. 

F - Flag indicating status of SS 

F = if SS not on 
F = 1 if SS is on 

3.3.11.4 Method 

Named common block /SYSTEM/ contains the word which contains the sense switch settings. 
Bit 1 of the word corresponds to sense switch 1, bit 2 corresponds to sense switch 2, etc. If 
the bit corresponding to SS is on then F = 1, if not then F = 0. 

Note that sense switches are set by the user via the DIAG card in the Executive Control Deck 
and not through physical sense switches set by the computer operator. 

3.3.11.5 Design Requirements 

SSWTCH resides in the core resident oortion of a link. 



3.3-15 



SUBROUTINE DESCRIPTIONS 

3.3.12 C0NMSG (Console Message Writer) . 

3.3.12.1 Entry Point: C0NMSG 

3.3.12.2 Purpose 

Writes the current time and a NASTRAN system message onto the system output device and 
(if the computer configuration permits) onto the on-line operator's console device. 

3.3.12.3 Calling Sequence 

CALL C0NMSG(MSG,CNT,YN) 

MSG - Array name containing message. 

CNT - Number of 4-character words in message (integer). 

YN - 1 = yes, = no. Print on-line device if yes and available. 

3.3.12.4 Method 

A computer real-time and/or job clock is interrogated. The number of message words 
indicated is sent to the system output device (usually printer) along with the clock reading(s). 
If the computer configuration permits and the yes/no switch is set yes, the same clock reading(s) 
and message is sent to the operator's console device (usually typewriter). 

3.3.12.5 Design Requirements 

Only the left-most four characters from each computer word are extracted and sent to the 
output device(s). 



3.3-16 



EXECUTIVE SUBROUTINE DESCRIPTIONS 

3.3.13 TTLPPG (Title Page Writer) . 

3.3.13.1 Entry Point: TTLPPG. 

3.3.13.2 Purpose 

To print on the system output file 2 title pages identifying the iob as a NASTRAN nrohlem, 
identifying the current NASTRAM source and object libraries and identifying the current Rinid 
Format series . 

3.3.13.3 Calling Sequence 
CALL TTLPPG. 

3.3.13.4 Method 

TTLPPG is called as the first executable statement in the Preface driver SEMINT. 

3.3.13.5 Design Requirements 

Whenever a new version of NASTRAN is installed, a level number of the form N.M must be 
updated in TTLPPG, where N is the source library level number and M is the obiect library version 
number. Whenever N is incremented by 1 , M is reset to zero. Minor changes in the system are 
accomplished by updating the necessary routines, thereby generating new object (relocatable) decks 
for these routines. H is incremented by 1 but the source library and hence N remain unchanged. 
The Rigid Format series is identified by a letter. A Rigid Format series can change only when N 
is changed. 



3.3-17 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4 UTILITY SUBROUTINE DESCRIPTIONS. 
3.4.1 MAPFNS (Machine Word Functions) . 

3.4.1.1 Entry Points: LSHIFT, RSHIFT, ANDF. !2IRF, X0RF, C(3MPLF, C0RSZ, C0RWDS. 

3.4.1.2 Purpose 

To perform basic computer word manipulations by standard binary digit (bit) operations. 
The manipulations are performed over the complete memory word length for the particular hardware. 
Also, to determine the size of open core (C(i)RSZ) and the absolute difference between locations in 
core (C(ilR,JDS). 

3.4.1.3 Calling Sequence 

All machine word functions are executed as FORTRAN integer function subroutines with 
integer arguments. 

3.4.1.4 Method 

The method employed within each function will be described following the separate function 
examples. 

3.4.1.5 Entries 

l< = LSHIFT (I.N) 

The entire bit structure of word I is shifted left N places and the resulting word replaces 
word K. Word I is unchanged. High-order bits shifted out are lost. Zeros are supplied to 
vacated low-order positions. The shift is logical; no special provision is made for the sign 
position. 

K = RSHIFT (I,N) 

The entire bit structure of word I is shifted right N places and the resulting word renlaces 
word K. Word I is unchanged. Low-order bits shifted out are lost. Zeros are supplied to 
vacated high-order positions. The shift is logical; no snecial orovision is made for the sign 
position. 

K = ANDF (I, J) 

A logical product of the bits within word I and word J is formed and stored into word K. 
Words I and J are unchanged. 



3.4-1 



SUBROUTINE DESCRIPTIONS 

K = 0RF (I.J) 

A logical sum of the bits within word I and word J is formed and stored into word K. 
Words I and J are unchanged. 

K = X0RF (I, J) 

The modulo-two sum (exclusive or) of the bits within word I and word J is formed and 
stored into word K. Words I and J are unchanged. 

K = C0MPLF (I) 

The ones complement of the bits within word I is formed and stored into word K. Word I 
is unchanged. 

K = C(JRSZ (I, J) 

The size of open core is computed and stored in location K through this function. Location 
I is normally the address of a labeled common cell defining the beginning of a particular open 
core area. Location J is normally the address of blank common (usually thought to be the end of 
a particular open core area). On computer memory configurations where blank cotmion does not 
define the end of open core, CfJRSZ ignores location J and substitutes a correct end value. The 
arguments I and J may be interchanged without affecting results. 

K = C8IRWDS (I.J) 

The absolute difference plus 1 between the addresses of locations I and J is comouted and 
stored into word K. Words I and J are unchanged. 

3.4.1,6 Design Requirements 

f-IAPFNS is written in assembly language. 



3.4-2 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.2 gPEN (Initiate Activity on a File ). 

3.4.2.1 Entry Point: 0PEN. 

3.4.2.2 Purpose 

To initiate activity on the requested file. 

3.4.2.3 Calling Sequence 

CALL J)PEN($n, NAME, BUFF, 0P) 

n - FORTRAN statement number defining the return to be taken in the event NAME is not 
in the FIST (i.e. the data block is purged). 

NAME - GIN0 file name of the data block which is to be read or written(see section 1.6.4.1), 

BUFF - An array whose dimension equals the contents of the first word of /SYSTFM/ which 
will be used by GIN|3 while the file is ooen. 

!0, open file to read with rewind 
1, open file to write with rewind 
2, open file to read without rewind 
3, open file to write without rewind 

3.4.2.4 Method 

(3PEN stores parameters in /GIN0X/ and then calls XGIN0 which searches the FIST for a name 
match and picks up from the FIAT the unit to which the data block is assigned. The position of 
the buffer is determined relative to /XNSTRN/. 

This index is saved in the BUFADD array in /GINjJX/. BUFADD is searched to determine if any 
other buffer overlaps the buffer currently assigned. GIN0 is called to initiate activity for the 
file. 

3.4.2.5 Design Requirements 

The address of the buffer assigned must be greater than the address of /XNSTRN/. 

3.4.2.6 Diagnostic Messages 

The following system fatal errors may be issued by 0PEN: 
3006 
3012 
3040 



3.4-3 



SUBROUTINE DESCRIPTIONS 

3.4.3 WRITE (Write Data in a Logical Record) . 

3.4.3.1 Entry Point: WRITE. 

3.4.3.2 Purpose 

To write a logical record, or portion of a logical record, on the requested file. 

3.4.3.3 Calling Sequence 

CALL WRITE(NAME,BL0CK,N,E0R) 

NAME - GIN0 file name of the data block which is to be written (see section 1.6.4.1). 
BL0CK- An array of dimension a N containing the data words to be written. 
N - The number of words to be written - integer - input. 

iO, the N words to be written by this call do not end the logical record, i.e. 
subsequent WRITE calls will provide additional data to be written in the 
current logical record. 
1, the N words to be written by this call end the logical record. 

3.4.3.4 Method 

WRITE stores parameters in /GIN0X/ and then calls XGIN0 which in turn calls GIN0 to oerform 
the actual processing of the call. 



3.4-4 



UTILITY SUBROUTINE DESCRIPTIONS 

3-4-4 CL0SE (Terminate Activity on a FileK 

3.4.4.1 Entry Point: CL0SE. 

3.4.4.2 Purpose 

To terminate activity on the requested file. 

3.4.4.3 Calling Sequence 
CALL CL0SE{NAME,0P) 

NAME - GIN0 file name of the data block to be closed (see section 1.6.4.1). 

1, if file was opened to write, write end-of-file and rewind. 
If file was opened to read, rewind only. 

2, close file at current file position (no end-of-file, no rewind). 
0P ( 

3, if file was opened to write, write end-of-file and position file in front of 

end-of-file mark. 

If file was opened to read, same as 0P = 2. 

If the requested file is not in the FIST or is not currently open, a normal return is given 
and no operation takes place. 

If the file was opened for output and the last logical record has not been written, it is 
written prior to honoring the 0P request. 

The buffer assigned when the file was opened is released and is available to the user on 
return. 

3.4.4.4 Method 

CL0SE stores parameters in /GIN0X/ and then calls XGIN0. If XGIN0 returns indicating the 
file is not in the FIST or not open, an immediate return is given to the user. Otherwise XGIN0 
calls GIN0 to process the call. 



3.4-5 



SUBROUTINE DESCRIPTIONS 

3.4.5 READ (Read Data From a Logical Record). 

3.4.5.1 Entry Point: READ. 

3.4.5.2 Purpose 

To read the contents of a logical record, or portion of a looical record, from the requested 
file. 

3.4.5.3 Calling Sequence 

CALL READ($ni,$n2,NAt^E,BL0CK.N,E0R.M) 

ni - F0RTRAN statement number defining the return to be taken in the event an end-of- 

file is encountered by this READ operation, 
nz - FORTRAN statement number defining the return to be taken at the end of the READ 
operation whenever the end-of-logical -record is encountered prior to transmitting 
the requested number of data words. 
NAME - GIN(3 file name of the data block which is to be read (see section 1.6.4,1). 
BLi3CK - An array of dimension s N, where the words read will be stored. 

(N > 0: The number of words to be read and stored at BL5"CK - integer - input. 
N - <N s 0: The number of words to be skipoed, i.e., read but not stored at BL(»CK. 
(integer - input. 

(0, subsequent calls to READ for the current logical record are exoected. 
E0R - <1, the current call is the last call for the current logical record. The file 
(will be positioned to the beginning of the next logical record before returning. 

M - If return to nz is given, the number of words actually read is stored in M. 
In no other case are the contents of M changed. 
Whenever return to nz is given, the file is positioned to the beginning of the next logical 
record regardless of the setting of E0R. 

A return to n, is possible only when a call to READ is given when the file is positioned at 
the beginning of a logical record. 



3.4-6 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.5.4 Method 

READ stores parameters in /GIN13X/ and then calls XGIN0 which in turn calls GIN0 to perform 
the actual processing of the call. 



3.4-7 



SUBROUTINE DESCRIPTIONS 

3.4.6 FUDREC (Forward Space One Logical Record ). 
3.4.5.1 Entry Point: FWDREC. 
3.4.G.2 Purpose 

To position the requested file forward one logical record. 

3.4.6.3 Calling Sequence 
CALL FWDREC ($n, NAME) 

n - FORTRAN statement number defining the return to be taken in the event an end-of-file 

is encountered. 
NAI-1E - GIN(3 file name of data block to be positioned forward(see section 1.6.4.1). 

This call will always position the file to the beginning of the next logical record unless 
an end-of-file is encountered. 

3.4.6.4 Method 

FWDREC stores parameters in /GIN0X/ and then calls XGIN0 which in turn calls GIN0 to process 
the call . 



3.4-8 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.7 BCKREC (Backspace One Logical Record) . 

3.4.7.1 Entry Point: 3CKREC. 

3.4.7.2 Purpose 

To position the requested file backward one logical record. 

3.4.7.3 Calling Sequence 
CALL BCKREC (NAME) 

NAME - GIN0 file name of data block to be positioned backward (see section 1.6.4.1). 

If the file is positioned in the middle of a logical record, the file is repositioned to 
the beginning of that record. Otherwise, the file is positioned to the beginning of the previous 
logical record. 

If the file is positioned at the beginning of file, no operation occurs and a normal return 
is given. 

3.4.7.4 Method 

BCKREC stores parameters in /GIN0X/ and then calls XGIN0 which in turn calls GIN0 to 
process the call . 



3.4-9 



SUBROUTINE DESCRIPTIONS 

3.4,8 REviIND (Position File to the Load Point ). 

3.4.8.1 Entry Point: REWIND 

3.4.8.2 Purpose 

To rewind the requested file. 

3.4.8.3 Calling Sequence 

CALL REWIND(NAME) 

NAi'lE - GINia file name of the data block to be rewound (see section 1.6.4.1). 
Rewind given for an output file has the effect of erasing any data which has been written 
on the file. 

3.4.8.4 Method 

REWIND stores parameters in /GIN0X/ and then calls XGIN0 which in turn calls GINiJ to 
process the call . 



3.4-10 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.9 E0F (Write an £nd-of-Fi1e ) . 

3.4.9.1 Entry Point: E0F. 

3.4.9.2 Purpose 

To write an end-of-file on the requested file. 

3.4.9.3 Calling Sequence 
CALL E0F(NAME) 

NAME - GIN0 file name of data block on which end-of-file is to be written(see section 1.6.4.1.) 
The file must be open to write at the time of this caTl . 

3.4.9.4 Method 

E0F stores parameters in /GIN0X/ and then calls XGIN0 which in turn calls GIN0 to process 
the call. 



3.4-n 



SUBROUTINE DESCRIPTIONS 

3.4.10 SKPFIL (Skip Files Forward or Backward ). 

3.4.10.1 Entry Point: SKPFIL. 

3.4.10.2 Purpose 

To position the requested file forward or backward a stated number of files. 

3.4.10.3 Calling Sequence 
CALL SKPFIL(NAME,N) 

NAME - GIN0 file name of the data block to be reoositioned (see section 1.6.4.1). 
N - The number of files to be skipped. N ^ means forward skin, M ^ means 
backward skip, N = means no ooeration - inteaer - inout. 

Notes: 

1. Following a forward skip, the file is positioned at the beqinning of the first 
logical record (i.e. immediately after the end-of-file mark). 

2. Following a backward skip, the file is positioned immediately in front of the 
end-of-file mark (or at the beginning-of-unit) . 

3. Request to skip backward from the beginning-of-unit is ignored and the file 
remains positioned at the beginning-of-unit. 

4. SKPFIL backward on a file opened to write has the effect of "erasing" file(s) 
written. 

3.4.10.4 Method 

SKPFIL stores parameters in /GI^X/ and calls XGIN0 which in turn calls PIN0 to nrocess the 
call. 



3.4-12 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.11 XGINia (GINg Utility Routine ). 

3.4.11.1 Entry Point: XGIN0. 

3.4.11.2 Purpose 

To convert the GIiN0 file name to a unit number, retrieve the buffer assigned to the file 
and call GIN0. 

3.4.11.3 Calling Sequence 
CALL XGIN0($ni,$n2.A.M) 

C0MM0N/GIN0X/LGIN!2IX,FILEX,E0R,0P, ENTRY, LSTNAM.N, NAME, NTAPE,XYZ(2),UNITAB(75),BUFADD(75) 

1, call from subroutine 0PEN 

2, call from subroutine 'v'RITE 

3, call from subroutine READ 
14, call from subroutine CL0SE 

EliTRY =<5, call from subroutine BCKREC ) integer - innut 

6, call from subroutine FUDREC 

7, call from subroutine SKPFIL 

8, call from subroutine E0F 
1 9, call from subroutine REWIND 

NAME - GIN0 file name of data block for which activity is requested - integer - input. 

FILEX - Unit number to which NAME is assigned - integer - output. 

LSTNAM - On entry to XGIN0, GIN0 name from previous call. On exit from XGIN0, 
LSTNAM = NAME - integer - input and outout. 

(O, file does not reside on tane ] 
NTAPE = < ■ > integer - outnut. 

(.1, file resides on tape j 

'if ENTRY = 1 or 4, F0RTRAN statement number defininn return in the event 
(name is not in FIST. 

|if ENTRY = 3 or 5, F0RTRAN statement number defining return in the event an 
^end-of-file is encountered. 

ri2 - If ENTRY = 3, F0RTRAN statement number defining end-of-logical -record prior to 

completion of requested read. 

3.4-13 



SUBROUTINE DESCRIPTIONS 

A - If ENTRY = 2 or 3, A is the user block (from/to) which data words are written/read. 
M - If ENTRY = 3 and return to n^ is given, M = number of words read - integer - output. 

3.4.11.4 Method 

The FIST is searched for a name match. If found, the pointer to FIAT is used to nick un the 

unit number and tape flag. If not found, a non-standard return is given (ENTRY = 1 or 4) or a 

fatal message is generated. The address of the buffer assigned to the file is picked uo and GIW 
is called to execute the requested operation. 

3.4.11.5 Design Requirements 

XGIU0 is designed as an integral part of the GIN0 collection of routines for use only by 
0PEN, READ, ^RITE, etc. 

The BUFADD table must be initialized to zero prior to the first call in a NASTRAN execution. 

3.4.11.6 Diagnostic Messages 

The following system fatal errors may be issued by XGIN0: 
3010 
3021 



3.4-14 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.12 GINg) (General Input/Output Routine ). 

3.4.12.1 Entry Point: GIN0. 

3.4.12.2 Purpose 

To provide general purpose Input/Output services to higher level routines (READ, WRITE, etc.) 
in the NASTRAN program. 

3.4.12.3 Calling Sequence 
CALL GIN(3($n^,$n2,BUFF,A,M) 

C!3MM0N/GIN!3X/LGIN0X,FILEX,E!3R.0P, ENTRY, LSTNAM,N, NAME, NTAPE,XYZ(2),UNITAB(75),BUFADD(75) 

1 , 0PEN Operation 

2, WRITE Operation 

3, READ Operation 

4, CL(?SE Operation 
ENTRY = ( 5, BCKREC Operation / Input, integer 

's, FWDREC Operation 

7, SKPFIL Operation 

8, E0F Operation 

9, REWIND Operation 

FILEX - Unit number of file - integer - input. 

E0R - End-of-record flag (see READ, WRITE) - integer - input. 
0P - Operation code (see 0PEN, CL0SE) - integer - input. 

N - Number of words to write/read or number of files to skip (see WRITE, READ, 
SKPFIL) - integer - input. 

BUFF - Address of buffer assigned to FILEX. 

ni - F0RTRAN statement number defining return in the event an end-of-file is encoun- 
tered (READ and FWDREC operations only). 

n2 - F0RTRAN statement number defining return in the event an end-of-record is encoun- 
tered prior to transmitting the requested number of words (READ operations only). 

A - User block (see WRITE, READ). 

M - Number of words actually read if end-of-record encountered and return to n2 is 

given (see READ) - integer - outout. 

3,4-15 



SUBROUTINE DESCRIPTIONS 

3.4.12.4 Method 

GIN0 blocks all logical records into fixed length physical records (blocks) for writing 
and reading. A description of the GIN0 buffer follows: 



Buffer Control Word (BCW) = 'READ' or 'WRIT' 



Current Buffer Pointer (CBP) 



Current Logical Record Pointer (CLR) 



Current Block Number (NBL0CK) 



Number of data words in logical record or record segment 



Data Words 



o 

in 



Control Word 



Loaical 
record 



Logical record 

and 
control words 



Number of data words in logical record or record segment 



Data Words 



Control Word 



Pointer to last logical record (LLR) 



Control word = 4*K + 2*F2 + Fl where 

Fl = 1 indicates continued record 

F2 = indicates last segment of continued record 

if Fl =0, K = number of words in logical record 

if F2 = 1, K = 6553fi*(Block No.) + CLR of 1st segment of logical record 

Processing of each operation takes place as follows: 

1. 0PEN. If a rewind is requested, the file is rewound and the first three words of the 
buffer are initialized followed by a return. Otherwise, the current file position is retrieved 
from UNITAB. If the file is logically between blocks, action occurs as above. Otherwise, the 
next block is read and the pointer to the current logical record is restored. If the block read 
is not the expected block, a recovery attempt is made. 



3.4-16 



UTILITY SUBROUTINE DESCRIPTIONS 

2. WRITE. For the first call to write in a logical record, Nf5L0CK and CLR are saved in 
UNITA3. User data is transferred to the buffer. If the buffer is filled, a control word indicat- 
ing continuation is placed, the block is written and the logical record is continued in the next 
block. After data transfer to the buffer, E(3R is tested. If on, a control word is nlaced in 

the buffer and pointers are moved to the beginning of a new logical record. 

3. READ. If the buffer is empty, the next block on the file is read. If nositioned at the 
beginning of a logical record, a test for logical end-of-file is made. If on, return to ni is 
given. Otherwise data is transferred from the buffer to the user area. If the looical end-of- 
record is encountered before the requested number of words have been transmitted, M is set with 
the number of words read, and return to n2 is given. If the logical record is continued to the 
next block, the next block is read. After the transfer of data is complete, ElZIR is tested. If 
on, pointers are moved to the beginning of the next logical record. 

4. CL0SE. If the file was opened to read, !3P is tested. If (3P = 1 , the file is rewound. 
If 0P ?* 1, the file is backspaced one block unless the file is logically between blocks. In 
either case, the logical position of the file (NBL0CK and CLR) is saved in UMITAB, BCW is set to 
zero and return is made. If the file was opened to write and CRP f CLR, control words for the 
last logical record are stored in the buffer. If 0P = 1 or 3, a logical end-of-file is placed. 
The current block is written on the file. If 0P = 1, the file is rewound, othervnse the file is 
backspaced one block. The logical position of the file is saved in UiUTAB, BCW is set to zero 
and return is made. 

5. BCKREC. If the buffer in core is empty, the file is backspaced one block, the block is 
read and LLR is used to set the pointers to the last logical record in the block. If the file is 
logically positioned in the middle of a logical record, pointers are reset to the beginning of a 
logical record. If the file is positioned at the beginning of a logical record, pointers are 
reset to the beginning of the previous logical record. 

6. FWDREC. M is set to zero and E0R to 1 and the code in the READ portion of GIN0 is used 
to position the file at the beginning of the next logical record. 



3.4-17 



SUBROUTINE DESCRIPTIONS 

7. SKPFIL. If a forward skip is requested, logical records are skipped until a looical 
end-of-file is encountered. This is repeated until the number of requested files has been 
skipped. 

If a backward skip is requested, the code in the BCKREC portion of GIN0 is used to position 
backwards one logical record. A test for load point is made. If yes, return is made. Otherwise, 
a logical end-of-file test is made. If no, the BCKREC is repeated. If yes, a test for number 
of requested files is made. If yes, return is given. Otherwise, the process is repeated. 

8. Ei3F. If the file was not opened to write, an error message is generated. If CBP f CLR, 
control words are placed to "close" the last logical record. A logical end-of-file is placed in 
the buffer. Return is made. 

9. REWIND. The file is rewound, pointers are reset and return is given. 
3.4.12.5 Design Requirements 

T. GIN0 is designed as an integral part of the GIN0 collection of routines and is to be 
called only by XGIM0. 

2. Since GIW "remembers" the position of files when they are closed, any activity on a 
file outside of GIN(3 will likely be fatal. 

3. Because of the packing used in the control word, the following maximums apply: 

Max. number of blocks written on one file = 2-1 where k = number of bits ^r\ 
the computer word - 18. 
Max. buffer size = 55535 words. 
3.4.12.6 Diagnostic Messages 

The following system fatal messages may be issued by 6IN0: 
3009 
3029 
3048 
3049 



3.4-18 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.12.7 Information Message 

GIN0 RECOVERY ATTEMPT 0N DATA BL0CK . EXPECTED BL0CK Nj3. = . ACTUAL BL0CK 

N0. = . 

This message is issued prior to Message 3049. GIN0 attempts to reposition the file. 
If the attempt fails, Message 3049 is issued, otherwise the problem proceeds. 



3.4-19 



SUBROUTINE DESCRIPTIONS 

3.4.13 i3PNC0R (Transmit Logical Records To/From Core Storage ) . 

3.4.13.1 Entry Points: 0PNCJ3R, WRTC0R, RDC0R. 

3.4.13.2 Purpose 

To simulate the GIN0 WRITE and READ calls providing the capability to write logical records 
of data in core storage and read logical records from core storage. 

3.4.13.3 Calling Sequence 

CALL 5IPNC!ilR(BL0CK) 

BL0CK - An array whose dimension is sufficient to hold a logical record to be written 
or read. 

CALL JRTC!2R(BL0CK,A,N.E0R) 

BL0CK - The array where the logical record is to be written. 

A - An array containing the data vMords to be written. 

M - The number of data words to be written from A. 

C= 0, additional data will be written in the logical rpcord via subseouent 
^gj^ _ \ calls to mJCm- 

(f 0, the current call is that last call for the current logical record. 
CALL RDCi2IR($ni ,$n2 .BL(3CK,A,N,E0R.M) 

nj - F0RTRAN statement number defining the return taken in the event an end-of-file 
is encountered. This return is not possible from RDC0R but is provided in the 
calling sequence for compatibility with READ. 

n2 - FORTRAN statement number defining the return taken in the event that the 

number of words requested to be read is not available in the record. In this 
case, M words are read and transmitted and the value M is returned to the user. 

BL0CK - The array where the logical record is stored. 

A - An array where the requested data words from the record will be stored. 

N - The number of data words to be read. 



3.4-20 



UTILITY SUBROUTIME DESCRIPTIONS 

(= 0, more data is to be read from the record via subsequent calls to RDC0R. 
E0R - { 

{^ 0, the current call is the last call for the current logical record. Any 
remaining words in the logical record are to be skipped. 

M - The number of words actually read in the event return to <r\2 is taken. 

The number of words available at BL0CK must be equal to (or greater than) the number of 
words in the logical record plus two . 

iilPNCiJR initializes a word pointer stored at BL0CK(1) to 1 and has no other function. The 
user may desire to perform this function himself with the statement BL0CK(1) = 1. This function 
must be accomplished prior to the first call to WRTC(3R or RDC0R for each logical record. 

3.4.13.4 Method 

0PNC!3R. BL5ICK(1) is set to one and return is made. 

WRTC0R. The current pointer stored at BL0CK(1) is picked un. N words are transmitted from 
A to BL0CK beginning at the current pointer plus one. If E0R = 0, the new Dointer is stored and 
return made. Otherwise, an end-of-record flag is stored in BL0CK following the last word 
written. The pointer (pointing to the flag) is stored and return made. 

RDC0R. The current pointer is picked up from BL0CK(1). Words are transmitted from BL0CK 
beginning at the current pointer plus one to A until (1) the end-of-record flag is encountered 
in which case the actual number of words transmitted is stored in M and RETURN 2 is given, or (2) 
N words have been transmitted. If E0R = 0, the new pointer is stored and return is made. If 
E0R / 0, BL0CK is searched until the flag is found, the pointer (pointing immediately prior 
to the flag) is saved and return is made. 

3.4.13.5 Design Requirements 

The flag value must be unique. Its value = (-16777215) must not be one of the data words 
written. 



3.4-21 



SUBROUTINE DESCRIPTIONS 

3.4.14 G0 PEN (Short Form for Subroutine 0PEN With Header Record Processing) . 

3.4.14.1 Entry Point: G0PEN. 

3.4.14.2 Purpose 

To provide a short form (without the non-standard return of subroutine (JPEN) for opening a 
GIN0 file, and to write a two-word header record if the data block is opened as output with 
rewind or to skip the header record if the data block is opened as input with rewind. 

3.4.14.3 Calling Sequence 

CALL G0PEN(FILE. BUFFER. 0PT) 

where: 

FILE = GIN0 file name (see section 1.6.4,1). 

BUFFER = GIN0 buffer location. 

OPT = any of the open options permitted by subroutine 0PEN (see section 3.4.2). 

3.4.14.4 Method 

Open the file (subroutine 0PEN). If 0PT = input with rewind (0), skip the first record of 
the data block. If 0PT = output with rewind (1), write the two v/ord BCD name of the data block 
as returned by subroutine FNAME. 

3.4.14.5 Design Requirements 

The data block must exist (must not be purged). If 0PT = innut with rewind (0), the first 
record of the data block must be at least two words long. Subroutines used: 0PEN, READ, WRITE, 
FNAME, MESAGE. 

3.4.14.6 Diagnostic Messages 

If the data block is purged or if an end-of-file or end-of-record condition is encountered 
when reading the data block, subroutine MESAGE will be called with internal messaoe numbers 1, 2, 
or 3, respectively (external message numbers are 3001, 3002 and 3003). 



3.4-22 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.15 FREAD (Short Form for Subroutine READ ). 

3.4.15.1 Entry Point: FREAD. 

3.4.15.2 Purpose 

To provide a short form (without the non-standard returns of subroutine READ) of reading a 
GIN0 file. 

3.4.15.3 Calling Sequence 

CALL FREAD(FILE.BL0CK,N,E0R) 

where: 

FILE = 6IN0 file name (see section 1.6.4.1). 

BL0CK= array into which N items are to be read. 

N = number of items to be read. 

E0R = any end of record option permitted by subroutine READ (see section 3.4.5). 

3.4.15.4 Method 

Read the N items from FILE into BL0CK. If subroutine READ returns an end-of-file or 
end-of-record condition, subroutine MESAGE is called with a fatal error condition. 

3.4.15.5 Design Requirements 

In addition to those imposed by READ, there must be N items remaining in the record to be 
read. Subroutines used: READ, MESAGE. 

3.4.15.6 Diagnostic Messages 

Subroutine MESAGE may be called with internal message number 2 or 3 (external messaqe 
numbers 3002,3003). 



3.4-23 



SUBROUTir^E DESCRIPTIONS 

3. 4. lb WRTTRL (Write Trailer) . 
3.4.1D.1 Entry Points: WRTTRL, RDTRL. 

3.4.16.2 Purpose 

WRTTRL will pack six v;ords of trailer information into three words and store them in the FIAT. 
RDTRL will retrieve and unpack the trailer information. 

3. 4. 15. 3 Calling Sequence 
CALL '.JRTTRL(FIL3LK) 

FILBLK(l) - GIN0 file name (see section 1.6.4.1). 
FILBLK(2-7) - Trailer information to be stored. 
CALL RDTRL(FILBLK) 

FILBLK(l) - GIN0 file name. 

FILBLK(2-7) - Storage space for trailer information. 

3.4.16.4 Method 

The index into the FIAT for the specified file is located in the FIST. The three packed 
words are stored in or retrieved from the FIAT. The information is also stored for all files 
equivalenced to the GIN0 file name. For RDTRL, if the file is purged, FILBLK(l) is set 
negative. 

3.4.16.5 Design Requirements 

Each word of trailer information is assumed to be a positive integer less than 2-1. 

3.4.16.6 Diagnostic Messages 

If the file did not exist in the FIST when WRTTRL was called, fatal error 3011 occurs. 



3.4-24 



UTILITY SUBROUTIi^E DESCRIPTIONS 

3.4.17 FiJAME (File Name) . 

3.4.17.1 Entry Point: FNAME. 

3.4.17.2 Purpose 

Given a GIN0 file ncime, FNAME returns the two BCD words which describe the data block. 

3.4.17.3 Calling Sequence 

CALL FNAHE(FILE,NAME) 

FILE - GIN0 file name (see section 1.6.4.1). 
NAME(2) - Storage for the two BCD words. 

3.4.17.4 Method 

The GIN0 file name is first located in the FIST. The index in the FIST is used to find 
the BCD descriptors in the FIAT. If the file does not exist in the FIST, "^(N0NE)^" is returned 
as the two words, ^ indicating a BCD blank. 



3.4-25 



SUBROUTINE DESCRIPTIONS 

3.4.18 CLSTAB (Close a GINg File and Write a Non-zero Trailer ). 

3.4.18.1 Entry Point: CLSTAB. 

3.4.18.2 Purpose 

To close a GIN0 file and generate a table trailer by callinn WRTTRL. 

3.4.18.3 Calling Sequence 

CALL CLSTAB{FILE,(3PT) 

where: 

FILE = GINI3 file number - Integer - input. 

0PT = any close option permitted by subroutine CL0SE (see section 3.4.4) - integer - Input, 

3.4.18.4 Method 

CALL CL0SE(FILE,0PT) 

Generate the table control block, ITABCB: 

ITABCB(l) = FILE 

ITABCB (7) = 1 

D0 10 I = 2,6 

10 ITABCB(I) = 

CALL V/RTTRL (ITABCB). 

3.4.18.5 Design Requirements 

Same as those for subroutines CL0SE and WRTTRL. Subroutines used: CL0SE, IJRTTRL. 



3,4-26 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.19 XRCARD (Executive Free-Field Card Data Conversion Routine ) 

3.4.19.1 Entry Point: XRCARD, 

3.4.19.2 Purpose 

To interpret NASTRAN free-field card input data as follows: 

1. Identify BCD alpha and numeric data fields as they are converted and placed in 
the user's buffer; 

2. Flag and output special data field delimiters; 

3. Convert BCD numeric fields to binary integer or binary floating point; 

4. Indicate when the data extends beyond one 72 column card. 

3.4.19.3 Calling Sequence 

CALL XRCARD(0UTBUF,L,INBUF) 

Where: 

0UTBUF = The buffer which is to contain the converted card image. 

L = The length of 0UTBUF available to XRCARD. 

INBUF - The buffer containing the card image to be converted. 

3.4.19.4 Method 

XRCARD's design is based on the necessity of having to function on a variety of computing 
machines having a variety of computer word structures, and a variety of differences in hollerith 
handling imposed by differing F0RTRAN compilers. 

XRCARD analyzes the twenty hollerith words input through INBUF as follows: 
Data Field Delimiters 
Type A: 

The following symbols signify the end of an alpha field or numeric field on the card. As 

these symbols are encountered, they will be flagged and placed in the output buffer to aid the 

user in identifying the data. 

( LEFT PAREN 

/ SLASH 

= EQUAL 

3.4-27 



SUBROUTIME DESCRIPTIONS 

Type B: 

The following symbol is identical to those listed above except that the symbol is not flagged 
or placed in the output buff?': 

, COMMA 

Jhen successive type A or type 3 delimiters are encountered, a null field indication (two BCD 
blank words) is output. A null field is generated for each successive delimiter. A null field 
is also generated when a type A or type B delimiter is followed by a $ indicatinn the end of data 
condition. 

Type C: 

The following symbols are identical to the COMMA excent that no null ^ield indication is 
output when they are encountered in succession. 

) RIGHT PAREN 
^ BLANK 

End of Data Indication 

There are two means by which end-of-data may be specified on the card: 

- The last data field ends in column 72, or is followed by blanks out through 
column 72; or a 

- $ is encountered, after which comments may be included out to column 80. 
Format of Output Data 

A mode word, M, is placed in the outout buffer to distinguish betv/een ^CD data and 
numeric data. 

iiumeric Mode Word : A new mode word is outout each time a numeric field is converted 
and output. (All numeric mode words are negative). 

N = -1 integer data (1 data word) 

= -2 floating point single precision (1 data v/ord) 
= -4 floating point double precision (2 data words) 

N indicates the type of numeric data and where to look for the next mode word. 



3.4-28 



UTILITY SUBROUTINE DESCRIPTIONS 

Aloha Mode Word : iJhen processing alpha data, only one mode word is outnut for successive 
alpha fields, i.e., an alpha mode word will never follow another aloha mode word. 

N = The number of successive alnha fields encountered on the card. Fach alnha ^ield 
consists of two 4-character computer words (le-^t adiusted). Thus N can be used 
to compute the location of the next mode word. 

The type A delimiters are output as aloha data and are 'covered' by the aloha mode word. 
Since data output in the alpha mode must consistsof two words a type A delimiter will appear as: 

;Jord 1 = Delimiter flag, all bits of the word are on. 

Word 2 = BCD delimiter, left adjusted, followed by BCD blanks. 

End-of-Data : The end-of-data flag is placed last in the output buffer and appears in place 
of an expected mode word. There are two end-of-data flags: 

- A word with all bits off, indicating that more data is to follow on a continuation card. 

- A word with all bits on except for the sign, indicating that no more data is to follow 
for this card type. 

Sample Input Card 

OhRDh H=l>E=1.0.AEi:'-CriErGH GOOD DATft 



00000000000 0000 000 ODOOOOOOOOOOOO 0000000000000000000000000000000000000000000 

1 ! 3 4 5 t 7 B 110111! IJMIS in; IB l!!Q!l!!!JZUSIS!)!l!930iUn]lllS!()ni39i«ili;431<4S<S<?<l«954SIS!S]HiSSSS;SISlS(15U!(3«lliSMIIUHJ0?II!;i;t7W577;i7>IO 

1 11 in 1 111 in 1) iiniimnn i iiinm in 1 1 in n ii 1 1 1 nn nnnninnn 

222222222222 222222 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 
■33333333 3 3 3 3 33 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 
Hi H44444444444444444 44444444 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 
5555555 5555 555S555555555 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 
6(i666GC 666666666060666666 6 66 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 fi fi 6 6 6 6 6 6 6 6 6 6 6 B B 6 6 6 6 6 6 6 

nmmnmmmmmi n innmimimmmnnmmmmmmmm 
?388:aao8 ease oooobbbbs BOSBBsaooBBBeBBsoBaaaaoBBBsasBBSssaoBBaaaoaoooooBooe 

39 99999999999999999999993999999999999999999999939999999999993999939999990939999 

I ! 3 4 S ■ 7 ■ J Kill! 13 14 IS 11 17 IB 1! 20 !1 !!2324IS7i!7a(i 3C 3132)3 14 3S3U;313!4B41<7 )i 44 454847 4B4) SI 5153 ;3545SSIS: SI S3t561S2t3ii(S6B17eBl! 70 71 7! 7174 75 757171 7!8j 



3.4-29 



SUBROUTINE DESCRIPTIONS 



Resulting Output Buffer for IBM 7094 or Univac 1108 



BCD Field 



BCD Field 



Output Del imiter 



Output Delimiter 



NOTE : For the IBM S/360 the 
output buffer shown here looks 
the same except that the right 
two blanks shown in the BCD 
fields here do not exist. For 
the CDC 6600 there are an 
additional four trailing blanks 
in each word of a BCD field than 
shown here. 



+ 


(alpha mode word) 


3 


c 


A R /~. 


/'\ 


A 


■^ -^ ^ /^ 


/\ 


A 


/^ /^ y^ /\ 


/^ 


/\ 


^^ /\ /\ /\ 


/\ 


all bits on 


-- 


yX -^ /X /\ 


/\ 


-( 


numeric mode word) 1 


integer 1 


+ 


(alpha mode word) 


2 


B 


/\ /^ /^ /^ 


/\ 


/^ 


/^ /^ /\ ^ 


/\ 


all bits on 


= 


/\ /^ /\ /\ 


/x 


-( 


numeric mode word) 2 


SI 


ngle-precision 1 





+ 


(alpha mode word) 


5 


A 


B C ^ ^ 


/^ 


/^ 


z^-. /\ y-K ^ 


y\ 


all bits on 


/ 


/\ y\ ^\ /\ 


/\ 


C 


D E F '^ 


^ 


G 


H /^ ^ /N 


/\ 


G 


D /x 


y\ 


/x 


/\ /^ /\ /^ 


y\ 


D 


A T A /^ 


y\ 


/\ 


/\ y\ /^ /'\ 


^\ 


all 


bits on sign bit 


Off 









Number of successive alpha fields 
(including Type A delimiters) 



End of data for this card 



'^ Indicates blank. 



3.4-30 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.19.5 Design Reqir'rements 

An alpha field must be eight characters or less. Long alpha fields will be truncated to 
eiglit characters. 

All data must be placed in card columns 1-72. 

A data field may not be split between two cards. 

The specification of all numeric data fields must conform to F0RTRAN IV standards. 

If an error condition is encountered, e.g., data bad, XRCARD will write a message, turn on 
the N0G0 flag in /SYSTEM/, sat the first word of 0UTBUF = 0, and make a normal return to the 
calling program. 



3.4-31 



SUBROUTINE DESCRIPTIONS 

3,4.20 RCARD (Fixed Field Card Data Conversion Routine) . 

3.4.20.1 Entry Point: RCARD. 

3.4.20.2 Purpose 

To interpret NASTRAN fixed-field (bulk data) card input as follows: 

- Identify BCD alpha and numeric data fields as they are converted and placed 
in the users buffer; and 

- Convert BCD numeric fields to binary integer or binary floating point. 

3.4.20.3 Calling Sequence 

CALL RCARD(0UTBUF , FRMTBF .NFLAG , INBUF) 

Where: 

0UTBUF = The buffer which is to contain the converted card image. 

FRMTBF = A buffer which contains identification flags for the converted data in 0UTBUF. 

NFLAG = Contains number of words returned in 0UTBUF. 

INBUF = The buffer containing the card image to be converted. 

Definition of Data Identification Flags Placed in FRMTBF 

= output for a blank data field. 

1 = output for an integer field. 

2 = output for a floating ooint field. 

3 = output for a BCD field. 

4 = output for a double precision floating point field. 
-1 = error. 

3.4.20.4 Method 

RCARD's design is based on the necessity of having to function on a variety of computing 
machines having a variety of computer word structures, and a variety of differences in Hollerith 
handling imposed by differing F0RTRAN compilers. 

Twenty 4-Hollerith words are received by RCARD on any particular call to RCARD. RCARD first 
determines from field 1 (words 1 and 2) if the data card is a continuation card, and whether the 



3,4-32 



UTILITY SUBROUTINE DESCRIPTIONS 

fields are single (2 words each) or double (4 words each) in length. Fields 2 through 9 (for 
single field cards) or 2 through 5 (for double field cards) are then considered one at a time. 
No consideration is made for the last field of any card (words 19 and 20). 

3.4.20.5 Design Requirements 

1. All BCD fields must begin with an alphabetic character. 

2. All BCD fields are defined to be eight characters in lennth. Names with less than einht 
characters will be filled with BCD blanks. 

3. When placed in the user output buffer, each BCD field will be divided into two four- 
character words (left adjusted) and stored in two successive locations of the output buffer. 
The remainder of the words is filled with BCD blanks. 

4. Special characters are not to be used as part of a BCD field except for * and + in field 
1 (column 1) which indicate a double field or single field (respectively) continuation card. 

5. The data fields will be stored successively in the users output buffer as they are 
encountered in scanning the card image from left to right. The number of output core loca- 
tions required per field type varies: 

a. Integer field = 1 core word (right adjusted). 

b. BCD field = 2 core words. 

c. Real single precision = 1 core word. 

d. Real double precision = 2 core words. 

6. The card type field (field 1 ) of a continuation card will not be oassed alonn to the user. 
Two zero words will replace the ID field in the output buffer. Thus the user can easily dis- 
tinguish the difference between a continuation card and a new card type. 

7. A check for bulk data card types SEQGP and SEQEP is made by RCARD. Fields 3, 5, 7, and 9 of 
these card types are processed by a special conversion. 

The input within these special fields will be similar to the Dewey decimal notation and 
consists of a multiple digit integer and up to three single digit sub-integers; e.g., (354.1.2) 
and (267.5). The special fields will be converted to a single integer by dropping any decimal 
points and appending a number of zeros equal to three minus the number of decimal points in 
the original number; e.g., (354120) and (267500). 



3.4-33 



SUBROUTINE DESCRIPTIONS 

8. PXARD does not know the length of the users output buffer, therefore, no check is made 
for exceeding the length of the buffer. However, the number of data words placed in the 
output buffer will be specified in NFLAG. 

9, Field 10 will not be passed along to the user. 

3.4.20.6 Diagnostic Messages 

Fields appearing to be incorrect to RCARO will cause a diagnostic to be written on the 
system output file followed by a card format heading, a card image echo, and an underlining of 
the field in question. Also, the /SYSTEM/ N0G0 flap is set .TRUE., a zero is placed in the outnut 
buffer for the field, and a -1 is placed in the format buffer for the field. RCARD will print 
diagnostics for all fields appearing incorrect and make a normal return. 



3.4-34 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.21 TAPBIT (Tape Bit Test) . 

3.4.21.1 Entry Point: TAPBIT. 

3.4.21.2 Purpose 

To examine the tape bit for a permanent GIN0 file to determine the existence of a physical 
tape for that file. 

3.4.21.3 Calling Sequence 

IF (TAPBIT(FILE)) G0 T(J ... 

FILE is the GIN0 file name (one of 'P(30L', '0PTP, 'NPTP', 'UMF ', 'NUMF', 'PLTT, 
'PLT2', 'INPT'). 

3.4.21.4 Method 

The permanent FIST is searched and the tape bit in the corresponding FIAT entry is 
examined. If the bit is on (indicating the presence of a physical tape), TAPBIT will be set 
.TRUE.. Otherwise it will be set .FALSE.. 

3.4.21.5 Design Requirements 

The type of TAPBIT must be declared LOGICAL. 
3.4.21.5 Diagnostic Messages 

A fatal call to MESAGE occurs if a GIN0 file name other than those listed is used. 



3.4-35 



SUBROUTINE DESCRIPTIONS 

3.4.22 PEXIT (Problem Exit) . 

3.4.22.1 Entry Point: PEXIT. 

3.4.22.2 Purpose 

To terminate the program. 

3.4.22.3 Calling Sequence 
CALL PEXIT. 

3.4.22.4 Method 

The diagnostic message queue is checked and if not empty the message writer MSGWRT is 
called. If the checkpoint flag is set a card is punched indicating the end of the restart 
checkpoint dictionary. The system output buffers are flushed and then the iob is terminated. 

3.4.22.5 Design Requirements 

PEXIT must have access to the F0RTRAM 1/0 routines. 



3.4-36 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.23 TWT0GIZI (Tlme-To-Go) . 

3.4.23.1 Entry Point: TMT0G0. 

3.4.23.2 Purpose 

Computes the running time remaining for this NASTRAN problem. 

3.4.23.3 Calling Sequence 
CALL TMT0G0 (TIME) 

TIME = Remaining time in integer seconds. 

3.4.23.4 Method 

During NASTRAN problem initialization, one system cell is set to the problem starting time 
(PSTART) while another is set to the maximum running time (IIXTIME) contained on the Executive 
Control Deck TIME card. TIME-T0-G0 is then found by reading the clock (N0W) and solving the 
following: 

TIME-T0-G0 = MXTIME - (N0W - PSTART). 

The CPU clock Is utilized on all machines except the IBM 7094 where none is available. 



3.4-37 



SUBROUTINE DESCRIPTIONS 

3.4.24 PAGE (Page Heading) . 

3.4.24.1 Entry Points: PAGE, PAGET, PA6E2 

3.4.24.2 Purpose 

To provide a standard page heading for NASTRAN output. 

3.4.24.3 Calling Sequence 

CALL PAGE 
CALL PAGE! 
CALL PAGE2(N) 

C{JWN/SYSTEM/XXX,(JTPE,SPACE(6),IPAGE,LinE,ITLINE,MAXLIN,DATE(3) 

0TPE - System outout unit - integer. 

IPAGE - Current page number - increased by Ion each call to PAGE. 

LINE - Number of data lines on previous page - LINE is set to zero by PAGE. 

ITLINE - Total number of lines of printout in run - ITLINE = ITLINE + LINE. 

MAXLIN - Maximum number of data lines allowed - if ITLINE > MAXLIN, PEXIT will be called, 

DATE(3)- Today's date: month, day, year - integer. 

N - Number of lines to be written - integer - input. 

C(JMM0N/«)UTPUT/TITLE(32) ,SUBTIT(32) ,LABEL(32) ,HEAD1 (32) ,HEAD2(32) ,HEAD3(32) 

3.4.24.4 Method 

PAGE writes a standard 6 line heading from TITLE. SU3TIT, LABEL, HEADl , HEAD2. HEAD3. 

PAGEl writes only the first 3 lines of a standard header. 

PAGE2 restores the page if N lines will not fit on the current page. 

3.4.24.5 Design Requirements 

ITLINE must be less than MAXLIN. PAGE must have access to the FORTRAN 1/0 routines. 



3.4-38 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.25 MESAGE (Message ). 

3.4.25.1 Entry Point: MESAGE. 

3.4.25.2 Purpose 

To queue nonfatal messages during the execution of a module; and for fatal messages give 
e core dump (CALL PDUMP), print the message queue (CALL MSGURT). and call PEXIT. 

3.4.25.3 Calling Sequence 
CALL MESAGE(N0,PARM,NAME) 

Where 

Hl/i = Internal message number. N0 positive defines the niessage as nonfatal; 

N0 negative defines the message as fatal. 

PARM = Parameter used in the printed message (usually the GIN0 file number) 

NAME(2) = Two words used in the printed message (usually two BCD words containing the 
name of the subroutine calling MESAGE). 

3.4.25.4 Method 

Non-fatal messages are queued in common block /MS6X/ until the maximum number is reached. 
All non-fatal messages after this are lost. When a fatal message is encountered, it is queued 
and appropriate action taken to terminate the run. 

3.4.25.5 Design Requirements 

The size of common block /MSGX/ limits the number of messages stored. 



3.4-39 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.2G MSGWRT (Messat^e Writer) . 

3.4.26.1 Entry Point: MSGWRT. 

3.4.26.2 Purpose 

To print NASTRAN error messages on the system output file. 

3.4.26.3 Calling Sequence 
CALL MSGWRT 
C!3MM0N/MSGX/N,M,MSG(4JO) 

where; 

N - is the total number of messages to be printed. 

M - maximum number of messages that can be queued by subroutine MESAGE in the array MSG. 

MSG - array where message parameters are queued. 

MSGd.I) - the internal message number of the I message. 

MSG(2.I) - if iMSGd.Dl f 30. MSG(2.I) is a GIN0 file number. 

If |MSG(1,I)I = 30, then MSG{2,I) is an internal message number and 
USRMSG is called. 

MSG(3,I), MSG{4,I) = parameters for the I ' message. 

3.4.26.4 Method 

The internal message number, M(1,I), if not equal to 30 in absolute value, is used by MSGWRT to 
print out the error message along with external message number, which is 3000 plus the internal 
message number. If the internal message number, M{1,I), is 30, subroutine USRMSG is called. 

3.4.25.5 Design Requirements 

External message numbers output by MSGWRT at present are 3001 through 3057. 
MSGWRT is called only by MESAGE. 



3.4-40 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.27 USRMSG (User Message Writer) . 

3.4.27.1 Entry Point: USRMSG. 

3.4.27.2 Purpose 

To print most NASTRAN user error tnesssges on the system output file. 

3.4.27.3 Calling Sequence 

CALL USRMSG(I) 

C0MM0N/MSGX/N,M,MS6(4,1O) 

where: 

I - Pointer into the MSG array. 

N - Not used in USRMSG. 

M - Not used in USRMSG. 

MSG(1,I) - If |MSG(1,I)| = 30, MSGWRT will call USRMSG. 

MSG(2,I) - Used by USRMSG as the internal message number. 

MSG(3,I), MSG(4,I) - Parameters for the I*^ message. 

3.4.27.4 Method 

USRMSG will print appropriate error message along with external message number, which is 
2000 plus internal message number. 

3.4.27.5 Design Requirements 

External message numbers output by USRMSG at present are: 2001--2137. 
USRMSG is called only by MSGWRT. 



3.4-41 (7/1/70) 



SUBROUTINE DESCRIPTIONS 

3.4.28 MATDUM (Matrix Dump (Print) Routine ). 

3.4.28.1 Entry Point: MATDUM. 

3.4.28.2 Purpose 

To print a general NASTRAN matrix. 

3.4.28.3 Calling Sequence 
CALL MATDUM(FILEA) 

FILEA - Seven-word array (matrix control block) - integer 

Word 

1 GINia name 

2 Number of columns 

3 Number of rows 

4 Form of matrix 

5 Type of matrix 

6 Maximum number of non-zero terms in any column 

7 Undefined 

3.4.28.4 Method 

The non-zero terms of each column are unpacked and printed. 

If the matrix control block does not contain legal values the table printer (see section 

3.4.29) is called. 

3.4.28.5 Design Requirements 

Open core at /TABPRX/. 

MATDUM must hold the non-zero band of the matrix in this area. 

Subroutine TABPRT and the FORTRAN 1/0 routines must be available to MATDUM, 



3.4-42 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.29 TABPRT (Table Printer ). 

3.4.29.1 Entry Point: TABPRT. 

3.4.29.2 Purpose 

To print any NASTRAN Data Block (especially tables). 

3.4.29.3 Calling Sequence 
CALL TA3PRT(FILEN) 

FILEN - GIN0 name of data block - inteqer - input. 

3.4.29.4 Method 

Each word is read, identified as to type -- integer, BCD, or real number and printed 10 
characters ler word, 10 numbers per line. Note that the identification method varies from 
machine to machine and is not 100% certain, i.e., certain words may be misidentified. 

3.4.29.5 Design Requirements 
Open core at /TA3PRX/. 

Double precision numbers v/ill not be correctly interpreted on the Univac 1108. 



3.4-43 



SUBROUTINE DESCRIPTIONS 

3.4.30 PRELgC (Position Data Block to Requested Record ). 

3.4.30.1 Entry Points: PREL(3C, L0CATE. 

3.4.30.2 Purpose 

To provide a convenient means of locating data records in data blocks output by the 
Input File Processor (IFP). 

3.4.30.3 Calling Sequence 
CALL PREL0C($n, BUFF, NAME) 

n - F0RTRAN statement number defining return taken in the event NAME is not in the 

FIST (i.e., data block is purged). 
BUFF - An array whose dimension equals the contents of the first word of /SYSTEM/ 

£lus_one. Used as a GIN0 buffer by PREL0C and L0CATE. 
NAME - GIN0 file name of data block to be read (integer). 
CALL L(i)CATE($n,3UFF,ID,IDX) 

n - F0RTRAN statement number defining return taken in the event that the requested 

record (defined by ID) is not present in the data block. 
BUFF - The same BUFF assigned when PREL0C was called. 

ID - The address of a two-word array. The first word is the integer record identifi- 
cation and the second word is the bit position in the trailer for the data block 
where the presence or absence of the record is defined. 
IDX - The contents of the third word of the record found will be stored in IDX 
(internal card number generated by IFP). 

Notes : 

1. If the data block is not purged, PREL0C will open the file and skip the header record. 

2. If the requested record is not present (as determined by the aonronriate trailer bit), no 
1/0 activity will occur. Otherwise, L0CATE will position the file to read the first data entry of 
the requested record (i.e., after the 3-word header for the record). See 2.3.2 for format of 
records and trailer. 



3.4-44 



UTILITY SUBROUTINE DESCRIPTIONS 



3. If the user does not read all data in a record and he wishes to use L0CATE to find 
another record, he should use FWDREC to skip the remainder of the current record prior to calling 
L0CATE. 

4. For optimum efficiency in processing a data block, the user should call L0CATE in 
the order in which the records appear on the data block, i.e. NASTRAN collating order. 
3.4.30.4 Method 

PREL0C stores NAME in BUFF(l) and then calls 0PEN using BUFF(2) as the buffer address. If 
the data block is purged, the non-standard return is given to the user. Otherwise. FWDRFC is 
called to skip the header record and return is made to the user. LOCATE calls RDTRL to read the 
data block trailer. The bit position identified by ID{2) is tested usino ANDF. If zero, the 
non-standard return is given. Otherwise, three words from the file are read. If the first word 
equals ID(1), IDX is set to the third word and return is made. Otherwise, the first word is saved 
and the remainder of the record is skipped. The first three words of each successive record are 
read and the test for match on first word is made until (1) an end-of-file occurs in which case 
the file is rewound, the header record skipped and the process is continued. (2) a match is found 
in which case IDX is set and return is given or (3) a match with the first record read is found 
in which case the record is skipped, a warning message is queued and the non-standard return is 
given. 

3.4.30.5 Diagnostic Messages 

The following messages may be issued by PREL0C: 
2072 
3002 
3003 



3.4-45 



SUBROUTINE DESCRIPTIONS 

3.4.31 S jiRT (Sort a Table) . 

3.4.31 .1 Entry Point: S0RT. 

3.4.31.2 Purpose 

TO sort a core contained table, or to sort a logical record from a specified inout file, 
on a specified keyword in each entry. 

3.4.31.3 Calling Sequences 

To sort a core contained table: 

CALL S0RT(O,O,NWDS,KEYWD,TA3LE,NTABLE) 

NWDS - The number of words in each entry of the table. Restriction: NVIDS r. 20. 
KEYWO - The word position within each entry on which the sort is to take nlace. 
TABLE - Address where the table is stored. 

NTABLE - Total number of words in the table (NTARLE must be an integral multiple of 
NWDS). 
To sort a logical record: 

C(i(MM«(N/SETUP/NFILE(5),BUF 

CALL S(JRT(INPFL,(3UTFL,NyDS,KEYWD.BL(}CK.NBLqCK) 

NFILE - The first three words must be set by the user prior to CALL S0RT with the 
GINia file names of three scratch files for use by S(JRT. Upon return to 
the user, NFILE(6) will contain the GIN0 file name of the file containing 
the sorted record. 
BUF - If INPFL = iSUTFL, then BUF points to an area in BL0CK where a GIN0 buffer 
is available for S0RT, i.e., BL0CK(BUF) is the buffer address. 
Restriction: BUF > NBL0CK. 
INPFL - GIN0 file name of data block containing the lonical record to he sorted. 
0UTFL - GIN0 file name of data block where the sorted record is to be written. 
If 0UTFL = 0, the sorted record will remain on NFILE(6). 



3.4-46 



UTILITY SUBROUTINE DESCRIPTIONS 

NUDS - The number of words in each entry of the record. Restriction: N''JDS ^ 20. 

KEYWD - Defined as above. 

BL0CK - An area in core to be used by S(i!RT to nerform the sort phase. 

NBL0CK - The number of computer words available at BL0CK. 

Notes : 

1. INPFL must be opened and positioned to the logical record by the user prior to 
entry to S0RT. The file is not closed by SjJRT. 

2. If 0UTFL f 0, this file must be opened and positioned by the user prior to entrv to 
S0RT. The file is not closed by S0RT. 

3. If INPFL = 0UTFL, the file is closed by S0RT, onened to write with rewind, and 
the sorted logical record is written as the first logical record on the file. The ^ile is 
not closed by SflRT. 

4. NFILE(6) is always closed with rewind. 
3.4.31.4 Method 

1. CiZIRE S0RT. The method used is a shuttle exchange or bubble sort which is optimum for 
data which is nearly in sort. The method is as follows: 

a. The key words of two successive entries are compared. If currently in sort, the 
process is repeated. If not, 

b. A search toward the beginning of the table is made to determine the position of the 
out-of-sort entry. 

c. From this position, the table is shifted one entry and the out-of-sort entry is 
inserted at its oroper oosition. 

d. If the last pair of entries have not been analyzed, the nrocess returns to step (a). 
Otherwise the sort is complete. 

2. FILE S8IRT. One GIN0 buffer is allocated at the end of BL0CK and a scratch file is 
opened to write. As many entries as can be held in the remaining core in BL0CK are read and 
sorted using the algorithm above. The sorted data is written as a logical record on the scratch 
file. This process is repeated until all data in the input record has been read and the sorted 



3.4-47 



SUBROUTINE DESCRIPTIONS 

strings written on the scratch file. If only one such sort was required, the sort is complete 
except for copying onto 0UTFL if requested. Otherwise, an optimum distribution of sorted recoros 
on two scratch files is computed using a Fibonacci sequence. The sorted strings are redistributed 
between two scratch files and the merge phase is entered. The two scratch files are read one 
entry at a time, merged, and new sorted entries written on a third scratch file. Note that, usina 
the Fibonacci sequence, one of the files containing sorted strings will have a greater number o^ 
strings (records) than the other. On each pass in the merge nhase, the merae occurs until the 
file with fewer strings is exhausted. At this point, the meraed file becomes the file with the 
larger number of sorted strings, the previous larger file becomes the file with the fewer strinas, 
and the previous file with fewer strings (which was exhausted) becomes the file onto which the 
merged strings are written. The process continues until the sort is complete. The resulting 
sorted record is copied onto 0UTFL if requested. 

3.4.31.5 Design Requirements 

The number of words per entry may not exceed 20. (A change in the dimension of the local 
variable TEMP may be made to relax this restriction.) 

The amount of core available at BL0CK must be at least one GIN0 buffer olus 2*NWDS during 
the core sort phase and three GIN0 buffers plus 2*NWDS durinn the merge nhase. 

The core table or logical record to be sorted must contain an integral number o-*" entries. 

3.4.31.5 Diagnostic Messages 

The following messages may be issued by S0RT: 
3001 
3002 
3008 



3.4-48 



(1) 

(2) 
(3) 
(4) 
(5) 
(6) 
(7) 
(8) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.32 GMMATD (General Matrix MultipTv and Transpose - Double Precision) . 

3.4.32.1 Entry Point: GMMATD. 

3.4.32.2 Purpose 

To perform any one of the following matrix operations: 

[A] [B] = [C] 

[A]"^ [B] = [C] 

[A] [B]T = [C] 

[A]^ [ef = [C] 

[A] [B] + [D] = [C] 

[A]^ [B] + [D] = [C] 

[A] [3^ + [D] = [C] 

[A]^ [B]^+ [D] = [CJ 

where [A], [B], [C], and [D] are real double precision matrices. This routine is used for 
small in-core matrices, in non-NASTRAN packed format, in such modules as SMAl , SMA2, SMA3 and 
DSMGl . 

3.4.32.3 Calling Sequence 

CALL GMMATD(A,IR(2IUA,IC0LA,MTA,B,IR0WB,IC0LB,MTB,C) 

A - A real double precision matrix of IR0WA rows and IC(^LA columns stored in the 
singly dimensioned double precision variable A. 
N-B. A must be stored by rows . For example, if 

1.0 4.0 

[A] = 2.0 5.0 

3.0 6.0 

then the matrix must be stored in the FORTRAN double precision array A as follows: 

A(l) = 1.0 

A(2) = 4.0 

A(3) = 2.0 

A(4) = 5.0 

A(5) = 3.0 



3.4-4'} 



SUBROUTINE DESCRIPTIONS 

A(6) = 6.0 

(A is input only) . 

IR0WA - number or rows of [A] - input. 

IC.0LA - number of columns of [A] - input. 

MTA - Flag used to aetermine if [A] is to be transposed and to determine if the output 
matrix, [C], is to be zeroed out; that is, to determine if a matrix product only, of the form 
[A] [B] = [C], will be performed or if a product and (in effect) a sum, of the form 
[A] [B] + [D] = [C], will be performed. 

1. If MTA = 0, then [A] is not transposed and hence either Equation (1) or (3) will 
be performed, depending upon MTB. 

If MTA = +1 then [A] is transposed and hence either Equation (2) or (4) will be 
performed, depending upon MTB. 

MTA is input only. 

2, If MTA is less than zero, [C] is not zeroed out. Hence the routine, in this 
case, computes 

[A] [B] + [D] = [C] if I^A = -2 and MTB = 0. 
[A] [B]^ + [D] = [C] if MTA = -2 and MTB = 1 . 
[A]^ [E] + [D] = [C] if MTA = -1 and MTB = 0. 
[A]^ [E]^ + [D] = [C] if MTA = -1 and MTB = 1. 
(see MTB definition below; 
where D is a real double precision matrix of IR0WA rows and IC0LB columns if 
MTA = -2 and D is IC0LA x ICi3LB if MTA = -1. D must be stored row-wise at the 
location of C by the calling program. 
B - real double precision matrix, stored row-wise. See comments for A above - input. 
IR0WB - the number or rows of [B] - input. 
IC0LB - the number of columns of [B] - input. 

MTB - Transpose flag for [B]. If MTB = 0, [B] is not transposed. If MTB = 1, [B] is 
transposed. Note that MTA and MTB are independent and that only MTA controls whether or not 

3.4-50 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

[C] win be zeroed out, MTB is input only. 

C - real double precision matrix. Input (if MTA < 0) and output. 

Examples on the use of the routine: 

1. If [A] is 3x3 and [B] is 3x1 and [C] = [A] [B] is desired then: 

CALL GMMATD(A, 3, 3,0. B. 3,1.0,0. [C] is 3x1. 

2. If [A] is nxl and [B] is nxl and the dot product is desired ([A]^ [B]) then: 

CALL GMMATD(A,N,1,1.B,N,1,0,C). [C] is 1x1, a scalar. 

3. Compute [C] = ([X] [Y])^ where [X] is 5x4 and [Y] is 4x7: 

CALL GMMATD(Y.4,7.1.X,5,4,1,C). C is 7x5. 

4. Compute D = [A] [B]^ + [C] where [A], [B] and [C] are 3x3: 

DO 10 I = 1, 9 
10 D(I) = C(I) 

CALL GMMATD(A,3.3.-2,B.3.3,1,D). 

3.4.32.4 Method 

The first phase of the subroutine sets up integer loop limits which are functions of the two 
transpose flags. If MTA is not less than zero, the C array is zeroed out. Then the classical 
mathematical definitions of the above matrix products are carried out. 

3.4.32.5 Design Requirements 

The orders of the [A] and the [B] matrices in combination with the transpose flags must define 
a conformable matrix product. 

3.4.32.6 Diagnostic Messages 

The subroutine examines the tranpose flags in combination with the orders of the matrices to 
make sure that a conformable matrix product is defined by this input data. This test clearly is 
made for purposes of calling routine checkout only. No tests are made, nor can they be made, to 
insure that the calling routine has provided sufficient storage for arrays. If a conformable 
matrix product is not defined by the input arguments, fatal error message 2021 is printed. 

3,4-51 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.33 GMMATS (General Matrix Multiply and Transpose - Single Precision) . 

3.4.33.1 Entry Point: GMMATS. 

3.4.33.2 Purpose 

To perform any one of the following matrix operations: 

[A] [B] = [C] (1) 

[Af [B] = [C] (2) 

[A] [B]"^ = [C] (^) 

[Af [sf = [C] (4) 

[A] [B] + [D] = [C] (5) 

[Af [B] + [D] = [C] (6) 

[A] [B]^ + [D] = [C] (7) 

[Af [B]^ + [D] = [C] (8) 

Where [A], [B], [D] and [C] are real single precision matrices. This routine is used for small 

in-core matrices in non-NASTRAN packed format in such modules as SDR2 and PLA3 and in the utility 
routine PREf-IAT. 
3.4.33.3 Calling Sequence 

CALL GMMATS(A,IR0WA,IC0LA.MTA,B.IR0WB.IC!3LB.MTB,C) 

This routine is exactly the same as subroutine GMMATD except that GMMATD operates on real 
double precision matrices, while GMMATS operates on real single precision matrices. See sub- 
routine description for GIWTD (see section 3.4.32) for details on subroutine arguments, method, 
design requirements and diagnostic messages. 



3.4-52 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.34 INVERD (Double Precision In Core Inverse Routine ) . 

3.4.34.1 Entry Point: INVERD. 

3.4.34.2 Purpose 

To compute the inverse of a real double precision matrix [A] and on option to solve the 
matrix equation [A] [X] = [B]. This routine is used to invert small in-core double precision 
matrices in non-NASTRAN packed format and is used as a utility routine in such modules as SMAl , 
SMA3 and DSMGl . 

3.4.34.3 Calling Sequence 

CALL INVERD (NDIM.A,N,3,M,0ETERM,ISING, INDEX) 

NDIM - The actual row dimension of the doubly subscripted arrays A and B in the 
calling program - integer - input. 

A - The square matrix to be inverted. [A]' upon return from INVERD is stored at 
A. Double precision - input and output 

N - The order of the matrix being inverted (the size of the upper left hand corner 

actually being inverted). N^ NDIM - integer - input. 
B - The column(s) of constants in the above equation. If [A] is to be inverted, 

then B is a dummy argument. The solution matrix [X] is returned at B. Double 

precision - input and output. 

M - The number of columns of constants. If M <_ 0, [A]" is comouted - intener - 
input. 

DETERM - The determinant of [A]. Double precision - output. 

ISING - Singularity indicator. If [A] is non-singular, ISING is set to 1; if [A] is 
singular, ISING is set to 2 - integer - output. 

INDEX - Doubly subscripted array of row dimension N and column dimension 3 used for the 
row and column interchanges - integer - internal working storage. 

3.4.34.4 Method 

The classical Gauss-Jordan method with full row and column interchanges is used. All 
arithmetic operations are double precision. 



3.4-53 



SUBROUTINE DESCRIPTIONS 

3.4.35 INVERS (Single Precision In Core Inverse Routine) . 

3.4.35.1 Entry Point: INVERS. 

3.4.35.2 Purpose 

To compute the inverse of a real single precision matrix [A] and on option to solve the 
matrix equation [A] [X] = [B]. This routine is used to invert small in-core single precision 
matrices in non-NASTRAN packed format and is used as a utility routine in such modules as SDR2. 

3.4.35.3 Calling Sequence 

CALL INVERS (NDIM.A.N.B.M.DETERM.ISING, INDEX) 

This routine is exactly the same as subroutine INVERD except that INVERD operates on real 
double precision matrices, while INVERS operates on real single precision matrices. All arith- 
metic operations are single precision. DETERM is real single precision. See subroutine descrin- 
tion for INVERD (see section 3.4.34) for details on subroutine arguments and method. 



3.4-54 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.36 PREMAT (Material Property Utility ). 

3.4.36.1 Entry Points: PREMAT, tW. 

3.4.36.2 Purpose 

To provide a utility routine for obtaininn material nroperties used by structural elet^ent 
subroutines. The first entry point, PREMAT, is called once by a module for initialization purposes. 
and then liAT can be called by the module's element subroutines repeatedly to fetch required 
material properties. 

3.4.36.3 Calling Sequence 

CALL PREMAT (Z.2Z,BFR,N1MAT,N2MAT,MPTF,DITF) 

Z - Integer array of open core given to the subroutine to store the material proper- 
ties and the direct input tables - input and output. 

ZZ - Same address as Z. Used as real in this routine - input and output. 

SFR - A GIN0 buffer (plus one cell) used by subroutine PREL0C as a buffer - input only. 

NIMAT - The length of open core, the Z array, given to PREMAT and MAT - Inteqer - 
input only. 

N2MAT - The length of open core used by PREMAT and MAT - intener - output only. 

MPTF - GIN0 file number of the Material Properties Table (ilPT) data block - input only. 

DITF - GIN0 file number of the Direct Input Tables data block, l^ DITF is negative, 
the routine assumes that the calling module is a Piecewise Linear Analysis 
module which implies material properties cannot be temperature dependent and 
that MATSl cards are to be read. 

PREMAT uses the 10 word of /SYSTEM/ which is the temperature set identification number for 
material properties chosen by the user in his Case Control Deck. PREMAT also uses /NAMES/ for 
various Gi;<l0 options. 



3.4-55 



SUBROUTINE DESCRIPTIONS 

CALL MAT (ELEMID) 

ELEMID - Integer element identification number; used only for diagnostic messages 
(see below) - input and output. 
C0MM0N/MATIN/MATID,INFLAG,TEMP,PLAARG,SINTH,C0STH 

HATID - Material property identification number - integer - input. 

INFLAG - Integer input flag which determines which sets of input data cards, MATl , MAT2, 
or MAT3, the routine will search in order to find MATID. Also INFLAG deter- 
mines in what format the output will be placed in the MAT0UT common block. 
Currently INFLAG may assume the values 1 throuah 7 defined as follows: 
INFLAG = 1 -- The material properties corresnonding to the MATID are outnut in 
"MATl" or isotropic material format (see /M,AT(3UT/ below). One dimensional 
elements such as R9D, BAR, SHEAR etc. require isotropic materials. If the 
MATID is not found among all the MATl material cards read by PREMAT, a fatal 
error occurs. 

INFLAG = 2 -- If INFLAG = 2, the material properties corresDonding to the 
HATID are output in "MAT2" or anisotropic material format. Two-dimensional 
elements such as TRMEM, TRIAl , QDPLT, QUADl etc. may use isotropic or 
anisotropic materials. First, the routine will try to find the MATID among 
the MATl cards. If it is found among the MATl cards, the variables E (modulus 
of elasticity), v (Poisson's ratio) and G (shear modulus) are used to construct 
the 3x3 symmetric matrix [G ] needed by two-dimensional elements, and the 
matrix is stored in /MAT0UT/: 



vE 
1-v' 



[G,] 



vE_ E 

-W7 1-v^ 



3.4-56 



UTILITY SUBROUTINE DESCRIPTIONS 

If the MATID is not found among the ^WT^ cards, the MAT2 cards are searched. 
If the MATID is not found among the MAT2 cards a ^'atal error occurs. If it is 
found, [G^], the 3x3 symmetric matrix input on the MAT2 card, is transformed 
by the matrix equation [G^] = [U]'''[G^] [U] and {a} = [U] {a^^}, where {a } is 
the temperature expansion coefficient vector innut on a MAT2 card. [U] is a 
function of sin 6 and cos 9 (see SINTH and C0STH below). 



[U] 



cos e sin-' 9 cos 9 sin 6 

sin^ e cos^ e -cos 9 sin 6 

-2 cos e sin 9 2 cos 6 sin 9 (cos^ 9-sin^ 



INFLAG = 3 -- If INFLAG = 3, it implies the inverse of the symmetric 2x2 
transverse shear matrix J will be stored in locations 16, 17 and 18 of 
/MAT0UT/. There are two cases: (1) the current MATID is not equal to the 
most recent MATID, MATID0, and (2) the current MATID is equal to the most 
recent MATID. 

1. If the current MATID is not equal to the most recent material identi-'^i- 
cation number (MATID0), the MATl cards are searched. If the MATID is 
found among the MATl cards, then locations 16,17 and 18 of /MAT0UT/ are 
set to 6, 0.0 and G respectively, where G is the shear modulus. If the 
MATID is not found among the MATl cards, the MAT2 cards are searched. 

If the MATID is not found among the MAT2 cards, a fatal error occurs. If 
it is found among the MAT2 cards, locations 15, 17 and 18 are set to zero. 

2. The current MATID is equal to the most recent MATID. If INFLG0, the 
most recent INFLAG is not 2, this is the same as case (1). If it is 2, 
then (a) if the MATID was found on a MATl card, locations 16, 17 and 18 
are set to G, 0.0 and G respectively; or (b) if the MATID was found on a 
MAT2 card, locations 16, 17 and 18 are set to 0.0. 

INFLAG = 4 -- If INFLAG is 4, this imnlies that only the density of the 
material, RH0, will be returned in /mT0UT/ and this in the first location. 
The MATID can be either on a MATl or MAT2 card. If the MATID cannot he ^ound 
among all MATl and MAT2 cards, a fatal error occurs. 



3.4-57 



SUBROUTINE DESCRIPTIONS 

INFLAG = 5 — INFLAG = 5 is reserved for use only by module PLAl . This option 
determines if the MATID is such that E, the modulus of elasticity, is defined 
as stress dependent by MATSl and TABLES! cards. If it is stress dependent, 
INDSTR, equivalenced to the first word of /MATgUT/, is set to +1. If not stress 
dependent, INDSTR is set to 0. Only MATl cards are admissible for INFLAG = 5. 

INFLAG = 6 — INFLAG = 6 is reserved for use by modules PLA3 and PLA4. The 
fourth word of /MATIN/, PLAARG (see below), is strain and is used as the inde- 
pendent variable in a table look-up for stress, which is stored in the first 
word of /MAT0UT/. Only MATl cards are searched to match the input MATID. 

INFLAG = 1 — INFLAG 7 implies that the material properties corresponding to 
the MATID w'll be output in MATS or orthotropic material format. Currently 
only the axisymmetric elements TRIARG, TRAPRG and T0RDRG use this option. If 
the MATID is found in the MATl set, the data &re stored in MAT3 format. If not 
found in the MATl set, the MAT3 set is searched. If not found here, a fatal 
error exists. 

INFLAG = 8 -- INFLAG = 8 is used only by two-dimensional element subroutines 
in modules PLA3 and PLA4. The fourth word of /MATIN/, PLAARG (see below), is 
stress (a) and is used as the ordinate in an inverse interpolation table look- 
up to obtain the abscissa which is strain (e). 

If either: a) the ordinate is in the range of the piecewise linear function 
defined by the table on a TABLES! bulk data card, or b) the ordinate is 
greater than the maximum (which is also the last) ordinate in the table but 
the slope of the line segment joining the last two points of the table is 
nonzero, then the second word of /MAT0UT/ is set to zero and the abscissa, 
obtained by inverse linear interpolation or extrapolation, is stored in the 
first word of /MATJiUT/. If either: a) the ordinate is less than the minimum 
(which is also the first) ordinate in the table, or b) the ordinate ,s 
greater than tiie iiaxijium ordinate in the table and the slope of the line 
segment joining the last two points of the table is zero, then the integer 
"1" is stored in the second word of /MAT0UT/ (and the first word of /MAT0UT/ 
is set to zero). Only MAT! cards are searched to match the input MATID. 

3.4-58 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

TEMP - Average element temperature. Used as the independent variable in a table look- 
up when it is determined that a material property is temperature dependent. 
Not used when INFLAG = 5 or 6. 

PLAARG - Element strain. Used as the independent variable in a table look-up when E, 

the modulus of elasticity, is defined as the first derivative of a strain-stress 
curve. Used only in the Piecewise Linear Analysis Rigid Format and only by 
modules PLA3 and PLA4. 

SINTH - Sine of the material property orientation angle. Used only when INFLAG = 2 

and the MATID is found among the MAT2 cards. Used to construct the [U] matrix 
referenced above. 

C0STH - Cosine of the material property orientation angle. The comments on SINTH, 
above, also apply here. 

C0MM0N/MAT0UT/ - (Output Common Block). Length 20 words. Depending upon the values of INFLAG, 
the output common block is defined variously as follows: 

1. MATl Format (INFLAG = 1) 

Uord Symbol Definition 

1 E Young's modulus (modulus of elasticity) 

2 G Shear Modulus 

3 V Poisson's ratio 

4 p Density 

5 a Thermal expansion coefficient 

6 T Thermal expansion reference temperature 

7 g Structural element damping coefficient 

8 o^ Stress limit for tension 

9 a Stress limit for compression 

10 a Stress limit for shear 
11-20 - Undefined 



3.4-59 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

2. MAT2 Format (INFLAG = 2) 

Word Symbol Definition 

1 Gil 

2 G12 

3 G13 I The 3x3 symmetric material 

4 622 [ property matrix 

5 G23 

6 G33 

7 RH0Y Density 

8 ALPH1 

9 ALPH2 > Thermal expansion coefficient vector 

10 ALPH12 

11 T0Y Thermal expansion reference temperature 
T2 GEY Structural element damping coefficient 

13 SIGTY Stress limit for tension 

14 SIGCY Stress limit for compression 

15 SIGSY Stress limit for shear 
16-20 - Undefined 

3. Transverse Shear Inverse Matrix (INFLAG = 3) 

Word Symbol Definition 

1-15 - Unchanged 



16 Jll 

17 J12 



18 J22 

19-20 Undefined 

RHg Only Format (INFLAG = 4) 

Word Symbol Definition 

1 RH(3 Density 

2-20 - Undefined 



The 2x2 symmetric inverse of the 
transverse shear matrix 



3.4-60 (12-1-69) 



UTILITY subroutine: descriptions 



5. PLA1 Use Only (INFLAG = 5) 



Word 

1 

2-20 



Symbol 
INDSTR 



Definition 

Stress dependent flag 

Undefined 



6. Stress Functional Value (INFLAG = 6) 



Word 



1 



S ymbol 
PLAANS 



2-20 
MAT3 Format (INFLAG = 7) 



Word 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

n 

12 
13 
U 
15 
16-20 



Symbol 
EX3 
EY3 
EZ3 
NUXY3 
NUYZ3 
NUZX3 
RH03 
GXY3 
GYZ3 
GZX3 
AX3 
AY3 ) 
AZ3 
TREF3 
GE3 



Definition 

Value of stress (o) as a function of 
£ (strain) 

Undefined 



Definition 

Young's Moduli x, y and z 
directions 

Poisson's ratios. Coupled strain 
ratios in the xy, yz, and zx 
directions 
Density 

Shear moduli 



Thermal expansion coefficients 

Thermal expansion reference temperature 
Structural element damping coefficient 
Undefined 



3.4-61 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

8. Strain Functional Value (INFLAG = 8) 

Word Symbol Definition 

1 PLAANS Value of strain (e) as an inverse 

function of stress (a) 

if the input stress is in the 
jpri I p } range of the function 

^- 1 if the input stress is outside 
the range of the function 

3-20 Undefined 

3.4,36.4 Method 

1. PREMAT: All the MATl, MAT2 and MAT3 cards are read from the MPT data block into open 
core so that each card is assigned 1 + 3*N words of core where N, a function of the card type, is 
the number of material property data items on that card type. The first word is the material iden- 
tification number and each material property is allocated 3 words: the first the input material 
property; the second a table (function) number which gives this material property as a function of 
temperature; the third a table number which gives this material property as a function of stress. 
Initially words 2 and 3 are set to zero. Although the third word is currently used only for MATl 
cards and for E, the modulus of elasticity, on that card, future development may make use of a 
more general application of stress dependent material properties. If there are no temperature 
dependent material properties for a non-Piecewise Linear Analysis problem, PREMAT is wrapped up 
and a RETURN to the calling routine is executed. 

For a non-Piecewise Linear Analysis problem for which a temperature set for material proper- 
ties was selected in the user's Case Control Deck, all MATT! , MATT2 and MATT3 cards are read into 
open core from the MPT data block. For a Piecewise Linear Analysis problem MATSl cards are read 
into open core from the MPT. A sorted list, with duplicates discarded, of the table numbers refer- 
enced on these cards is constructed in open core. This table number list is constructed so that 
every referenced table has eleven locations allocated to it. These eleven locations are used as a 
dictionary for the tables. The contents are: the table number (word 1); the table type 1,2,3, or 
4 (word 2); pointers to the first and last entries in the table (words 3 and 4); parameters from 
the TABLE card (words 5 through 11). The DIT data block is then read. For each table read, it is 
determined by scanning the table number list whether or not the table is required for problem 

3.4-62 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

solution. If it is required, the table is read into open core and the dictionary entry for the 
table is completed. For a required table which is a type 4 (polynomial) table, the functional 
values of the polynomial at the end points of the interval of the real line over which the 
polynomial is defined are calculated by an "internal subroutine" and stored in the table 
dictionary. If the table is not required, it is read until an end-of-table indicator is sensed. 
This process continues until all tables of the set TABLEMl , TABLEM2, TABLEM3 and TABLEM4 or of 
the set TABLESl, are exhausted. When all referenced tables have been read into core, PREMAT is 
wrapped up and a return is generated. 

2. MAT: The basic logic of the MAT routine is straightforward. Eight types of table look- 
ups, described above for INFLAG = 1, 2, 3, 4, 5, 6, 7 and 8 are supported. A computed-go-to on 
INFLAG is executed and each option is carried out as described above. "Internal subroutines" 
which are entered via F0RTRAN ASSIGN and G0 T0 statements and return to their correct "calling" 
locations via ASSIGNED G0 T0's are used liberally by MAT. It should be noted that each time MAT 
is called, MATID, INFLAG and other applicable input items, are saved. On the next call if the 
input is identical with the input of the previous call, nothing is stored in /MAT0UT/. Hence, 
the calling routine should use /MAT0UT/ as a "read-only data set". 

3.4.36.5 Design Requirements 

Subroutine GMMATS is the only non-root segment subroutine used by this routine. There are no 
other special requirements. 

3.4.35.6 Diagnostic Messages 

The following messages can be output via PREMAT and/or MAT: 3008, 2017, 2018, 2019, 2041, 
2042, 2103, 2112, 2113, 2114, 2115, 2116, and 2117. 



3.4-63 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.37 PRLTRD (Utility for Modules Which Use the CSTM Data Block - Double Precision Version ). 

3.4.37.1 Entry Points: PRETRD, TRANSD 

3.4.37.2 Purpose 

A utility routine for modules which use the CSTM (Coordinate System Transformation Matrices) 
data block, TRANSD generates a real double precision 3x3 direction cosine matrix which mans a 
vector from a local coordinate system to basic coordinates. PRETRD sets uo eventual calls to 
TRANSD. For a module to use TRANSD a call to PRETRD is made once and only once. 

3.4.37.3 Calling Sequence 

CALL PRETRD(CSTM.NCSTM) 

CSTM = array of coordinate system transformation matrices (see data block descrintion 
for CSTM, section 2.3) - mixed - input. 

NCSTM = length of the CSTM array. NCSTM = 14*the number of coordinate svstems in the 
CSTM data block - integer - input. 

CALL TRANSD(ECPT,TA) 

ECPT = array of length 4. The first word is an inteoer coordinate system identification 
number and the next 3 words are the components of a vector in basic coordinates - 
input only. 

TA = real double precision 3x3 direction cosine matrix which maps a vector from the 
local coordinate system designated by ECPT(l) to basic coordinates - output. 

3.4.37.4 Method 

The CSTM array is searched to find a coordinate system transformation identification number 
that matches ECPT(l). If the coordinate system is rectangular, the 3x3 matrix, call it T, which 
is in words 5 through 14 of the CSTM blocks, is stored in TA and a RETURN is generated. If the 
coordinate system is basic, the identity matrix is returned. If the coordinate system is spherical 
or cylindrical, we calculate 



= [if {E - V' 



where E is the input vector stored at ECPT(2) and V is the translation offset vector in basic 



3.4-64 



UTILITY SUBROUTINE DESCRIPTIONS 



coordinates found in the CSTM block in words 3, 4 and 5; and 



i A-'ui." 



vF+y 



If the coordinate system is cylindrical define: 







~x/r 


-y/r 


0" 


\ 


= 


y/r 


x/r 















1. 



If the coordinate system is spherical define: 



Vx' + y' + z% 

^x/e ^ -y/r- 
y/^ II x/r 



_Z/J!, 



■rd 0.0 



Then TA = TT is computed and the subroutine returns to the calling program. 

3.4.37.5 Design Requirements 

The routine is designed so that a module which uses the CSTM data block can have a utility 
routine to fetch a coordinate system transformation matrix. Typically, a module driver will 
attempt to open the file which contains the CSTM data block. If the data block is not Durged, 
the module will read the entire data block into open core, close the file and call PRETRD to 
transmit the address of the array and the length of the array. Once this initialization call 
has been made, TRANSD may be called in the module as many times as necessary. The routine Hoes 
not perform any 1/0 operations. The routine assumes the format of the CSTM data block, as outlined 
in the Data Block Description for the CSTM (section 2.3 of the Programmer's Manual) is correct, and 
no numerical checks are made. 

3.4.37.6 Diagnostic Messages 

If the coordinate system identification number transmitted via ECPT(l) can not be found in 
the CSTM array user fatal message 2025 occurs. The user should check coordinate system numbers 
on GRID bulk data cards against those defined on C0RD1C, C0RD1R, etc, bulk data cards to insure 
that there are no undefined coordinate systems. 



3.4-65 



SUBROUTINE DESCRIPTIONS 

3.4.38 PRETRS (Utility for Modules Which Use the CSTM Data Block - Single Precision Version) . 

3.4.38.1 Entry Points: PRETRS, TRAHSS. 

3.4.38.2 Purpose 

A utility routine for modules which use the CSTM (Coordinate System Transformation Matrices) 
data block, TRANSS generates a real single precision 3x3 direction cosine matrix which maos a 
vector from a local coordinate system to basic coordinates. PRETRS sets up eventual calls to 
TRANSS. For a module to use TRANSS a call to PRETRS is made once and only once. 

3.4.38.3 Calling Sequence 

CALL PRETRS(CSTM,NCSTM) 

CALL TRANSS(ECPT,TA) 

This routine is exactly the same as subroutine PRETRD (see section 3.4.37) and TRANSD 
except that TRANSD, an entry point, returns a real double precision matrix TA and uses double 
precision arithmetic, while TRANSS returns a real sinc|1e precision matrix TA and uses sinnle 
precision arithmetic. See subroutine description for PRETRD for details on subroutine arguments, 
method, design requirements and diagnostic messages. 



3.4-66 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.39 PRETAB (Table Look-Up ). 

3.4.39.1 Entry Points: PRETAB, TAB. 

3.4.39.2 Purpose 

To read tables (functions) from the data block DIT, Direct Input Tables, into core and to 
set up table dictionaries which are subsequently used when the calling routine requests a 
functional value from a table via a call to the entry point TAB. The routine is designed so 
that PRETAB is called once and only once by a module and so that TAB may be called many times as 
a table look-up routine. 

3.4.39.3 Calling Sequence 

CALL PRETAB(DITF.Z,IZ,BUF,LCRGVN,LCUSED,TABN0L.LIST) 

DITF - GINI3 file number of the Direct Input Tables data, block - integer - input. 

1 - Array of core given to the subroutine as working storage - real - Input and 

output. 

IZ - Same address as Z. Used as integer in this routine. 

BUF - A GIN0 buffer (plus one cell) used by subroutine PRELJIC - input. 

LCRGVN - The length of Z array, given to PRETAB and TAB - integer - input. 

LCUSED - The number of cells of core used by PRETAB - integer - output. 

TABN0L - List of table numbers that the calling routine will be referencing via TAB 
calls. TABNjSLd) = N is the number of tables to be referenced. TABN0L(2), 
... , TABN0L(N +1) contain the table numbers. Note that is an admissible 
table number. Table defines a function which is Identically zero for 
all values of the independent variable - integer - input. 

LIST - Array of control words for subroutine LOCATE and table types. LIST(l) = M 
is the number of triples which follow in the list. The first two words of 
each triple are the subroutine LOCATE control words for the particular table 
being referenced and the third word is the table tyoe: 1 , 2, 3 or 4 - integer 
input. 



3.4-67 



SUBROUTINE DESCRIPTIONS 

CALL TAB(TABID,X,Y) 

TABID - Table number - integer - input. 

X - Abscissa for table number TABID at which the functional value is desired - real - 

input. 
Y - Functional value (ordinate) of abscissa X for table number TABID - real - output. 

3.4.39.4 Method 

PRETAB: For each table in the TABN0L list an 11 word table dictionary entry is defined in 
open core. The first word in each entry is the table number obtained from the TABN0L list. Then 
the DIT data block is read. For each entry of the DIT, it is determined whether or not this table 
number is in the TABNfIL list. If it is not, then the table is read serially until an end-of-table 
indicator is sensed. If it is a table called for in the TABN0L list, the program sets words 2 and 
3 of the table dictionary, the table type (1,2,3 or 4) and the pointer to the 1st entry in the 
table respectively. The table is then read into core, and the 4th word of the table dictionary, 
the pointer to the last entry in the table, is set. Words 5 through 11 of the dictionary, the 
table parameters, are set. If the table type is 4, indicating a polynomial, the functional values 
of the polynomial at the end points of the interval of the real line over which the polynomial is 
defined are calculated. After the tables for an entry in the LIST array have been exhausted, a 
check is made to determine if all tables in the TABN0L list have been found (after each table is 
found the table number is set negative). If all tables have been found, the table numbers in 
TABNI3L are set to their original positive status and the routine is wrapped up. If all tables 
have not been found, the next class of table cards, defined by the next triple in the LIST array, 
are located in the DIT data block and the process is repeated. 

TAB: The table dictionary is searched until a match is found with the input argument TABID. 
The table type (1, 2, 3 or 4) is determined, the (functional) argument is computed after a 4-way 
branch on table type, and a transfer is made to either the "internal subroutine" which performs 
linear interpolation-if the table type is 1, 2 or 3--or the "internal subroutine" which performs 
polynomial evaluation--if the table type is 4. 



3.4-68 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.39.5 Design Requirements 

DIT must not be purged. Enough open core must be made available to construct the table 
dictionaries and to contain all referenced tables in core. All table numbers must be unique. 
All table numbers input via the TABN0L array must be found in the DIT data block. A table 
number referenced by the TABID argument of TAB must have been referenced previously in the TABN0L 
array. 

3.4.39.5 Diagnostic Messages 

The following diagnostic messages may appear: 
3008 
2088 
2089 
2090 



3.4-69 



SUBROUTINE DESCRIPTIOMS 

3.4.40 AXIS (Draw an Axis on a Plot ). 

3.4.40.1 Entry Point: AXIS. 

3.4.40.2 Purpose 
To draw an x or y axis on a plotter. 

3.4.40.3 Calling Sequence 
CALL AXIS{X1.Y1,X2,Y2,PEN,!3PT) 
C(}MM8IN/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where : 

XI, YL = starting point of the axis line - real - input. 

X2,Y2 = terminal point of the axis line - real - input, 

PEN = pen number or line density to be used (its meaning depends on the plotter) 
- integer - input. 

!-l to initiate the line mode. 
+1 to terminate a series of plot commands, ^ - integer - input 
to draw an axis. 

/PLTDAT/ 

MJIDEL = plotter model number - integer - input. 

PL0TER = plotter number (i) - integer - input. 

NPENS = largest number of pens or maximum density for plotter i - integer - input. 

3.4.40.4 Method 

This subroutine calls LINE or AXISi, depending on whether the plotter has available a single 
conmand used for drawing an axis. At this writing, only plotter 3 has a special axis command. 

If SIPT ;* 0, all other arguments are ignored, and LINE or AXISi is called. Otherwise, 
alternate pen number (PENX) is calculated modulo NPENS and is used as the pen number passed to 

3.4-70 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

LINE or AXISi, as follows: 

PENX = PEN - NPENS * ((PEN-1)/NPENS) 

3.4.40.5 Design Requirements 

Generally. AXIS or LINE should be called with 0PT = -1 before axes are generated, even though 
it is not necessary to specifically put all plotters in the line mode (e.g., plotter 3). Once 
this is done, it need not be repeated unless the plotter has been put into some other mode (e.g.. 
the typing mode). 

Subroutines used: LINE, AXISi. 



3.4-71 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.41 AXISi (Axis Routine for Plotter i ). 

3.4.41.1 Entry Point: AXISi. 

3.4.41.2 Purpose 

To set up a plot command to draw an x or y axis on plotter i. 

3.4.41.3 Calling Sequence 

CALL AXISi(Xl,Yl,X2,Y2,PEN.0PT) 

C8IMM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

XI. Yl = starting point of the axis line - real - input. 

X2,Y2 = terminal point of the axis line - real - input. 

PEN = pen number or line density to be used (meaning depends on plotter)- integer - 
input. 

!-l to initiate the line mode \ 

+ 1 to terminate a series of plot commands \ -integer - input. 
to draw an axis / 

/PLTDAT/ 

XYMIN = minimum x and y values of the region permitted on plotter i - real - input. 

XYMAX = maximum x and y values of the region permitted on plotter i - real - input. 

0RIGIN = location of the lower left corner of the plotter relative to its true physical 
origin - real - input. 

3.4.41.4 Method 

Taking into account the true origin of the plotter, the plot comnand is generated. 



3.4-72 (12-1-69) 



SUBROUTINE DESCRIPTIONS 



3.4.41.5 Design Requirements 
Subroutine used: WPLTi. 



3.4-72a (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.42 SKPFRM (Skip a Variable Number of Frames ). 

3.4.42.1 Entry Point: SKPFRM. 

3.4.42.2 Purpose 

Tc skip a variable number of frames, if appropriate to the plotter. 

3.4.42.3 Calling Sequence 
CALL SKPFRf4 (BFRAMS) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

BFRAMS = number of frames to be skipped - integer - input. 

/PLTDAT/ 

M(ilDEL = plotter model number - integer - input. 

PL0TER = plotter number - integer - input. 

REG = plot region parameters - real - input. 

AXYMAX = size of the paper (x.y) used, less the borders, in plotter units - real - input. 

EDGE = size of the borders (x.y) in plotter units - real - input. 

CAMERA = currently active camera - integer - input. 

0RIGIN = location (x,y) of the lower left corner of the plotter relative to its true 
physical origin - real - input. 

3.4.42.4 Method 

For plotters 3 and 9. the specified number of frames (BFRAMS) are skipped. For plotters 4 
to 7, the remainder of the current plot is skipped, and another half plot is also skipped. For 
plotters 1, 2 and 4. nothing is done due to the absence of any automatic method of skipping blank 
paper. 

3.4-73 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 



3.4.42.5 Design Requirements 

Subroutines used: LINE, WPLTi , 



3.4-73a (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.43 SEi C AM (To Initiate £ New Plot ). 

3.4.43.1 Entry Point: SELCAM. 

3.4.43.2 Purpose 

To select a camera and/or to generate a setup record for a new plot. 

3.4.43.3 Calling Sequence 

CALL SELCAM (CAMERA, PLTNUM,0PT) 

C{)MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

CAMERA = camera number to be selected (if appropriate) - integer - input. 

PLTNUM = plot number - integer - input. 

0PJ j( = if the camera is to be selected when appropriate, and nothing is to be done 
when not appropriate - integer - input. 

/PLTDAT/ 

[■1I3DEL = plotter model number - integer - input. 

PL0TER = plotter number - integer - input. 

XYMAX = size of the paper (x,y) used, less the borders, in plotter units - real 
- input. 

EDGE = size of the borders (x,y) in plotter units - real - input. 
CAMNUM = last selected camera - integer - output. 

0RIGIN = location (x,y) of the lower left corner of the plotter relative to its true 
physical origin - real - input and output. 

3.4.43.4 Method 

If 0PT ?( and a camera is not appropriate to the plotter, nothing is done by this subroutine. 

3.4-74 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

Otherwise, what is done is dependent upon the plotter hardware requirements. 

For plotters 1, 2 and 8, the plotter is stopped with the plot number displayed in the console 
lights. For plotters 2 and 9 the specified camera is selected. And for plotters 4 to 7, a block 
address record with the plot number is generated. 

3.4.43.5 Design Requirements 

Subroutines used: APLli , LINE. 



3.4-74a (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.44 IDPLglT (Generate an " ID" Plot). 

3.4.44.1 Entry Point: IDPL0T. 

3.4.44.2 Purpose 

To identify the owner of all the plots by printing the information contained on the PL0TID 
card in the user's Case Control Deck prior to generating the first plot. 

3.4.44.3 Calling Sequence 
CALL IDPL(2T (IDX) 
C0MM0N/0UTPUT/SKIP{32,6),ID(32) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

(o if a plot id was not generated I 
IDX = \ - integer - output. 

(1 if a plot id was generated ) 

/0UTPUT/ 

ID = user supplied PL0TID, in the Case Control Deck - BCD - input. 

/PLTDAT/ 

XYMIN 



XYMAX 



= ^plot region parameters - real - input. 



AXYMAX = size of the paper (x,y) used, less the borders, in plotter units - real 
- input. 

EDGE = size of the borders (x,y) in plotter units - real - input. 

CNTX,CNTY= number of counts per printed character in the x and y directions respectively 
- real - input. 

PLTYPE = plotter type - integer - input. 



3.4-75 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3,4,44.4 Method 

If there is no PLI2TID (ID = blanks), IDX is set to zero and no identification is generated. 
Otherwise, IDX is set to one and an identification is generated. Tt-e current region parameters 
are saved (they will be restored at the end of the subroutine) and are set to include the entire 
paper area. The identification generated varies, depending upon the plotter type. 

If the plotter is a microfilm plotter (|PLTYPE| = 1), an entire frame is generated as identi- 
fication. The top and bottom of the frame are a series of closely spaced horizontal lines. The 
PL0TID is then printed three times in the center of the frame. 

If the plotter is a drum or table plotter (|PLTYPE| f 1), the identification is printed once 
at the very bottom of the paper within the bottom border. 

After the identification is generated, the PL0TID is set to blanks. This insures that the 
identification will be generated prior to the first plot only. 

3.4.44.5 Design Requirements 

Subroutines used: AXIS, PRINT. 



3.4-75a (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.45 INTGPX (Search a List of Integers) . 

3.4.45.1 Entry Points: INTGPX, INTGPT. 

3.4.45.2 Purpose 

Given a list of N integers, to find the index of the list item equal to ITEM (primarily used 
to search a list of external grid point id's). 

3.4.45.3 Calling Sequence 

CALL INT6PX(LIST,N) 
K = INTGPT (ITEM) 

where : 

LIST = list of N integers, in arbitrary order - input. 

N = number of entries in LIST - integer - input. 

ITEM = integer for which a match is to be found in LIST - input. 

3.4.45.4 Method 

Search LIST using a linear search until a match for ITEM is found. Then the result (INTGPT) 
is set equal to the index of LIST where the match occurs. If no match is found, the result is 
set = 0. 

3.4.45.5 Design Requirements 

INTGPX must be called before INTGPT is used. As long as LIST does not change location and 
the value of N does not change, INTGPX need not be called again. 



3.4-76 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.46 INTLST (Interpret a List of Integers ). 

3.4.46.1 Entry Point: INTLST. 

3.4.46.2 Purpose 

To interpret a list of integers and/or pairs of integers separated by the word T0 or THRU. 

3.4.46.3 Calling Sequence 

CALL INTLST(LIST,N,SIGN,N1,N2) 

where : 

LIST - the list to be interpreted - integer - input. 

N - index location of the next list iteni{s) to be interpreted - integer - input. 

SIGN - s-'in (+1) of the interpreted integer or the first of a pair of integers - 

output. 
Nl - absolute value of the interpreted integer or the first of a pair of integers - 

output. 
N2 - absolute value of the second integer of pair of integers (= Nl if not a pair) - 

output. 

3.4.46.4 Method 

SIGN = +1 if LIST(N) is positive or negative. 
Nl = absolute value of LIST(N). 

If LIST(N+1) ?( T0 or THRU, then N2 = Nl and N is incremented by 1. 
If LIST(N+1) = T0 or THRU, then N2 = absolute value of LIST(N+2) and N is incremented 
by 3. 

3.4.46.5 Design Requirements 

Initially, N must be set to the index of the first integer or integer pair to be interpreted 
in LIST. If the list is consecutive, N need not subsequently be altered until a new list is to 
be interpreted. It is advisable that the value following the last item in LIST be set = to 
avoid the chance that it may equal T0 or THRU. 



3.4-77 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.47 LINE (Draw a Line on a Plotter ). 

3.4.47.1 Entry Point: LINE. 

3.4.47.2 Purpose 
To draw a line on a plotter. 

3.4.47.3 Calling Sequence 

CALL LINE(X1,Y1,X2,Y2,PEN,0PT) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5 

where: 

Xl.Yl = starting point of the line - real - input. 

X2,Y2 = terminal point of the line - real - input. 

PEN = pen number or line density to be used - integer - input. 
^-1 to initiate the line mode 

0PT = \+l to terminate a series of plot commands. } integer - input. 



to draw a line. 



/PLTDAT/ 

M0DEL = plotter model number - integer - input. 

PL0TER = plotter number (i) - integer - input. 

REG = X and y values defining the region in which the line is to be drawn - real - 

input. 
NPENS = maximum number of pens or line density possible for plotter i - integer - input. 

3.4.47.4 Method 

If the line to be drawn is entirely outside the specified region, the subroutine immediately 
returns without drawing anything. If only part of the line is outside the region, only that 
portion of the line within the region is drawn. The actual pen number or line density used will 
be modulo the maximum number of pens or line density as follows: 

PENX = PEN - NPENS* ((PEN-1 )/NPENS) 
Then LINEi is called. 

3.4-78 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.47,5 Design Requirements 

Generally, LINE should be called with 0PT = -1 before any lines are drawn, even though it is 
not necessary to specifically put all plotters in the line mode (e.g., plotter 3). Once this is 
done, it need not be repeated unless the plotter has been put into some other mode (e.g., the 
typing mode). If 0PT f 0, all other arguments are ignored. Subroutine used: LINEi. 



3.4-78a (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.48 LINEi (Draw a Line on Plotter i) . 

3.4.48.1 Entry Point: LINEi. 

3.4.48.2 Purpose 

To dra.w a line on plotter i. 

3.4.48.3 Calling Sequence 

CALL LINEi(Xl,Yl,X2,Y2.PEN JPT) 

C0MM(2N/PLTDAT/ - see PLTDAT Miscellaneous Table description section 2.5. 

where: 

XI, Yl = starting point of the line - real - input. 
X2,Y2 = terminal point of the line - real - input. 
PEN = pen number or line density to be used - integer - input. 

^-1 to initiate the line mode. ] 

0PT = <+l to terminate a series of plot commands. >- integer - input. 
' to draw a line. ; 

/FLTDAT/ 

M0DEL. = plotter model number - integer - input. 
PLATER = plotter number - integer - input. 
i4AXLEN = maximum length of a line segment - real - input. 

0RIGIN = X and y values of the current position of the pen (applicable only to incre- 
mental plotters) - real - input and output. 

3.4.48.4 Method 

If I3FT f 0, all other arguments are ignored. If (JPT = -1 and if applicable for plotter i, a 
flag is set so that when LINEi is subsequently called with 0PT = 0, the plotter will be put into 
the line mode before drawing the requested line. If 0PT = +1 and if applicable for plotter i, the 
pen is raised. Then, no matter which plotter is being used the current sequence of plotter 
commands is terminated. If {(PT = 0, the line is drawn as a series of line segments, each of 
maximum length MAXLEN. 

3.4-79 (12-1-69) 



SUBROUTINE DESCRIPTIONS 



3.4.48.6 Design Requirements 
Subroutines used: WPLTi. 



3.4-80 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.49 PRINT (Print a Title on a Plotter) . 

3.4.49.1 Entry Point: PRINT. 

3.4.49.2 Purpose 
To type a title on a plotter horizontally or vertically. 

3.4.49.3 Calling Sequence 

CALL PRINT(X,Y,XYD,CHR,N,0PT) 

C|i!MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

X,Y - starting or ending point of the title to be typed (always left-to-right or 
top-to-bottom) - real - input. 

(+1 if X = starting or ending point of the title - integer - input. 
XYD -| an. 

(+2 if Y = starting or ending point of the title - integer - input. 
CHR - title to be typed (four characters/word - left adjusted followed by blanks) 

BCD - input. 
N - number of words in the title - integer - input. 

^-1 to initiate the typing mode. 
0PT -<+l to terminate a series of plot commands. \ - integer - input. 

' to type a title. 

/PLTDAT/ 

CNTCHR = number of plotter counts per character in the x and y directions - real - input. 

3.4.49.4 Method 

If 0PT f 0, all other arguments are ignored and TIRE is called. Otherwise, each character 
in the title (CHR) is separated and put into another array (C). This is done for each 20 words 
of the title (80 characters), and TIPE is then called to type these characters. 

3.4.49.5 Design Requirements 

Generally, one of the typing subroutines (PRINT, TIPE, TYPFLT, TYPINT, SYMB0L) should be 

3.4-81 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

called with 0PT = -1 before any typing is attempted, even though it is not necessary to specifi- 
cally put all plotters in the typing mode (e.g., plotter 3). Once this is done, it need not be 
repeated unless the plotter has been put into some other mode (e.g., the line mode). 
Subroutines used: TIRE. 



3.4-82 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.50 RDM0DX (Read a File Containing XRCARD Translations) . 

3.4.50.1 Entry Points: RDM0DX, RDM0DY, RDM0DE, RDW0RD. 

3.4.50.2 Purpose 

Tc read from a file or storage a record containing the subroutine XRCARD interpretation of 
free field data cards (e.g., the PCDB data block). 

3.4.50.3 Calling Sequence 

CALL RDM0DX(FILE,M0DE„W0RD) 
CALL RDM0DY(A,M0DE.W0RD) 
CALL RDM0DE($ni,$n2,$n3) 
CALL RDW0RD 
where: 

FILE = GIN0 file name which is to be read - integer - input. 

M0DE = storage location into which the XRCARD mode value is to be read - integer - output. 

W0RD = 2 locations into which XRCARD card items are to be read - integer - output. 

A = array which is to be "read" (instead of FILE) - integer - input. 

ni = the F0RTRAN statement number defining the return at which numeric data are 
interpreted (M0DE < 0). 

n2 -■ the F0RTRAN statement number defining the return at which alphabetic data are 
interpreted (0 < M0DE < 1,000,000). 

ns = the F0RTRAN statement number defining the return when the end of a logical card 
is encountered (M0DE >^ 1,000,000). 

3.4.50.4 Method 

RDM0DX and RDM0DY are initialization calls for the file and core oriented options respectively. 
For RDM0DE: 

1. An XRCARD mode value is read into M0DE. If M0DE = 0, the end of a physical card 
has been encountered, but not the end of a logical card. In this case, the record is ter- 
minated (if FILE is being read). Then the first word of the next record or location is read 
into M0DE. 

3.4-83 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

2. If M0DE < 0, the next word is read into W0RD(1). If M0DE = -4, another word is 
read into W0RD(2), 

3. If < M0DE < 1,000,000. BCD information follows as pairs of 4-character words. The 
first two of these words are read into NEXT(l) and NEXT(2). If NEXT(l) is a blank or NEXT(2) 
is a delimiter, the value of M0DE is decremented by one, and if M0DE is still greater than 
zero, the next two words are read into NEXT(l) and NEXT(2). This continues until either 
M0DE = 0. or NEXT(l) is not a blank and NEXT(2) is not a delimiter. If M0DE does become 
zero, step 1 is then re-executed. 

4. If M0DE >^ 1,000,000, the end of a logical card has been encountered. If FILE is 
being read, the current record is terminated. 

For RDW0RD: 

1. The two words now in NEXT(l) and NEXT{2) are stored in W0RD(1) and W0RD(2). 

2. M0DE is decremented by one. If M0DE is still gerater than zero, the next two 
words are read into NEXT(l) and NEXT(2). If NEXT(l) is a blank or NEXT(2) is a delimiter, 
this step is repeated until either M0DE = 0, or NEXT(l) is not a blank and NEXT(2) is not a 
delimiter. 

3.4.50.5 Design Requirements 

RDM0DX or RDM0DY must be called before RDM0DE and RDU0RD. As long as FILE does not change 
in value, and M0DE, W0RD, and A do not change locations, RDM0DX and RDM0DY need not be called 
again. If RDM0DX is called, FILE must be opened and properly positioned by the calling program. 
In addition, RDM0DE and RDW0RD cannot be called when FILE is closed. If an end-of-file or-record 
condition is encountered, a fatal error occurs (see subroutine FREAD). 



.4-84 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3,4.51 SGINi3 (G1N0 for Unformatted Tapes) . 

3.4.51.1 Entry Points: S0PEN, SWRITE, SE0F, SCL0SE. 

3.4.51.2 Purpose 

To write unformatted BCD and binary tapes to drive NASTRAN plotters. 

3.4.51.3 Calling Sequences 

CALL S0PEN{$n,PLTTP, BUFFER, LBUFF) 

n -- F0RTRAN statement number defining the return if PLTTP is not available 
for writing. 

PLTTP - GIN0 file name of the plot tape. This may have two values: PLTl - BCD plot 
tape; PLT2 - binary plot tape - BCD - input. 

BUFFER - Array in which the plot data transmitted during SWRITE calls are stored. 
LBUFF - Length of the buffer array - integer - input. 

CALL SWRITE(PLTTP,DATA.LDATA,I0PT) 

PLTTP - GIN0 file name of the plot tape - BCD - input. 

DATA - Array of plot data (1 character/word, right justified, leading zeros). 

LDATA - Length of the DATA array in words - integer - input. 

(o, potentially more data to be transmitted in this record. 1 
i0PT -J integer - input. 

(1, end of record with this data transmission. | 

CALL SE0F(PLTTP) 

PLTTP - GIN0 file name of the plot tape on which a physical E0F will be written. 
CALL SCL|aSE( PLTTP) 

PLTTP - GIN0 file name of the plot tape. 

3.4.51.4 Method 

SGIN!3 stores data in BUFFER until I0PT = 1 or BUFFER is filled. It then transmits the data 
to a physical tape without any control words. The data are transmitted to SGIN0 1 character (right 

3.4-85 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

justified, leading zeros) per word. SGIN0 packs these characters into fuil words. SGIN0 is in 
FORTRAN on all machines. On the IBM 7094 it interfaces with GIN0; the Univac 1108 version uses 
NTRAN; the IBM S/360 uses F0RTRAN 1/0; and the CDC 6600 use XI0RTNS, See section 5 for details. 

3.4.51.5 Design Requirements 

Only one of PLT1 or PLT2 may be open at one time. 

S0PEN must be called before SWRITE, SE0F, or SCL0SE. 

PLTl or PLT2 must be physical tapes if they are written on. 



3.4-86 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.52 STPLglT (To Initiate a New Plot or Terminate the Current Plot ). 

3.4.52.1 Entry Point: STPL0T. 

3.4.52.2 Purpose 

To initiate a new plot or terminate the current plot. 

3.4.52.3 Calling Sequence 

CALL STPL0T(PLTNUM) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

C(3MM0N/XXFARM/ - see XXPARM Miscellaneous Table description, section 2.5. 



where: 



if nonnegative, the plot number ) 
PLTNUM = [ - integer - input, 

(if negative, terminate the current plot 



/PLTDAT/ 

M0DEL = plotter model index - integer - input. 

PL0TER = plotter number - integer - input. 

REG = plot region parameters - real - input. 

XYMAX = size of the paper (x.y) used, less the borders, in plotter units - real - input. 

PLTYPE = plotter type - integer - input. 

PLTAPE = plot tape - BCD - input. 

10 if an end-of-file mark is to be written on the plot 

j tape after each plot 
^9f ^ { \ - integer - input. 

Jl if n£ end-of-file mark is to be written on the plot 

I tape after each plot 
/XXPARM/ 

CAMERA = camera number (if applicable) to be used - integer - input. 
BFRAMS = number of blank frames between plots - integer - input. 



3.4-87 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.52.4 Method 

A. If PLTNUM is nonnegatlve: 

1. Select the specified camera or create a setup record appropriate to the plotter 
(CALL SELCAM). 

2. Skip to a new frame (if applicable) and create the owner identification. If the 
owner identification is generated by subroutine IDPL0T, re-execute step 1 and skip to a 
new frame. 

3. If appropriate to this plotter, insert the desired number of blank frames on film 
only. If the camera specified is camera 2 (paper only), no blank frames are inserted. 

4. If the plot number is nonzero, type this number in the upper left and right corners 
of the picture. 

B. If PLTNUM is negative: 

1. Terminate the current plot tape record. 

2. Close the current plot tape file (CALL SCL0SE). 

3. If each plot is to be separated by an end-of-file mark (EOF = 0), write an end-of- 
file on the plot tape (CALL SEjJF). 

3.4.52.5 Design Requirements 

Subroutines used include: IDPL0T, SELCAM, SKPFRM, TYPINT, SCL|i)SE, SE0F. 



3.4-87a (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.53 SYMB0L (Type a Symbol on a Plotter) . 

3.4.53.1 Entry Point: SYMBOL. 

3.4.53.2 Purpose 

To type a symbol on a plotter. 

3.4.53.3 Calling Sequence 

CALL SYMB(3L(X,Y,SYM,SIPT) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 
C0MM0N/SYMBLS/ - see SYMBLS Miscellaneous Table description, section 2.5. 

where: 

X,Y - point at which the symbol is to be typed - real - input. 

SYM - two consecutive storage locations each containing an index into the SYMBLS 
table - integer - input. 

!-l to initiate the typing mode. \ 
+1 to terminate a series of plot commands. > -integer - input. 
to type the symbol . / 

/PLTDAT/ 

M0OEL - plotter model number - integer - input. 

PL0TER - plotter number (i) - integer - input. 
/SYMBLS/ 

NSYM - number of symbols defined in the SYMBLS table - integer - input. 

SYMBL(20,i) - character indices defining the symbols of plotter i - integer - input. 

3.4.53.4 Method 

If 0PT t 0, all other arguments are ignored and TYPEi or DRWCHR is called. Otherwise, an 
alternate symbol index (SYMX) is calculated modulo NSYM for each index in SYM and is used as the 
actual symbol index, as follows: 

3.4-88 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIOtlS 

SYMX = SYM. - NSYM*((SYM. ,)/NSYM) , j = 1, 2. 

Then TYPEi or DRWCHR is called for each symbol. 

The reason for SYM being two indices is to enable the user to create any additional symbol 
by combining any two of the valid symbols in the SYMBLS table. Note: any of the indices in SYM 
may = 0. This would imply that a new symbol is not being created. 

3.4.53.5 Design Requirements 

Generally, one of the typing subroutines (PRINT, TIPE, TYPFLT. TYPINT, SYMBOL) should be 
called with 0PT ^ -1 before any typing is attempted, even though it is not necessary to put all 
plotters in the typing mode (e.g., plotter 3). Once this is done, it need not be repeated unless 
the plotter has been put into some other mode (e.g., the line mode). 

Subroutines used: TYPEi, DRWCHR. 



3.4-89 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.54 TIPE (Type a Line of Characters on a Plotter ). 

3.4.54.1 Entry Point: TIPE. 

3.4.54.2 Purpose 

To type a line of characters on a plotter horizontally or vertically. 

3.4.54.3 Calling Sequences 

CALL TIPE (X,Y,XYD,CHR,N,(JPT) 

C8IMMJIN/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

C0MM(JN/CHAR94/ - see CHAR94 Miscellaneous Table description, section 2.5. 

where: 

X,Y - starting or ending point of the line to be typed (always left-to-right or top-to- 
bottom) - real - input. 

!+l if X = starting or ending point of the line. ) 
- \ - integer - input. 

+2 if Y = starting or ending point of the line. ) 

CHR - line of characters to be typed (one character/word - left adjusted followed by 

blanks) - BCD - ir.put. 

N - number of characters to be typed - integer - input. 

^-1 to initiate typing mode. \ 

(3PT -<+l to terminate a series of plot commands. > - integer - input. 
V to type a line of characters. ) 

/PLTDAT/ 

M0DEL - plotter model number - integer - input. 

PL(JTER - plotter number (i) - integer - input. 

CNTCHR - number of plotter counts per character in the x and y directions - real - input. 
/CHAR94/ 

CHAR - Section I of the CHAR94 table - BCD - input. 

3.4-90 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 



3.4.54.4 Method 

If 0PT ^ 0, an other arguments are ignored and TYPEi or DRUCHR is called. Otherwise, for 
each character to be typed, an index into the CHAR character set is found. This is done 80 
characters at a time. If a character cannot be located, it is treated as a blank. For each set 
of 80 character indices set up, TYPEi or DRWCHR is called. 

3.4.54.5 Design Requirements 

Generally, one of the typing subroutines (PRINT, TIPE, TYPFLT, TYPINT, SYMB0L) should be 
called with 0PT f -1 before any typing is attempted, even though it is not necessary to put all 
plotters in the typing mode (e.g., plotter 3). Once this is done, it need not be repeated unless 
the plotter has been put into some other mode (e.g., the line mode). 

Subroutines used: TYPEi, DRWCHR. 



3.4-91 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.55 TYPFi (Type a Line of Characters on Plotter i) . 

3.4.55.1 Entry Point: TYPEi . 

3.4.55.2 Purpose 

To type a line of characters on plotter i horiziontally or vertically. 

3.4.55.3 Calling Sequence 

CALL TYPEi{X,Y,XYD,CHR,N,0PT) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

C0MM0N/CHAR94/ - see CHAR94 Miscellaneous Table description, section 2.5. 

where: 

X,Y = starting or ending point of the line to be typed (always right-to-left or top-to 

bottom) - real - input. 

(+1 if X = starting or ending point of the line. I 
XYD = I - integer - input. 

(+2 if y = starting or ending point of the line. ) 

CHR = indices of the line of characters to be typed (see description for TIPE. section 
3.4.54) - integer - input. 

N = number of characters to be typed - integer - input. 

!-l to initiate the typing mode, \ 
+1 to terminate a series of plot commands) - integer - input. 
to type a line of characters. / 

/PLTDAT/ 

XYMIN = minimum x and y values of the region in which the line is to be typed - real - 
input. 

XYMAX = maximum x and y values of the region in which the line is to be typed - real - 
input. 

CNTCHR = number of plotter counts per character in the x and y directions - real - input. 



3.4-92 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

/CHAR94/ 

CHRC0D = Section II, III, or IV of the CHAR94 table - integer - input. 
3.4.55.4 Method 

If 0PT i^ 0, all other arguments are ignored. If 0PT = -1 and if applicable for plotter i, a 
flag is set so that when TYPEi is subsequently called with 0PT = 0, the plotter will be put into 
the typing mode before typing the first character. If 0PT = +1, the current sequence of plotter 
commands is terminated. 

Define: 

LSTCHR = last legitmale character index for plotter i. 

NCHR = number of character indices which must be changed for plotter i. 

CHAR = NCHR pairs of character indices. The first index of each pair is the index 
which must be changed, and the second index is the replacement index. 
If N _< 0, it is assumed that one character is to be typed. 

Each character index in CHR is checked against LSTCHR. If the index is greater than LSTCHR. 
a blank is inserted at the corresponding point on the plot. Otherwise, indices are altered if 
need be from CHAR and the character is typed. 

No characters will be typed outside the region as defined by XYMIN and XYMAX. 
3.4.55.5 Design Requirements 
Subroutines used: WPLTi. 



3.4-93 (12-1-69) 



SUBROUTINE DESCRIPTIONS 



3.4.55 TYPFLT (Type a Floating Point Number on a Plotter) . 

3.4.56.1 Entry Point: TYPFLT. 

3.4.56.2 Purpose 

To type a floating point number on a plotter, horizontally or vertically. 

3.4.56.3 Calling Sequence 

CALL TYPFLT (X.Y.XYD.V, FIELD, 0PT) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

- point at which the number is to be typed (always left-to-right or top-to-bottom) 



X,Y 



- real - input. 



XYD 



(+1 if X = starting or ending point of the typed number. I 
_ ) - J - integer - input. 

I +2 if Y = starting or ending point of the typed number. ) 
V - number to be typed - real - input. 
FIELD - field width of the typed number. If FIELD > 0, the number will be centered at 

(X,Y). If FIELD < 0, the number will be typed starting or ending at (X,Y). If 

|XYD| = 1 or 2, the number will be typed horizontally or vertically 

respectively - integer - input. 



-1 to initiate the typing mode. 



m 



I 



+1 to terminate a series of plot commands. I - integer - input. 



to type the number. 
/PLTDAT/ 

M0DEL - plotter model number - integer - input. 

PL0TER - plotter number (i) - integer - input. 

CNTCHR - number of plotter counts per character in the x and y directions - real - input. 

3,4,56.4 Method 

If 0PT ?* 0, all other arguments are ignored and TYPEi or DRWCHR is called. Otherwise, the 



3.4-94 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

number of significant digits (NSIG) to be typed is determined. 

If V > 0, the typed number will be unsigned. If FIELD > 4, the number of significant digits 
typed will be at least = FIELD - 4. If FIELD < 4, NSIG = FIELD - 1. 

If V < 0, the typed number will be signed. If FIELD > 5, the number of significant digits 
typed will be at least FIELD - 5. If FIELD <_ 5, KSIG = FIELD - 2. 

The number (V) is multiplied by some power of ten such that the product is between lo'' and 

Q 

10 . It can then be expressed as an 8-significant digit integer. If the number is such that NSIG 
digits cannot be typed without an exponent, a standard form is used: -X.XXXX ... + XX. Otherwise 
the decimal point is adjusted and the exponent will not be printed. 

3.4.56.5 Design Requirements 

Generally, one of the typing subroutines (PRINT, TIPE, TYPFLT, TYPINT, SYMB0L) should be 
called with 0PT = -1 before any typing is attempted, even though it is not necessary to put all the 
plotters in the typing mode (e.g.. plotter 3). Once this is done, it need not be repeated unless 
the plotter has been put into some other mode (e.g., the line mode). 
Subroutines used: TYPEi , DRWCHR. 

3.4.56.6 Diagnostic Messages 

If NSIG significant digits cannot possibly be typed in the field width (FIELD) specified, 
the entire field will be filled with asterisks (**...*). 



3.4-95 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.57 TYPINT (Type an Integer Number on a Plotter) . 

3.4.57.1 Entry Point: TYPINT. 

3.4.57.2 Purpose 

To type an integer number on a plotter, horizontally or vertically. 

3.4.57.3 Calling Sequence 

CALL TYPINT (X.Y.XYD.NUM, FIELD, 0PT) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

X,Y - point at which the number is to be typed (always left-to-right or top-to-bottom) 
- real - input. 

!+l if X = starting or ending point of the typed number.) 
— ' - integer - input. 

+2 if Y = starting or ending point of the typed number.) 

NUM - number to be typed - integer - input. 

/+1 if the typed number is to be centered at (X.Y). If |XYDl = 1 or 2, the number 
will be typed horizontally or vertically, respectively. 
-1 or 0, the number will be typed starting or ending at (X,Y). If FIELD = -1, 
FIELD will be set to the number of digits typed by the subroutine; in this 
case, FIELD must be a symbol in the call statement. - integer - input and 
output. 

■ 1 to initiate the typing mode. \ 
0PT -{+1 to terminate a series of plot commands. \ -integer - input. 
to type the number. / 

/PLTDAT/ 

M0DEL - plotter model number - integer - input. 

PL0TER - plotter number (i) - integer - input. 

CNTCHR - number of plotter counts per character in the x and y directions - real - input. 



3.4-96 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.57.4 Method 

If 0PT fO, all other arguments are ignored and TYPEi or DRWCHR is called. Otherwise, each 
digit of the number is separated and used as character indices for the TYPEi or DRWCHR subroutines. 
In addition, if FIELD < 0, FIELD is set = the number of digits printed. 

3.4.57.5 Design Requirements 

Generally, one of the typing subroutines (PRINT, TIPE, TYPFLT, TYPINT, SYMB0L) should be 
called with 0PT = -1 before any typing is attempted, even though it is not necessary to 
specifically put all plotters in the typing mode (e.g., plotter 3). Once this is done, it need 
not be repeated unless the plotter has been put into some other mode (e.g., the line mode). 

Subroutines used: TYPEi, DRWCHR. 



3.4-97 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.58 WPLT1 (Write a Plotter Conmand for Plotter 1) . 

3.4.58.1 Entry Point: WPLTl. 

3.4.58.2 Purpose 

To write a plotter command for plotter 1. 

3.4.58.3 Calling Sequence 

CALL WPLTl (A,0PT) 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

C0MM0N/CHAR94/ - see CHAR94 Miscellaneous Table description, section 2.5. 

where: 

A(l) - x-coordinate (integer). 

A(2) - y-coordinate (integer). 

A(3) - annotation character index (a). 

A(4) - control character index (ci). 

A(5) - control character index (cz). 

A(6) - control character index (ca). 

(0, if A is a plot command ) 

0PJ .) } integer - input, 

(l , if a series of plot commands is to be terminated ) 

/PLTDAT/ 

EDGE - size of the x and y borders of the paper - real - input. 

PL0T - GINS) file name of the plot tape to be written - BCD - input. 

/CHAR94/ 

CHAR(60,3) - sections II, III, and IV of the CHAR94 character table - integer - input. 

3.4.58.4 Method 

If computer 1 (IBM 7094) is the computer being used, section II of the CHAR94 table is used 
as the characters written on the plot tape; if computer 4 (CDC 6600) section IV is used; if any 

3.4-98 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

other computer, section III is used. 

The lower left corner of the paper is assumed to be at (O.O). Taking into account the x and 
y borders, the true x and y coordinates are calculated. These coordinates are then separated into 
four integer digits. The plot command is then set up and written as follows: 

rbx4X2X2Xibby^y2y2yibCiC2bbc2babbbbb 

preceeded by 35 blanks. The resulting plot command is 60 characters long, 

r = record mark (character 49 in the CHAR94 table) 

b = blank (character 48 in the CHAR94 table) 

X. = x-coordinate digit 

y. = y-coordinate digit 

c. = control character 

a = annotation character. 

3.4.58.5 Design Requirements 

Subroutine used: SWRITE. 



3.4-99 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.59 UPLT2 (Write a Plotter Command for Plotters 2 and 8 ) 

3.4.59.1 Entry Point: WPLT2. 

3.4.59.2 Purpose 

To write a plot conmand for plotters 2 and 8. 

3.4.59.3 Calling Sequence 

CALL UPLT2 {k,m) 

C0MMS)N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

C;JMM0N/CHAR94/ - see CHAR94 Miscellaneous Table description, section 2.5. 

where: 

A(l) = x-coordinate (integer). 

A(2) = y-coordinate (integer). 

A(3) = annotation character index (a). 

A(4) = control character index (ci). 

A(5) = control character index (02). 

A(6) = control character index (ca). 

(0, if A = plot command ) 

0PT =< /--integer - input. 

(1, if a series of plot commands is to be terminated' 

/PLTDAT/ 

AXYMAX - size of the paper (in plotter units) being used, less the border - real - input. 

PL0T - GIN0 file name of the plot tape to be written - BCD - input. 
/CHAR94/ 

CHAR(60,3) - sections II, III and IV of the CHAR94 table - integer - input. 

3.4.59.4 Method 

If computer 1 (IBM 7094) is the computer being used, section II of the CHAR94 table is used 
for the characters written on the plot tape; if computer 4 (CDC 6600), section IV is used; if any 

3.4-100 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

other computer, section III is used. 

Assuming the true physical origin of the plotter to be at tlie center of the paper, the true 
X and y coordinates are calculated. These coordinates are then separated into four integer digits. 
A plot command is then set up and written as follows: 

Xs^x^X2X2X^Ys v^y2y2yibbbbbbbbc^C2ac2 

preceeded by 96 blanks. The resulting plot command is 120 characters long. 
X = character X (character 34 in the CUAR94 table) 
Y = character Y (character 35 in the CHAR94 table) 
s^ = + or - character depending upon the sign of the x-coordinate. 
s = + or - character depending upon the sign of the y-coordinate. 
X. = x-coordinate digit, 
y. = y-coordinate digit. 

b = blank (character 48 in the CHAR94 table). 
c^ = control character. 
a = annotation character. 

3.4.59.5 Design Requirements 

Subroutine used: SWRITE. 



3.4-101 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.60 WPLT3 (Write a Plotter Command for Plotter 3 ). 

3.4.60.1 Entry Point: WPLT3. 

3.4.60.2 Purpose 

To write a plot command for plotter 3. 

3.4.60.3 Calling Sequence 

CALL WPLT3 (A,0PT) 

C0HM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

A(l) and A(2) = 36 bit plot command set up by AXIS3, LINE3, or TYPE3, as 2 18-bit words 
(right justified, leading zeros) - input. 

(O, if A = plot command ) 

0PT =1 ) - integer - input. 

11, if a series of plot commands is to be terminated; 

/PLTDAT/ 

PL0T - GIN0 file name of the plot tape to be written - BCD - input. 

[■lAXCHR - plot tape buffer size (number of characters) - integer - input. 

3.4.60.4 Method 

Each plotter command is 36 bits long (6 six-bit characters). Six of the 36 bits in A(l) and 
A(2) are written on the plot tape until all 36 bits have been written. In addition, the number 
of six-bit characters written in a record is calculated. When WPLT3 is called with |i)PT = 1, a 
check is made to determine if the number of 6 bit characters written in the current record is 
an integer multiple of the number of characters per word on the computer. If such is not the case, 
an additional 36 bit command is written as many times as necessary until this condition does 
exist before terminating the plot tape record. The command used will do nothing to affect the 
generated plot. 

3.4.60.5 Design Requirements 
Subroutine used: SWRITE. 

3.4-102 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.61 GIN0I0 (GINg Input/Output Routine ). 

3.4.61.1 Entry Point: GIN0I0. 

3.4.61.2 Purpose 
6IN0I0 executes the physical input/output operations for subroutine RIN?. 

3.4.61 .3 Calling Sequence 

CALL GIN0I0($n,0PC!2IDE.BUFF) 

C0MM0N/GIN0X/LGIN2IX,FILEX,E0R,!3P, ENTRY, LSTNAM.N, NAME, NTAPE,XYZ(2),UNITAB(75),BUFADD(75), 
N3UFF3,ERR0R,N0SECT. 

n - F0RTRAN statement number defining return in the event of an 1/0 error. 

1, Rewind 

2, Write one block 
0PC0DE - (3, Read one block ) input - integer. 

4, Backspace one block 
'5, Forward space one block 

BUFF - Address of the block to be read or written. 

FILEX - Unit number of file - integer - innut. 

NBUFF3 - Length of block to be read or written - integer - innut. 

J 7, Abnormal completion of 1/0 operation 
8, Physical end-of-file encountered ^ integer - output. 

,9, Data transmission error 

N0SECT - Number of sectors per block on FASTRAND drum (Univac 1108 only) - integer - input. 

3.4.51.4 Method 

The machine cell in /SYSTEM/ is tested. For the IBM 7094 or IBM S/360 computers, F0RTRAN REWIND, 
iJRITE, READ and BACKSPACE operations are used. For the Univac 1108, the NTRAN routine is used. 

3.4.61.5 Design Requirements 

GIN0I0 is designed as an integral part of the GIN0 collection of routines and i s to be 
called only by GIN0. 



3.4-103 



SUBROUTINE DESCRIPTIONS 

Since all input/output operations by 61N0 are made by Glt<010, a change to interface with a 
new or different operating system can easily be made by modifying GIN0I0. 



3.4-104 



UTILITY SUljROUTINE DESCRIPTIONS 

3.4.62 EJECT (Automatic Page Eject) 

3.4.62.1 Entry Point: EJECT 

3.4.62.2 Purpose 

Automatic line counting for printed oulpul and new page initiation when pages are filled. 

3.4.62.3 Calling Sequence 

K = EJECT (LINES) 

C0MM0N /SYSTEM/ - see SYSTEM table description, section 2.4.1.8. 

where: 

LINES - Number of lines to be printed. 

/SYSTEM/ 

MAXLIN - Maximum number of lines permitted per page. 
LINCNT - Number of lines thus far printed on this page. 

3.4.62.4 Method 

If the number of lines already printed on this page (LINCNT) added to the number of lines 
about to be printed (LINES) would be greater than the number of lines permitted per page 
(MAXLIN), a new page is started (CALL PAGEl) , the current line counter is set to the number 
of lines to be printed (LINCNT = LINES), and the result of this function is set to 1 (EJECT = 1) 

If the number of lines about to be printed (LINES) will fit on this page (LINCNT + LINES <_ 
(^XLIN). the result of this function is set to (EJECT = 0). 

3.4.62.5 Design Requirements 

If it is desired to force a new page to be started, simply set LINCNT = MAXLIN before 
calling this function. 



3.4-105 



SUBROUTINE DESCRIPTIONS 

3.4,63 PLAMAT (Material Property Utility for Two-Dimensional Elements in Piecewise Linear 
Analysis ). 

3.4.63.1 Entry Point: PLAMAT. 

3.4.63.2 Purpose 

To perform the following matrix operation: 

[C] = [A]T [B] [A] . 

where [A] is equal to [U] (see the subroutine description for PREMAT and MAT, section 3.4.36.3, 
for a definition of [U] with INFLAG = 2), and [B] is equal to a previously calculated material 
properties matrix which is in common block /PLAGP/, The result [C], which is symmetric, is stored 
in common block /MAT0UT/, 

3.4.63.3 Calling Sequence 

CALL PLAMAT 

C0MM0N/PLAGP/GP(9),MIDGP,ELID 

C0MM0N/MATIN/MATID, INFLAG, ELTEMP,PLAARG,SINTH,C0STH 

C0MM(aN/MAT0UT/Gll,G12,G13,G22,G23,G33,DUMMY(14) 

where: 

/PLAGP/ 

GP(9) = 3x3 material properties matrix calculated in a PLA element driver - real - input. 

MIDGP = the material identification number associated with GP - integer - input. 

ELID = the element identification number associated with GP - integer - input. 
/mTIN/ 

HATID = the incoming material identification number - integer - input. 

ikflag\ 

ELTEMP>= not used by PLAflAT. 
PLAARG ) 

3.4-106 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

SINTH = Sine of the material property orientation angle - real - input. 

CfilSTH = Cosine of the material property orientation angle - real - input. 

/MAT(3UT/ 

Same as /MAT0UT/ with INFLAG = 2 as described in section 3.4.36.3 except only the first 
six cells are used. 

3.4.63.4 Method 

This routine checks to see if the incoming material identification number (MATID) is equal to 
the material identification number (MIDGP) which was used to calculate the material properties 
matrix stored in /PLAGP/. If they are not equal, this routine calls MAT with INFLAG = 2 and 
returns to the calling program. This will only happen in combination elements (TRIAl , TRIA2, 
QUADl , QUAD2) where there is a different material identification number used for the membrane and 
plate properties. If they are equal, then the matrix operation described above is performed. 



3.4-107 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4.64 IJPLT4 {virite a Plotter Command for Plotters 4 Through 7 ). 

3.4.64.1 Entry Point: !'JPLT4. 

3.4.64.2 Purpose 
To write plot commands for plotters 4 through 7. 

3.4.64.3 Calling Sequence 

CALL WPLT4 (A,0PT) 

CSi)MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

a(1) = command type (0 = control, 2 = line, 4 = position) 

^ - integer, 

A(2-N) = additional data used to generate the plot commands (contents and( 

input, 
length, N, vary with conmand type) 



|0, if a plot command is to be generated I 

(l, if the current command buffer is to be terminated I 



0PT - V . integer, input. 



/PLTDAT/ 



PLTMDL = plotter model number - integer - input. 

PL0TER = plotter number - integer - input. 

PL0T = GIN0 file name of the plot tape to be written - BCD - input. 

3.4.64.4 ;1ethod 

The resulting plot command varies in length, depending both on the command type and the amount 
of necessary drum movement. If A(l ) = (control command), A(2) = number of control characters 
in the resulting command (one character expressed as a right adjusted integer in each word of the 
A array, starting in A(3)). 

If A(l) = 2 or 4 (line or positioning command), the resulting plot command will begin with the 
characters necessary to lower or raise the pen, respectively, unless the pen is already down or up, 
respectively. A(2) and A(3) contain the number of X and Y half steps necessary to draw the line 



3.4-108 (7/1/70) 



UTILITY SUBROUTINE DESCRIPTIONS 

(with the pen down or up), while A(4) and A(5) contain pointers to two character strings needed to 
draw the entire line except for the final half step. A(6) and A(7) contain the pointers needed to 
draw the last half step of the line only. The pointers in A(4 - 7) will cause drum movements as 
follows: 

1 = +Y 9 = +Y/2 17 = +X/2, +Y 

2 = +X, +Y 10 = +X/2, +Y/2 18 = -X, +Y/2 

3 = +X 11 = +X/2 19 = +X, -Y/2 

4 = +X, -Y 12 = +X/2, -Y/2 20 = +X/2, -Y 

5 = -Y 13 = -Y/2 21 = -X/2, -Y 

6 = -X, -Y 14 = -X/2, -Y/2 22 = -X, -Y/2 

7 = -X 15 = -X/2 23 = -X, +Y/2 

8 = -X, +Y 16 = -X/2, +Y/2 24 = -X/2, +Y 

The number of characters in a string is a function of the internal plotter model number, PLTMDL. 
If PLTMDL = 1, each string is three characters; if PLTMDL = 2 or 4, each string is tv/o characters; 
and if PLTMDL = 3 or 5, each string is only one character. 

As required, this subroutine will automatically initiate each plot tape record with the 
necessary "conditioning, synchronizing, and start plot" characters, and terminate each plot tape 
record with the necessary "stop plot" characters. 

3.4.64.5 Design Requirements 

The only incremental drum movements available for the CALCOMP drum plotter indicated as 
PLTMDL = 1 are the first eight (8) as listed above. Therefore, when A(l) = 2 or 4, the values in 
A(4 - 7) must be less than nine (9). 

Subroutine used: SWRITE. 



3.4-109 (7/1/70) 



SUBROUTINE DESCRIPTIONS 

3.4.65 WPLT9 (Write a Plotter Command for Plotter 9) . 

3.4.65.1 Entry Point: WPLT9. 

3.4.65.2 Purpose 

To write a plot command for plotter 9. 

3.4.65.3 Calling Sequence 

CALL WPLT9 (A,0PT) 

C9m9H/Pi^O^J/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

A = 10-character plot command (1 character per word, right justified, leading 
zeros) - integer - input. 

iO if A = plot command | 

/ integer - input. 
1 if a series of plot commands is to be terminated ) 

/PLTDAT/ 

PL0T = GIM0 file name of the plot tape to be written - BCD - input. 

3.4.65.4 Method 

If 0PT = 0, the 10 characters are written on the plot tape without any changes. If 0PT = 1 , 
two characters are appended to the current record: 

62g (EXIT code) and 61g (N0P code). 

3.4.65.5 Design Requirements 
Subroutine used: SWRITE. 



3.4-no (12-1-69) 



- integer - input. 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.66 WPLT1Q (Write a Plotter Coinmand for the NASTRAN General Purpose Plotter ), 

3.4.66.1 Entry Point: WPLTIO. 

3.4.66.2 Purpose 
To write the plotter commands for the NASTRAN general purpose plotter. 

3.4.66.3 Calling Sequence 

CALL WPLTIO (A,0PT) 

C0MMiaN/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

A(l) = plot mode index 

A(2) = control index 

A(3) = x, = x-coordinate 

A(4) = y-i = y-coordinate 

A(5) = x„ = x-coordinate 

A(6) = Yp = y-coordinate 

(0 if A = plot command ) 

0PT =1 / - integer - input, 

(l if a series of plot commands is to be terminated) 

/PLTDAT/ 

EDGE = size of the borders (x,y) in plotter units - real - input. 

PL0T = GIN0 file name of the plot tape to be written - BCD - input. 

f'lAXCHR = plot tape buffer size (number of characters) - integer - input. 

3.4.66.4 Method 

Each plot command written is composed of 30 six-bit unsigned integers. The plot mode index, 
A(l), and the control index, A(2), are the first two integers. The next 20 integers represent 
the values in A(3-6). Each value is represented by five 6-bit integers, each integer being a 
decimal digit of the decimal representation of the value as follows: 

3.4-111 (12-1-69) 



SUBROUTINE DESCRIPTIONS 



where the original integer value is given by 

dQ.lO^ + d^.10^ + d2.10^ + d3.10^ + d^.lO° . 

This representation is used so as to make it easy to recover the original integer values on any 
binary computer. The last 8 characters are always zeros. 

The end result is a plot command of the following format: 

MCP^P3P2PiPQQ4Q3Q2QiqoR4R3R2'^l'^0^4^3^2^1^0°°°°°°°° 

where : 

M = plot mode index 

C = control index 

st 
P. = decimal digit of the 1 integer value 

Q. = decimal digit of the 2" integer value 

rd 
R^ = decimal digit of the 3 integer value 

S^ = decimal digit of the 4 integer value 

= zero 

When WPLTIO is called with 0PT = 1 , the current plot tape record is filled with as many dummy 
plot commands as is necessary to generate a fixed length record. The dummy plot command is made 
of 30 zeros. This is done so that the plot tape can be read in F0RTRAN without having to worry 
about variable length records as long as the plot tape buffer size (MAXCHR) is an integer multiple 
of the number of characters per word on the computer on which the plot tape is being read (see 
section 6.10.6 for further details). 

3.4.66.5 Design Requirements 

Subroutine used: SWRITE. 



3.4-112 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.67 PLTSET (Plotting Parameter Initialization) . 

3.4.67.1 Entry Point: PLTSET. 

3.4.67.2 Purpose 

Given the internal plotter and model numbers, to initialize the /XXPARM/ and /PLTDAT/ tables 
as needed by the NASTRAN plotter software package. 

3.4.67.3 Calling Sequence 

CALL PLTSET 

C0MM0N/XXPARM/ - see XXPARM Miscellaneous Table description, section 2.5. 

C0MM0N/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

where: 

/XXPARM/ 

PBUFSZ = plot tape buffer size (number of words) - integer - output. 

PAPSIZ = size of the paper to be used (inches) - real - input. 
/PLTDAT/ 

M0DEL = internal plotter model number - integer - input. 

PL0TER = internal plotter number - integer - input. 

REG = plotting region parameters - real - output. 

AXYMAX = size of the paper (x.y) used, less the borders, in plotter units - real - output. 

XYEDGE = size of the borders (x.y) in plotter units - real - output. 

XYMAX = maximum useable x and y coordinate values on the plotter - real - output. 

CNTSIN = number of plotter counts per inch of paper - real - output. 

CNTCHR = number of plotter counts per character in the x and y directions - real - output. 

PLTYPE = plotter type - integer - output. 

PBFSIZ = plot tape buffer size (number of characters) - integer - output. 



3.4-113 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

3.4,67,4 Method 

Using the internal plotter (PL0TER) and model (M0DEL) numbers, the initialization needed to 
properly use the NASTRAN plotting software is performed as follows: 

1. Section 2 of /PLTDAT/, of which XYMAX, CNTSIN, CNTCHR, PLTYPE and PBFSIZ are a part, is 
set to a duplicate of section PL0TER+2. 

2. PBUFSZ of /XXPARM/ is then set to PBFSIZ/CHRWRD where CHRWRD = number of characters per 
word on the subject computer, 

3. AXYMAX and XYEDGE are calculated based upon the plotter type and/or paper size. If the 
plotter is a table plotter (PLTYPE = +2 or -2), the borders are set up as 1/2 inch borders. 
If the plotter is not a table plotter and has no typing capability (PLTYPE = -1 or -3), 

the borders are set up as half the horizontal and vertical character sizes (CNTCHR/2), 
Otherwise, the borders are set to zero, 

4. The plotting region is then set to (0,0,AXYMAX(1) ,AXYMAX(2)) , This region can be sub- 
sequently altered by the module writer. 



3.4-114 (12-1-69) 



UTILITY SUBROUTmE DESCRIPTIONS 

3.4.68 DRWCHR (To Draw a Line of Characters) . 

3.4.68.1 Entry Point: DRWCHR. 

3.4.68.2 Purpose 

To draw a line of characters on a plotter, horizontally or vertically. 

3.4.68.3 Calling Sequence 

CALL DRWCllR (X,Y,XYD,CHR,NN,0PT) 

C0HM0H/PLTDAT/ - see PLTDAT Miscellaneous Table description, section 2.5. 

C0r'lM0N/CHRDRW/ - see CHRDRW Miscellaneous Table description, section 2.5. 

where: 

X,Y = starting or ending coordinate of the line of characters to be drawn (always left- to- 
right or top-to-bottom) - real - input. 

{+1 if X = starting or ending point of the line| 
> - integer - input. 
+2 if Y = starting or ending point of the line' 

CHR = indices of the line of characters to be drawn (see subroutine TiPE) - integer - 
input. 

M = number of the characters to be drawn - integer - input. 

-1 to initiate the line mode. 
0PT =^+1 to terminate a series of plot commands. ) - integer - input. 
to draw a line of characters. 

/PLTDAT/ 

REG = plot region parameters - real - input. 

XYilAX = size of the paper (x,y) used, less the borders, in plotter units - real - input. 

EDGE = size of the border (x,y) in plotter units - real - input. 

CNTCHR = number of plotter counts per character in the x and y directions - real - input. 
/CHRDRW/ 

LSTIND = index of the last character which can be drawn - integer - input. 

3.4-115 (12-1-69) 



SUBROUTINE DESCRIPTIONS 

CHRIND = indices into XYCHR used to locate the data needed to draw characters - integer 
- input. 

XYCHR = lines which must be drawn to produce alphanumeric characters - integer - input. 

3.4.68.4 Method 

If 0PT = 0, all other arguments are ignored and LINE is called. Otherwise, the characters 
are drawn. The width and height of each character position are assumed to be integer multiples 
of 8 and 16, respectively. The size of the drawn character will be this integer multiple of 6. 
The remaining space in each character position is used as the horizontal and vertical spacing. 
No character will be drawn outside the region specified in REG. 

3.4.68.5 Design Requirements 
Subroutine used: LINE. 



3.4-116 (12-1-69) 



UTILITY SUBROUTINE DESCRIPTIONS 

3.4.69 FNDPLT (Determine the Internal Plotter and Model Indices) . 

3.4.69.1 Entry Point: FNDPLT. 

3.4.69.2 Purpose 

Given the external name and model of a plotter, to determine the corresponding internal 
plotter and model numbers used by the NASTRAN plotting software package. 

3.4.69.3 Calling Sequence 

CALL FNDPLT (PLATER, M0DEL,PLTNAM,PM0DEL) 
where: 

PL0TER = internal plotter number - integer - output. 

i'I0DEL = internal model number - integer - output. 

PLTNAM(2) = external plotter name - BCD - input. 

PM0DEL(2) = external model name - integer or BCD - input and output. 

3.4.69.4 Method 

PLTNAM and PM0DEL are compared with an internal table of plotter names and models. When a 
match is found, PL0TER and M0DEL are set to the corresponding internal plotter and model numbers. 
If a match is found only for the plotter name (PLTNAM), the model name for the first model appro- 
priate to the matched model name will be used to determine PLjJTER and M0DEL, and the model name 
used will be stored in PH0DEL. If no match is found, PL0TER and M0DEL will be set to zero. See 
section 3.1 for further details. 



3.4-117 (12-1-69) 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5 MATRIX SUBROUTINE DESCRIPTIONS. 

3.b.l BLDPK (Build a Packed Column of a Matrix ). 

3.5.1.1 Entry Points: BLDPK, BLDPKI, ZBLPKI, BLDPKN. 

3.5.1.2 Purpose 

To write a column of a matrix in NASTRAN packed format. 

3.5.1.3 Calling Sequence 

If several different matrices are to be packed concurrently, the multi-column version is 



used: 



CALL BLDPK{TYPIN,TYP0UT,NAME,BL0CK,0PT,1 ) 
CALL BLDPKI(A,I,NAME,BL0CK,0PT) 
CALL BLDPKN(NAME,BL0CK,0PT,MCB) 

where: 

BLDPK is an initialization call and is made once for each column to be packed. 
BLDPKI is the call made to supply a single element of the column to be packed. 
BLDPKN is a call to terminate processing of the column. 

TYPIN - Arithmetic type of the elements to be packed (1 = real single precision, 2 = real 
double precision, 3 = complex single precision, 4 = complex double precision)- integer - input. 
TYP0UT - Arithmetic type of the elements in the packed column - integer - input. 

'0PT = 'WRITE': GIN0 file name of data block where packed column will be written. 



NAME - , 

^5IPT = 'WRTC0R': An array in core where packed column will be written. 

BLCICK - An array of dimension a 6 for use by BLDPK and BLDPKI. 

'WRITE': The packed column will be written by GIN0. ) i»»„* 
'WRTC0R': The packed column will be written in core, j ^"^""""^^"^ "^"^ 

A - An array of dimension 1, 2 or 4 (depending on TYPIN) where the element to be packed is 
stored - real - input. 

I - Row position of element to be packed - integer - input. 

HCB - An array of dimension 7 where the trailer information about the matrix is accumulated. 

If only one matrix is being packed, the single column version should be used as it is more 
efficient. 

C0MM0N/ZBLPKX/A(4),I 

3.5-1 



SUBROUTINE DESCRIPTIONS 



CALL BLDPK(TYPIN,TYP0UT,NAME,O, 0PT,O) 

CALL ZBLPKI 

CALL BLDPKN(NAME,O,0PT,MCB) 

where: 

BLDPK and its arguments are as defined above. 

ZBLPKI is the call made to provide an element of the column to be packed. The element (A), 
and its row position (I), are stored in /ZBLPKX/ by the user prior to each CALL ZBLPKI. 
BLDPKN and its parameters are defined as above. 

Note: 

BLDPKN accumulates the following two words of MOB: 

MCB(2) = column number 

MCB(6) = number of words in the densest column 

In the multi-column version, BL0CK must be different for each matrix being oacked. 

3.5.1.4 Method 

Format of a packed column (one logical record): 



Row 


position of 


first non- 


zero element 


Type 


of elements 


= TYP0UT 




Not 


used 






Not 


used 






Not 


used 






First non-zero € 


lement 




Row 


position of 


second non 


-zero element 




or second 


non-zero element 


Last 


non-zero element 




16777215 (intege 


r) = 24 "V 


bits 



' Column header 



Column body 



■Column trailer 



3.5-2 



MATRIX SUBROUTINE DESCRIPTIONS 

Example: 

Assume a column of a real single precision 19xN matrix is to be packed in real single 
precision form: 



Row Position 


Value 


Packed Format 


1 


0.0 


4 


2 


0.0 


1 


3 


0.0 


Not used 


4 


1 .0 


Not used 


5 


2.0 


Not used 


6 


0.0 


1.0 


7 


3.0 


2.0 


8 


4.0 


7 


9 


5.0 


3.0 


10 


5.0 


4.0 


11 


7.0 


5.0 


12 


8.0 


5.0 


13 


0.0 


7.0 


14 


0.0 


8.0 


15 


0.0 


15777215 


15 


0,0 




17 


0.0 




18 


0.0 




19 


0.0 





For each of the 15 possible combinations of TYPIN and TYPjJUT, BLDPK sets switches for the 
type of conversion to be used in packing. For the multi-column version, these switches and 
other pointers are saved in BL0CK. BLDPKI restores the switches and oointers and moves the 
element and its row position to /ZBLPKX/ then enters code common with ZBLPKI. If the element 
is zero, an immediate return is given. If the element is the first non-zero element for the 
column, the 5-word header is written followed by the element. Otherwise, the row position of 
the current element is compared to the row position of the last element. If the difference is 
unequal to one, the current row position is written. In either case, the non-zero element is 
written and return is made. 



3.5-3 



SUBROUTINE DESCRIPTIONS 

3.5.1.5 Design Requirements 

Let I. and I .^i be the rows positions of two elements supplied in successive calls to 
BLDPKI or ZBLPKI. Then I.^^ =- I. for all 1 of a column. 

If 0PT = 'WRTC0R', then the block NAME must be initialized prior to each call to RLDPK 
(see 0PNC0R). 

If the single column version is used, subroutine PACK may not be called between calls to 
BLDPK and BLDPKN. 

MCB{2) and MCB(6) must be set to zero by the user prior to the first call of BLDPKN for 
a matrix. 



3.5-4 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.2 PACK (Pack a Column of a Matrix) . 

3.5.2.1 Entry Point: PACK. 

3.5.2.2 Purpose 

To pack and write a column of a matrix. 

3.5.2.3 Calling Sequence 
C0MM0N/PACKX/TYPIN,TYP0UT,I,N.INCR 
CALL PACK(A,NAME,0PT,MCB) 

A - An array where the elements of the column are stored in unpacked form. 

l0PT = 'WRITE', GIN0 name of the data block where the packed column will be 
NAME - ^written. 

(0PT = 'WRTC0R', an array in core where the packed column will be stored. 



0PT 



jWRITE: Packed column will be written by GIN!3. ) ^ ^^ 

(WRTC0R: Packed column will be stored in core at NAME.) Subroutine name 



MCB - An array of dimension = 7 where the matrix trailer information will be 
accumulated. 

TYPIN - Arithmetic type of the elements of the column stored at A (1 = real single 
precision, 2 = real double precision, 3 = complex single precision, 4 = com- 
plex double precision). 

TYP0UT - Arithmetic type in which the elements are to be in packed form. Same conven- 
tion as TYPIN. 

I - Row position of the element stored at A(l). 

N - Row position of the last element in the column stored at A. 

INCR - Spacing of the elements in column stored at A in units of elements, e.g., if 
real double precision elements are stored consecutively, INCR = 1. 

3.5.2.4 Method 

BLDPK is called to initiate activity for the column. For each element in the column, Z^^LPKI 
is called to perform packing and writing. BLDPKN is called to terminate activity for the column 
and update the matrix trailer. 



3.5-5 



SUBROUTINE DESCRIPTIONS 

3.5.2.5 Design Requirements 

See subroutine description for BLDPK, section 3.5.1. 



3.5-6 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.3 INTPK (Interpret a Packed Column of a Matrix ). 

3.5.3.1 Entry Points: INTPK, INTPKI, ZNTPKI. 

3.5.3.2 Purpose 

To read and interpret a column of a matrix in NASTRAN packed format. 

3.5.3.3 Calling Sequence 

If several different matrices are to be read and interpreted concurrently, the multi-column 
version is used. 

CALL INTPK($n,NAME,BL0CK,0PT,TYP(2!UT,l) 

CALL INTPKI{A,I,NAME,BL!3CK,!3PT,E0L) 

where INTPK is the initialization call and is made once for each column to be read and 
interpreted. 

INTPKI is the call made to read successive non-zero elements of the column. Each call to 
INTPKI returns one non-zero element. 

n - F0RTRAN statement number defining return to be taken in the event the column is null. 

(0PT = 'READ', GIN0 file name of data block where the matrix is storeJ. 



NAME 

(OPT = 'RDCfJR', as array of core storage where the matrix is stored. 

BL0CK - An array of dimension £ 6 for use by INTPK and INTPKI. 

('READ' - The column will be read by GIN0. ) i 4. 

('RDC0R' - The column will be read from core storage.) Subroutine name 

TYPfJUT - Arithmetic type into which the elements are to be unpacked (+1 = real single 

precision, +^2 = real double precision, +3 = complex single precision, +4 = complex 
double precision). If TYP0UT -= 0, the sign of each non-zero element is to be 
changed - integer - input. 

A - An array of dimension 1, 2 or 4, depending on TYP0UT, where the non-zero element is to be 
stored - real - output. 

I - Row position of the non-zero element - integer - output. 

E0L = 1 indicates last non-zero element in the column was read on the current call to 
INTPKI, =0 otherwise - integer - output. 

3.5-7 



SUBRO'JTINE DESCRIPTIONS 

If only one matrix is to be read and interpreted, the single-column version should be used 
as it is more efficient. 

C0MM0N/ZNTPKX/A{4),I,E0L,E0R 

CALL INTPK($n,NAME,O,0PT,TYP(3UT.O) 

CALL ZNTPKI 

where INTPK and its arguments are defined as above. 

ZNTPKI is the call made to read successive non-zero elements of the column. One element (A), 
its row position (I), end-of-column indicator (ES3L), and end-of-record indicator (E0R) are stored 
in /ZNTPKX/ for each call to ZNTPKI. 

EfJL is defined as above. 

E0R = 1 indicates the end-of-record has been read by ZNTPKI, = otherwise (ZNTPKI buffers 
ahead so that E0R will usually be one before E0L is one. E0R is always one when E0L = 1). 

3.5.3.4 Method 

INTPK reads the 5-word line header for the column. If 0PT exits via RETURN 2, a null column 
exists and RETURN lis made to the user. Otherwise, for each of the 32 combinations of TYP0UT and 
the type of the elements in the column, a switch for pickup and conversion of the elements is set. 
For the multi-column version, this switch and other pointers are stored in BL0CK. For the sinole 
column version, one buffer is read into /DESCRP/. INTPKI restores the switch and pointers and 
then enters code common with ZNTPKI. A test is made to determine if a read is necessary (this 
is almost always required in tlie multi-column version since only one element at a time is read). 
The non-zero element is picked up from /DESCRP/, converted if necessary, and stored in /ZNTPKX/, 
Its row position is stored in /ZNTPKX/. The next word in the column is now tested (a read being 
given first if necessary). If the (integer) absolute value of this number is less than 16777215, 
the number is the row position of the next non-zero element. If = 15777215, it is the trailer 
word and the last non-zero element has been read. In this case E0L is set to 1 . If ^ 15777215, 
the number is a real number and the row position of the next non-zero element equals the current 
row position plus one. For the multi-column version, A, I and E0L are moved from /ZNTPKX/ to 
the user, and the parameters are saved in BL0CK. 



3.5-8 



MATRIX SUBROUTINE DESCRIPTIONS 



3.5.3.5 Design Requirements 



1. If 8IPT = RDCJIR, the calling module must initialize NAME prior to each call to INTPK see 
j)PNC0R (section 3.4.13). 

2. If the single column version is used, subroutine UNPACK must not be called during 
interpretation of a column, i.e., subsequent to a call to INTPK and prior to a return from ZNTPKI 
with E0L = 1. 

3. The format of floating point words on computers which execute this program must be such 
that any non-zero floating point word is larger in absolute value than the integer 16777215. 

4. When using the single column version, if the user does not complete interpretation of 
the column, he must insure that the remainder of the column is skipped. This may be accomplished 
by 

IF (E0R.Eq.O) CALL FWDREC($n,NAME) . 

5. The first word of /DESCRP/ must contain the length of /DESCRP/. 

3.5.3.6 Diagnostic Messages 

The following messages may be issued by INTPK: 
3002 
3003 



3.5-9 



SUBROUTINE DESCRIPTIOfiS 

3.5.4 UNPACK (Unpack a Packed Column of a Matrix ) . 

3.5.4.1 Entry Point: UNPACK. 

3.5.4.2 Purpose 

To read and unpack a column of a matrix stored in NASTRAN packed format. 

3.5.4.3 Calling Sequence 
CALL UNPACK($n.NAME,A,0PT) 
C(i)Mrt0N/UNPAKX/TYP8IUT , I ,N , INCR 

n - F0RTRAN statement number defining return to be taken if the column is null. 

(0PT = 'READ', GIN0 name of data block containing the column to be unnacked. 
NAME 



0PT 



0PT = 'RDC0R', an array where the packed column is stored. 
('READ' - column will be read by GIN0. 



Subroutine name 
i'RDClilR' - column will be read from core at NAME. 



A - An array where the unpacked column will be stored. 

TYP0UT - Arithmetic type in which the elements are to be stored at A (1 = real single 

precision, 2 = real double precision, 3 = complex single precision, 4 = complex 
double precision). TYP0UT ^ means that each of the elements will be stored 
with a change of sign. 

I - Row position of the element to be stored at A{1). 

N - Row position of the last element to be stored at A. 

INCR - Spacing of the elements to be stored at A in units of elements, i.e., if 

complex single precision elements are to be stored at A(l), A(5), A(7), etc., 
INCR = 2. 

1. Zeros are stored for zero elements. 

2. If I i or N « 0, the column is unpacked from the first non-zero element throuqh 
the last non-zero element and I and N are set to these row positions. 

3. If return to statement n is given, zeros are ncrt stored at A. 

3.5-10 



Notes : 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.4.4 Method 

Activity for the column is initiated by a call to INTPK. A non-standard return from INTPK 
results in an immediate RETURN 1 to the user. ZNTPKI is called to obtain the first non-zero 
element. If its row position is less than I, ZNTPKI is repeatedly called until a row position * I 
or end-of-column is found. If the row position of the first non-zero element is greater than I, 
zeros are stored for the missing elements. Each non-zero element whose row nosition is less than 
or equal to N is stored and zeros are stored for missinn elements. Non-zero elements whose row 
positions are greater than N are skipped until the end-of-column is reached. 

3.5.4.5 Design Requirements 

See subroutine INTPK (see section 3.5.3). 

3.5.4.6 Diagnostic Messages 

In a coding sense messages 3002 and 3003 are possible. However, they violate the design of 
GIN0 or 0PNC0R and therefore, if obtained, should indicate an obscure program design error or 
machine error. 



3.5-11 



SUBROUTINE DESCRIPTIONS 

3.5.5 CALCV (Compute a Partitioning Vector ). 

3.5.5.1 Entry Point: CALCV. 

3.5.5.2 Purpose 

To build a partitioning vector of zeros, ones and twos to be used by subroutines MERGE 
and PARTN. 

3.5.5.3 Calling Sequence 

CALL CALCV(FILEP.SET1 .SUBO.SUBl ,C0RE) 

FILER - GIN0 file number of partitioning vector - integer - Input. 
SETl - Bit position of major set - integer - input. 
SUBO - Bit position of zero subset - integer - input. 
SUBl - Bit position of one subset - integer - input. 
C0RE - Open core. 

C0MIW/PATX/LC(3RE,NSUBO,NSUB1,NSUB2,FUSET 

LC0RE - Length of open core - integer - input. 

NSUBO - Number of rows in zero subset - integer - output. 

NSUBl - Number of rows in one subset - integer - output. 

NSUB2 - Number of rows in two subset (not in one or zero subset) - integer - output. 

FUSET - File name of USET - integer - input. 

3.5.5.4 Method 

Each element of USET is examined and classified. If it belongs to SETl it is further 
classified into SUBO, SUBl, and SUB2. 

A vector is constructed which has zeros, ones and twos in order as elements of USET are so 
classified. 

3.5.5.5 Design Requirements 

LC0RE must be - twice length of GIN0 buffer. 

3.5.5.6 Diagnostic Messages 

System messages if USET or FILEP are not correct GIN0 files. 



3.5-12 



MATRIX SUBROUTINE DESCRIPTIONS 
3 . J . 6 PARTN - MERGE (Partition a Matrix - Merge Matrides Together ) . 

3.5.6.1 Entry Point: PARTM, MERGE. PARTN and MERGE are two distinct routines but are so 
closely related that they are described together here, 

3.5.5.2 Purpose 

PARTN will break up a matrix into four submatrices. 



[A] 



All ] Ai2 
I 



MERGE is the inverse of PARTN in that given the four buildina blocks An A22 MERGE 

will reconstruct [A]. 

3.5.6.3 Calling Sequence 

CALL PARTN (RP,CP,Z) 

CALL MERGE (RP.CP.Z) 

RP - Matrix control block of the row partitioning vector - integer - input. 

CP - Matrix control block of the column partitioning vector - integer - input. 

Z - Array of open core. 

If RP(1) £ 0, or CP(1) 5 0, the core locations from RP{8) or CP{8) will contain this 
vector in packed form. 

If RP(1) = CP{1) < the arrays RP and CP coincide in core. 
C0MM0N/PARMEG/MCBA(7) .MCBAll (7) ,MCBA21 (7) ,MCBA12(7) ,MCBA22(7) .LC0RE.RULE 

MCBA - Matrix control block for LA] - input. 

MC3A11 - Matrix control block for [All] - input. 

MC3A21 - Matrix control block for [A21] - input. 

MC3A12 - Matrix control block for [A12] - input. 

MCBA22 - Matrix control block for [A22] - input. 

If any submatrix is not desired or does not exist set MCBAij(l) = 0. 

LCfiIRE - Length of Z array - integer - input. 

RULE - Rule to be applied to the row and column partitioning vectors - integer - innut. 

3,5-13 



SUBROUTINE DESCRIPTIONS 

3.5.G.4 Method 

Each element of [A] is assigned to the appropriate submatrix by the followinq schemes. 
RULE > N = I RULE I 

a. . e [All] if RP(I) = CP(J) = M 
a. . e [A21] if RP(I) = N, CP(J) f N 
a. . £ [A12] if RP(I) f N, CP(J) = N 
a. . e [A22] if RP(I) f N, CP(J) / N 
RULE -i N = I RULE I 

a. . e [An] if RP(I) 2 N, CP(J) * N 
a. . £ [A21] if RP(I) = N, CP{J) - N 
a. . e [A12] if RP(I) * N, CP{J) z N 
a. . e [A22] if RP(I) * N, CP(J) < N 
Subroutine RULER (RULE, IP, ZC!3NT,0NCMT, LIST, NR0HP, BUFF, I0PT) is called twice to accomnlish 
this assignment where 

RULE - Rule tc be applied 

IP - Either RP or CP 

ZCONT - Number of elements (rovM or column) assigned to the one class. 

0NCNT - Number of elements (row or column) assigned tc the two class. 

For example, if RULER is analyzing RP and RP(I) = N this element of RP is said to belong to 
the 1 class in that it will go either to [All] or [A21]. 

LIST - A list of zeros and ones. Zero, if the element belongs to the one class. 
One, if the element belongs to the two class. 

NR0WP - Number of rows in IP 

BUFF - One GIN0 buffer space 

I0PT - If I0PT = 1, LIST will be stored 1 number per word. If I0PT = 0, LIST will be 
packed 32 bits/word. 
Non-zero elements are read, classified and output. 

3.5-14 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.6.5 Design Requirements 

Open core must contain n GIN0 buffers + 1 column (single precision) of [A] and 1 row/32 of 
[A], where n = the number of submatrices present plus one. 

3.5.6.6 Diagnostic Messages 

If insufficient core is available as described above, fatal message 3008 is given. 



3.5-15 



SUBROUTINE DESCRIPTIONS 

3.5.7 SSG2A (Driver for PARTN ) . 

3.5.7.1 Entry Point: SSG2A. 

3.3.7.2 Purpose 

To partition a vector into two subsets (i.e., to be a driver for PARTN). 

3.5.7.3 Calling Sequence 

CALL SSG2A(VECTi3R, PARTI ,PART2,PVECT) 

VECT0R - GIN0 file number of vector to be partitioned - integer - input. 

PARTI - GIN0 file number of major oartition - integer - input, 

PART2 - GIN0 file number of minor partition - integer - input. 

PVECT - GIN0 file number of partitioning vector - inteqer - input. 
C0MM0N/PATX/XXX,NR0W1 ,NR0W2 

NR8IW1 - Number of rows in PARTI - integer - input. 

NR8rW2 - Number of rows in PART2 - integer - input. 

3.5.7.4 Method 

The PARTN common block is filled. 

Based on the trailer of VECT0R and tiR0Wl , NR0W2: 

{vector}^ {IS 

3.5.7.5 Design Requirements 

Open core is needed at /SSGA2/. 



3.5-16 



MATRIX SUBROUTINE DESCRIPTIONS 

3,5.8 SDR1B (Driver for MERGE ). 

3.5.8.1 Entry Point: SDRIB 

3.5.8.2 Purpose 

To drive MERGE forming VECT0R 

Ucm] - {mix 

^ ' ^ PART2 ' 

3.5.8.3 Calling Sequence 

CALL SDR1B(PVECT,PART1 ,PART2,VECT0R,MAJ0R,SUBO,SUB1 ,USET.I0PT,IYS) 

PVECT - GIN0 name of partition vector - integer - input. 

PARTI - GIN|3 name of vector which corresponds to SUBO set - inteqer - innut. 

PART2 - GIN0 name of vector which corresponds to SUBl set - integer - inout 

VECT0R - GIN0 name of merged vector - integer - input. 

MAJ0R - Bit position of set of VECT0R - integer - input. 

SUBO - Bit position of set of PARTI - integer - input. 

SUBl - Bit position of set of PART2 - integer - input. 

USET - GIN0 name of USET - integer - input. 

I0PT - '0' I 

) These are used in a module specific call to 

) handle the YS data block in a special manner. 
lYS - '0' [ 

3.5.8.4 Method 

CALCV is called to obtain partitioning vector. 
PARMEG common block is filled. 
MERGE is called. 

3.5.8.5 Design Requirements 
Open core at /SDRBl/. 



3.5-17 



SUBROUTINE DESCRIPTIONS 

3.5.9 UPART (Symmetric Partition Driver ) . 

3.5.9.1 Entry Points: UPART, MPART 

3.5.9.2 Purpose 

To compute a partitioning vector and then perform a series of symmetric partitions. A 
symmetric partition is such that the row partitionino vector equals the column partitioning vector. 

For example: 



t^n^ 



^ff 



^sf 



^fs 



Ss 



3.5.9.3 Calling Sequence 

CALL UPART(USET.SCR1 ,MAJ0R,SUBO,SU31 ) 

USET - GIN0 file number of USET - integer - input. 

SCRl - Scratch file on which the partitioning vector will be written - integer - input. 

MAJ0R - Bit position within a USET word of the super set (e.g., n set in the above 
example) - integer - input. 

SUBO - Bit position of the first subset (e.g., f set in the above example) - integer - 
input. 

SUBl - Bit position of the second subset (e.g., s set in the above example) - integer - 
input. 

CALL MPART(KNN,KFF,KSF,KFS,KSS) 

KNN - GIN?) name of the matrix to partitioned - inteoer - inout. 

KFF,KSF,KFS,KSS - GIN0 names of the nartition cutouts. A zero will cause the respective 
matrix not to be written. 

3.5.9.4 Method 

A call to UPART causes CALCV to compute a partitioning vector. 

MPART drives PARTN and is called repeatedly to partition several matrices (i.e. KNN, MNN, 
3NN, M'AH) in a similar symmetric manner using the same partitioning vector. 

3.5.9.5 Design Requirements 
Open core at /UPARTX/. 



3.5-li 



MATRIX SUBROUTIME DESCRIPTIONS 

3.5.10 ADD (Matrix Addition Routine) . 

3.5.10.1 Entry Point: ADD. 

3.5.10.2 Purpose 

To compute [C] = a[A] + 0[B] or on option [C] = a[A]. 

3.5.10.3 Calling Sequence 
CALL ADD (Z) 

Z -- Array of core 

C0MM0N/ADDX/MCBA(7),MCBB(7),MCBC(7),TYPA,ALPHA(4),LC0RE,TYPB,BETA(4) 

MCBA - Matrix Control Block for [A] - input. 
MCBB - Matrix Control Block for [B] - input. 
MCBC - Matrix Control Block for [C] - input. 
TYPA - Type of Alpha - integer - input. 

1 - real single precision 

2 - real double precision 

3 - complex single precision 

4 - complex double precision 

ALPHA - a - input - type depends on TYPA. 
LCjJRE - Length of Z array. 
TYPB - Type of BETA - integer - input. 
BETA - e - input - type depends on TYPB. 

3.5.10.4 Method 

The type of arithmetic is determined to be the maximum type of [A], [B], [C], a, 
The non-zero terms of [A] and [B] are processed into [C]. 
If MCBB(l) = 0, a[A] will be computed. 

3.5.10.5 Design Requirements 

Z must be at least three GIN0 buffers long. 
If a[A] only is to be computed, MCBB(l) = 0. 



3.5-19 



SUBROUTINE DESCRIPTIONS 

3.5.11 SSG2C (Driver for ADD ). 

3.5.11.1 Entry Point: SSG2C. 

3.5.11.2 Purpose 

To drive ADD to compute [C] = a[A] + B[B]. 

3.5.11.3 Calling Sequence 

CALL SSG2C (FILEA,FILEB,FILEC,I0P,BL0CK) 

FILEA - GIN0 file number of [A] - integer - input. 

FILE3 - GIN0 file number of [B] - integer - input. 

FILEC - GIN0 file number of [C] - integer - input. 

I0P - Option flag - integer - input. 

IF I0P < the first column of [A] v/ill be added to each column of [B] to 
give [C]. 



BL0CK - 


■ 11 -word array 


containing coeffi 


cie 


nts - input. 




Word 


Type 




Meaninq 




1 


Integer 




Type of a 




2 


Real 




a 




3 






a 




4 






a 




5 






a 




6 






Not used 




7 


Integer 




Type of S 




8 


Real 




8 




9 






S 




10 






B 




11 






B 



3.5-20 



I^IATRIX SUBROUTINE DESCRIPTIONS 

3.5.11.4 Method 

The trailers of FILEA and FILEB and BL0CK are used to fill the ADDX common block. 
The type of FILEC is the minimum type compatible with a[A] and 6[B]. 

3.5.11.5 Design Requirements 
Open core at /SSGC2/. 



3.5-21 



SUBROUTINE DESCRIPTIONS 

3.3.12 HPYAD (ilatrix Multiplication Routine ) . 
3. b. 12.1 Entry Point: MPYAD. 

3.5.12.2 Purpose 

To evaluate the matrix equation 

D = + [A] [Q] + [C] or D = + [A]""" [B] + [C]. 

3.5.12.3 Calling Sequence 
CALL MPYAD(Z,Z,Z) 
C0MM0N/MPYADX/A(7),B(7),C(7),D(7),NZ,T,SIGNAS,SIGNC,PREC,SCR 

Z - An area of working storage. 

NZ - The number of computer words at Z. 

A,B,C - Matrix control blocks for the matrices A, B, C. 

If C{1) = 0, C is not used, i.e. [D] = + [A] [B] or + [a'''] [B]. 

D - Matrix control block for the product matrix. 

D(l) must contain the GIN0 file name prior to entry. 

D(5) must contain the arithmetic type of the elements of D. MPYAD will accumulate 

D(2), D(C) and set 0(7) = 0. 

(= 0, + [A] [B] + [C] is computed. 

T { T 

(?* 0, 1 [A] [B] + [C] is computed. ^' 

(+1, compute +[A] [B] or +[A]"'^ [3] 
SIGNAB = 

(-1, compute -[/] [3] or -[A]' [B] 

(+1 , use + C 
SIGNC = < 

(-1 , use - C 

Note: If C(l) = 0, SIGUC is ignored. 

(l , perform arithmetic in single precision 



PREC 

(2, perform arithmetic in double precision 

SCR = GIN0 file name of a scratch file for use by MPYAD. 



3.5-22 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.12.4 Method 

1. General Comments. Two alternative methods of performing the matrix multiplication are 
available in MPYAD. Method One holds as many unpacked columns of the B and D matrices as core 
storage will allow. The A matrix is read interpreti vely by INTPK. For each non-zero element in 
A, all combinatorial terms for columns of B currently in core are computed and accumulated in the 
storage for D. At the completion of one pass of the A matrix, the matrix product is complete to 
the extent of the number of columns of B currently in core. (If the C matrix is present, columns 
are initially unpacked into the storage for D.) The process is repeated until the B matrix is 
exhausted. One GIN0 buffer only is required for Method One. The number of passes of the A 
matrix for Method One equals the number of columns of B divided by the number of columns of B and 
D which can be held in core at one time. In Method Two one column of B is held in core at one 
time in packed form (i.e., non-zero terms and row positions only) and either one column o^ D in 
unpacked form (T = 0) or one element of D (T = 1 ) . The remaininn storaqe is allocated to 
storage of columns of A in packed form (as described above). For all the columns of A in 
storage at one time the B and E matrices are passed, column by column, forming partial answers 

on each pass. The E matrix is initially the C matrix (if present) and thereafter is the partial 
product matrix from the previous pass. Three GIN0 buffers are required for Method Two. It may 
be seen that the A matrix is passed once and the number of passes of the B and E matrices equals 
the number of columns of A divided by number of columns of A that may be held in core at one time. 

2. Initialization Phase. The arithmetic type of the elements of D is determined as a 
function of the types of A, B and C and the precision requested by the user. Various Dointers 
for both Methods One and Two are computed. A determination of sufficient core storage is made (one 
unpacked column of B plus one unpacked column of D plus one GIW buffer). Switches are set for 
the type of arithmetic to be performed and the pickup and conversion of elements of B. If the 
number of passes for Method One is less than 4, Method One is selected. Otherwise the A matrix 

is read interpretively once by INTPK, and allocation of storage for Method Two is determined. If 
the number of passes for Method Two is less than the number for Method One, Method Tv;o is selected. 
Otherwise Method One is used. 



3.5-23 



SUBROUTINE DESCRIPTIONS 



3. Method One. The allocation of core storage for Method One is shown below: 



JZB or JZDB- 



NZZ- 
NZ 



^21 



'nl 



'12 
^22 



'n2 



'Ir 
^2r 



nr 



^11 
'21 



■'ml 



^12 
'22 



\2 



Hr 
'2r 



mr 



GIN0 buffer 



1st column of D (ND words) 



2nd column of D 



J.L. 

r column of D 



'1st column of B (NB words) 



' 2nd column of B 



th 
r column of B 



3.5-24 



IWRIX SUBROUTINE DESCRIPTIONS 

Columns of B and C are read and unpacked by UNPACK. INTPK is called to initiate reading and 
interpreting the S,th column of A (x. = 1 initially). For each non-zero term in A, a., or a . 
depending on T, the following arithmetic computations are made: 

T = 0= dij = ^ii^j ' ^ij 
T ;^ 0: d,j = a,, b.. . d,j 

where j runs across the columns of B and D currently in core. At the conclusion of a oass of the 
A matrix, the columns of D in core are packed and written by PACK. The orocess is repeated until 
the multiplication is complete. 

4. Method Two. The allocation of core storage for Method Two is shown on the next page. 



3.5-25 



SUBROUTINE DESCRIPTIONS 



1 






^2 
^i,l 






■ 






rtn' — rr ^ 


Pointer to (r+l)st column of A 
Pointer to r column of A 

Pointer to 2nd column of A 
Pointer to 1st column of A = AC0RE 


riKbTL ■- * 


nrnnr » 


16777215 




^ 


GIN0 buffer 


BUF3 * 




GIN0 buffer 


liUi c ■* 


BUFl = NZZ ► 

NZ ► 


GIN0 buffer 



.th 



q column of D (ND words) 



non-zero elements 
in 1st column of A 



non-zero elements 
in rth column of A 



Pointers to columns of A 
in core stored backward 
(oointer to (r+l)st column 
delimits end of r*" column) 



>non-zero elements 
in qtii column of B 



Note: Allocation for case T = 1 is same except that AC0RE = 1. Consequently, additional 
columns of A may be held in storage on each pass. 



3.5-26 



MATRIX SUBROUTINE DESCRIPTIONS 

To begin each pass, as many columns of A that can be held in core are stored in packed form 
using INTPK. Pointers to the beginning of each column are kept. For each column of B the 
following sequence occurs: 

1. BLDPK is called to initiate packinq of a column of D. 

2. The column of B is stored in packed form at BC0RE using INTPK (if column is null, the 
corresponding C column is copied to D) . The transoose flaq is tested. 

3. 1 f 0: for each non-zero term in A in the p row d,=a b.+d.is formed. 

"^ ok pq qk pk 

When the row of A is complete, ZBLPKI is called. When all rows of A are complete, 
BLDPKN is called. 

4. T = 0: the corresponding column of C is read and unpacked by UNPACK. Then, for each 
non-zero term in A in the p column, d, = a. b + d, , is computed. When all 
columns of A in core are complete, the column of D is packed and written by PACK. 

5. When all columns of B and C are complete, a test for completion of the multiplication 
is made. 

6. If incomplete, the C and D files are switched and the orocess described above is 
repeated. 

3.5.12.5 Design Requirements 

Core storage must be sufficient to hold one unpacked column of B olus one unpacked column of 
D plus one GIN?) buffer. 

The matrices to be multiplied (and added) must have compatible dimensions. MPYAD does not 
check this. 

3.5.12.5 Information Messages 

Q^NMSG is called at entry and at exit from MPYAD. Consequently, the line xxxxx MPYAD will 
appear twice for each call to MPYAD (where xxxxx = time in seconds). The difference is the 
execution time for MPYAD. 



2073 MPYAD METH0D ={2} . N0. 0F PASSES 



This message gives the method selected and number of nasses required. 



3.5-27 



SUBROUTINE DESCRIPTIONS 

2102 LEFT-HAND MATRIX R0W P!3SITI0N 0UT 0F RANGE - IGN0RED. 

A term in the A matrix whose row position is larger than the stated dimension was 
detected and ignored. 

3.5.12.7 Diagnostic Messages 

The following messages may be issued by MPYAD: 
3001 
3002 
3008 



3.5-28 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.13 SSG2B (Driver for MPYAD ) . 

3.5.13.1 Entry Point: SSG2B. 

3.5.13.2 Purpose 

To drive MPYAD to compute 

[D] = 1 [A] [B] 1 [C] 
or 

[D] = + [Af [S] + [C] 

3.5.13.3 Calling Sequence 

CALL SSG2B(FILEA,FILEB,FILEC, FILED, T.PREC.ISIGN.SCRl) 

FILEA - GIN0 name of [A] - integer - input. 

FILEB - GIN0 name of [B] - integer - input. 

FILEC - GIN0 name of [C] - integer - input. 

FILED - GIN0 name of [D] - integer - inout. 

T - Transpose flag - integer - input. 
T = implies use [A] 
T = 1 implies use [A] 

PREC - Precision of computation - integer - input. 1 = real single precision, 

2 = real double precision, 3 = complex single precision, 4 - complex double 
precision. 

ISIGN - Sign of products - integer - input. 

, (sign [A3] = sign (ISIGN) 
ISIGN = + 1 =>{ ^ ' ' 

(sign [C] = sign (ISIGN) 

I ISIGN I >1 => + [AB] - [C] 
I ISIGN I < 1 =>- [AB] + [C] 

SCRl - GIN0 scratch file - integer - input. 

3.5.13.4 Method 

SSG23 fills /MPYADX/ and calls MPYAD to comnute [D] in above equation. 

3.5.13.5 Design Requirements 
Open core at /SSGB2/. 

3.5-29 



SUBROUTINE DESCRIPTIONS 

3.5.14 SDCgHP (Syimietnc Decomposition ). 

3.5.14.1 Entry Point: SDC0MP. 

3.5.14.2 Purpose 

To decompose a real symmetric matrix [A] into the form [A] = [L] [D] [L]^ where [L] is a 
unit lower triangular matrix and [D] a diagonal matrix stored in place of the unit elements on 
the diagonal of [L]. On option, the Cholesky decomposition [A] = [C] [C]^ is done for a real, 
positive definite matrix, with only the lower triangle [C] beino output. SDC!2MP will also comnute 
the determinant of [A]. 

3.5.14.3 Calling Sequence 
CALL SDC(i)MP($ni,Z,Z,Z) 
C0MM(3N/SFACT/A(7),L(7),C(7).SCR1,SCR2,NZ,DET,P(JWER,CHLSKY 

A(7) - Matrix control block for [A]. 

L(7) - Matrix control block for [L]. 

C{7) - Matrix control block for [L] or [C]. 

SCRl, SCR2 - Two scratch files. 

NZ - The number of computer words at Z. 

DET - Double precision cell where the scaled value of the determinant of [A] will 
be stored. 

PJIWER - Scale factor to be applied to DET (Determinant = DET*1O**P0WER) . 

CHLSKY - When CHLSKY = 1, form [C] 

Z - An area of working storage. 

ni - Statement number to which control is transferred if the decomposition fails. 

3.5.14.4 Method 

1. Mathematical Considerations. Any non-singular real symmetric matrix [A] can be uniquely 

decomposed Into the factors [A] = [L] [D] [L] . The elements of [D] and [L] are given by: 

i-1 
''i = ^-i - ^^^ ^k '^k 



3.5-30 



MATRIX SUBROUTINE DESCRIPTIONS 



2. General Comments. Interpretation of the above equations identifies that element t. . is 
composed of products of the elements in the i row of [L] times the elements in the j**^ row of 
[L] times the diagonal elements of [D] (Figure 1). Also, element I., affects only the elements in 
the i row or the i column of [L], (Figure 2). 

The above considerations indicate the means of optimizing the decomposition process to ner- 
form only the necessary operations and to keep elements in core only as long as needed. As an 
example, if [A] was strictly banded, with a bandwidth of B, then the inner product calculation of 
S... extends only to the band as all other terms are zero (Figure 3). Also in this example, all 
terms of [L] in column 5 affect only the elements inside the triangle. As soon as these terms 
are computed, column 5 need not be held in core. The optimum algorithm for banded matrices v/ould 
be to hold the triangular portion of the band in core, compute terms corresponding to the first 
column, output the first column, and move the triangular area down the band (Figure 4). 

In practice, however, structural matrices are not strictly banded, but semi-banded with a 
few scattered terms existing outside the band. The basic algorithm remains the same excent that 
the terms outside the band (active elements) must be handled in an analogous manner to those 
inside the band (band elements). This creates a rectangular storage area for the active rows 
(rows of [L] which contain at least one active element) plus a second traingular area for terms 
arising out of interactions between active rows. The storage requirements are shown in Figure 5. 

Given a matrix [A], SDC0MP will determine the optimum combination of B (bandwidth), and 
C (number of active rows) by estimating the time required to decompose [A] for all combinations 
of B and C and choosing the pair corresponding to the minimum time. 

Figures 6, 7, and 8 show how storage is allocated to various operations. 



3.5-31 



SUBROUTINE DESCRIPTIONS 




Mo 



Figure 1. Computation of element i^j' 
,6 - [^10.6 - Mo, 5 ''S *6,5 - ^0,4^4^6.4 ' * * ■*10.1*'l^6.l] /<^ 




Figure 2. Affect of element i. .. 



3.5-32 



MATRIX SUBROUTINE DESCRIPTIONS 







ik 












Iv 










:■:■:-;■:■: 




k 
















Is 




6 










M 




















\ 












m 






™s 






















k 




10 










ill 


^ 




■:-:■:■;■;■ 


Ilk 
















^ai ■■ 




k 




























>)^ 
























W: 






Iv 






















liikA* 


: 


11 



Figure 3. Computation of element i-jj (banded matrix) 

Mo. 6 -[^lo.e - ^0,5 '^b'-e.s] /^e 




Figure 4. Core storage requirements for a banded matrix. 



3.5-33 



SUBROUTINE DESCRIPTIONS 




Figure 5. Core storage requirements for a matrix with active rows. 



3.5-34 



MATRIX SUBROUTINE DESCRIPTIONS 

I Storage for the partially computed elements of [L] that are within the band. 

II Storage for a completed column of [L]. 

Ill Storage for the next column of [A] to be read in. 

IV Storage for the partially computed elements of [L] that are outside the band. 

V Storage for intermediate results computed from interactions between active rows. 



n^" 



i 



■II 



II 






K 


K 


K / — COLUMNS HELD IN CORE 






\/ 








J 


\ 






r 




\ 




B 


-1 












\ 














[ 






\ 


















N 


,. / — SPILL COLUMNS 
















V 


>c 


















/ 




\ 






















\ 


























\ 


k 


^123 


— ' 








r-l3 








T 


1 III 












I4SP- 


\ 


rU 


ii 




r 










































I 


V 
















c 
1 


































t 


































-* 


B+l 


^ 





-I5SP 




Figure 6. Definition of storage areas. 



3.5-35 



SUBROUTINE DESCRIPTIONS 




Figure 7. Location of storage areas within the matrix. 



3.5-36 



MATRIX SUBROUTINE DESCRIPTIONS 



II- 



13- 



14- 



15 



12 — - 



NZ — - 



III 



IV 



II 



UNUSED CORE 



I/O BUFFERS 



Figure 8. Location of storage areas within core. 



3.5-37 



(2) 



(3) 



(4) 



f ENTER j 



Initialize 
Parameters 



Make I/O Pass on [A] 
to Generate the B vs. C 
Vector and Copy [A] 
onto an Alternate File 



Obtain the Optimum 
B and C. Compute R 



Allocate Core 



Fill the Initial Tri- 
angle (Area I). Use a 
Scratch File for Columns 
if R > B - 1 




YES 



Read Band Portion 
of the Next Column 
of [A] into Area III 




2A 



SUBROUTINE DESCRIPTIONS 



Process the 
Final Triangle 



(11) 




(12) 



REWRITE [L] 



Generate the CHOLESKY 
Matrix [C] 



(13) 



EXIT 



Figure 9, (a) SDC^iiP program flow 



3.5-38 



MATRIX SUBROUTINE DESCRIPTIONS 




2A 



(6) 




Add Column of 
Interaction Elements 
(Area V) into Area IV 





3A 



Read Active Element 
Portion of the Next 
Column of [A] 



(7) 



Merce Active Row 
(Area IV) into 
Area III 



Reduce the Size of 
the Interaction 
Triangle 




Add Element into 
Existing Row (Area IV) 



YES 



Create New Row 
in Area IV 



Expand Interaction 
Triangle for New Row 




3A 



Figure 9.(b) SDCJIiiP program flow 



3.5-39 



(8) 



(9) 



SUBROUTINE DESCRIPTIONS 




Move the First Column of 
Area I into Area II and 
Divide by the Diagonal 



(10) 



Move First Column of 
Active Elements (Area IV 
into Area II 



Compute Interactions 
Between Active Elements 
and Add them into 
Area V 



Add Contributions of the 
Current Pivitol Column 
into Area I, Moving it Up 
as You Proceed 



Add Terms to the Active 
Rows (Area IV) and 
Move It Up 



Write Out Completed 
Column of [L] (Area II) 




Figure 9.(c) SDC0ilP program flow 



3.5-40 



I>1ATRIX SUBROUTINE DESCRIPTIONS 

3. Program Flow. The flowchart in Figure 9 gives the logical flow of SDC0MP. The following 
are comments expanding on certain areas of the flowchart: 

(1) Allocate buffers, initialize determinant, and write header records. 

(2) A vector is generated containing the number of active rows for varying bandwidths. 
The matrix [A] is copied onto an alternate file for use during the decomposition. 

(3) The estimated time for decomposition is computed for each combination of B and C. 
The B and C corresponding to the minimum time is picked. R, the number of columns 
which can be held in core, is also computed at this time. 

(4) Pointers to the various areas of core shown in Figure 6 are computed as a function 
of B, C and R. 

(5) The banded portion of the first B-1 columns of [A] are read into Area I. If R < B-1, 
columns are written on a scratch file. 

(6) As the decomposition proceeds, active rows gradually merge into the band. This 
means a column from Area V will merge into Area IV and a row from Area IV will 
merge into Area III. When this occurs, the current number of active rows decreases 
by one and the size of the interaction triangle is reduced. 

(7) As active elements corresponding to the next column of [A] are read in, they are 
either added to an already existing active row, or a new active row must be created. 
Whenever a new row is created, indices are stored identifying the row, the active 
element is stored in Area IV, and the interaction triangle is expanded to accomodate 
the added row. 

(8) As a column emerges from the triangle in Area I, it is a completed column of [L]. 

(9) Before the column can be output, all terms involving this column must be computed 
and stored. These intermediate terms are stored in either Areas I, IV, or V, depend- 
ing where the elements are located. 

(10) A column of [L] can be output. All areas of temporary storage have been updated. 
Areas I, IV, and III have all moved over one column relative to their previous 
position in the matrix. 



3,5-41 



SUBROUTINE DESCRIPTIONS 

(11) When all columns of [A] have been read in, all active rows have merged and only Area 
I exists. This final triangle is processed to complete the computation of [L]. If 
spill exists, as more core is made available by columns of [L] being output, addi- 
tional columns of the spill file are read in. 

(12) The file containing [L] is now complete. An additional file is created with the 
columns of [L] written in the reverse order. This Generates a nseudo unner tri- 
angular matrix that is used by FBS for the solution of a set of equations. 

(13) If CHLSKY was set, [L] is read, the diagonal term picked up, each column is 
multiplied by the square root of the diagonal, and the resulting [C] matrix is 
output. 

3.5.14.5 Auxiliary Subroutines 

Subroutine Name: L05!P 

Purpose: To compute the inner arithmetic loop of SDC0MP. 

3.5.14.6 Design Requirements 

The input matrix [A] should be well conditioned or positive definite as the decomposition is 
done without pivoting. 

Core storage requirements deoend on the oarameters B and C. For a given B and C, Areas II, 
III, IV, and V must reside in core along with a minimum of two columns of Area I and 5 GIN« buffers. 

Files containing [L] and [L]^ should be used as input only to FBS as they are not in 
standard NASTRAN format. 

3.5.14.7 Information Messages 

1. C0NMSG is called at entry and exit from SDC0MP. The line 

xxxx SDC0MP 
will appear twice per decomposition. The execution time of SDC0MP will be the difference in the 
times (where xxxxx = time in seconds). 



3.5-42 



IWRIX SUBROUTINE DESCRIPTIONS 

1. Message 3023 gives the values of the parameters, B, C, and R chosen for the decomposition. 

2. Message 3027 gives the estimated time in seconds to do the decomposition. 

3. Message 3024 indicates that a matrix has scattered terms way off the diagonal (i.e., a 
large bandwidth). Instead of searching all combinations of B and C, the search is started 
at the maximum bandwidth. 

3.5.14.8 Diagnostic Messages 

1. If SCD0MP was unable to find a combination of B and C which would meet core restrictions, 
fatal message 3008 occurs. 

2. In a coding sense, message 3025 is possible. However, it violates the design of SDC0MP 
and therefore, if obtained, should indicate an obscure program design error, or machine error. 

3. Message 3026 indicates that sufficient space was not reserved for the generation of the 
B vs. C vector. SDC0MP should be recompiled to increase BMAX and CMAX. 



3.5-43 



SUBROUTINE DESCRIPTIONS 

3.5.15 DECgMP (Un symmetric Matrix Decomposition) 

3.5.15.1 Entry Point: DEC0MP 

3.5.15.2 Purpose 

To decompose a real square matrix [A] into the form 

[A] = [L][U] (1) 

(where [L] is a unit lower triangular matrix, and [U] is an upper trianqular matrix), usinn 
partial pivoting within the lower band. 

3.5.15.3 Calling Sequence 

CALL DECfiIMP ($n,X,X,X) 

CS3MM0N /DC0MPX/ A(7) ,L(7) ,U(7) .SCR(3) .DET,P0WER,NX,MINDIA,B,BBAR.C,CBAR,R 

n - Statement number to which control is transferred if [A] is singular. 

X - An area of core available to DEC(JMP. 

A - Matrix control block for the input matrix [A] (if A(l) < 0, avoid 

re-writing [U] in reverse order). 

L,U - Matrix control blocks for the output matrices [L] and [U]. 

SCR(3) - GIN0 file names for three scratch files - integer. 

DET - Double precision cell where the scaled value of the determinant of [A] 
will be stored. 

P;3WER - Scale factor to be applied to DET (det([A]) = DET * 10**P?I'.JER) . 

NX - Number of computer words available at X. 

MINDIA - Double precision word where the value of the minimum diagonal of [U] is 
stored. 
Integer values describing the upper anc lower semi-bandwidths, number of active 
rows and columns and number of columns of [L] held in core, used to decompose 
[A]. (If B, BBAR = 0, GENVEC is called to compute the parameters before de- 
composint [A]. If B, BBAR / 0, the given parameters are used for decompositio 



3.5-44 




MATRIX SUBROUTINE DESCRIPTIONS 

3.5.15.4 Method 

1. Mathematical Considerations: By expanding Equation 1, introducing element notation, 
and forming the multiplication, we can solve for the elements of [L] and [U]. These 
equations are given by: 

i-1 

"ij = ^ij-^fi 'ik"kj '^^J • (3) 

2. General Comments: The implementation of the above equations is accomplished with 
several constraints in mind. The decomposition procedure is optimized such that the 
minimum number of operations is performed, with the minimum amount of core used. To 
accomplish this, the elements of the input matrix [A] are separated into two groups: 
terms inside the band (band elements), and terms outside the band (active elements). 
Also, pivoting is used only within the lower band to avoid unnecessarily filling the 
matrix with non-zero terms. 

Since, in practice, structural matrices tend to be semi-banded with scattered terms 
existing outside the band, this division of the matrix should optimize the decomposition 
process. Several parameters are generated to describe this division. B is defined as 
the upper bandwidth, 5 as the lower bandwidth, C is defined as the number of active 
columns, and C" as the number of active rows, where an active column is defined as a column con- 
taining one or more active elements above the diagonal, and an active row contains one or more 
active elements below the diagonal. Corresponding to these parameters, several storage areas 
are defined to hold the various parts of the matrix. The description and location of these 
areas are given in Figures 1 , 2 and 3. A flow chart for DEC0MP is given in Figure 4. 

The storage areas in Figures 1,2, and 3 are defined as follows: 

I Storage for the completed columns of [L] still required for computation. 

II Storage for the current column being computed. 

Ill Storage for active column elements. 

IV Storage for active row elements. 

V Storage for elements created by interactions between active row and column elements. 

VI Storage for indexes identifying active columns. 

VII Storage for indexes identifying active rows. 

3.5-45 



SUBROUTINE DESCRIPTIONS 




I4SP 
14 



II 



III 



12 
IPAK 



V — 



^ 


— 






- c 


H 


-- I3SP— ^ 




T 


1 






1 






13--^ 

-- 


























































2B+B 



VI _;^n 

C/2 C/2 



-I 


■■^~ 
















































































B+B 















































































I6SP 



I7SP 



hd 



Figure 1. Definition of storage areas for DEC0;1P. 



3.5-46 



MATRIX SUBROUTINE DESCRIPTIONS 




















































gx 







































gx 






:S;: 















































g;:;: 

























X 








;•;•:%' 






i-Si: 























II 

















Sij 




:•:•:■•■ 
































X 
















:■:•:■: 



















" 







































































i 










•**M"I 

































:::S 


m 


i 











































^ 


M 


i 










m 




























\ 


m 


.'X'l 


i 








m 


■.••:" 





























\ 


m 


i 


S| 


:':S: 




* 


.;.;•■. 



























I- 




\ 


'.'.V 

m 


i 


^ 


;>>>: 


:* 






'•'.•y. 




























\ 


m 


i 




i* 






•y-< 





























\ 


iof? 


m 


'«; 




































"N 


m 


;i«ii 










;•;•': 








X 































;»; 






m 


m 
















X 


























:■:•:•: 


■:•:•:- 


M 


m 


^M 












X 































yy.\ 


i;!t:i 


m 



:ii 



IV- 



Figure 2. Location of storage areas within the matrix 



3.5-47 



SUBROUTINE DESCRIPTIONS 



II 



12 
13 

14 



15 



I6SP 
I7SP 



NZ 





I 




II 




III 




IV 




V 




VI 




VII 



























UNUSED CORE 



I/O BUFFERS 



Figure 3. Allocation of core for DEC0MP 



3.5-48 



HATRIX SUBROUTINE DESCRIPTIONS 



ENTER 



(1) 



Initialize 
Parameters 



(2) 




Solve a Matrix of 
Order 1 or 2 
(0NETW0) 



/ RETURN j 



(3) 



YES 



Pick the Optimum 
B.B.C.C.R (GENVEC) 



(4) 



Initialize Pointers 
to Various Core 
Areas 



YES 



(5) 



<' c 


- 0? >-— 

flO 




(6) 






Transpose the 




Generate Active Columns 
Corresponding to Active 
Elements in the First 
B + 1 Rows of [A] 


1 


f 


Active C 
Terms (T 


olumn 

RANSP) 










2A 



Figure 4. (a) DEC0HP program flow 



3.5-49 



SUBROUTINE DESCRIPTIONS 



(7) 




(22) 



Finish Outputing 
Colunins of [L] , 
Re-write [U] 
(FINWRT) 



/ RETURN j 



Read Band Portion of 
A into Area III 



(8) 



Read Active Row 
Terms into Area IV 




(9) 



Add Active Column 
(Area III) into Area II 
Add Interaction Tenns 
(Area V) to Area IV. 



:io) 



Operate on the Current 
Column of [A]by All 
Previous Columns of [L] 



(12) 



(11) 



Compute the Elements 
for Active Rows 



Search the Lower Band of 
Area II for the Haximun 
Element and Interchange 
Rows to Move it to the 
Diagonal 



^ 3A 



Figure4.{b) DEC0MP program flow 



3.5-50 



MATRIX SUBROUTINE DESCRIPTIONS 




3A 



(13) 



Interchange Active 
Column Elements and 
Add in Terms from 
Last Column of[L] 



(14) 



Output Column of [U] 
Plus Active Column 
Terms 




(15) 



Compute Active Row- 
Column Interaction 
Elements 



(16) 



Move Elements in 
Area III One Row Up 



[17) 



Output Colimn of [L] 



(18) 



Move Elements of 
Area IV Over One 
Column 



(19) 



Read Next Row of 
Active Column 
Elements 



(20) 



Zero Area II 



Move Elements of Area 
Over One Column. Add 
Lower Band of Area II 
to Area I 




YES 



Merge Interaction 
Elements into Area III 
if Necessary 



(2i: 




2A 



Figure 4. (c) DEC0MP program flow 



3.5-51 



SUBROUTINE DESCRIPTIONS 

3. Program Flow: The flow chart in Figure 4 gives the logical program flow of DEC0MP. 
The following comments expand on certain portions of the flow chart: 

(1) Allocate buffers, initialize the determinant, and write header records. 

(2) If the order of [A] is 1 or 2, subroutine 0NETW0 is called to handle the 
decomposition. 

(3) If 6 and B" are input as zero, GENVEC is called to pick the optimum parameters 
for decomposition. 

(4) The pointers into the various areas of core shown in Figure 1 are computed. 

(5) If there exist active elements in the upper triangle, TRANSP is called to 
transpose these elements. 

(6) Active columns are initialized for all columns having an active element 
within the first 3 + 1 rows of [A]. 

(7) The band portion of the next column of [A] is read into Area II. 

(8) Any active elements occurring below the diagonal in the current column are 
added into existing active rows, or new active rows are created. 

(9) When an active column merges into the band, a column from Area III is added 
into corresponding positions in Area II, and a column of interaction elements 
in Area V is added to the active row terms in Area IV. 

(10) The current column of [A] in Area II is operated on by the columns of [L] 
stored in Area I. 

(11) Terms corresponding to active rows not yet merged into the band are added into 
Area 1 1 . 

(12) The lower band portion of Area II is searched for the maximum element. Rows 
are interchanged to bring it to the diagonal position, and the interchange 
index is stored in Area I. 

(13) Active columns elements are interchanged corresponding to the interchange 
within the band. If a column of [L] is about to be output (i.e., B + B 
columns of [L] are stored in Area I), terms arising from that column are added 
into the active columns. 



3.5-52 



MATRIX SUBROUTINE DESCRIPTIONS 

(14) The column of [U] from Area II plus a row of active column terms in Area III 
are output. 

(15) If active rows and columns exist, terms arising from their interaction are 
computed and added into Area V. 

(16) Elements in the active columns are moved up one row position in Area III to 
replace the output elements, and make room for a new row. 

(17) The first column of [L] in Area I is written out if Area I is full. The 
active row elements belonging to that column are also outout. 

(18) The columns of [L] in Area I are moved over one column and the lower band 
portion of Area II is stored in Area I. 

(19) Active rows in Area IV are moved over one column. 

(20) The next row of active elements in the upper triangle of [A] is read. 
Elements are added to existing active columns, or new columns are created. 

(21) When possible, a row of interaction elements in Area V is merged into the 
bottom row of active column elements (Area III). 

(22) After processing all columns of [A], FINWRT is called to complete the 
outputting of [L] and to re-write [U]. 

3.5.15.5 Auxiliary Subroutine TRANSP 

1. Entry Point: TRANSP 

2. Purpose: To do an in-core transpose of the active elements occurring outside the band 
and in the upper half of the matrix (i.e., transpose all elements a. • such that j - i ^ B). 

' J 

3. Calling Sequence: CALL TRANSP (X,X,NX,A,B,SCRFIL) 

X - An area of core available to TRANSP. 

NX - Number of words available at X. 

A - GIN0 file containing the input matrix [A] - integer. 

B - Upper bandwidth of matrix [A]. 

SCRFIL - GIN0 file where transposed elements are stored. 



3.5-53 



SUBROUTINE DESCRIPTIONS 

4. Method: The input matrix [A] is read, and all elements occurring outside the band in 
the upper triangle are stored in core, along with their row and column position. This list 
is then searched and elements output in transposed order. 

3.5.15.6 Auxiliary Routine 0NETW0 

1. Entry Points: iSNETW^.FINWRT 

2. Purpose: 0NETW0 is a separate routine whose sole responsibility is to solve matrices 
of order one or two. 

FINWRT is a section of code separated from DEC0MP due to compiler overflow. Its 
function is to finish outputting the remaining columns of [L] and to re-write the columns 
of [U]. 

3.5.15.7 Auxiliary Subroutine GENVEC 

1. Entry Point: GENVEC 

2. Purpose: To pick the optimum B, B, C, C, and R for a given matrix [A]. 

3. Calling Sequence: CALL GENVEC ($n^ ,BUF,A,NX,X,N,B,BBAR,C,CBAR,R,IENTRY) 

n-] .- Statement to which control is transferred if a null column is discovered 
in [A]. 

BUF - Location of a GIN0 buffer. 

A - GIN0 file containing the input matrix [A]. 

X - An area of core available to GENVEC. 

NX - Number of words of core available at X. 

N - The order of the matrix [A]. 

B.BBAR, /Integer output parameters giving the ootimum values for the upper and lower 
C.CBAR, - < bandwidths, the number of active rows and columns, and the number of columns 
Vc 



R Vof [L] held in core. 

TFNTRY /= 1 implies DEC!3MP called GENVEC 
\= 2 implies CDC0MP called GENVEC 



4. Method: The following logic flow gives the means by which the optimum bandwidths are 
chosen. 



3.5-54 



MATRIX SUBROUTINE DESCRIPTIONS 

A. Locate extreme non-zero terms 

1. Initialize active column list to zero. The length of the list is equal to the 
maximum value of the upper bandwidth (B) that is of interest. 

(B = J.^ or the order of the problem, whichever is less, where N is the order of 
^ max NMn 

the matrix and Mg is the arithmetic time in y seconds for performing one multiply and 

one add. 

2. Initialize the column list to zero. The length of the list is the order of 

the problem. • 

3. Locate the non-zero elements in the next column of the matrix. 

4. Insert the column number of all non-zero elements in the correct row oosition 
of the column number list with the following constraints: 

a. Consider only elements in the lower triangle. 

b. Do not insert column numbers in row positions already occupied. 

5. Insert the row number of the non-zero element located in the lowest numbered 
row into the column position of the row number list for the current column under 
consideration. 

6. Return to step 4 until all columns of the matrix have been processed. 

B. Determine active columns 

1 . Zero counter E 

Set Counter F to N-1 
Set Counter G to N-1 
Set Counter H to 2 

2. Beginning with the last entry in the row number list, subtract the current 
value of counter H, and test for a negative sign. If negative, increment counter 
E by one. 

3. The current value of counter E is the number of active columns when the upper 
bandwidth is equal to the current value of counter F. Compare counter E with the 
existing entry in the active column list for the bandwidth indicated by counter F. 
Update the active column list if counter E is greater than the existing entry. 

4. Decrement counter F by one. Return to step 2 unless counter F is zero. 

3.5-55 



SUBROUTINE DESCRIPTIONS 

5. Decrement counter G by one. Increment counter H by one. Set counter F to the 
value of counter G. Zero counter E. Return to step 2 unless counter G is zero. 

5. The final active column list contains the maximum number of active columns for 
bandwidths of unity through the maximum upper bandwidth investigated. 

7. Prepare reduced active column list by extracting pairs - minimum B and 
associated C for unique values of C. 

C. Determine active rows for given B and B 

1. Extract pairs (row number, L, and column number, K) from the column number 
list for which 

L - K > B 

2. Consider a new list of pairs consisting of K and L + B. For each pair 
(K, L + B) determine the number of remaining pairs (K., (L + B).) for which 

K. < L + B and (L + B). > K 

3. The maximum number of pairs satisfying the relation in step 2 for any single 
pair is C for the given B and B. 

D. Select B, B, C and Z for Minimum Decomposition Time 

1. Select the next value of B and associated C from the reduced active column 
list (begin with maximum B of interest). 

2. Assume B = B and C = C. 

3. Calculate R and T with preliminary timing equations. 

4. Save the minimum T and the associated B and C. 

5. Return to step 1 unless all entries in reduced active column list have been used. 

6. If the matrix is unsymmetric use B and C from step 4 and set B = B. 

7. Determine C for a given B and B. 

8. Calculate R and T with the preliminary timing equations. 

9. Compare with the previous minimum T. 



3,5-56 



MATRIX SUBROUTINE DESCRIPTIONS 

10. If the new T exceeds the previous minimum by more than 20% or B = maximum B 
of interest go to 12, 

n. Save the minimum T along with associated B, B, C and C. Increment S by 2% of 
the B associated with minimum T and go to 7. 

12. Return to B = B. 

13. Decrement B by 2% of the B associated with minimum T and determine the 
associated C. 

14. Calculate R and T with the preliminary timing equations. 

15. Compare with the previous minimum T while decrnmenting S. 

16. If the new T exceeds the previous minimum by more than 20% or B = 2 go to 18. 

17. Save the minimum T along with associated B, B, C and C and go to 13. 

18. Save values of B, B, C and C associated with the minimum value of T from 
upsearch and downsearch on B, for use in decomposition. 

3.5.15.9 Auxiliary Function FINDC 

1. Entry Point: FINDC 

2. Purpose: To find the number of active rows (C) for a given B and B. 

3. Calling Sequence: CALL FINDC (B,BBAR,N,X,Y,CBAR) 

B - Upper bandwidth - integer. 

BBAR - Lower bandwidth - integer. 

N - Order of the problem. 

X - Column number list. 

Y - Scratch vector. 

CBAR - The number of active rows, C. 

4. Method: See step C in the GENVEC method. 



3,5-57 



SUBROUTINE DESCRIPTIOMS 

3.5.15.10 Auxiliary Routine TIMEEQ 

1. Entry Points: T,TFIN,RC0RE 

2. Purpose: To compute the preliminary and final timing equations for decomposition, 
and to compute the core allocation function. 

3. Calling Sequences: CALL T (B,BBAR,C,CBAR,R,IENTRY,N,TIM) 

CALL TFIN (B.BBAR,C.CBAR,R,IENTRY,N,TIMEX) 
CALL RC0RE (B.BBAR.C.CBAR.N.IENTRY.NX.R) 

D RD AD 

c'cBAR " ^PP^"" ^"'^ lower bandwidths, number of active rows and columns. 

IFNTRY i~^ implies entry was from DEC0MP. 
\=2 implies entry was from CDC0MP. 

N - The order of the problem. 

TIM - Floating point value for the preliminary time. 

TIMEX - Floating point value for the final timing equation. 

NX - Number of core words available to DEC0MP or CDC0MP. 

R - The number of columns of [L] that can be held in core (output by RC0RE, 

input to T and TFIN) . 

4. Method: The following equations are evaluated to give the desired output. 

A. Core Function 

R = (NX - {(B + B + 1) + 2*IENTRY*MIN0(N,B + B + B) + 

2*IENTRY*C*(B + 2) + 2*C*IENTRY*(MIN0(B + B.N) + 1) + (4) 

2*IENTRY*C*C + C + C*IENTRY + C) - 6*SYSBUF)/(2*IENTRY*B) 

B. Preliminary Timing Equation 

TIM = -\ [MrBR + M.(BC + BC + BC + 2CC) + IB(B + B - R - 1)] (5) 

10° 

where 

Mg = Arithmetic time in y seconds for one term inside the band. 

M_ = Arithmetic time in y seconds for one term in the active row or 
active column. 



3.5-58 (12-1-69) 



MATRIX SUBROUTINE DESCRIPTIONS 



I = 1/9 time in p seconds for one term. 



C. Final Timing Equations 

TIMEX is a function of T, , !„, T, and T. as defined below (P = matrix 

packing time in u seconds for one term). 

T, is given by: 

T^ = K^ [MgBR + IS{B + B - R) + P(B + 2B)] , (6) 

where 

(n - B - 2B , if N - B - 2B > 
Ki = . (7) 

(O , if N - B - 2B < . 

Tp is given by: 

h - 
Tg = Y- tBKjMg + (K3 - R)(I - Mg)B + 2PB + PKg] , (8) 

where 

K2 = K3 = B + S (9) 

if N >. B + 2B; otherwise, 

K2 = N - B , (10) 

and 

(b + B ifN^B + B 

K = . (11) 

^ (N if N < B + B . 

To is given by: 



where 



B + B-R,ifB-R<.0 

h = - (13) 

B , if B - R > . 



3.5-59 



SUBROUTINE DESCRIPTIONS 



and 



if N > B + 2B. Otherwise, 



Kg = B +|b , (14) 



and 



N-R,ifN-R£B 

K4 = L . (15) 

^ B , if N - R > B . 



Kg = N (16) 

T- is given by: 

T4 = (N - B)[Mj,(BC + BC + BC + CC) + P(C + C)] . (17) 



Finally, 



TIMEX = (T^ + '''2 + T3 + ^n)^0'^ , (18) 



where TIMEX is the total estimated time for decomposition. 

3.5.15.11 Auxiliary Subroutine DL0J2P 

1. Entry Points: DL00P,DDL!3i3P,XL(il0P 

2. Purpose: To improve efficiency of F0RTRAN generated code for several loops 
in DEC0MP. 

3.5.15.12 Design Requirements 

Core storage requirements depend on the parameters B, §, C and C. Areas II, III, IV, and V 
must reside in core at all times, along with a minimum of two columns of Area I, and five fiIN0 
buffers. GENVEC is designed to pick the combination of B, B, C, and C such that the problem 
will allocate if at all possible. 

The file containing [U] is not in standard format, as the active column terms are stored 
out of place. For this reason [L] and [U] should be used as input only to GFBS or an associated 
routine. 



3.5-60 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.15.13 Information Messages 

1. C0NMSG is called at entry and exit from DECAMP. The line 

XXXX DEC0MP 

will appear twice per decomposition. The actual execution time of DECAMP will be the 
difference in the times (where XXXX = time in seconds). 

2. 3023 B = XXX C = XXX R = XXX 

3028 BBAR = XXX CBAR = XXX R = XXX 

These messages give the parameters chosen for the decomposition. 

3. 3027 DECi3MPi2SITI0N TIME ESTIMATE = XXX 

Gives the estimated time for the decomposition in seconds. 

3.5.15.14 Diagnostic Messages 

Fatal error messages 3008 and 3025 may occur. 



3.5-61 



SUBROUTINE DESCRIPTIONS 

3.5.16 CDCgMP (Complex Matrix Decomposition) 

3.5.16.1 Entry Point: CDC0MP 

3.5.16.2 Purpose 

To decompose a complex square matrix [A] into the form [A] = [L][U] where [L] is a 
unit lower triangular matrix and [U] is an upper triangular matrix. 

3.5.16.3 Calling Sequence 

CALL CDC0MP ($n^,X,X,X) 

C9mW /CDCMPX/ A(7),L(7),U(7),SCR(3),DET(2),P|3WER,NX,MINDIA,B,BBAR,C,CBAR,R 

n-] - Location in calling program where control is transferred if [A] is sinqular. 

X - An area of working storage. 

A - Input matrix control block for [A]. 

L,U - Output matrix control blocks for [L] and [U]. 

SCR(3) - Three scratch files available for use. 

DET{2) - Two double precision words where the real and imaginary values of the 
determinant are stored. 

P0WER - Scale factor to be applied to the determinant (det ([A]) = DET*1Q**P0WER) . 

NX - Number of computer words at X. 

MINDIA - Double precision word where the modulus of the minimum diagonal element 
of [U] is stored. 

B.BBAR, Tlf B = BEAR = 0, compute and store B.BBAR.C.CBAR.R before decomposing [A]. 

C CBAR < 

' )If B or BBAR ^ 0, use previously stored values of B.BBAR.C.CBAR and R for 



(decomposing. 



3.5-62 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.16.4 Method 

CDC0MP is simply a copy of DEC0MP with the arithmetic statements replaced by complex 
arithmetic. Pointers to storage areas were modified to accommodate the extra words needed. 

3.5.16.5 Auxiliary Subroutine CTRNSP 

Purpose: Complex version of TRANSP (see section 3.5.15.5). 

3.5.16.6 Auxiliary Subroutine C0M12 

Purpose: Complex version of 0NETW0 (see section 3.5.15.6). 

3.5.16.7 Design Requirements 

See subroutine descriptions for DEC0HP, section 3.5.15. 

3.5.16.8 Diagnostic Messages 

See subroutine descriptions for DEC0MP, section 3.5.15. 



3.5-63 



SUBROUTINE DESCRIPTIONS 

3.5.17 FBS (Forward - Backward Substitution) . 

3.5.17.1 Entry Point: FBS. 

3.5.17.2 Purpose 

Given the decomposition of a real symmetric matrix [A] = [L] [D] [L] FBS will perform the 
forward-backward pass necessary to solve the system of linear equations [A] [X] = [B]. 

3.5.17.3 Calling Sequence 
CALL FBSCZ.Z) 

C0MM(}N/FBSX/L(7) ,U(7) ,B(7) ,X(7) ,NZ,PREC,SIGN 

L,U - Matrix control blocks for the lower and upper triangular factors cutout from 
SDCgfMP. 

B.X - Matrix control blocks for the matrices [B] and [X]. 

NZ - Number of computer words at Z. 

(1, perform arithmetic in single precision. 



PREC - 

(2, perform arithmetic in double precision. 

(+1, solve [A] [X] = [B]. 
SIGN - { 

(-1, solve [A] [X] = -[B]. 

Z - An area of working storage. 

3.5.17.4 Method 

Mathematical Considerations. Given the unit upper and lower triangular matrices [L] and 
[L] , with the diagonal matrix [D] stored over their diagonals, FBS solves the two systems of 
equations given by 

[L] [Y] = +[B] 
and 

[L^ [X] = [D]-^[Y] 



3.5-64 



MATRIX SUBROUTINE DESCRIPTIONS 
Elements of [Y] and [X] are given by 

Program Flow. Overall program flow is identical to that of GFBS (see section 3.5.19). The 
only difference in the two routines is FBS uses the decomposed matrices output from SDC0MP, while 
GFBS uses those output by DEC0HP. Likewise, the computed equations differ slightly. 

3.5.17.5 Design Requirements 

One colunn of [B] and one GIN|3 buffer must fit in core. 

3.5.17.6 Diagnostic Messages 

See GFBS (see section 3.5.19). 



3.5-65 



SUBROUTINE DESCRIPTIONS 

3.5.18 SSG3A (Driver for FBS) . 

3.5.18.1 Entry Point: SSG3A. 

3.5.18.2 Purpose 

, To solve [A] [X] = [B] using [A] = [L] [L] . On option to compute the residual matrix 
[RES] = [A] [X] - [B]. 

3.5.18.3 Calling Sequence 

CALL SSG3A(FILEA,FILEL,FILELT,FILEB,FILEX,SCR1,SCR2, IRES. FILER) 

FILEA - GIN0 file name of [A] - integer - input. 

FILEL - GINU file name of [L] - Integer - input. 

FILELT - 6IN0 file name of [L]^ - integer - input. 

FILEB - GIN0 file name of [B] - integer - input. 

FILEX - GIN0 file name of [X] - integer - input. 

SCRl - GINjJ name of scratch file - integer - input. 

SCR2 - GIN0 name of scratch file - integer - input. 

IRES - Option for residual vector - integer - input. IRES = suppresses calculation 
of residual vector. 

FILER - GINP file name of residual vector - integer - input. 

3.5.18.4 Method 

/FBSX/ is set to compute [A] [X] = [B]. 

SSG2B is called to compute [RES] = [A] [X] - [B] (see section 3.5.17.3), 

For each column of [X], {X^}, e^ is computed. 

e^ = {X.}'^{RES^}/{B.}^{X.} 

3.5.18.5 Design Requirements 
Open core at /SSGA3/. 



3.5-66 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.19 GFBS (General Forward - Backward Substitution) . 

3.5.19.1 Entry Point: GFBS. 

3.5.19.2 Purpose 

Given the decomposition of a general square matrix [A] = [L] [U], GFBS will solve the system 
of equations [A] [X] = [L] [U] [X] = ± [B] 

3.5.19.3 Calling Sequence 
CALL GFBS (Z,Z) 
C0W10N/GFBSX/L(7),U(7).B(7),X(7),NZ.PREC.ISIGN 

L.U.B.X - Matrix control blocks for the matrices [L], [U], [B], and [X]. 

X{5) - Desired output type for [X]. 

NZ - Number of computer words available at Z. 



PREC 



ISIGN 



1, use single precision arithmetic 

2, use double precision arithmetic 

1, solve [A] [X] = + [B], 
.-1, solve [A] [X] = -[B]. 



Z - An area of working storage. 
3,5.19.4 Method 

1. Mathematical Considerations. Given [L], [U] (n by n lower and upper triangular 
matrices) and [B] (a n by m matrix) GFBS solves the two systems of equations 

[L] [Y] = + [B] 
and 

[U] Lxj = [Y] 



3.5-67 



SUBROUTINE DESCRIPTIONS 



Elements of [Y] and [X] are given by 

^1j = l^^ij - J+i "ik^j^^i (2) 

2. Initialization Phase. The type of arithmetic to be performed is computed as a function 
of the type of [L], [3], and the precision requested by the calling routine. Corresponding 
transfer vectors are set up to transfer control to the proper arithmetic computation. Core 
storage is filled with as many columns of [B] as possible. 

3. Forward Pass. The intermediate values of [Y] are computed directly over the columns of 
[B] currently in core. This is a forward pass on [L] since it is read sequentially forward. 
Interpretation of Equation 1 shows that y, . is complete after the first column of [L] has been 
read, y,. after column 2, etc. Elements of [L] are read one at a time via INTPK and the 
appropriate term subtracted off. 

4. Backward Pass. Elements of [X] are computed by processing [U] in the reverse order. 
Reading the last column of [U] completes x^ ., the n-1 column of [U] gives \.] ^y etc. In order 
to facilitate the reading of [U], it was written in the reverse order by DECjIMP, allowing a 
forward pass to be made in actuality. 

5. Output Phase. The finished columns of [X] are packed and output via PACK. If more 
columns of [3] still exist, core is once again filled with vectors of [B] and the process 
repeated until all columns of [X] have been computed. 

3.5.19.5 Design Requirements 

At least one column of [B] must be unpacked in core, along with one RIN0 buffer. 

3.5.19.6 Diagnostic Messages 

If insufficient core is available for GFBS, fatal message 3008 occurs. 

If a diagonal term does not exist for a column of [U], fatal message 3005 occurs. This is 
noramlly detected in DEC0MP implying care was not taken in processing singular matrices in the 
calling routine calling DEC0MP. 



3.5-68 



MATRIX SUBROUTINE DESCRIPTICNS 

3 . 5 . 20 SIZLVER (SiitiuUaneous Equation Solution Routine ) . 

3.5.20.1 Entry Point: S0LVER. 

3.5.20.2 Purpose 

To perform the following three functions: 

1. Solve [A] [X] = -[B] for X where A is a real symmetric matrix which has been 
decomposed by SDC0MP. 

2. Evaluate the matrix equation [E] = [D] + [B]^ [X] 

3. On option, compute 

in 



[D] 

3.5.20.3 Calling Sequence 

CALL S0LVER(L,U,X.B,D,E, EPS. FLAG, SCR) 

where: 

L.U are the GIN0 file names of the data blocks containing the lower and uooer triangular 
factors of A, respectively. 

X is the GIN0 file name of the data block where the solution matrix will be written. 
B is the GIN0 file name of the data block containing the right hand matrix in [A] [X] = -[B] 
D,E are the GIN0 file names of the data blocks in Equation (2) above. 
EPS is the real single precision result of the division in Equation (3). 
SCR is the GIN0 file name of a scratch file for use by S0LVER. 
\^ 0, compute e from Equation (3) above and store in EPS 



FLAG . 

0, do not compute e 

/S0LVRX/ is open core for S0LVER 

Note: 

1. L must be output from subroutine SDC0MP. 

2. If D = A, then E is the error residual matrix. 



SUBROUTINE DESCRIPTIONS 

3.5.20.4 Method 

/FBSX/ is initialized and FBS is called to solve [A] [X] = -[B]. 

/MPYADX/ is initialized and MPYAD is called to compute [E] = [D] + [B] [A]. FLAG is 
tested. If FLAG = 0, return is made. Otherwise, INTPK is called to unpack and interpret each 
non-zero term of E. The cumulative sum of the absolute value of all non-zero terms of E is 
formed in double precision. This operation is then performed on D. Finally e is the division 
of these two quantities and is stored in EPS in sinqle orecision. 

3.5.20.5 Design Requirements 

/S0LVRX/ must be inserted at the end of the overlay segment containinn S0LVFR. 

3.5.20.6 Diagnostic Messages 

The following system fatal message may be issued by S0LVER: 
3001 



3.5-70 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.21 DMPY (Multiply a Diagonal Matrix by an Arbitrary Matrix) . 

3.5.21.1 Entry Point: DMPY. 

3.5.21.2 Purpose 

To pre or post multiply an abritrary matrix [B] by a diagonal matrix, i.e. [C] = [D][B] or 
[C] = [B][D]. 

3.5.21.3 Calling Sequence 

CALL DMPY(Z,Z) 

C(KMM(3N/DMPYX/D(7).B(7).C(7),NZ. FLAG. SIGN 

Z - An area of working storage. 

NZ - The number of computer words at Z. 

D - Matrix control block for the diagonal matrix. 

B - Matrix control block for the general matrix. 

C - Matrix control block for the product matrix. 

C(l) must contain the GIN0 file name prior to entry. 

C(5) must contain the arithmetic type of the elements of C, 

DMPY will accumulate C(2) and C(6) and set C(7) = 0. 

C(3) and C(4) may be set by the user before or after the call. 

(= 0, pre-multiply B by D. 
FLAG - < 

[^ 0, post-multiply B by D. 

(+1, form positive product. 
SIGN - ' 



(-1, form negative product. 
3.5.21.4 Method 



The type of arithmetic is determined (real or complex). The elements of the diagonal 
matrix, D, are unpacked at Z. INTPK is used to read and interpret the non-zero elements of B, 
column by column. The following equations are used: 



Pre-multiplication: r. . = Hh 

ij 1 i,1 

Post-multiplication: c. = b d 

1.1 1,1 i 



3.5-71 



SUBROUTINE DESCRIPTIONS 

3.5.21.5 Design Requirements 

Double precision arithmetic is used throughout. 

The amount of core at Z must be sufficient to hold the unpacked diagonal terms of D and 
two GIN0 buffers. 

The dimensions of D and B must be compatible although this is not checked. 

3.5.21.6 Diagnostic Messages 

The following system fatal messages may be issued by DMPY: 
3001 
3002 



3.5-72 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.22 ELIM (Perform a Matrix Reduction ). 

3.5.22.1 Entry Point: ELIM. 

3.5.22.2 Purpose 

To perform a matrix reduction on the structural model by computing the matrix equation: 
[Ki,.] = [K..] + [Kjif [G.] + [s/CKji] + [GjfCKjj] [Gj] 

3.5.22.3 Calling Sequence 

CALL ELIM{KII3,KJIB,KJJB,GJ,KII,SCR1,SCR2,SCR3) 

where KIIB, KJIB, KJJB, GO and KII are the GIN0 file names of each of the matrices in the 
above equation. SCRl . SCR2 and SCR3 are GIN0 file names of three scratch files used by ELIM. 
Open core for ELIM is defined by /ELIMX/. 

3.5.22.4 Method 

ELIM computes the above matrix equation by three successive calls to MPYAD. These are as 
follows: 

[SCRl] = [Kjj] [G.] . []?..] 

tSCR2] = [K..]T [G.] + []<..] 

[Kii] = [Gj]^ [SCRl] + [SCR2] 

3.5.22.5 Design Requirements 

/ELIMX/ must be included at the end of the segment in which ELIM resides. 



3.5-73 



SUBROUTINE DESCRIPTIONS 

3.5.23 FACTOR (Decompose a Matrix Into Triangular Factors) . 

3.5.23.1 Entry Point: FACT0R. 

3.5.23.2 Purpose 

To decompose a symmetric matrix into its two triangular factors. 

3.5.23.3 Calling Sequence 

CALL FACTOR (A.L.U.SCRl ,SCR2) 

Where A, L, U are the GIN0 file names of the data blocks for the symmetric matrix to be 
decomposed, its lower triangular factor and its upper triangular factor, respectively. If U is 
negative, FACT0R will decompose the symmetric matrix [A] on file A such that 

[A] = [C][cf , 

where the Cholesky decomposition is used. [C] will be written on U as a lower triangular matrix. 
L will contain the lower triangular factor of a standard non-Cholesky decomposition. SCRl and 
SCR2 are GINU file names of two scratch files for use by FACT0R. The common block /FACTRX/ is 
open core for FACTOR. 

3.5.23.4 Method 

FACTfJR initializes /SFACT/ and calls SDC0MP to accomplish the decomposition, 

3.5.23.5 Design Requirements 

/FACTRX/ must be included at the end of the segment which contains FACT0R, 

3.5.23.6 Diagnostic Messages 

The following system fatal message may be issued by FACT0R: 
3005 



3.5-74 (12-1-69) 



MATRIX SUBROUTINE DESCRIPTIONS 

3.5.24 TRANP1 (Driver for TRNSP ). 

3.5.24.1 Entry Point: TRANPl . 

3.5.24.2 Purpose 

To drive TRNSP to compute [B] = [A]^, 

3.5.24.3 Calling Sequence 

CALL TRANPUFILEA,FILAT.NSCRTH,SCR1.SCR2.SCR3,SCR4.SCR5,SCR6,SCR7,SCR8). 
FILEA - GIN0 name of [A] - integer - innut. 
FILAT - GIN0 name of [A] - integer - input. 
NSCRTH- Number of scratch files - integer - input. 
SCRl , ... , SCR8 - GIN0 names of scratch files - integer - inout. 

3.5.24.4 Method 

/TRNSPX/ is set based on the trailer of FILEA. 

3.5.24.5 Design Requirements 
Open core at /DTRANX/. 



3,5-75 



SUBROUTINE DESCRIPTIONS 



3.5.25 TRNSP (Matrix Transpose) . 

3.5.25.1 Entry Point: TRNSP. 

3.5.25.2 Purpose 

To compute [A] given [A]. 

3.5.25.3 Calling Sequence 
CALL TRNSP(Z) 

Z - Array of core. 
C0MM0N/TRNSPX/MCBA(7).MCBAT(7),LC0RE,NSCRTH,SCR(8) 
MCBA - Matrix control block for [A] - input. 
MC3AT - Matrix control block for [A] - input. 
LC0RE - Length of Z array - integer - inout. 

NSCRTH - Number of scratch files available - integer - innut. 1 i NSCRTH * 8. 
SCR - List of GIN0 names of scratch files - integer - input. 

3.5.25.4 Method 

Three methods are possible: 

Method 1 - In-core matrices. 

If the full matrix can be held in core, [A] is unpacked into core, and packed 

out onto [A] . 

Method 2 - Simple sub-matrices. 

The matrix [A] is broken up one column at a time into submatrices. The submatrices 
are written on scratch files, read in and transposed one at a time. The break-un of 
[A] can be pictured as follows: 



[A] 



SCRATCH 


1 


SCRATCH 


2 


SCRATCH 


3 



etc. 



3.5-76 



MATRIX SUBROUTINE DESCRIPTIONS 

If insufficient scratch files are available to hold [A], multiple passes may be made 
Method 3 - Multiple passes on submatrices. 

If multiple passes on [A] are necessary in Method 2, it may be more efficient to 
create larger submatrices and pass each submatrix several times rather than several 
passes on [A]. The break-up of [A] can be pictured as follows: 

CI3RE L0AD 1 



[A] 



L 





[SCRATCH 1 


C0RE L0AD 2 1 


C0RE L0AD 3 ' 


SCRATCH 2 


C0RE L0AD 4 i 



etc. 



TRNSP will choose between the methods to minimize running time. 

3.5.25.5 Design Requirements 

Methods 2 and 3 require at least one scratch file. 

Neither [A] nor [A] may be purged. 

One unpacked column of [A] and NSCRTH+1 GIN0 buffers must fit into core. 

3.5.25.6 Diagnostic Messages 

A message indicating insufficient core is produced if the third of the above requirements 
is not satisfied. Either reduce the number of scratch files or increase the open core 
available to TRNSP. 



3.5-77 



GENERAL COMMENTS AND INDEXES 

4.1 GENERAL COMMENTS AND INDEXES 

The NASTRAN modules (a module is a logical group of subroutines) documented in this 
section have been classified into 7 categories: 1) Executive Preface modules, 2) Executive 
modules, 3) Executive DMAP instructions, 4) Executive DMAP modules, 5) functional modules, 
5) output modules, and 7) matrix modules. 

Executive Preface modules are those which are executed prior to the execution of the 
first module in a DMAP sequence. They consist of: 1) XCSA (Executive Control Section Analysis), 
which processes the NASTRAN Executive Control Deck; 2) IFPl (Input File Processor, Part 1), 
which processes the NASTRAN Case Control Deck; 3) XS0RT (Executive Bulk Data Card Sort), 
which sorts the NASTRAN Bulk Data Deck; 4) IFP (Input File Processor), which processes the 
sorted Bulk Data Deck; 5) IFP3 (Input File Processor 3), which processes bulk data cards 
unique to an axisymmetric conical shell problem; 6) XGPI (Executive General Problem 
Initialization), the heart of the Preface, which a) translates (compiles) a DMAP sequence 
into an internal form, the 0SCAR, - see section 2.4.2.1, and b) for problem restarts, 
initializes data blocks and labeled common blocks; and 7) UMFEDIT (User Master File Editor), 
which creates and manipulates User Master Files. 

The only module classified as an Executive module, per se, is XSFA (Executive Segment 
File Allocator), which is the "administrative manager" of files for NASTRAN. 

Executive DMAP instructions documented in this section are REPT, JUMP, C0ND. EXIT and 
END. The DMAP instructions BEGIN, LABEL and FILE are not allocated a separate section, and 
therefore brief explanations follow. 

1. The BEGIN DMAP instruction is a declarative DMAP instruction which denotes the 
beginning of a DMAP sequence. It is analogous to a computer operating system control 
card which calls a compiler of the system. 

2. The FILE DMAP instruction is a declarative DMAP instruction which alters the normal 
attributes of a data block in an 0SCAR entry (see an explanation of the attributes 

AP, LTU, TP, NTU of a data block in the Data Section Format for functional modules 
section in the description of the 0SCAR, section 2.4.2.1). These attributes of a data 
block are used by the Executive Segment File Allocator (XSFA) module in performing its 
task. 



4.1-1 



MODULE FUNCTIONAL DESCRIPTIONS 

3. The LABEL DMAP instruction is used to label a location in a DMAP sequence so 
that the location may be referenced by the DMAP instructions JUMP, C0ND and REPT. 

A more detailed description of these three Executive DMAP instructions can be found 
in section 5 of the User's Manual. 

Executive DMAP modules consist of CHKFNT, SAVE. PURGE, EQUIV, PARAM and SETVAL. In 

addition to the descriptions in this section, the reader is referred to section 5 of the 

User's Manual, where further explanations of the uses of EQUIV, PURGE and CHKPNT can be 
found. 

Functional modules comprise the bulk of the descriptions in this section. Functional 
modules perform the actual structural problem solution. The reader is referred to section 5 
of the User's Manual for a) general comments on DMAP rules and b) the syntactical rules of 
the DMAP calling sequences referring to functional modules. 

Output modules are those whose entire output is directed a) to the system output 
file and/or b) to a tape which will drive a plotting device. 

Matrix modules are those which, although no different operationally from functional 
modules, are most likely to be used by the program user who wishes to take advantage of the 
Direct Matrix Abstraction capabilities of NASTRAN; therefore, they are separately categorized. 

4.1.1 Use of Module Functional Descriptions 

Each module documented by means of a Module Functional Description (MFD) has been 
assigned an integer i, and its MFD is documented in section 4.i. For functional modules, 
a consistent numbering scheme has been followed, wherever possible, in the MFD's. For a 
functional module whose assigned integer is i, then, 

4,i Title 

4.i .1 Entry Point 

4.i.2 Purpose 

4.i.3 DMAP Calling Sequence 

4.i.4 Input Data Blocks 

4.i.5 Output Data Blocks 

4.i.5 Parameters 



4.1-2 



GENERAL COMMENTS AND INDEXES 

4.1.7 Method 

4.i.8 Subroutines 

4.1.9 Design Requirements 

4.i.l0 Diagnostic Messages 

comprises this numbering scheme. The title: a) classifies the module into one of the seven 
categories defined in the first paragraph of section 4.1; b) defines the module name, which, 
if it is a DMAP module (one which is called by a DMAP instruction), is the name by which it 
must be called in the DMAP calling sequence; and c) defines, parenthetically, the phrase 
from which the name was derived. Comments on the remaining sections follow. 

1. Entry Point 

This section defines the entry point of the module. A module's entry point usually 
agrees with the module name, but there are exceptions. For example, the READ (Real 
Eigenvalue Analysis Displacement) module has the entry point REIG (the entry point READ 
is a subroutine in the GIN0 collection of routines). 

2. Purpose 

A brief description of the purpose of the module is given. The casual or first-time 
reader will perhaps go no further than read the purpose. 

3. DMAP Calling Sequence 

The DMAP calling sequence as it appears in a Rigid Format is given (see section 3 of 

the User's Manual for a detailed description of the Rigid Formats in NASTRAN). 

DMAP calling sequences for Executive DMAP instructions and for Executive DMAP modules follow 

no fixed format. Refer to the individual Module Functional Descriptions for details on their 

DMAP calling sequences. Functional modules, which are always "called" via a DMAP calling 

sequence, do have a fixed format. Consider the following DMAP calling sequence for functional 

module SMA2, which generates the mass matrix, [M ], and the damping matrix, [B ]: 

SMA2 CSTM.MPT.ECPT.GPCT.DIT/MGG.BGG/V.Y.WTMASS = 1 .O/V,N,N0MGG/V,N.N0BGG/V,Y, 
C8IUPBAR = -1 $ 

SMA2 is the module name. The name of a module must begin with an alphabetic character 



4.1-3 (3/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

followed by up to seven additional alphanumeric characters. Following the name is a blank 
field. Following this blank field is the list {CSTM.MPT.ECPT.GPCT.DIT} of data blocks input 
to the module. The list is terminated by a slash (/). Each item in this list is separated 
by a comma. Note that the number of commas for this list is one less than the number of input 
data blocks. The second slash terminates the list {MGG.BGG} of data blocks output from the 
module. The rule for naming input and output data blocks is the same as for mpdule names. 
Each subsequent slash terminates a parameter field. Each parameter field contains three parts 
separated by commas. The first part is either the letter "V" or the letter "C", defining the 
parameter as a variable or as a constant respectively. The second part is either the letter 
"Y" or the letter "N". "Y" implies "yes" the value of the parameter may be specified on a 
PARAM bulk data card, and "N" implies "no" the value of the parameter may not be specified on a 
PARAM bulk data card. The third part may be either: (a) the name of the parameter, (b) the 
value of the parameter, or (c) the name and the value of the parameter. A variable parameter 
must have a name, hence a variable parameter may not be specified only by its value. The rule 
governing the names of parameters is the same as that for module names. The value of a 
parameter may be complex double precision, complex single precision, double precision, real, 
integer or BCD. In the example given, the name of the first parameter is WTMASS, and its 
initial value (which can be overridden by a value on a PARAM card because of "Y" prior to the 
name) is 1.0. Note that the slash terminating the last parameter field is omitted. Although 
one can terminate the last parameter field with a slash, this final slash is usually omitted. 
A dollar sign, "$", terminates a DHAP statement. 

4. Input Data Blocks 

A short description of each of the module's input data blocks is given along with 
notes explaining what the module's design requires about the status (purged or not 
purged) of the data blocks. Detailed data block descriptions are found in section 2 
of the Programmer's Manual. 

5. Output Data Blocks 

A short description of each of the module's output data blocks and an explanation of 
the action taken when an output data block has been pre-purged are given in this 
section. An output data block is said to be pre-purged if the data block has been 



4.1-4 



GENERAL COMMENTS AND INDEXES 

explicitly purged in a previous PURGE DMAP instruction, or if the data block does not 
appear in the DMAP calling sequence for the module. 

6. Parameters 

The order of DMAP parameters in a DMAP calling sequence is the same as the order of the 
F0RTRAN variables corresponding to the parameters in blank common at module execution time. 
Each variable DMAP parameter is defined as whether a) it is input data into, or output 
data from, the module, or both (e.g., a DMAP loop counter which is incremented within the 
module); b) the type of the parameter: integer, real, double precision, complex single 
precision, complex double precision, or BCD; and c) the default value of the parameter 
as defined either i) in the Module Properties List (MPL) Executive table, ii) by means 
of a PARAM or SETVAL DMAP instruction, or iii) by means of the DMAP statement itself. An 
example of the third type of default value is 

M0DULEA A,B,C/D,E/V,N,UVU/V,Y.XYZ=-1 $. 

The parameter XYZ is set to -1 by the above statement. For further information on DMAP 
parameters see paragraph 3 above, section 2.4.2.2 in the Programmer's Manual and section 
5 of the User's Manual. 

7. Method 

A discussion of the method used by the module writer to achieve the purpose of the 
module is given in this section. 

8. Subroutines 

The subroutines which comprise the module are described in this section. However, 
not all subroutines capable of being called by a module are listed here. Utility 
routines and matrix routines that are in the root segment are not listed in this 
section. These inlcude: MAPFNS, all the GIN0 routines (0PEN, WRITE, CL0SE, READ, FWDREC, 
BCKREC, REWIND, E(aF, SKPFIL, XGIN0, GIN0, 0PNC0R), FREAD, G0PEN, WRTTRL, FNAME, CLSTAB, 
PREL0C, PEXIT, TMT0G0, MESA6E, and the matrix packing and unpacking routines (BLDPK, PACK, 
INTPK, UNPACK). Descriptions for these routines are found in section 3. 



4.1-5 



MODULE FUNCTIONAL DESCRIPTIONS 

9. Design Requirements 

Design requirements peculiar to the module are presented. 

10. Diagnostic Messages 

Diagnostic messages unique to the module are given in this section. A detailed list 
of NASTRAN diagnostic messages can be found in section 6 of the User's Manual. 



4.1-6 



GENERAL COMMENTS AND INDEXES 



4.1.2 Alphabetical Index of Module Functional Descriptions 



Section Number 


Module Name 


4.78 


ADD 


4.56 


CASE 


4.59 


CEAD 


4.10 


CHKPNT 


4.13 


C0ND 


4.67 


DDRl 


4.68 


DDR2 


4.81 


DEC0MP 


4.47 


DPD 


4.49 


DSMG1 


4.51 


DSMG2 


4.18 


END 


4.17 


EQUIV 


4.14 


EXIT 


4.82 


FBS 


4.61 


FRRD 


4.58 


GKAD 


4.66 


GKAM 


4.32 


GPSP 


4.29 


GPWG 


4.21 


GP1 


4.22 


GP2 


4.25 


GP3 


4.31 


GP4 


4.5 


IFP 


4.3 


IFP1 


4.6 


IFP3 


4.12 


JUMP 


4.72 


MATGPR 


4.71 


MATPRN 


4.73 


MATPRT 


4.33 


MCE1 


4.34 


MCE2 


4.84 


MERGE 


4.79 


MPYAD 


4.57 


MTRXIN 


4.70 


0FP 


4.19 


PARAM 


4.83 


PARTN 


4.52 


PLA1 


4.53 


PLA2 


4.54 


PLA3 


4.55 


PLA4 



Section Number 


Module Name 


4.24 


PL0T 


4.23 


PLTSET 


4.76 


PRTMSG 


4.77 


PRTPARM 


4.16 


PURGE 


4.64 


RAND0M 


4.37 


RBMG1 


4.38 


RBMG2 


4.39 


RBMG3 


4.40 


RBMG4 


4.48 


READ 


4.11 


REPT 


4.15 


SAVE 


4.35 


SCE1 


4.45 


SDRl 


4.46 


SDR2 


4.62 


SDR3 


4.74 


SEEMAT 


4.20 


SETVAL 


4.27 


SMA1 


4.28 


SMA2 


4.30 


SMA3 


4.86 


SMPYAD 


4.36 


SMP1 


4.50 


SMP2 


4.80 


S0LVE 


4.41 


SSG1 


4.42 


SSG2 


4.43 


SSG3 


4.44 


SSG4 


4.75 


TABPT 


4.26 


TAl 


4.65 


TRD 


4.85 


TRNSP 


4.8 


UMFEDIT 


4.60 


VDR 


4.2 


XCSA 


4.7 


XGPI 


4.9 


XSFA 


4.4 


XS0RT 


4.69 


XYPL0T 


4.63 


XYTRAN 



4.1-7 



MODULE FUNCTIONAL DESCRIPTIONS 



4.1.3 Alphabetical Index of Entry Points 1n Module Functional Descriptions 

Names listed under entry point which end in the characters "BD" are block data subprocirams , 



Section Number 


Entry Point 


Module Name 


Paqe Number 


4.46.8 


AI 


SDR2 


4.46-7 


4.46.8 


AJ 


SDR2 


4.46-7 


4.46.8 


AK 


SDR2 


4.46-7 


4.46.8 


AM 


SDR2 


4.46-7 


4.46.8 


AMATRX 


SDR2 


4.46-7 


4.48.8.25 


ARRM 


READ 


4.48-18 


4.41.11.37 


BAR 


SSGl 


4.41-27 


4.41.11.22 


BASGLB 


SSGl 


4.41-22 


4.46.8 


BINT 


SDR2 


4.46-7 


4.28.8.16 


BVISC 


SMA2 


4.28-8 


4.55.1 


CASE 


CASE 


4.56-1 


4.59.8.14 


CDETM 


CEAD 


4.59-12 


4.59.8.15 


CDETM2 


CEAD 


4.59-12 


4.59.8.19 


CDETM3 


CEAD 


4.59-14 


4.59.8.9 


COIFBS 


CEAD 


4.59-8 


4.59.8.18 


CDTFBS 


CEAD 


4.59-14 


4.59.1 


CEAD 


CEAD 


4.59-1 


4.59.8.1 


CEADIA 


CEAD 


4.59-3 


4.59.8.8 


CINFBS 


CEAD 


4.59-8 


4.59.8.2 


CINVPR 


CEAD 


4.59-3 


4.59.8.3 


CINVPl 


CEAD 


4.59-4 


4.59.8.4 


CINVP2 


CEAD 


4.59-4 


4.59.8.5 


CINVP3 


CEAD 


4.59-6 


4.59.8.10 


CMTIMU 


CEAD 


4.59-9 


4.59.8.6 


CN0RM 


CEAD 


4.59-7 


4.59.8.7 


CN0RM1 


CEAD 


4.59-7 


4.23.8.3 


CNSTRC 


PLTSET 


4.23-3 


4.46.8 


C0EF 


SDR2 


4.46-7 


4.41.11 .7 


C0MBIN 


SSGl 


4.41-17 


4.23.8.2 


C0MECT 


PLTSET 


4.23-3 


4.41.11.34 


C0NE 


SSGl 


4.41-26 


4.4.5.7 


CRDFLG 


XS0RT 


4.4-5 


4.41.11 .19 


CR0SS 


SSGl 


4.41-21 


4.59.8.17 


CSQRT 


CEAD 


4.59-13 


4.59.8.12 


CSUB 


CEAD 


4.59-10 


4.59.8.16 


CSUMM 


CEAD 


4.59-13 


4.59.8.11 


CXTRNY 


CEAD 


4.59-9 



4.1-8 



GENERAL COMMENTS AND INDEXES 



Section Number 


Entry Point 


Module Name 


Page Number 


4.78.1 


DADD 


ADD 


4,78-1 


4.49.8.6 


DBEAM 


DSMGl 


4.49-6 


4.49.8.10 


DC0NE 


DSMGl 


4.49-7 


4.81.1 


DDC0MP 


DEC0MP 


4.81-1 


4.67.1 


DDRl 


DDRl 


4.67-1 


4.68.1 


DDR2 


DDR2 


4,68-1 


4.68.8.1 


DDRl A 


DDRl 


4,68-4 


4.68.8.2 


DDRIB 


DDRl 


4.68-5 


4.27.8.5 


DFTCK 


SMAl 


4.27-9 


4.48.8.24 


DETDET 


READ 


4.48-17 


4.48.8.28 


DETFBS 


READ 


4.48-19 


4,48.8.15 


DETM 


READ 


4,48-13 


4.48.8.16 


DETMl 


READ 


4.48-15 


4.48.8.17 


DETM2 


READ 


4.48-16 


4.48.8.18 


DETM3 


READ 


4,48-16 


4.48.8,19 


DETM4 


READ 


4,48-16 


4.48.8,20 


DETM5 


READ 


4,48-16 


4,48,8,21 


DETM6 


READ 


4,48-16 


4,82,1 


DFBS 


FBS 


4,82-1 


4,41,11,9 


DIRECT 


SSGl 


4,41-18 


4,27.8,27 


DKEF 


SMAl 


4,27-16 


4,27,8,22 


OKI 


SMAl 


4.27-13 


4,27.8,25 


DKINT 


SMAl 


4,27-14 


4.27,8,26 


DKJ 


SMAl 


4,27-15 


4,27.8.31 


DKJAB 


SMAl 


4,27-17 


4,27.8.23 


DKK 


SMAl 


4.27-14 


4.27.8,24 


DKM 


SMAl 


4.27-14 


4,27,8,29 


DKIOO 


SMAl 


4.27-16 


4,27,8,33 


DK211 


SMAl 


4.27-18 


4.27,8.32 


DK219 


SMAl 


4.27-18 


4.27.8.28 


DK89 


SMAl 


4,27-16 


4.27.8.38 


DMATRX 


SMA2 


4,27-21 


4.28.8 


DMEF 


SMA2 


4.28-3 


4,28,8 


DM I 


SMA2 


4,28-3 


4,28,8 


DM I NT 


SMA2 


4,28-3 


4,28,8 


DMJ 


SMA2 


4,28-3 


4,28.8 


DMJAB 


SMA2 


4,28-3 


4,28.8 


DMK 


SMA2 


4,28-3 


4.28.8 


DMM 


SMA2 


4.28-3 


4.79.1 


DMPYAD 


MPYAD 


4.79-1 


4.28.8 


DM100 


SMA2 


4.28-3 



4.1-9 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Section Number 


Entry Point 


Module Name 


Page Number 


4.28.8 


DM211 


SMA2 


4,28-3 


4.28,8 


DM219 


SMA2 


4,28-3 


4.28.8 


DM89 


SMA2 


4.28-3 


4.47.1 


DPD 


DPD 


4.47-1 


4.47.8.1 


DPDAA 


DPD 


4.47-7 


4.47.9.2 


DPDCBD 


DPD 


4.47-8 


4.47.7.1 


DPDl 


DPD 


4.47-3 


4.47.7.1 


DPD2 


DPD 


4.47-3 


4.47.7.1 


DPD3 


DPD 


4.47-3 


4.47.7.1 


DPD4 


DPD 


4.47-3 


4.47.7.1 


DPD5 


DPD 


4.47-3 


4.24.1 


DPL0T 


PL0T 


4.24-1 


4.23.1 


DPLTST 


PLTSET 


4.23-1 


4.49.8.9 


DQDMEM 


DSMGl 


4.49-7 


4.24.8,6 


DRAW 


PL0T 


4.24-7 


4.49.8.5 


DR0D 


DSMGl 


4.49-6 


4.49.8.7 


DSHEAR 


DSMGl 


4.49-6 


4.49.1 


DSMGl 


DSMGl 


4.49-1 


4.51.1 


DSMG2 


DSMG2 


4.51-1 


4.49,8,1 


DS1 


DSMGl 


4.49-5 


4,49,8.2 


DS1A 


DMSGl 


4.49-5 


4,49,8.4 


DS1ABD 


DSMGl 


4.49-6 


4,49.8.3 


DS1B 


DSMGl 


4.49-5 


4.85.1 


DTRANP 


TRNSP 


4.85-1 


4.49.8.8 


DTRMEM 


DSMGl 


4.49-7 


4.27.8.35 


D4K 


SMA1 


4.27-19 


4.27,8,36 


D5K 


SMA1 


4.27-20 


4.27,8,37 


D6K 


SMA1 


4.27-20 


4.24.8.11 


DVECTR 


PL0T 


4.24-10 


4.48,8,23 


EADD 


READ 


4.48-17 


4,23,9,2 


EDESBD 


PLTSET 


4.23-5 


4.41.11.4 


EDTL 


SSGl 


4,41-16 


4.24.8.16 


ELELBL 


PL0T 


4.24.12a 


4.48,8,36 


EMPC0R 


READ 


4.48-19C 


4.41.11.2 


EXTERN 


SSGl 


4.41-14 


4.4.5,8 


EXTINT 


XS0RT 


4.4-5 


4,41,11,33 


FCURL 


SDR2 


4.41-26 


4,41,11.26 


FDCSTM 


SSGl 


4.41-23 


4.48,8.22 


FDVECT 


READ 


4.48-17 


4.41.11,28 


FEDT 


SSGl 


4.41-24 


4.46.8 


FFIOO 


SDR2 


4.46-7 



4,1-10 (12-1-69) 



GENERAL COMMENTS AND INDEXES 



Section Number 


Entry Point 


Module Name 


Page Number 


4.41.11.27 


FGPTT 


SSGl 


4.41-24 


4.48.8.37 


FILCiaR 


READ 


4.48-19d 


4.24.8.2 


FIND 


PL0T 


4.24-4 


4.46.8 


FJAB 


SDR2 


4.46-7 


4.41.11.18 


FKDPNT 


SSGl 


4.41-21 


4.24.8.12 


FNDSET 


PL0T 


4.24-10 


4.41.11.21 


FNDSIL 


SSGl 


4.41-22 


4.65.8.5 


FiSRMl 


TRD 


4.65-14 


4.41.11.11 


FP0NT 


SSGl 


4.41-19 


4.61.1 


FRRD 


FRRD 


4.61-1 


4.61.8.1 


FRRDIA 


FRRD 


4.61-5 


4.61.8.2 


FRRD IB 


FRRD 


4.61-6 


4.61.8.3 


FRRDIC 


FRRD 


4.61-6 


4.61.8.4 


FRRDID 


FRRD 


4.61-6 


4.61.8.5 


FRRDIE 


FRRD 


4.61-7 


4.61.8.6 


FRRD IF 


FRRD 


4.61-7 


4.46.8 


F4 


SDR2 


4.46-7 


4.46.8 


F5 


SDR2 


4.46-7 


4.46.8 


F6 


SDR2 


4.46-7 


4.46.8 


F6211 


SDR2 


4.46-7 


4.46.8 


F6219 


SDR2 


4.46-7 


4.46.8 


F89 


SDR2 


4.46-7 


4.24.8.4 


6ETDEF 


PL0T 


4,24-6 


4.58.1 


GKAD 


GKAD 


4.58-1 


4.58.8.1 


GKADIA 


GKAD 


4.58-6 


4.58.8.2 


GKADIB 


GKAD 


4.58-6 


4.58.8.3 


GKADIC 


GKAD 


4.58-7 


4.58.8.4 


GKAD ID 


GKAD 


4.58-7 


4.66.1 


GKAM 


GKAM 


4.66-1 


4.66.8.2 


GKAMIA 


GKAM 


4,66-4 


4.66.8.1 


GKAMIB 


GKAM 


4.66-3 


4.41.11.23 


GLBBAS 


SSGl 


4.41-22 


4.32.1 


GPSP 


GPSP 


4.32-1 


4.24.8.10 


GPTLBL 


PL0T 


4.24-9 


4.24.8.9 


GPTSYM 


PL0T 


4.24-9 


4.29.1 


GPWG 


GPWG 


4.29-1 


4.29.8.1 


GPIJGIA 


GPWG 


4.29-5 


4.29.8.2 


GPWGIB 


GPWG 


4.29-5 


4.29.8.3 


GPWGIC 


GPWG 


4.29-6 


4.21.1 


GPl 


GPl 


4.21-1 


4.22.1 


GP2 


GP2 


4.22-1 


4.25.1 


GP3 


GP3 


4.25-2 



4.1-11 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Section Number 


Entry Point 


Module Name 


Page Number 


4.25.8.3 


GP3A 


GP3 


4.25-4 


4.25.8.4 


GP3B 


GP3 


4.25-7 


4.25.8.2 


GP3C 


GP3 


4.25-2 


4.31.1 


GP4 


GP4 


4.31-1 


4.41.11.16 


GRAV 


SSGl 


4.41-20 


4.41.11.5 


GRAVLl 


SSGl 


4.41-16 


4.41.11.6 


GRAVL2 


SSGl 


4.41-16 


4.41.11.29 


GRAVL3 


SSGl 


4.41-24 


4.46.8 


IFAC 


SDR2 


4,46-7 


4.5.1 


IFP 


IFP 


4,5-1 


4.5,7.9 


IFPPK.IFPPKI, 


.IFPPKN IFP 


4.5-7 


4.3.1 


IFPl 


IFPl 


4.3-1 


4.3.7.1 


IFPIB 


IFPl 


4.3-2 


4.3.7.2 


IFPIC 


IFPl 


4.3-3 


4.3.7.3 


IFPID 


IFPl 


4.3-4 


4.3.7.4 


IFPIE 


IFPl 


4.3-4 


4.3.7.5 


IFPIF 


IFPl 


4.3-4 


4.3.7.6 


IFPIG 


IFPl 


4.3-5 


4.3.7.8 


IFPIXY 


IFPl 


4.3-6 


4,6.1 


IFP3 


IFP3 


4.6-1 


4.6.8,1 


IFP3B 


IFP3 


4.6-15 


4.5,7,8 


IFS1P 


IFP 


4.5-6 


4.5.7.8 


IFS2P 


IFP 


4.5-6 


4.5.7.8 


IFS3P 


IFP 


4.5-6 


4.5.7.8 


IFS4P 


IFF 


4,5-6 


4.5.7.1 


IFXIBD 


IFP 


4,5-5 


4.5.7,2 


IFX2BD 


IFP 


4,5-5 


4,5.7.3 


IFX3BD 


IFP 


4,5-5 


4.5.7.4 


IFX4BD 


IFP 


4.5-6 


4.5.7,5 


IFX5BD 


IFP 


4,5-6 


4,5,7,6 


IFX6BD 


IFP 


4.5-6 


4,5,7.7 


IFX7BD 


IFP 


4.5-6 


4.4,5,3 


INITC0 


XS0RT 


4.4-4 


4.65,8,3 


INITL 


TRD 


4.65-13 


4,4.5.9 


INTEXT 


XS0RT 


4.4-5 


4,65.8,8 


INTFBS 


TRD 


4.65-15 


4.24,8,7 


INTVEC 


PL0T 


4.24-8 


4,48,8.40 


INVERT 


READ 


4.48-19e 


4.48.8.14 


INVFBS 


READ 


4.48-12 


4.48.8,6 


INVPWR 


READ 


4.48-8 


4.48.8.7 


INVPl 


READ 


4.48-8 



4,1-12 (12-1-69) 



GENERAL COMMENTS AND INDEXES 



Section Number 


Entry Point 


Module Name 


Page Number 


4.48.8.8 


INVP2 


READ 


4.48-9 


4.48.8.9 


INVP3 


READ 


4.48-9 


4.48.8.41 


INVTR 


READ 


4.48. 19f 


4.4.5.11 


ISFT 


XS0RT 


4.4-6 


4.27.8.7 


KBAR 


SMAl 


4.27-10 


4.27.8.17 


KBEAM 


SMAl 


4.27-12 


4.27.8.18 


KC0NE 


SMAl 


4.27-13 


4.27.8.16 


KELAS 


SMAl 


4.27-12 


4.27.8.30 


KFAC 


SMAl 


4.27-17 


4.27.8.9 


KPANEL 


SMAl 


4.27-10 


4.27.8.11 


KQDMEM 


SMAl 


4.27-11 


4.27.8.14 


KQDPLT 


SMAl 


4.27-12 


4.27.8.6 


KR0D 


SMAl 


4.27-10 


4.27.8.21 


KT0RDR 


SMAl 


4.27-13 


4.27.8.20 


KTRAPR 


SMAl 


4.27-13 


4.27.8.12 


KTRBSC 


SMAl 


4.27-11 


4.27.8.15 


KTRIQO 


SMAl 


4.27-12 


4.27.8.19 


KTRIRG 


SMAl 


4.27-13 


4.27.8.10 


KTRMEM 


SMAl 


4.27-11 


4.27.8.13 


KTRPLT 


SMAl 


4.27-11 


4.27.8.8 


KTUBE 


SMAl 


4.27-10 


4,2.5.2 


LDi 


XCSA 


4.2-2 


4.2.5.3 


LiBD.LiABD 


XCSA 


4.2-2 


4.41.11.8 


L0ADX 


SSGl 


4.41-17 


4.46.8.36 


MAGPHA 


SDR2 


4.46-19 


4.28.8.12 


MASSD 


SMA2 


4.28-7 


4.28.8.7 


MASSTQ 


SMA2 


4.28-5 


4.72.1 


MAT6PR 


MATGPR 


4.72-1 


4.71.1 


MATPRN 


MATPRN 


4.71-1 


4.65.8.6 


MATVEC 


TRD 


4.65-14 


4.28.8.8 


MBAR 


SMA2 


4.28-6 


4.28.8.17 


MBEAM 


SMA2 


4.28-8 


4.28.8.9 


MCBAR 


SMA2 


4.28-6 


4.33.1 


MCEl 


MCEl 


4.33-1 


4.33.8.1 


MCEIA 


MCEl 


4.33-2 


4.33.8.2 


MCEIB 


MCEl 


4.33-2 


4.33.7 


MCEIC 


MCEl 


4.33-2 


4.33.8.3 


MCEID 


MCEl 


4.33-2 


4.34.1 


MCE2 


MCE2 


4.34-1 


4,28.8.11 


MC0NE 


S.MA2 


4.28-6 


4.28.8.10 


MC0NMX 


SMA2 


4.28-6 


4.28.8.18 


MCR0D 


SMA2 


4.28-8 



4.1-13 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Section Number 


Entry Point 


Module Name 


Page Number 


4.84.1 


MERGEX 


MERGE 


4.84-1 


4.28.8 


MFAC 


SMA2 


4.28-3 


4.24.8.13 


MINMAX 


PL0T 


4.24-n 


4.41.11.24 


MPYL 


SSGl 


4.41.23 


4.41.11.25 


MPYLT 


SSGl 


4.41-23 


4.28.8.21 


MQDPLT 


SMA2 


4.28-8a 


4.28.8.5 


MR0D 


SMA2 


4.28-5 


4.48.8.11 


MTIMSU 


READ 


4.48-10 


4.28.8.15 


MT0RDR 


SMA2 


4.28-7 


4.28.8.14 


MTRAPR 


SMA2 


4.28-7 


4.28.8.19 


MTRBSC 


SMA2 


4.28-8 


4.28.8.22 


MTRIQD 


SMA2 


4.28-8a 


4.28.8.13 


MTRIRG 


SMA2 


4.28-7 


4.28.8.20 


MTRPLT 


SMA2 


4.28-8a 


4.57.1 


MTRXIN 


MTRXIN 


4.57-1 


4.28,8.6 


MTUBE 


SMA2 


4.28-5 


4.41.11.20 


N0RM 


SSGl 


4.41-21 


4.48.8.10 


N!3RM1 


READ 


4.48-10 


4.70.1 


(3FP 


0FP 


4.70-1 


4.70.8.1 


0FPPUN 


0FP 


4.70-2 


4.70.8.2 


(2FP1 


0FP 


4.70-3 


4.70.8.3 


0FP1A 


0FP 


4.70-3 


4.70.8.4 


0FP1BD 


0FP 


4.70-3 


4,70.8.5 


!3FP2BD 


0FP 


4.70-3 


4.70.8.6 


0FP3BD 


0FP 


4.70-3 


4.70.8.7 


0FP4BD 


0FP 


4.70-3 


4.70.8.8 


0FP5BD 


0FP 


4.70-3 


4.48.8.5 


0RTCK 


READ 


4.48-7 


4.59.8.13 


0RTH0 


CEAD 


4.59-10 


4.7.5.10 


0SCDMP 


XGPI 


4.7-6 


4.24.8.1 


PARAM 


PL0T 


4.24-4 


4.83.1 


PARTNX 


PARTN 


4.83-1 


4.41.11.17 


PERMUT 


SSGl 


4. 41-20 


4.24.8.14 


PERPEC 


PL0T 


4.24-11 


4.55.8.5 


PKBAR 


PLA4 


4.55-4 


4.55.8.10 


PKQADl 


PLA4 


4.55-5 


4.55.8.11 


PKQAD2 


PLA4 


4.55-5 


4.55.8.7 


PKQDM 


PLA4 


4.55-5 


4.55.8.18 


PKQDMS 


PLA4 


4.55-7 


4.55,8.13 


PKQDM 1 


PLA4 


4.55-6 


4.55.8.22 


PKQDPL 


PLA4 


4.55-8 


4.55.8.4 


PKR0D 


PLA4 


4.55-4 



4.1-14 (12-1-69) 



GENERAL COMMENTS AND INDEXES 



Section Number 


Entry Point 


Module Name 


Page Number 


4.55.8.14 


PKTQl 


PLA4 


4,55-6 


4.55.8.16 


PKTQ2 


PLA4 


4,55-7 


4.55.8.20 


PKTRBS 


PLA4 


4,55-8 


4.55.8.8 


PKTRIl 


PLA4 


4,55-5 


4.55.8.9 


PKTRI2 


PLA4 


4.55-5 


4.55.8.6 


PKTRM 


PLA4 


4.55-4 


4,55.8.17 


PKTRMS 


PLA4 


4.55-7 


4.55.8.12 


PKTRMl 


PLA4 


4.55-6 


4.55.8.21 


PKTRPL 


PLA4 


4.55-8 


4.55.8.19 


PKTRQD 


PLA4 


4.55-7 


4.55.8.15 


PKTRQ2 


PLA4 


4.55-6 


4.52.1 


PLAl 


PLAl 


4.52-1 


4.53.1 


PLA2 


PLA2 


4.53-1 


4.54.1 


PLA3 


PLA3 


4.54-1 


4.54.8.1 


PLA31 


PL A3 


4.54-3 


4.54.8.2 


PLA32 


PLA3 


4.54-3 


4.55.1 


PLA4 


PLA4 


4.55-1 


4.55.8.3 


PLA4B 


PLA4 


4.55-4 


4.55.8.1 


PLA41 


PLA4 


4.55-3 


4.55.8.2 


PLA42 


PLA4 


4.55-3 


4.41.11.13 


PL0AD 


SSGl 


4.41-9 


4.24.8.3 


PLOT 


PL0T 


4,24-5 


4.24.8.5 


PLT0PR 


PL0T 


4,24-6 


4.41.11.15 


PRESAX 


SSGl 


4,41-20 


4.24.8.15 


PR0CES 


PL0T 


4.24-12 


4.76.1 


PRTMSG 


PRTMSG 


4.76-1 


4.77,1 


PRTPRM 


PRTPRM 


4.77-1 


4.54.8.4 


PSBAR 


PLA3 


4.54-4 


4,54,8,9 


PSQADl 


PLA3 


4.54-5 


4,54,8,10 


PSQAD2 


PLA3 


4.54-5 


4.54.8,6 


PSQDM 


PLA3 


4.54-4 


4.54.8.12 


PSQDMl 


PLA3 


4.54-6 


4.54.8,16 


PSQPLl 


PLA3 


4.54-7 


4,54,8,3 


PSR0D 


PLA3 


4.54-3 


4.54,8,15 


PSTPLl 


PLA3 


4,54-6 


4,54.8,13 


PSTQl 


PLA3 


4,54-6 


4.54.8,18 


PSTQ2 


PLA3 


4.54-7 


4,54,8,14 


PSTRBl 


PLA3 


4,54-6 


4,54,8,7 


PSTRIl 


PLA3 


4.54-5 


4.54.8,8 


PSTRI2 


PLA3 


4.54-5 


4,54.8,17 


PSTRQ2 


PLA3 


4.54-7 


4,54,8,5 


PSTRM 


PLA3 


4.54-4 


4.54,8,11 


PSTRMl 


PLA3 


4.54-5 



4.1-15 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Section Number 


Entry Point 


Module Name 


Page Number 
4.41-27 


4. 41. n. 35 


QDHEM 


SS61 


4.19.1 


qPARAM 


PARAM 


4.19-1 


4.48.8.38 


QRITER 


READ 


4.48-19d 


4.64.1 


RAND0M 


RAND0M 


4.64-1 


4.64.8.4 


RANOl 


RAND0M 


4.64-6 


4.64.8.5 


RAND2 


RAND0M 


4.64-6 


4.64.8.6 


RAND3 


RAND0M 


4.64-7 


4.64.8.7 


RAND4 


RAND0M 


4.64-7 


4.64.8.2 


RAND5 


RAND0M 


4.64-6 


4.64.8.8 


RAND6 


RAND0M 


4.64-7 


4.64.8.1 


RAN07 


RAND0M 


4.64-5 


4.64.8.3 


RAND8 


RAND0M 


4.64-4 


4.37.1 


RBMGl 


RBMGl 


4.37-1 


4.38.1 


RBMG2 


RBMG2 


4.38-1 


4.39.1 


RBMG3 


RBMG3 


4.39-1 


4.40.1 


RBMG4 


RBMG4 


4.40-1 


4.48.8.1 


READl 


READ 


4.48-4 


4.48.8.2 


READ2 


READ 


4.48-5 


4.48.8.3 


READ3 


READ 


4.48-6 


4.48.8.4 


READ4 


READ 


4.48-7 


4.48.8.42 


READ6 


READ 


4.48-19f 


4.48.1 


REI6 


READ 


4.48-1 


4.41.11.14 


RF0RCE 


SS61 


4.41-19 


4.27.8.34 


R0MBDK 


SMAl 


4.27-19 


4.46.8 


R0MBER 


SDR2 


4.46-7 


4.48.8.35 


R0TATE 


READ 


4.48-19C 


4.48.8.34 


R(i)TAX 


READ 


4.48-19C 


4.4.5.2 


RPAGE 


XS0RT 


4.4-3 


4.46.8.15 


SBAR1 


SDR2 


4.46-12 


4,46.8.32 


SBAR2 


SDR2 


4.46-18 


4.46.8.5 


SBEAMl 


SDR2 


4.46-10 


4.46.8.24 


SBEAM2 


SDR2 


4.46-16 


4.46.8.27 


SBSPL2 


SDR2 


4.46-16 


4.35.1 


SCEl 


SCEl 


4.35-1 


4.46.8.16 


SCBINEl 


SDR2 


4.46-12 


4.46.8.30 


SC0NE2 


SDR2 


4.46-17 


4.46.8.31 


SC0NE3 


SDR2 


4.46-18 


4.45.1 


SDRl 


SDRl 


4.45-1 


4.45.8.1 


SDRIA 


SDRl 


4.45-5 


4.45.8.2 


SDRIC 


SDRl 


4.45-5 


4.45.8.3 


SDRID 


SDRl 


4.45-5 


4.46.1 


SDR2 


SDR2 


4.46-1 



4.1-16 (12-1-69) 



GENERAL COMMENTS AND INDEXES 



Section Number 


Entry Point 


Module Name 


Page Number 


4.46.8.2 


SDR2A 


SDR2 


4.46-8 


4.46.8.1 


SDR2AA 


SDR2 


4.46-8 


4.46.8.3 


SDR2B 


SDR2 


4.46-9 


4.46.8.20 


SDR2C 


SDR2 


4.46-13 


4.46.8.21 


SDR2D 


SDR2 


4.46-14 


4.46.8.22 


SDR2E 


SDR2 


4.46-15 


4.62.1 


SDR3 


SDR3 


4.62-1 


4.62.8.1 


SDR3A 


SDR3 


4.62-9 


4.74.1 


SEEMAT 


SEEMAT 


4.74-1 


4.46.8.13 


SELASl 


SDR2 


4.46-12 


4.46.8.26 


SELAS2 


S0R2 


4.46-16 


4.23.8.1 


SETINP 


PLTSET 


4.23-3 


4.20.1 


SETVAL 


SETVAL 


4.20-1 


4.24.8.8 


SHAPE 


PL0T 


4.24-8 


4.48.8.32 


SIC0X 


READ 


4.48-19b 


4.48.8.33 


SINCAS 


READ 


4.48-19b 


4.41.11.12 


SL0AD 


SSGl 


4.41-19 


4.27.1 


SMAl 


SMAl 


4.27-1 


4.27.8.2 


SMAIA 


SMAl 


4.27-8 


4.27.8.3 


SMAIB 


SMAl 


4.27-9 


4.27.8.4 


SMAIBD 


SMAl 


4.27-9 


4.28.1 


SMA2 


SMA2 


4.28-1 


4.28.8.2 


SMA2A 


SMA2 


4.28-4 


4.28.8.3 


SMA2B 


SMA2 


4.28-4 


4.28.8.4 


SMA2BD 


SMA2 


4.28-4 


4.30.1 


SMA3 


SMA3 


4.30-1 


4.30.8.1 


SMA3A 


SMA3 


4.30-5 


4.30.8.2 


SMA3B 


SMA3 


4.30-5 


4.30.8.4 


SMA3BD 


SMA3 


4.30-6 


4.30.8.3 


SMA3C 


SMA3 


4.30-6 


4.48.8.30 


SMLEIG 


READ 


4.48-19a 


4.36.1 


SMPl 


SMPl 


4.36-1 


4.50.1 


SMP2 


SMP2 


4.50-1 


4.80.1 


S0LVE 


S(JLVE 


4.80-1 


4.46.8.7 


SPANLl 


SDR2 


4.46-10 


4.46.8.25 


SPANL2 


SDR2 


4.46-16 


4.46.8.12 


SQDMEl 


SDR2 


4.46-11 


4.46.8.10 


SQDPLl 


SDR2 


4.46-11 


4.46.8.27 


SQRTM 


READ 


4.48-19 


4.46.8.4 


SR(301 


SDR2 


4.46-10 


4.46.8.23 


SR0D2 


SDR2 


4.46-16 



4.1-17 (12-1-69) 



MODULE FUNCTIOMAL DESCRIPTIONS 



Section Number 


Entry Point 


Module Name 


Page Number 


4.41.1 


SSGl 


SSGl 


4.41-1 


4.41.11.1 


SSGIA 


SSGl 


4.41-14 


4.42.1 


SSG2 


SSG2 


4.42-1 


4.42.8.1 


SSG2B1 


SSG2 


4.42-4 


4.43.1 


SSG3 


SSG3 


4.43-1 


4.44.1 


SSG4 


SSG4 


4.44-1 


4.65.8.7 


STEP 


TRD 


4.65-15 


4.46.8.19 


ST0RD1 


SDR2 


4.46-13 


4.46.8.35 


ST(JRD2 


SDR2 


4.46-19 


4.46.8.28 


STQME2 


SDR2 


4.46-17 


4.46.8.18 


STRAP 1 


SDR2 


4.46-13 


4.46.8.34 


STRAP2 


SDR2 


4.46-18 


4.46.8.8 


STRBSl 


SDR2 


4.46-10 


4.46.8.17 


STRIRl 


SDR2 


4.46-13 


4.46.8.33 


STRIR2 


SDR2 


4.46-18 


4.46.8.11 


STRMEl 


SDR2 


4.46-11 


4.46,8.9 


STRPLl 


SDR2 


4.46-11 


4.46.8.14 


STRQDl 


SDR2 


4.46-12 


4.46.8.29 


STRQD2 


SDR2 


4.46-17 


4.46.8.6 


STUBEl 


SDR2 


4.46-10 


4.48.8.13 


SUB 


READ 


4.48-11 


4.48.8.26 


SUMM 


READ 


4.48-18 


4.3.7.7 


SWSRT 


IFPl 


4.3-6 


4.75.1 


TABPT 


TABPT 


4.75-1 


4.26.1 


TAl 


TAl 


4.26-1 


4.26.8.2 


TAIA 


TAl 


4.26-14 


4.26.8.3 


TAIB 


TAl 


4.26-14 


4.26.8.4 


TAIC 


TAl 


4.26-14 


4.26.8.5 


TAICA 


TAl 


4.26-15 


4.26.8.6 


TAIF 


TAl 


4.26-15 


4.26.8.7 


TAIG 


TAl 


4.26-15 


4.41.11.3 


TEMPI 


SSGl 


4.41-15 


4.41.11.10 


TP0NT 


SSGl 


4.41-18 


4.65.1 


TRD 


TRD 


4.65-1 


4.65.8.1 


TRDIA 


TRD 


4.65-12 


4.65.8.2 


TRD IB 


TRD 


4.65-12 


4.65.8.4 


TRDIC 


TRD 


4.65-13 


4.65.8.9 


TRDID 


TRD 


4.65-16 


4.65.8.10 


TRDIE 


TRD 


4.65-16 


4.48.8.31 


TRIDI 


READ 


4.48-19a 


4.41.11.36 


TRIMEM 


SSGl 


4.41-27 



4.1-18 (12-1-69) 



GENERAL COMMENTS AND INDEXES 



Section Number 


Entry Point 


Module Name 


Page Number 


4.85.1 


TRNSP 


TRNSP 


4.85-1 


4.41.11.32 


TT0RDR 


SSGl 


4.41-26 


4.41.11.31 


TTRAPR 


SSGl 


4.41-25 


4.41.11.30 


TTRIRG 


SSGl 


4.41-25 


4.8.1 


UMFEDT 


UMFEDIT 


4.8-1 


4.8.6 


UMFZBD 


UMFEDIT 


4.8-1 


4.48.8.29 


VALVEC 


READ 


4.48-19 


4.60.8.1 


VDR 


VDR 


4.60-5 


4.60.8.2 


VDRA 


VDR 


4.60-5 


4.60.8.3 


VDRB 


VDR 


4.60-6 


4.60.9.2 


VDRBD 


VDR 


4.60-7 


4.48.8.39 


WILVEC 


READ 


4.48-19e 


4.76.8.2 


WRTMSG 


PRTMSG 


4.76-2 


4.4.5.5 


XBCDBI 


XS0RT 


4.4-4 


4.11.1 


XCEI 


REPT 


4.11-1 


4.12.1 


XCEI 


JUMP 


4.12-1 


4.13.1 


XCEI 


COND 


4.13-1 


4.14.1 


XCEI 


EXIT 


4.14-1 


4.18.1 


XCEI 


END 


4.18-1 


4.10.1 


XCHK 


XCHK 


4.10-1 


4.9.5.2 


XCLEAN 


XSFA 


4.9-4 


4.2.1 


XCSA 


XCSA 


4.2-1 


4.9.5.4 


XDPH 


XSFA 


4.9-6 


4.17.1 


XEQUIV 


EQUIV 


4.17-1 


4.4.5.4 


XFADJ 


XS0RT 


4.4-4 


4.4.5.10 


XFADJl 


XS0RT 


4.4-5 


4.9.5.7 


XFILPS 


XSFA 


4.9-7 


4.7.5.9 


XFLDEF 


XGPI 


4.7-5 


4.7.5.8 


XFL0RD 


XGPI 


4.7-5 


4.7.1 


XGPI 


XGPI 


4.7-1 


4.7.6.2 


XGPIBD 


XGPI 


4.7-7 


4.7.5.2 


XGPIBS 


XGPI 


4.7-3 


4.7.5.1 


XGPIDG 


XGPI 


4.7-3 


4.7.5.1 


XGPIMW 


XGPI 


4.7-3 


4.7.5.5 


XIPFL 


XGPI 


4.7-4 


4.7.5.4 


XLNKHD 


XGPI 


4.7-4 


4.7.5.5 


X0PFL 


XGPI 


4.7-4 


4.7.5.3 


X0SGEN 


XGPI 


4.7-3 


4.7.5.6 


XPARAM 


XGPI 


4.7-4 


4.9.5.6 


XPLEQK 


XSFA 


4.9-6 


4.9.5.5 


XP0LCK 


XSFA 


4.9-6 



4.1-19 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Section Number 


Entry Point 


Module Name 


Page Number 


4.4.5.6 


XPRETY 


XS0RT 


4.4-4 


4,9.5.3 


XPUNP 


XSFA 


4.9-5 


4.16.1 


XPURGE 


XPURGE 


4.16-1 


4.4.5.1 


XRECPS 


XS0RT 


4.4-3 


4.2.5.1 


XRGDFM 


XCSA 


4.2-1 


4.15.1 


XSAVE 


XSAVE 


4.15-1 


4.2.5.4 


XSBSET 


XCSA 


4.2-2 


4.7.5.7 


XSCNDM 


XGPI 


4.7-4 


4.9.1 


XSFA 


XSFA 


4.9-1 


4.4.1 


XS0RT 


XS0RT 


4.4-1 


4.9.5.1 


XS0SGN 


XSFA 


4.9-3 


4.48.8.12 


XTRNSY 


READ 


4.48-11 


4.63.8.1 


XYDUMP 


XYTRAN 


4.63-5 


4.63.8.2 


XYFIND 


XYTRAN 


4.63-5 


4.63.8.4 


XYL0G 


XYTRAN 


4.63-6 


4.63.8.3 


XY0UT 


XYTRAN 


4.63-6 


4.69.1 


XYPL0T 


XYPL0T 


4.69-1 


4.63.8.5 


XYTICS 


XYTRAN 


4.63-7 


4.63.1 


XYTRAN 


XYTRAN 


4.63-1 



4.1-20 (12-1-69) 



EXECUTIVE PREFACE MODULE XCSA (EXECUTIVE CONTROL SECTION ANALYSIS) 

4.2 EXECUTIVE PREFACE MODULE XCSA (EXECUTIVE CONTROL SECTION ANALYSIS) 

4.2.1 Entry Point : XCSA 

4.2.2 Purpose 

To process the NASTRAN Executive Control Deck. 

4.2.3 Call ing Sequence 

CALL XCSA. XCSA is called only by subroutine SEMINT. 

4.2.4 Method 

The cards of the Executive Control Deck are read and processed with checks being made for 
illegal formats, duplication and errors peculiar to the particular card being processed. When 
all of the control cards have been processed (i.e., CEND control card found), the Executive 
Control Table (XCSA) is written on the Problem Tape and XCSA returns to the calling routine. 

4.2.5 Subroutines 

4.2.5.1 Subroutine Name: XRGDFM 

1. Entry Point: XRGDFM 

2. Purpose: To select a rigid format based on the S0L card in the Executive Control Deck. 

3. railing Sequence: CALL XRGDFM (NEWS0L,0LDS0L,IAPP) 

NEWS(3L - Two-word array containing solution and subset numbers taken from S0L 
control card. 

(ilLDS0L - Two-word array containing solution and subset numbers taken from the 

Old Problem Tape if the problem is a restart. If not a restart, 0LDS0L = 0. 

lAPP - Approach code (1 = F0RCE, 2 = DISPL, 3 = DMAP) taken from the APP card 
in the Executive Control Deck. 

4. Method: If the problem is being restarted, a check is made for a solution (Rinid 
Format) change. If the solution has been changed, a bit is set in table MEDMSK in 
named common block /XMDMSK/. 



4.2-1 



MODULE FUNCTIONAL DESCRIPTIONS 

A check is made for a legal solution number, and, if acceptable, a branch is made 
on the solution number, and subroutine LDi (i = solution number) is called to create the 
DMAP and MED records for the XCSA table. XRGDFM then returns to the calling routine XCSA. 

4.2.5.2 Subroutine Name: LDi, where i = solution number, i = 01, 02, .,., 12. 

1, Entry Point: LDi 

2, Purpose: To write the DMAP sequence and MED records of the XCSA Executive Table for 
solution (Rigid Format) i (see XCSA Executive Control Table description, section 2.4.2.5), 

3, Calling Sequence: CALL LDi (SUBSET) 

SUBSET - Solution subset number from the S0L control card. 

4, Method: The packed DMAP program is generated, and then subroutine XSBSET is called to 
select the proper solution subset for the DMAP proaram by altering the ISl array. Uoon 
return from XSBSET the arrays ISl, JNM and INM (see 4.2,6,2 below) are written on the New 
Problem Tape to complete the MED record for Executive Table XCSA. LDi then returns to 
calling routine, 

5, Restrictions: Due to restrictions imposed by various FORTRAN compilers, lengthy Rigid 
Formats (e.g., Piecewise Linear Analysis (i » 06), Direct Complex Eigenvalue Analysis (i = 08) 
have required auxiliary subroutines (e.g., L061 auxiliary to LD06 and L081 auxiliary to LD08, 
see section 4.2.5.3) to contain the Rigid Format. 

4.2.5.3 Block Data Subprograms LiBD and LiABD 

Associated with each LDi subroutine are the block data programs LiBD and LiABD for i = 01 , 

02 12, While the LDi subroutine contains the i Rigid Format in F0RTRAN DATA statements, 

the LiBD block data subprogram contains bit numbers for the Card Name Restart Table and bit 
numbers for the File Name Restart Table for the i*^ Rigid Format, and the LiABD block data sub- 
program contains the general Restart Tables for the i Rigid Format, 

4.2.5.4 Subroutine Name: XSBSET 

1, Entry Point: XSBSET 

2. Purpose: To eliminate DMAP instructions not belonging to the specified subset by 
altering the ISl array, 

4.2-2 



EXECUTIVE PREFACE MODULE XCSA (EXECUTIVE CONTROL SECTION ANALYSIS) 

3. Calling Sequence: CALL XSBSET (IDl ,NSS, SUBSET, ISl ,NDI,NWPI) 

IDl - Table containing DMAP instruction numbers of those instructions that are 
not part of the specified subset. 

NSS - Number of subsets in table IDl. 

SUBSET - Subset to be selected from table IDl. 

ISl - Module execution decision table. 

NDI - Number of DMAP instructions in DMAP program. 

NWPI - Number of words per ISl entry. 

4. Method: Table IDl is searched and the proper subset is selected. Each DMAP instruction 
has a corresponding entry in table ISl. If the ISl entry for an instruction is zero, then 
the instruction is eliminated from the DMAP program. Therefore zeroing the ISl entries of 
those instructions specified in table IDl yields the proper subset. XSBSET then returns to 
the calling routine. 

4.2.6 Design Requirements 

4.2.6.1 Use of Open Core 

Open core is used for GIN0 buffers, for generating the XPTDIC Executive Table (see section 
2.4) on restarts, and for storing user generated DMAP programs. Named common block /XCSABF/ 
defines the beginning of open core for module XCSA. Since XPTDIC is not stored permanently in 
open core and because the use of open core to store a DMAP program and a call to LDi are 
mutually exclusive, the LDi subroutines can be origined for overlay purposes at the same location 
as /XCSABF/. 

4.2.6.2 Restart Tables Initialized in the Routines 

The following tables are initialized by the LDi (i = solution number) subroutine or its 
associated Block Data program and are used to aid module XGPI in restarting a problem which uses 
Rigid Format i . 

1. ISl - Module Execution Decision Table: This table when used in conjunction with table 
MEDMSK in named common block /XMDMSK/ will provide module XGPI with the information needed 
to decide whether or not to set the execute flag in an 0SCAR entry. Each DMAP instruction 



4.2-3 



MODULE FUNCTIONAL DESCRIPTIONS 

in a Rigid Format has a corresponding entry in IS! . An entry in IS! can be one to five 
words in length, and only bits 1 through 31 are used to form a truth table. Note that if 
an IS! entry is zero, the corresponding DMAP instruction is unconditionally excluded from 
the Rigid Format DMAP program being compiled by module XGPI. 

2. JNM - File Name Restart Table: The JNM table provides module XGPI with the capability 
of regenerating data blocks which are missing in the restart dictionary and which are 
needed to restart the problem. Note that the restart must be a modified restart. If a 
data block is missing, the JNM table will indicate which bit to set in table MEDMSK, MEDMSK 
is then used with ISl to determine which DMAP modules must be re-executed in order to 
correctly regenerate the missing data block. 

Sample JNM Entry: 



Word 1 
2 
3 



Data Block 
Name (BCD) 



BN (integer) 



BN is the bit number of the bit which is to be set in table MEDMSK to regenerate the 

specified data block. The usable bits (bits 1-31) of MEDMSK are numbered sequentially 

starting from bit 31 of the first word. MEDMSK is five words long. 

Example: 



BN = 
MEDMSK 

Word 



,.,93, 9't , . . . ,l2k, 125, ...,155. 



S31 



] S 31 



lS31 



iS 3 1 



; S 31 



1 



3. INM - Card Name Restart Table: When the problem is beinn restarted and inout data 
(Bulk Data and/or Case Control Data) has been modified, table INM tells module XGPI 
whether or not the modifications affect the compilation of the DMAP program associated 
with the Rigid Format. Table MJCD in named common block /IFPXl/ and table MJMSK in named 
common block /IFPXO/ indicate which cards have been modified. If INM has an entry for a 
modified card, the INM entry will indicate which bit to set in table MEDMSK. MEDMSK is 
then used with ISl to determine which DMAP modules must be re-executed. 



4.2-4 



EXECUTIVE PREFACE MODULE XCSA (EXECUTIVE CONTROL SECTION ANALYSIS) 



Sample INM Entry: 



Word 1 
2 
3 



-- Card Name (BCD) 
BN (integer) 



BN is the number of the bit which is to be set in table MEDMSK if the associated card name 
has been modified. See sample JNM entry for further description of BN. 

4. IDl - Subset Table: DMAP instructions in a DMAP program are numbered sequentially 
starting with "BEGIN" as instruction number 1. Table IDl contains the instruction numbers 
of those instructions that are not to be included in a subset. 

Sample IDl Entry: 



Word 1 


"l 


(integer) 




2 


'i 


(integer) 


I 


• 


• 


> N, words 


m, 


h 


) 




• 





Repeat for all subsets 



N^ = number of instructions to delete in subset 1. (N, >^ 0) . 
I . - I|^ = DN!AP instruction numbers of instructions to be deleted. 



4.2-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.2.7 Diagnostic Messages 

Every effort is made to get through module XCSA so that the modules IFP1 and IFP can process 
the Case Control Deck and the Bulk Data Deck. XCSA sets the N0G(2i flag in named common block 
/SYSTEM/ according to the severity of the errors found. 

N0GS8 = - no errors found. 

1 - job will terminate after module XGPI. 

2 - job will terminate after IFP modules. 

3 - job terminates in XCSA. 

See diagnostic message section of User's Manual (section 6.2) for a detailed discussion of 
XCSA error messages. XCSA messages include numbers 501 thru 526. 



4.2-6 



EXECUTIVE PREFACE MODULE IFPl (INPUT FILE PROCESSOR, PART 1) 

4.3 EXECUTIVE PREFACE MODULE IFPl (INPUT FILE PROCESSOR, PART 1) 

4.3.1 Entry Point : IFPl 

4.3.2 Purpose 

To process the Case Control Deck, See section 2,3 of the User's Manual for a discussion 
of the Case Control Deck, 

4.3.3 Calling Sequence 

CALL IFPl. IFPl, a Preface module, is called only by subroutine SEMINT. 

4.3.4 Input Data 

The input data consists of the Case Control Deck and the CASECC data block from the Old 
Problem Tape if the problem is a restart. 

4.3.5 Output Data Blocks 

CASECC - Ccse Control Data Table. 

PCDB - Plot Control Data Table (for the structure plotter), 

XYCDB - XY output Control Data Block, 

Notes : 

1. CASECC will always exist. 

2. PCDB will exist only if a structure plotter package is included in the Case 
Control Deck. 

3. XYCDB will exist only if a XY0UT plotter package is included in the Case 
Control Deck. 

4.3.6 Method 

The Case Control Cards are read and stored on a scratch file for later use. The title 
cards are abstracted to form page headings. Title card abstraction is stopped by a SYM, SUBCASE, 
SYMC0M or REPCASE card. IFPl is stopped by a BEGIN BULK card. 



4.3-1 



MODULE FUNCTIONAL DESCRIPTIONS 

The construction of CASECC is as follows: 

1. The scratch tape is read one card at a time, and subroutine XRCARD is called to 
translate the card. 

2. The first four characters beginning with a non-blank are identified in a key word 
table, and card type dependent routines are executed, (See Case Control Deck in User's 
Manual). 

3. When "SUBCASE" type cards are encountered, a CASECC record is written out. 

4. If the card OUTPUT (PL{)T) is encountered, XRCARD images of succeeding cards are written 
on PCDB. 

5. If the card OUTPUT (XYfJUT) is encountered, IFPIXY processes the succeeding cards into 
the XYCDB. 

The module conclusion is as follows: 

1. A copy of CASECC is placed on the NPTP for use in restart. 

2. If this run is a restart, IFPIB is called to analyze CASECC changes and set modify flags 
for later use in Executive Preface module XGPI (see section 4.7). 

4.3.7 Subroutines 



4.3.7.1 Subroutine Name: IFPIB 

1. Entry Point: IFPIB 

2. Purpose: To set modify flags for use in modified restart. 

3. Calling Sequence: CALL IFPIB (ICASE, (JPTP, CASECC, IBUFl ,IBUF2,LENCC) 

ICASE - A two-dimensional array (LENCC,2) for storage of both copies of CASECC 

array - input. 
0PTP - GIN0 file name of the Old Problem Tape - BCD - input. 
CASECC - GIN0 file name of CASECC - BCD - input. 

IBUF2} " '"^'^^ buffer pointers - integer - input. 
LENCC - Row dimension of ICASE - integer - input. 



4.3-2 



EXECUTIVE PREFACE MODULE IFPl (INPUT FILE PROCESSOR, PART 1) 

C0MM0N/IFPXO/SPACE(3) ,NW0RDS 

NW0RDS - Pointer into /IFPXO/ such that IFPl modify flags are in SPACE{NW0RDS) . 

4. Method: 

CASECC and the copy of CASECC on the 0PTP are compared according to the following 
scheme. The local array IW0RD classifies each word in CASECC into and 1, words: If 
the CASECC word is non-zero and IBIT is non-zero in this position, the IBIT bit is turned on 
in /IFPXO/. 1 word: If the CASECC word is different from the 0PTP word and IBIT is 
non-zero in this position, the IBIT is turned on in /IFPXO/. 

IFPIB also determines the loop nature of the problem. The looping rules are as 
follows: 

a. The current problem will loop under the following conditions: SPC set changes; 
MPC set changes; direct input matrix changes; transfer function set changes; tran- 
sient load changes; differential stiffness coefficient set is greater than zero; and 
Piecewise Linear coefficient set is greater than zero. If any of the above 
conditions are met, L00P$ is turned on in /IFPXO/. 

b. The old problem might have been a looping problem if the above conditions were 
present in the 0PTP CASECC. If the old problem was a looping problem as determined 
in (a) and the number of records in CASECC changes, L00P1$ is set (this should 
force the re-execution of the entire loop). 

c. If the problem is not a looping problem, N0L00P$ is set. 

4.3.7.2 Subroutine Name: IFPIC 

1. Entry Point: IFPIC 

2. Purpose: To construct set lists from SET cards. 

3. Calling Sequence: CALL IFPIC (ISUB, 181 ,C0RE,SCR1 ,NWPC, ICC, NZ, THRU, NSET) 

ISUB - 1 - master set. 2 - set belongs to a subcase - integer - input. 

181 - Pointer to storage for set in core - integer - input/output. 

C0RE - Open core array. 

SCRl - GIN0 file number of scratch file containing card images - integer - input. 



4.3-3 



MODULE FUNCTIONAL DESCRIPTIONS 

NWPC - Number of words per card - integer - input. 

ICC - Current line count of Case Control card echo - integer - input/output. 

NZ - Length of open core - integer - input/output. 

THRU - BCD value "THRU" - BCD - input. 

NSET - Number of sets found to current set - integer - input. 

4.3.7.3 Subroutine Name: IFPID 

1. Entry Point: IFPID 

2. Purpose: To write user diagnostic messages from IFPl . 

3. Calling Sequence: CALL IFPID (MSGN) 

MSGN - User message number - integer - input. 

4.3.7.4 Subroutine Name: IFPIE 

1. Entry Point: IFPIE 

2. Purpose: To write out CASECC and update sets. 

3. Calling Sequence: CALL IFPIE (CASE,ISUBC,SYMSEQ.NWDSC,I81 ) 

CASE - Array containing Case Control record to be written out (CASE (LENCC,2)). 

ISUBC - Five word BCD array containing current subcase number - BCD - output. 

SYMSEQ - Symmetry coefficient array - real - input. 

NWDSC - Pointer to beginning of set lists - integer - input/output. 

181 - Pointer to end of set list - integer - output. 

4.3.7.5 Subroutine Name: IFPIF 

1. Entry Point: IFPIF 

2. Purpose: To find the first four characters beginning with a non-blank on one input 
card. 



4.3-4 



EXECUTIVE PREFACE MODULE IFP1 (INPUT FILE PROCESSOR, PART 1) 

3. Calling Sequence: CALL IFPIF ($n.IW0RD,IS,IBEN,II) 

$n - F0RTRAN statement number which defines the return to be taken if the entire 
card is blank. 

IW0RD - First four characters beginning with a non-blank, left justified - BCD - output. 
IS - Number of bits/character times (number of characters/word-1 ) - integer - input. 
IBEN - Mask used to determine if character is blank 'bOOO' - input. 
II - Pointer to word in which IW0RD begins - integer - output, 
C0MM0N/IFP1X/C!3RE(2O) 

IFPIX - 20-word array holding card image - BCD - input. 
C0MM0M/IFP1A/ 

IFPIA - See /IFPIA/ description under Design Requirements (section 4.3.8). 
4.3.7.6 Subroutine Name: IFPIG 

1. Entry Point: IFPIG 

2. Purpose: To find an equal sign and copy the remainder of the data into a specified arrays 

3. Calling Sequence: CALL IFPIG (ITYPE.CASE.ISUBl) 

ITYPE - Indicates area in which to store data. 

1. TITLE \ 

2. SUBTITLE j 

3. LABEL f 

4. HEADl > of /0UTPUT/ 

5. HEAD2 I 

6. HEAD3 1 

7. PL0TID ^ 

8. First 32 words of CASE 

- integer - input. 
CASE - Case control array (132,2) unless ITYPE = 8, when it may be only 52 word array. 
ISUBl - Subcase number -1 or 2 of CASE array. 

C0MM0N/IFP1X/C0RE(2O) 
IFPIX - 20-word array holding card image. 



4.3-5 



MODULE FUNCTIONAL DESCRIPTIONS 

C0MM0N/S)UTPUT/ 
0UTPUT - Output common block - holds BCD titles for NASTRAN pages. 

C0MM0N/IFP1A/ 
IFPIA - See /IFPIA/ description under Design Requirements (section 4.3.8). 

4.3.7.7 Subroutine Name: SWSRT 

1. Entry Point: SWSRT 

2. Purpose: To check set lists for duplicates and overlapping intervals. SWSRT also 
sorts lists into increasing order. 

3. Calling Sequence: CALL SWSRT (LIST,IST0R.NLIST) 

LIST - Array of set members. 

IST0R - Scratch space of length NLIST. 

NLIST - Number of members in LIST. 

4.3.7.8 Subroutine Name: IFPIXY 

1. Entry Point: IFPIXY 

2. Purpose: To construct the XYCDB data block. 

3. Calling Sequence: CALL IFPIXY (FLAG) 

FLAG - 0, first entry for initialization; 1, data entry; -1, last entry. FLAG is set 
to 1 on return from the first entry - integer - input/output. 

C0MM0N/ I FP 1 X/CARD ( 20 ) , CARD 1 ( 20 ) 

CARD - Contains card data as read from the input file. 

CARD! - Contains XRCARD translation of CARD unless CARD(l) contains 'XTIT', 'YTIT', 

'TCUR', 'YTTI' or 'YBTI'. In this case CARD! (20) contains BCD data occurring 

after the equal sign. 

4.3.8 Design Requirements 

1 . One scratch file. 

2. Open core at /IFPIX/. 



4.3-6 



EXECUTIVE PREFACE MODULE IFPl (INPUT FILE PROCESSOR, PART 1) 



C0MM0N/IFP1X/ 



Card 
Image 



XRCARD 

translation 

of input card 



20 words 



set lists 
currently 
active 



2 GIN0 buffers 



3. Common block IFPIA. 



Name 


Length 


Meaning 




Initialized to 


NAME 


2 


Name of data block for error 
messages. 




CASE 
CC 


SUBC 




Subcase key word 




SUBC 


SET 




Set key word 




SETb 


SYMS 




Symmetry sequence key word 




SYMS 


TSTE 




Time step card selection key 


word 


TSTE 


LABE 




Label key word 




LABE 


SUBT 




Subtitle key word 




SUBT 


SCRl 




GIN0 file number of scratch 


file 


301 


CASECC 




GIN0 file name of CASECC 




CASE 


BLANK 




Blank word 




bbbb 



4.3-7 



MODULE FUNCTIONAL DESCRIPTIONS 



Name 

CARD 

C0UN 

T 

BEGI 

TITL 

CASEN 

SPCF 

VEL0 

ACCE 

ELF0 

STRE 

DISP 

0UTP 

SYM 

FREQ 

DL0A 

TEMP 

DEF0 

TIME 

SPC 

MAXL 

IC 

METH 

L0AD 

MPC 

STIF 

ALL 

THRU 

S0RT 

UNSCI 



Length 



Meaning 
Heading word card 

Heading word 
C0UNT 

Begin bulk key word 

Title key word 

Case Control page heading 

Forces of constraint key word 

Velocity key word 

Acceleration key word 

Element forces key word 

Element stress key word 

Displacement key word 

Output key word 

Symmetry subcase key word 

Frequency set key word 

Dynamic loading key word 

Temperature field key word 

Deformation set key word 

Time key word 

Single-point constraint set key word 

Maximum number of output lines key word 

Initial condition set selection id 

Real eigenvalue or buckling method 
selection key word 

Load set selection key word 

Multipoint set selection key word 

Stiffness thermal field key word 

ALL key word 

THRU key word 

Sorted echo key word 

Unsorted echo key word 



Initialized to 

CARD 

C0UN 

T 

BEGI 

TITL 

Case Control 
Deck echo 

SPCF 

VEL0 

ACCE 

ELF0 

STRE 

DISP 

0UTP 

SYM 

FREQ 

DL0A 

TEMP 

DEF0 

TIME 

SPC 

MAXL 

IC 

METH 

L0AD 
MPCb 
STIF 
ALLb 
THRU 
S0RT 
UNS0 



4.3-8 



EXECUTIVE PREFACE MODULE IFPl (INPUT FILE PROCESSOR, PART 1) 



Name 
ECH0 
PL0T 
M0DE 
PUNC 
PRIN 
NWPC 
NCPW 
B0TH 
N0NE 
PCDB 
NAME 

VECT 

SYMC 

EQUAL! 

NM0DES 

IB0B 



I END 

ISYMCM 

L0ADN 

I0UT2 

ICC 

NSET 

NSYM 

IN0M0R 

NPTP 

0PTP 

D0L 

ZZZZBB 



Length 



Meaning 






Initiated to 


Bulk data echo key word 






ECH0 


Plot key word 






PL0T 


Modes key word 






M0DE 


Punch key word 






PUNC 


Print key word 






PRIN 


Number of words per card 






20 


Number of characters per word 


(NASTRAN) 


4 


Echo-sorted and unsorted 






B0TH 


None key word 






N0NE 


Plot control data GIN0 file 


name 


PCDB 


GIN0 error message for PCDB 


fi 


le 


PCDB 
bbbb 


Alternate displacement key 


vord 


VECT 


Symcom key word 






SYMC 


Equal sign left adjusted 






=bbb 


Value of modes card 






1 


Structure plot flag 










0, not currently in structure 
plot mode 

1, in structure plot mode 



Symcom flag 

Current Subcase ID number 

Printed card count 

Number of current set lists 

Number of 'SYM' subcases 

Flag to turn off Title card search 

GIN0 file name of the New Problem Tape 

GIN0 file name of the Old Problem Tape 

Dollar sign 

Hollerith zeros 







1 



1 



1 



NPTP 

0PTP 

$bbbb 

OOOObb 



4.3-9 



MODULE FUNCTIONAL DESCRIPTIONS 



Name 

ISTR 

ISU3 

K2PP 
B2PP 
M2PP 

0500 

REPC 

LENCC 

LINE 

m 

TFL 

DEFA 

ELST 

MAT 

0FRE 

I MAG 

PHAS 

REAL 

CMET 

SDAM 

INER 

ADIS 

AVEL 
AACC 

N0NL 
C0NF 
XYPL 
PLC0 



Length 



Meaning 
Storage flag for IFP1G titles 
Subcase or master CASECC pointer 



Initiated to 
1 

1 



K2PP 

Key words for direct innut matrix selection B2PP 

M2PP 

Key word for differential stiffness set DSC0 
selection 

Key word for repeat subcase subcase REPC 

Length of Case Control Record 166 

Key word for LINE/page count LINE 

Word to distinguish between SUBC0M 0Mbb 
SUBCASE 

Key word for transfer function set selection TFL 

Key word for default specification DEFA 

Key word for element stress set selection ELST 

Key word for thermal material set selection MATE 

Key word for output frequency set selection 0FRE 

Key word for real/imaginary printout IMAG 

Key word for magnitude/phase printout PHAS 

Key word for real or real /imaginary printout REAL 

Key word for complex eigenvalue set selection CMET 

Key word for Structural Damping Table for SDAM 
use in modal formulation 

Key word for Inertia Relief Element set INER 
selection 

Key word for solution set displacement SDIS 
selection 

Key word for solution set velocity selection SVEL 

Key word for solution set acceleration SACC 
selection 

Key word for non-linear load set selection N0NL 

Not used 

Key word for XYPL0T packet delimiter XYPL 

Key word for Piecewise Linear set selection PLC0 



4.3-10 



EXECUTIVE PREFACE MODULE IFPl (INPUT FILE PROCESSOR, PART ]] 



Name 
AXIS 

NLL0 

DELE 

XYCB 

0NEB 

HARM 

SINE 

COS I 

SUBS 

AVEC 

F0RC 

RAND 

XY0U 

0L0A 

PLTl 

PLT2 

XT IT 
YTIT 
TCUR 
YTTI 
YBTI 

IBEN 

EQUAL 

4 



Length 



Meaning 

Key word for selection of Axis 
symmetric boundary condition 

Key word for non-linear output 
set selection 

Key word for element deletion 
set selection 

GIN0 file name of XY control data block 

BCD one 

Key word for harmonic output control 

Key word for sine boundary conditions 

Key word for cosine boundary conditions 

Key word for SUBSEQ 

Key word for solution set vector output 

Not used 

Key word for random set selection 

Key word for XYPLiJT packet delimiter 

Key word for output load set selection 

GIN0 file name of BCD plot tape 

GIN0 file name of binary plot tape 

Key words for XY output titles 



Initiated to 

AXIS 

NLL0 

DELE 

XYCB 
Ibbb 
HARM 
SINE 
COSI 
SUBS 
SVEC 

RAND 

XY0U 

0L0A 

PLTl 

PLT2 

XT IT 
YTIT 
TCUR 
YTTI 
YBTI 



Right shifted blank 'OOOb' 
Right shifted equal '000=' 

Interface with /SYSTEM/ (see section 2.4). 

IFPl can set the following cells of SYSTEM: 

a. N0G0 - (N0G0 flag). If a fatal error is detected. 

b. NLPP - (Number of lines per page). If a LINE card is supplied by the user. 

c. STFTEM - (Material Temperature Set ID). If a TEMP(MATE) card is supplied. 

d. ECH0 - (Echo flag). If an ECH0 request is made. 

e. SPL0TS - (Structure Plot Request). If a structure plot packet is requested, 



4.3-11 



MODULE FUNCTIONAL DESCRIPTIONS 

f. PL0TF - (Plot Flag). If a structure plot request is present. 
5. Interface with /0UTPUT/. 

IFPl supplies the problem title, subtitle, and label as well as the Plot ID. 

4.3.9 Diagnostic Messages 

IFPl makes every attempt to process the entire Case Control Deck so that the complete 
Preface will run. Hence all fatal messages only cause the N0G0 flag to turn on. 

IFPl causes messages 601-699. For the exact nature of these messages, refer to the 
Diagnostic Message section of the User's Manual. 



4.3-12 



EXECUTIVE PREFACE MODULE XS0RT (EXECUTIVE BULK DATA CARD S0RT) 
4.4 EXECUTIVE PREFACE MODULE XSI3RT (EXECUTIVE BULK DATA CARD S0RT) 

4.4.1 Entry Point : XS0RT 

4.4.2 Purpose 

The function of XS0RT is to prepare a file on the New Problem Tape containing the sorted 
bulk data. The operation of XS0RT is influenced by the type of run. If a cold start, the bulk 
data is read from the system input stream (or the User's Master File), sorted and written on the 
New Problem Tape. If an unmodified restart, the bulk data is copied from the Old Problem Tape 
onto the New Problem Tape. If a modified restart, the bulk data is read from the Old Problem 
Tape, and cards are deleted and/or added in accordance with cards in the system input stream. 
Additionally, flags are set within restart tables for each card type changed in any way. Again, 
the sorted bulk data is written onto the New Problem Tape. A print of the unsorted and/or sorted 
bulk data is made on request. XS0RT processes all data cards between the BEGIN BULK and ENDDATA 
cards in the input stream. Both cards must be present to properly bracket the NASTRAN Bulk 
Data Deck. 

4.4.3 Calling Sequence 

CALL XSfJRT. XS0RT, a Preface module, is called only by the Preface driver, SEMINT. 

4.4.4 Method 

If the input is to be from a User Master File, XS(3RT begins by positioning the file to the 
beginning of the proper subset of bulk data cards. INITC0 is then called to initialize machine 
dependent masks and constants. The open core below XS0RT (/ES0RT/) is divided into 5 GIN0 buffers 
and a work buffer. This work buffer will contain each data card and a chaining pointer to 
indicate its sorted position. That is, the cards will be placed into the work buffer in the 
same order as read, but their sorted order will be shown by a chaining word with each card 
pointing to the position of the next card in alphanumeric sort. If the work buffer is unable 
to hold all of the bulk data cards, each subset that fills the buffer is unchained and written 
in sorted order onto a scratch file. This writing onto a scratch file frees the work buffer for 
another subset of data cards. 



4.4-1 



MODULE FUNCTIONAL DESCRIPTIONS 

Three scratch files may become involved in sorting a large number of bulk data cards. 
After the first two scratches are filled with sorted subsets, they are merged, while main- 
taining the sorted order, onto a third scratch. From this point, after each new subset 1s 
written onto a scratch, it is merged with the scratch containing all previous subsets. As 
an example, assume three scratches are named A, B, and C. Scratch A is written with the first 
subset of data from a filled work buffer. Scratch B is written with the second subset. 
Scratch A and B are then merged to form scratch C. This frees scratch A and B. Scratch A is 
then written with the third subset of data. A and C are merged to form a new B. A is then 
written with the fourth subset. A and B are merged to form a new C. This process continues 
until all bulk data has been sorted. Following the final merge, one of the scratch files 
will contain all of the sorted bulk data cards. 

As the sort and merge operations are being performed, any continuation cards or delete 
cards encountered are written onto separate holding files. After all data cards in the input 
stream have been processed, each of these holding files is processed. The delete card values 
are placed in ascending order and any overlaps or redundancies are removed. The continuation 
cards are checked for duplication and an in-core dictionary of their connection words is formed. 

XS0RT may now make a pass through the scratch file containing all of the sorted bulk data 
cards within the input stream. During this pass, the User Master File (UMF) or the Old 
Problem Tape (0PTP) data cards are merged with those from the input stream. Both the UMF and 
0PTP data cards were properly sorted during their preparation. As this merge progresses, any 
data cards designated for removal by delete control cards are discarded. If the NASTRAN run 
for which XS0RT is operating is a restart, all data cards within the input stream plus any 
deleted from the 0PTP will cause data card type flags to be set within restart tables. This 
entire pass is not performed if the run does not require either a UMF or 0PTP. 

Now a final pass of the resulting sorted data is made to introduce any continuation cards 
and write the completed Bulk Data Deck onto the New Problem Tape. The continuation cards are 
connected to the sorted data cards by matching connection words. Continuation cards can in no 
way affect the sorted order. If a print of the resulting sorted deck is requested, it is 
performed during this pass. 

During any sort collation the data cards are ordered by comparing half-fields from left 
to right. Each bulk data card may contain up to ten, eight column (character) fields. 



4.4-2 



EXECUTIVE PREFACE MODULE XS0RT (EXECUTIVE BULK DATA CARD S0RT) 

Because of computer word size constraints, each data card is stored into twenty memory words, ^'our 
characters (half a card field) per word. Sorting proceeds by comparinci the first words (4 charac- 
ters) from each card. If an order cannot be established, i.e., the words are equal, the second 
words from each card are compared, and so on, until an order is established or total duplication 
is determined. Each field (8 characters) is left (BCD) or right (integer) justified prior 
to sorting to eliminate leading or trailing blanks. The characters within the first field 
of each card are converted to a special internal character set prior to comparing to eliminate 
machine dependent collation sequences which might order the same cards differently on different 
machines. This internal set forces the collation order to be ascending from blank through 
all numbers then all letters. A flowchart is given in Figure 1. 

4.4.5 Subroutines 



In the following, note that XRECPS, RPAGE, INITC0, XFADJ, XBCDBI, XPRETY, CRDFLG, EXTINT, 
and INTEXT are secondary entry points in XRECPS. 

4.4.5.1 Subroutine Name: XRECPS 

1. Entry Point: XRECPS 

2. Purpose: Positions the continuation card file to the proper record (card image) as 
determined from the in-core continuation card dictionary. 

3. Calling Sequence: CALL XRECPS (NEW, 0LD) 

Where: NEW = the file position being requested 
0LD = the file position last requested. 
Both arguments are integer record numbers. 

4.4.5.2 Subroutine Name: RPAGE 

1. Entry Point: RPAGE 

2. Purpose: Counts output print lines for XS0RT, and performs the necessary interface 
with the system subroutine PAGE. 

3. Calling Sequence: CALL RPAGE (NLINE) 

Where: NLINE = integer number of lines being output. If NLINE >_ 100 a page eject is 



4.4-3 



WDULE FUNCTIONAL DESCRIPTIONS 

forced and the line count Is set to NLINE - TOO. 

4.4.5.3 Subroutine Name: INITC0 

1. Entry Point: INITC0 

2. Purpose: Initializes machine dependent masks and constants within XSjtRT. 

3. Calling Sequence: CALL INITC0 

4.4.5.4 Subroutine Name: XFADJ 

1. Entry Point: XFADJ 

2. Purpose: Adjusts four character fields, left or right, two or four fields at 

a time. If the fields contain only integers, the shift is right, otherwise the shift 
will be left. This routine determines only the direction of shift required. Actual 
shifting is performed by XFADJl. 

3. Calling Sequence: CALL XFADJ (BUF.SD.K) 
Where: BUF = field array to be shifted 

(0, shift two fields at a time 



SD ■^' 

[], shift four fields at a time 

0, returned if right shift was done. 

1, returned if left shift was done. 

4.4.5.5 Subroutine Name: XBCDBI 

1. Entry Point: XBCDBI 

2. Purpose: Converts two, four character BCD integer fields (right adjusted in the left 
most four characters of the computer word) into a single binary integer (right adjusted 
in the second of the two Input words). 

3. Calling Sequence: CALL XBCDBI (BUF) 
Where: BUF = two v/ord array to be converted. 

4.4.5.6 Subroutine Name: XPRETY 
1. Entry Point: XPRETY 



4.4-4 



EXECUTIVE PREFACE MODULE XS0RT (EXECUTIVE BULK DATA CARD S0RT) 

2. Purpose: "Pretties-up" printed output by left adjusting all fields to eliminate any 
leading zeros introduced when integer fields are right adjusted. 

3. Calling Sequence: CALL XPRETY (BUF) 
Where: BUF = card image array. 

4.4.5.7 Subroutine Name: CRDFLG 

1. Entry Point: CRDFLG 

2. Purpose: Sets the card type flags within the restart tables. 

3. Calling Sequence: CALL CRDFLG (CARD) 

Where: CARD = first of two word card type field. 

4.4.5.8 Subroutine Name: EXTINT 

1. Entry Point: EXTINT 

2. Purpose: Converts card type field from the machine dependent character code to 
an internal machine independent code. 

3. Calling Sequence: CALL EXTINT (CTYBF) 

Where: CTYBF = first of two word card type field. 

4.4.5.9 Subroutine Name: INTEXT 

1. Entry Point: INTEXT 

2. Purpose: Converts the card type field from an internal machine independent code to 
the machine dependent character code. 

3. Calling Sequence: CALL INTEXT (CTYBF) 

Where: CTYBF = first of two word card type field. 

4.4.5.10 Subroutine Name: XFADJl 

1. Entry Point: XFADJl 

2. Purpose: Adjust four character fields left or right, two or four fields at a time. 
This routine performs actual shifting with the direction of shift controlled through the 



4.4-5 



MODULE FUNCTIONAL DESCRIPTIONS 



calling sequence. (Note entry point XFADJ). 

3. Calling Sequence: CALL XFADJl (6UF, SHIFT. SD) 

Where: BUF = Field Array to be shifted. 
SHIFT = Function LSHIFT or RSHIFT. 

(O, shift two fields at a time. 



SD = 

(.1, shift four fields at a time. 

4.4.5.11 Function Name: ISFT 

1. Entry Point: ISFT 

2. Purpose: Performs special shifting functions for subroutine XFAJl. 

3. Calling Sequence: CALL ISFT 

RESULT = ISFT(BUF,SFTCNT,J) 

where: BUF = Word to be shifted. 
SFTCNT = Bits to be shifted. 

J = Shift direction control; 3 - right, 4 = left. 

4.4.6 Design Requirements 

1. Data cards operated upon by XS0RT must conform to the NASTRAN format for bulk 
data cards (ten, eight character fields per card). See section 2 of the User's Manual 
for details. 

2. Data cards must contain only valid BCD key punch codes or blanks. Non-standard 
multi -punched code (e.g., some IBM EBCDIC) will cause unpredictable results. 

3. XS0RT requires sufficient open core to contain five GIN0 buffers and a work buffer 
for at least ten data cards. (Each data card requires twenty-one core locations). Sort 
efficiency increases in proportion to the size of the work buffer. 

4. The continuation card dictionary must fit into the core work buffer during the final 
pass. Each continuation card requires two dictionary locations. 

5. XS0RT logic is biased toward input that is already sorted. That is, the program 
will operate at a much greater speed if verifying a sort rather than producing a sort. 



4.4-6 



EXECUTIVE PREFACE MODULE XSi3RT (EXECUTIVE BULK DATA CARD S0RT) 

4.4.7 Diagnostic Messages 

XS0RT can produce two catagories of diagnostic messages. The first are termed USER 
messages and deal with bulk data card errors. The second are termed SYSTEM messages which 
are generally fatal in nature and indicate serious 1/0 malfunctions. 

XS0RT message numbers includes 201 through 216. All messages are listed and explained in 
section 6 of the User's Manual. 



4.4-7 



MODULE FUNCTIONAL DESCRIPTIONS 



XSiJRT 




Position UMF 
to proper file 



Call 

INITC0 

to initialize 

constants & 

masks 




lA 



Initialize work buffer 
with low & high limit 




2A 



Read card 
from input 




Print card 



Adjust char, to left 
to each field 




Write card on 
contin. file 





Write card on 
delete file 





IB 



Figure l.(a) Flowchart for module XS0RT. 



4.4-8 



EXECUTIVE PREFACE MODULE XS0RT (EXECUTIVE BULK DATA CARD S0RT) 




Between 



Does 
field on 
this card fall 
between same fields on 
,j;wo other cards or is^ 
it equal to^ 
other- 



Move to 
next field 



Has 
last field 
been reached^ 
? 



No 




Yes 



Merge two scratches & 
form a 3rd scratch 



Duplicate card 



Sorted position found 
set chaining pointer 




2A 




2B 




Unchain sorted work buffer 
and write on a scratch 




Set-up next 
scratch for 
next unload 



I 



lA 




Process delete card file - sort 
& eliminate redundancy re-write 
onto file 



^ 

Merge Old Prob. Tape or UMF 

with final merged scratch from 
input. Remove any cards deleted 




IC 



Figure l.(b) Flowchart for module XS0RT. 
4.4-9 



MODULE FUNCTIONAL DESCRIPTIONS 




Fonii continuation card 
dictionary in core 



I 



Copy sorted card 
file onto new 
problem tape 



Scan sorted card file produced 
from the last merge (T) or merge 
0if UMF or restart 





Print card{s) 



f RETURN j 



Copy sorted card without 

continuation onto new 

problem tape 



Collate cont. card with sorted 
card. Write both onto new 
problem tape 




ID 



Figure l.(c) Flowchart for module XS0RT. 



4.4-10 



EXECUTIVE PREFACE MODULE XS0RT (EXECUTIVE BULK DATA CARD S0RT) 




Figure 1.(d) Flowchart for module XS0RT. 
4.4-11 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 

4.5 EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 

4.5.1 Entry Point : IFP 

4.5.2 Purpose 

To process the Bulk Data Deck sorted by Executive Preface module, XS;jRT. This task is 
accomplished as follows: 1) the sorted Bulk Data Deck is read from the New Problem Tape (NPTP) 
card-by-card; 2) the contents of each field of each card are validated (see section 2.4 of the 
User's Manual for detailed descriptions of each bulk data card); 3) card images or modified 
card images are written on data blocks or the NPTP or the Data Pool File (see section 2.3.2 of 
the Programmer's Manual for details on the formats of these data blocks). 

4.5.3 Calling Sequence 

CALL IFP. IFP, an Executive Preface module, Is called only by the Preface driver, 
subroutine SEMINT. 

4.5.4 Input 

The input to IFP consists of the Bulk Data Deck sorted by Executive Preface module XS0RT. 

4.5.5 Output 

The output of IFP consists of: 1) data blocks used in Rigid Formats; 2) the AXIC data 
block, which is processed by Executive Preface module IFP3 and is present only If the NASTRAN 
run is a conical shell (a unique structural element) problem solution; 3) the PVT Executive table, 
which contains the names and values of all DMAP parameters Input by means of the PARAM bulk data 
card, and which 1s written on the New Problem Tape to be processed by Executive Preface module 
XGPI; and 4) DMI's (Direct Matrix Inputs) and DTI's (Direct Table Inputs), each of which is 
written on the Data Pool File as a data block and is indistinguishable from any matrix data block 
or table data block pooled by the Executive Segment File Allocator (XSFA) module. 



4.5-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.5.5.1 Output Data Blocks Used in Rigid Formats 

GE0M1 - Grid point, coordinate system, and sequence data. 

GE0M2 - Element connection data. 

GE0M3 - Static loads and temperature data. 

GE0M4 - Displacement set definitions data. 

EPT - Element Property Table. 

MPT - Material Property Table. 

DIT - Direct Input Tables. 

EDT - Element Deformation Table. 

DYNAMICS - Collection of bulk data cards for a dynamics problem. 

MATP00L - Data block containing matrices input on DMIG bulk data cards. 

Note: Do not confuse the DTI (Direct Table Input) bulk data card and the DIT (Direct 
Input Table) data block. 

4.5.6 Method 

4.5.6.1 General Comments 

The bulk data cards processed by IFP are classified into five categories. Listed below is 
a brief explanation of each with a few examples. 

1. Closed End Cards (Fixed Length Card) 

Cards such as CQUAD2 and PR(3D go through all the standard bulk data card checks (see 4.5.6.2) 
before being processed by the card dependent subroutines within IFP, (IFSiP, i = 1, 2, 3, 4). 
These closed end cards are output to one of the standard GIN0 files. 

2. Open Ended Cards (Variable Length Cards) 

In cards such as SPCl and PLFACT, since the length and therefore the formats are not 
known, the bulk data checks using the data initialized in the block data subprograms 
must be made in the card dependent subroutines. Also, since the length is not known, a 
flag is placed at the end of the information for that card before being written on the 
file in order that routines reading an open ended card will be signaled as to an end-of- 
card condition. 



4.5-2 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 

3. GRDSET and BAR0R Cards 

Special cards such as GRDSET and BARfilR are not output to a GIN? data block, but are stored 
in local variables, and provide default values for the GRID and CBAR cards. 

4. DMI and DTI Cards 

DMI and DTI cards are unique in the manner in which they are used by the user and orocessed 
by IFP. The DMI card enables the user to define matrix data blocks directly, while the 
DTI card gives the user the capability to input his own table data blocks directly. The 
user must write a DMAP sequence or use the ALTER feature - see section 2.2 of the User's 
Manual - in the Executive Control Deck to alter the Rigid Format chosen in order to use 
the DMI or DTI feature since he is defining his own data blocks. Both DMI and DTI cards 
are written directly onto the Data Pool File. 

5. PARAM Cards 

PARAM bulk data cards are stored in open core by IFP until the entire Bulk Data Deck has 
been processed. PARAM cards are then written as the PVT (Parameter Value Table) on the 
NPTP for subsequent processing by the Executive Preface module XGPI. 

4.5.6.2 Card Processing 

1. IFP searches the NPTP for the Bulk Data Deck and extracts it in 20 word (one physical 
card) segments. Each card is passed to subroutine RCARD, which takes the BCD card images 
and converts the fields thereon to values, and identifies the values as to type: blank 
data field, integer data field, real single precision data field, BCD data field, real 
double precision data field or a data field which is in error. 

IFP always has two physical bulk data cards in internal storage areas: the "current" 
card and the "next" card. M is the local F0RTRAN array where the values of the current 
bulk data card are located, and Ml the local F0RTRAN array where the values of the next 
card are located. After the current card is processed, the data in Ml are transferred into 
M, and new card values for Ml are input from the NPTP. When the values from Ml are trans- 
ferred to M, the first two words (the card mnemonic) are stripped off. Ml (3) Is stored 1n 
M(l), Ml(4) is stored inM(2),and so on. 



4.5-3 



MODULE FUNCTIONAL DESCRIPTIONS 

2. /IFPXl/ is referenced to verify the admissibility of the name (mnemonic) of the 
particular card taken from the NPTP. 

3. The approach acceptability flag is checked. This flag is defined as follows: 

= OK for any approach; 

1 = Not used by displacement approach; 

2 = Illegal for displacement approach. 

The approach flag (DISPL, DMAP) is found In /SYSTEM/. 

4. The proper output files are established. See Table 1 or Table 2 for the outout file 
on which the various bulk data cards will reside. 

5. Uniqueness flags, which reside In C(JMM(}N/IFPX5/, are defined for each card 
type as follows: 

- No check is made; 

1 - A check is made; 

2 - A special check is made. 

For example, on the bulk data card C0NRUD, field 2 is the EID, and it must be unique with 
respect to all other C0NR0D EID's. 

6. The next physical card is read from the NPTP. This will be the next card to be processed. 

7. A check for too many continuation cards is made. This check is made on fixed length 
cards only. 

8. A check is made for the minimum and maximum number of words for a logical bulk data card. 

9. A check for the proper types of values for the fields on a card Is made by referencing 
/IFPX7/, which contains format codes for each card type as follows: 

= Blank 

1 = Integer 

2 = Real 

3 = BCD 

4 = Double Precision 

5 = Anything. 



4.5-4 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 

When RCARD passes format values to IFP, a format code of will override this check. In the 
card dependent code check (step 10), the value will be looked at to see if it is in error. 

10. An auxiliary subroutine IFSiP, i = 1, 2, 3, 4, is called to execute card dependent code. 

11. If the input card passes the tests in the card dependent code, the data are written on 
the appropriate GIN0 output file. 

4.5.6.3 Module Conclusion 

When the sorted Bulk Data Deck has been exhausted, the following steps are carried out. 

1. The appropriate trailer codes are written for each data block. For listings of 
trailer information reference section 2.3.2. 

2. The PVT is written on the NPTP. 

3. Restart flags are set in /IFPXO/. 

4.5.7 Subroutines 

IFP uses the utility routine RCARD described in section 3.4.20. 

4.5.7.1 Block Data Subprogram: IFXIBD 

Purpose: To initialize /IFPXl/, which is used by IFP to validate card names. All bulk 
data card names must appear in this table. 

4.5.7.2 Block Data Subprogram: IFX2BD 

Purpose: To initialize /IFPX2/. This table contains two words per entry (two words per 
card type): the first gives the GIN0 output file number, and the second gives the approach 
acceptability flag. 

4.5.7.3 Block Data Subprogram: IFX3BD 

Purpose: To initialize /IFPX3/. This table contains two words per entry (two words per 
card type): the first word is used as the Conical Shell Problem flag, and the second word is 
used internally to store the number of words to be output to the GIN0 output file. 



4.5-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.5.7.4 Block Data Subprogram: IFX4BD 

Purpose: To initialize /IFPX4/. This table contains two words per entry (two words per 
card type): the first is the minimum number of words allowable, the second is the maximum 
number of words allowable. The first word of an entry being negative implies the card is open 
ended . 

4.5.7.5 Block Data Subprogram: IFX5BD 

Purpose: To initialize /IFPX5/. This table contains two words per entry (two words per 
card type): the first is a pointer into /IFPX7/, the second is the field 2 uniqueness check flag. 

4.5.7.6 Block Data Subprogram: IFX6BD 

Purpose: To initialize /IFPX6/. This table contains two words per entry (two words per 
card type): the first is header word 1 (card type), the second is header word 2 (trailer bit 
position) of the three word header information of each logical record, which corresponds to all 
the data of particular bulk data card type. See section 2.3.2 for details. 

4.5.7.7 Block Data Subprogram: IFX7BD 

Purpose: To initialize /IFPX7/. Each entry contains the admissible sequence of format 
codes for that card type (see step 9 in section 4.5.6.2 above). 

4.5.7.8 Subroutine Name: IFSiP, i = 1, 2, 3, 4 

1. Entry Point: IFSiP, i = 1, 2, 3, 4 

2. Purpose: These are the four subroutines that the module driver IFP calls to execute 
card dependent code. 

3. Calling Sequence: CALL IFSiP ($n^ ,$n2,$n3) 

n, - FORTRAN statement number defining the return taken in the event of a format 
or data error. 

ny - F(JRTRAN statement number defining the return taken when local variables are 
set to provide default values for appropriate cards. 

n, - F0RTRAN statement number defining the return taken in the event of a data error. 



4.5-6 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 
4.5.7.9 Subroutine Name: IFPPK 

1. Entry Points: IFPPK, IFPPKI.IFPPKN 

2. Purpose: To provide IFP with a shortened version of subroutine BLDPK in order to 
preserve core storage on machines with minimal memory capacities. This routine is used 
to write DMI cards on the Data Pool File in NASTRAN matrix format. 

4.5.8 Design Requirements 

Open core is defined in /IFPXX/. Open core is used to store all PARAM cards until the 
Bulk Data Deck has been exhausted, at which time the PARAM cards are written on the NPTP as 
the PVT Executive table. 

4.5.9 Diagnostic Messages 

If a fatal error is detected during any phase of the processing of module IFP, the N(8G0 flag 
will be set, and the error message will be printed out. IFP will continue processing data cards 
until all are processed. IFP may issue error messages 301 through 332. 



4.5-7 



MODULE FUNCTIONAL DESCRIPTIONS 

Table 1(a). Bulk Data Cards Processed by IFP Sorted by Internal Card Number. 

The following list gives an explanation of the column headings on the following pages of 
Table 1. 

A = Internal IFP Bulk Data Card Number 

B = Bulk Data Card Name (an asterisk following a name implies the card is not available) 

C = Internal IFP GIN0 Output File Number 

D = Data Block Name 

E = Approach Acceptance Indicator 

-2 = Illegal for the Force Approach 

-1 = Not Used by the Force Approach 
Q = OK for any Approach 

1 = Not Used by the Displacement Approach 

2 = Illegal for the Displacement Approach 

F = Minimum Number of Words Allowed Per Logical Card (F negative implies an open ended card) 
G = Maximum Number of Words Allowed Per Logical Card 
H = Format Check Pointer Into IFX7BD 
I = Field 2 Uniqueness Check Flag 

= No Check is Made 

1 = Check is Made 

2 = Special 

J = Subroutine L0CATE Code for Card on Output Data Block 

K = Trailer Bit Position 

L = Pointer to Secondary (Card Dependent) Code 

51 = Subroutine IFSIP 

52 = Subroutine IFS2P 

53 = Subroutine IFS3P 

54 = Subroutine IFS4P 

M = FORTRAN Statement Number in the Card Dependent Subroutines 
N = Conical Shell Problem Flag 
-1 = Illegal for Shell Mode 



4.5-8 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 

Table 1(b). Bulk Data Cards Processed by IFP Sorted by Internal Card Number. 

= OK for Shell Mode 

1 = Puts Card Into Different Data Block 

= Users Map for Data Blocks IFX2BD IFX6BD 

Values for I = 1 ,2 or 3 

J = 1,2 or 3 

H = A.B.C.D or E 

K = 1,2,3,4,5 or 6 
I = Is Data Statement in the Block Data Program 

J = The Group of A Through E Continuation Card Blocks Within the Ith Data Statement 
H = Alphabetic Character in Col 6 (Continuation Column) in the Jth Group 
K = The Pair Number on Line H Where the Actual Data is 



4.5-9 



MODULE FUNCTIONAL DESCRIPTIONS 



Table 1(c). Bulk Data Cards Processed by IFP Sorted by Internal Card Number. 
B CD EFG HIJKL MN 



1 

2 

3 

4 

5 

6 

7 



19 
20 
21 
22 



GRID 

GRDSET 

BEAM0R* 

SEQGP 

C0RD1R 

CiJRDlC 

CglRDlS 

8 C5)RD2R 

9 C0RD2C 

10 C0RD2S 

11 PLfJTEL 

12 SPCl 

13 SPCADD 

14 SUP0RT 

15 13MIT 

16 SPC 

17 MPC 

18 F0RCE 
MOMENT 
F0RCE1 
M0MENT1 
F0RCE2 

23 M(JMENT2 

24 PL0AD 

25 SL0AD 

26 GRAV 

27 TEMP 

28 GENEL 

29 PR0D 

30 PTUBE 
PVISC 
PBEAM* 

33 PTRIAl 

34 PTRIA2 

35 PTRBSC 

36 PTRPLT 

37 PTRMEM 

38 PQUADl 

39 PQUAD2 

40 PQDPLT 

41 PQDMEM 

42 PSHEAR 

43 PTWIST 

44 PMASS 

45 PDAMP 

46 PELAS 

47 C!3NR(3D 

48 CR0D 

49 CTUBE 

50 CVISC 

51 CBEAM* 

52 CTRIAl 

53 CTRIA2 

54 CTRBSC 

55 CTRPLT 

56 CTRMEM 

57 CQUADl 

58 CQUAD2 



31 
32 



1 GEjilMl 
1 GE0M1 
8 GE0M2 



6E0M1 
GE0M1 
GE0M1 
GE0M1 
GE0M1 
GE0M1 

1 GE0M1 

8 GE0M2 
10 GE0M4 
10 GE0M4 
10 GE0M4 
10 GE0M4 
10 GE0M4 
10 GE0M4 

9 GE0M3 
GE0M3 
GE0M3 
GE0M3 
6E0M3 
GE0M3 
GE0M3 
GE0M3 
GE0M3 
GE0M3 

8 GE0M2 

2 EPT 
EPT 
EPT 
EPT 
EPT 



9 
9 
9 
9 
9 
9 
9 
9 
9 



EPT 
EPT 
EPT 
EPT 
EPT 
EPT 



2 EPT 
2 EPT 



EPT 

EPT 

EPT 

EPT 

EPT 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 
8 GE0M2 






-2 
-1 








-2 

-2 

-2 

-2 

-2 

-2 















-2 





-2 



-2 













-2 

-2 

-2 







-2 
-2 










12 
12 
12 



4 
4 
4 

4 8 

4 8 

4 8 

4 8 

12 16 

12 16 

12 16 

4 8 

4 8 

4 8 

4 8 

4 8 

4 8 

4 8 

8 12 

8 12 

8 12 

8 12 

8 12 

8 12 

8 12 

4 8 

8 12 

4 8 



-4 
4 



9 

12 
12 



4 

4 

3 

4 

4 

4 

4 

4 

4 

4 

4 

4 

4 

4 

4 

4 

4 8 

8 12 



24 

16 

8 

12 

12 

8 

16 

8 

12 

8 

8 

8 

8 

8 



4 
4 
4 



8 
8 
8 

8 24 
8 12 
8 12 
8 12 
8 12 
8 12 
8 12 
8 12 



1 1 

13 2 

25 2 

37 

37 

37 

37 

45 1 

45 1 

45 1 

505 

-1 

-1 1 

37 

37 

101 

-1 

109 

109 

121 

121 

133 

133 

145 

157 



165 1 
157 
-1 1 
165 1 
177 1 
189 
197 1 
221 1 
237 
257 1 
257 1 
237 
221 
237 
257 
237 
237 
237 
269 
269 
497 
277 1 
37 
37 
37 
289 1 
313 1 
313 1 
313 1 
313 1 
313 1 
325 1 
325 1 



4501 


5301 
1801 
1701 
1901 
2101 
2001 
2201 
5201 
5481 
5491 
5601 
5001 
5501 
4901 
4201 
4801 
4001 
4601 
4101 
4701 
5101 
5401 
4401 
5701 
4301 
902 
1602 
1802 
102 
1202 
1302 
1102 
1502 
1402 
702 
802 
602 
502 
1002 
1702 
402 
202 
302 
1601 
3001 
3701 
3901 
101 
3301 
3401 
3201 
3601 
3501 
2801 
2901 



45 



53 
18 
17 
19 
21 
20 
22 
52 
58 
59 
56 
50 
55 
49 
42 
48 
40 
46 
41 
47 
51 
54 
44 
57 
43 

9 

16 
18 

1 
12 
13 

n 

15 

14 

7 

8 

6 

5 

10 

17 

4 

2 

3 

16 

30 

37 

39 

1 

33 

34 

32 

36 

35 

28 

29 



S3 

S3 

S3 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

S3 

S3 

SI 

SI 

SI 

S3 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

S3 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

SI 

S3 

SI 

SI 

SI 

SI 

SI 

SI 

SI 



100 
200 
300 
40 
500 
600 
700 
800 
900 
1000 
1111 
3980 
4020 
1400 
1400 
1600 
1700 
1800 
1800 
2000 
2000 
2200 
2200 
2400 
2500 
2600 
2500 
2800 
2900 
2920 
310 
2960 
2980 
3000 
3020 
3020 
3000 
2980 
3000 
3020 
3000 
3000 
3000 
3200 
3200 
3240 
3260 
3281 
3282 
3283 
3340 
3360 
3360 
3360 
3360 
3360 
3460 
3460 



IJHK 

llAl 

11A2 

11A3 

11A4 

HAS 

11A6 

llBl 

11B2 

11B3 

11B4 

1185 

11B6 

llCl 

11C2 

11C3 

11C4 

11C5 

11C6 

llDl 

1102 

11D3 

11D4 

11D5 

11D6 

llEl 

11E2 

11E3 

11E4 

11E5 

nE6 

12A1 

12A2 

12A3 

12A4 

12A5 

12A6 

12B1 

12B2 

12B3 

12B4 

12B5 

12B6 

12C1 

12C2 

12C3 

12C4 

12C5 

12C6 

12D1 

12D2 

12D3 

12D4 

12D5 

12D6 

12E1 

12E2 

12E3 

12E4 



4.5-10 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 



Table 1(d), Bulk Data Cards Processed by IFP Sorted by Internal Card Number. 
B CD EFG HIJKLMN 




IJHK 



59 CQDPLT 


8 


6E0M2 





8 


12 


325 


1 


2701 


27 


SI 


3460 


_] 


60 CQDMEM 


8 


GE0M2 





8 


12 


325 


1 


2601 


26 


SI 


3460 


-1 


61 CSHEAR 


8 


GE0M2 





8 


12 


337 


1 


3101 


31 


SI 


3540 


-1 


62 CTWIST 


8 


GE0M2 





8 


12 


337 


1 


3801 


38 


SI 


3540 


-] 


63 C0NM1 


8 


GE0M2 





8 


28 


349 


1 


1401 


14 


SI 


3580 


-I 


64 C0NM2 


8 


GE0M2 





8 


20 


377 


1 


1501 


15 


SI 


3600 


-1 


65 CMASSl 


8 


GE0M2 


-2 


4 


12 


337 


1 


1001 


10 


SI 


3620 


-] 


66 CMASS2 


8 


GE0H2 


-2 


4 


12 


397 


1 


1101 


11 


SI 


3623 


-1 


67 CMASS3 


8 


GE0M2 


-2 


4 


8 


37 





1201 


12 


SI 


3674 


-l 


68 CMASS4 


8 


GE0M2 


-2 


4 


8 


409 





1301 


13 


SI 


3697 


_] 


69 CDAMPl 


8 


GE0M2 - 


-2 


4 


12 


337 


1 


201 


2 


SI 


3620 


-1 


70 CDAMP2 


8 


GE0M2 


-2 


4 


12 


397 


1 


301 


3 


SI 


3623 


-1 


71 CDAMP3 


8 


GE0M2 


-2 


4 


8 


37 





401 


4 


SI 


3675 


-] 


72 CDAMP4 


8 


GE0M2 


-2 


4 


8 


409 





501 


5 


SI 


3698 


-] 


73 CELASl 


8 


GE0M2 


-2 


4 


12 


337 


1 


601 


6 


SI 


3620 


_] 


74 CELAS2 


8 


GE0M2 


-2 


4 


12 


417 


1 


701 


7 


SI 


3800 


-I 


75 CELAS3 


8 


GE0M2 


-2 


4 


8 


37 





801 


8 


SI 


3676 


-I 


76 CELAS4 


8 


GE0M2 


-2 


4 


8 


409 





901 


9 


SI 


3699 


-1 


77 f-IATl 


3 


MPT 





4 


20 


429 


1 


103 


1 


SI 


3860 




78 MAT2 


3 


MPT 





8 


20 


449 


1 


203 


2 


SI 


3880 


_] 


79 CTRIARG 


8 


GE0M2 


-2 


8 


12 


738 


1 


1708 


17 


S4 


790 


-I 


80 CTRAPRG 


8 


GE0M2 


-2 


8 


12 


737 


1 


1808 


18 


S4 


800 


-1 


81 DEF0RM 


4 


EOT 


-2 


4 


8 


157 


104 


1 


SI 


2500 


-1 


82 PARAM 


6 


PVT 





-5 


16 


-1 


2 








S3 


3960 




83 MP C ADD 


10 


GE0M4 


-2 


4 


8 


-1 




4891 


60 


S3 


4020 




84 L0AD 


9 


GE0M3 





4 


8 


-1 




4551 


61 


S3 


4060 




85 EIGR 


7 


DYNAMICS 


-2 


14 


18 


469 




307 


3 


S2 


850 





86 EIGB 


7 


DYNAMICS 


-2 


14 


18 


469 




107 


1 


S2 


850 





87 EIGC 


7 


DYNAMICS 


-2 


-4 


10 


-1 




207 


2 


S2 


870 





88 REACT 


8 


GE0M2 


2 


8 


24 


597 




5251 


62 


S4 


880 


-1 


89 


1 







8 


8 


-1 


2 






S2 


890 





90 MATSl 


3 


MPT 


-2 


4 


16 


545 




503 


5 


84 


900 


-1 


91 MATTl 


3 


MPT 





4 


16 


545 




703 


7 


S4 


900 





92 0MIT1 


10 


6E0M4 


-2 


-4 


8 


-1 




4951 


63 


S3 


3981 


-1 


93 TABLEMl 


5 


DIT 





-4 


16 


-1 




105 


1 


S2 


930 





94 TABLEM2 


5 


DIT 





-4 


16 


-1 




205 


2 


S2 


930 





95 TABLEM3 


5 


DIT 





-4 


16 


-1 




305 


3 


S2 


930 





96 TABLEM4 


5 


DIT 





-4 


16 


-1 




405 


4 


S2 


960 





97 TABLESl 


5 


DIT 


-2 


-4 


16 


-1 




3105 


31 


S2 


930 




98 TEMPO 


9 


GE0M3 





4 


12 


269 




5641 


65 


S4 


980 


_1 


99 TABLES2* 


5 


DIT 


-2 


-4 


16 


-1 




3205 


32 


S2 


930 


-1 


100 TABLES 3* 


5 


DIT 


-2 


-4 


16 


-1 




3305 


33 


S2 


930 


.] 


101 TABLES4* 


5 


DIT 


-2 


-4 


16 


-1 




3405 


34 


S2 


960 


.] 


102 MATT2 


3 


MPT 





4 


16 


525 




803 


8 


S4 


1020 


-] 


103 I1ATS2* 


3 


MPT 


-2 


4 


16 


525 




603 


6 


S4 


1020 


.1 


104 CT0RDRG 


8 


GE0M2 


-2 


4 


12 


750 




1908 


19 


S4 


1040 


_1 


105 SP0INT 


8 


GE0M2 


-2 


4 


9 


794 


5551 


49 


S4 


1050 


-1 


106 SEQD 


8 


GE0M2 


2 


-4 


9 


-1 





7508 


75 


S2 


1060 


_■) 


107 SEQDBFE 


3 


GE0M2 


2 


4 


8 


37 





4608 


46 


S2 


1070 


_] 


108 QDSEP 


8 


GE0M2 


2 


4 


8 


37 





4808 


48 


S4 


1080 


-I 


109 SPQUADl 


2 


EPT 


2 


4 


16 


221 





6502 


65 


SI 


2980 


-I 


110 SPQUAD2 


2 


EPT 


2 


4 


8 


237 





6602 


66 


SI 


3000 


_1 


111 SPQDMEM 


2 


EPT 


2 


4 


8 


237 





6302 


63 


SI 


3000 


_■) 


112 SPQDPLT 


2 


EPT 


2 


4 


12 


257 





6402 


64 


SI 


3020 


.] 


113 ZI 


13 


F0RCE 


2 


8 


12 


485 





8913 


89 


S4 


1130 


-I 


114 CTRIA3 


8 


GE0M2 


2 


8 


12 


313 


1 


3458 


41 


SI 


3360 


_] 


115 PTRIA3 


2 


EPT 


2 


-4 


8 


-1 


1 


1352 


24 


SI 


1690 


-I 


116 SETRBFE 


8 


GE0M2 


2 


4 


8 


549 





4708 


47 


SI 


1160 


-] 



12E5 

12E6 

13A1 

13A2 

13A3 

13A4 

13A5 

13A6 

13B1 

13B2 

13B3 

13B4 

13B5 

13B6 

13C1 

13C2 

13C3 

13C4 

13C5 

13C6 

13D1 

13D2 

13D3 

13D4 

13D5 

13D6 

13E1 

13E2 

13E3 

13E4 

13E5 

13E6 

21A1 

21A2 

21A3 

21 A4 

21A5 

21A6 

21B1 

21B2 

21B3 

21B4 

21B5 

21B6 

21C1 

21C2 

21C3 

21C4 

21C5 

21C6 

21D1 

21D2 

2103 

21D4 

21D5 

21D6 

21E1 

21E2 



4.5-11 



MODULE FUNCTIONAL DESCRIPTIONS 



B 



Table 1(e). Bulk Data Cards Processed by IFP Sorted by Internal Card Number. 
CD EFG HIJK LMN 



117 VECDN 

118 VECGP 

119 DMI 

120 DMIG 

121 PT0RDRG 

122 MATS 

123 DLS3AD 

124 EP0INT 

125 FREQl 

126 FREQ 

127 N0LIN1 

128 Nfi)LIN2 

129 N(ilLIN3 

130 N0LIN4 

131 RL0AD1 

132 RL(3AD2 

133 TABLEDl 

134 TABLED2 

135 SEQEP 

136 TF 

137 TIC 

138 TLtlADl 

139 TL0AD2 

140 TABLED3 

141 TABLED4 

142 TSTEP 

143 DSFACT 

144 AXIC 

145 RIN6AX 

146 CCPEAX 

147 PC0NEAX 

148 SPCAX 

149 MPCAX 

150 0MITAX 

151 SUPAX 

152 P0INTAX 

153 SECTAX 

154 PRESAX 

155 TEMPAX 

156 F0RCEAX 

157 M0MAX 

158 EIGP 

159 MASSC 

160 EDFIR 

161 DF0RM 

162 TABDMPl 

163 TABDMP2* 

164 TABDMP3* 

165 TABDMP4* 

166 FREQ2 

167 CQUAD3 

168 PQUAD3 

169 SPQUAD3 

170 SETR 

171 SPTRIAl 

172 SPTRIA2 

173 SPTRMEM 



13 


F0RCE 


2 


8 


12 


177 1 


8313 


83 


S4 


1170 


-1 


13 


F0RCE 


2 


8 


12 


585 1 


8413 


84 


S4 


1180 


-1 


12 


P!30L 





-4 


16 


-1 








S2 


1190 





14 


MATP00L 


-2 


-4 


12 


-1 


114 


1 


S2 


1200 





2 


EPT 


-2 


4 


8 


237 


2102 


21 


SI 


3000 


-1 


3 


MPT 


-2 


4 


20 


449 1 


1403 


14 


S4 


1220 


-1 


7 


DYNAMICS 


-2 


4 


8 


-1 1 


57 


5 


S3 


4060 





7 


DYNAMICS 


-2 


4 


9 


794 


707 


7 


S4 


1050 





7 


DYNAMICS 


-2 


4 


8 


705 


1007 


10 


SI 


1250 





7 


DYNAMICS 


-2 


4 


88 


-1 1 


1307 


13 


S3 


1260 





7 


DYNAMICS 


-2 


8 


12 


725 


3107 


31 


SI 


1270 





7 


DYNAMICS 


-2 


8 


12 


725 


3207 


32 


SI 


1280 





7 


DYNAMICS 


-2 


8 


12 


725 


3307 


33 


SI 


1290 





7 


DYNAMICS 


-2 


8 


12 


725 


3407 


34 


SI 


1290 





7 


DYNAMICS 


-2 


8 


8 


337 1 


5107 


51 


S3 


1310 





7 


DYNAMICS 


-2 


8 


8 


337 1 


5207 


52 


S3 


1310 





5 


DIT 


-2 


-4 


16 


-1 1 


1105 


n 


S2 


930 





5 


DIT 


-2 


-4 


16 


-1 1 


1205 


12 


S2 


930 





7 


DYNAMICS 


-1 


4 


8 


37 


5707 


57 


SI 


40 


-1 


7 


DYNAMICS 


-2 


8 


12 


-1 


6207 


62 


SI 


1360 





7 


DYNAMICS 


-2 


4 


12 


713 


6607 


66 


SI 


1370 





7 


DYNAMICS 


-2 


8 


8 


681 1 


7107 


71 


S3 


1380 





7 


DYNAMICS 


-2 


8 


16 


689 1 


7207 


72 


S3 


1390 





5 


DIT 


-? 


-4 


16 


-1 1 


1305 


13 


S2 


930 





5 


DIT 


-2 


-4 


16 


-1 1 


1405 


14 


S2 


960 





7 


DYNAMICS 




4 


8 


-1 1 


8307 


83 


SI 


1420 





3 


MPT 


-2 


4 


8 


-1 1 


53 


10 


S3 


1430 





15 


AXIC 


-2 


4 


8 


93 


515 


5 


S3 


1440 





15 


AXIC 


-2 


4 


12 


245 1 


5615 


56 


S3 


1450 





15 


AXIC 


-2 


4 


8 


645 1 


2315 


23 


S3 


1460 





2 


EPT 


-2 


4 


28 


653 1 


152 


19 


S3 


1470 





15 


AXIC 


-2 


4 


12 


485 


6215 


62 


S3 


1480 





15 


AXIC 


-2 


4 


8 


-1 


4015 


40 


S3 


1490 





15 


AXIC 


-2 


4 


8 


337 


4315 


43 


S3 


1500 





15 


AXIC 


-2 


4 


8 


337 


6415 


64 


S3 


1500 





15 


AXIC 


-2 


4 


8 


517 1 


4915 


49 


S3 


1520 





15 


AXIC 


-2 


4 


12 


177 1 


6015 


60 


S3 


1530 





15 


AXIC 


-2 


4 


12 


61 


5215 


52 


S3 


1540 





15 


AXIC 


-2 


4 


8 


237 


6815 


68 


S3 


1550 





15 


AXIC 


-2 


4 


12 


109 


2115 


21 


S3 


1560 





15 


AXIC 


-2 


4 


12 


109 


3815 


38 


S3 


1560 





7 


DYNAMICS 


-2 


4 


8 


561 


257 


4 


SI 


1580 





13 


F0RCE 


2 


4 


8 


-1 


3313 


33 


S3 


1590 


-1 


13 


F0RCE 


2 


4 


8 


37 


1513 


15 


S3 


1600 


-1 


4 


EOT 


2 


4 


8 


101 


204 


2 


S3 


1610 


-1 


5 


DIT 


-? 


-4 


16 


-1 1 


15 


21 


S2 


930 





5 


DIT 


-2 


-4 


16 


-1 1 


25 


22 


S2 


930 





5 


DIT 


-2 


-4 


16 


-1 1 


35 


23 


S2 


930 





5 


DIT 


-2 


-4 


16 


-1 1 


45 


24 


S2 


960 





7 


DYNAMICS 


-2 


4 


8 


705 


1107 


11 


SI 


1660 





8 


GE0M2 


2 


8 


12 


325 1 


2958 


40 


SI 


3460 


-1 


2 


EPT 


2 


-4 


8 


-1 1 


852 


49 


SI 


1690 


-1 


2 


EPT 


2 


-4 


8 


-1 1 


6702 


67 


SI 


1690 


-1 


8 


GE0M2 


2 


-4 


9 


-1 


7608 


76 


S2 


1060 


-1 


2 


EPT 




4 


16 


221 1 


7402 


74 


SI 


2980 


-1 


2 


EPT 


2 


4 


8 


237 


7502 


75 


SI 


3000 


-1 


2 


EPT 


2 


4 


8 


237 


7702 


77 


SI 


3000 


-1 





IJHK 

21 E3 

21E4 

21E5 

21 E6 

22A1 

22A2 

22A3 

22A4 

22A5 

22A6 

22B1 

22B2 

22B3 

22B4 

22B5 

22B6 

22C1 

22C2 

22C3 

22C4 

22C5 

22C6 

22D1 

22D2 

22D3 

2204 

22D5 

22D6 

22E1 

22E2 

22E3 

22E4 

22E6 

22E6 

23A1 

23A2 

23A3 

23A4 

23A5 

23A6 

23B1 

23B2 

23B3 

23B4 

23B5 

23B6 

23C1 

23C2 

23C3 

23C4 

23C5 

23C6 

23D1 

2302 

23D3 

23D4 

23D5 



4.5-12 (12-1-69) 



EXECUTIVE PREFACE MODULE IFP (mPUT FILE PROCESSOR) 

Table 1(f). Bulk Data Cards Processed by IFP Sorted by Internal Card Number. 
B CD EFG HIJK LMN 



IJHK 



174 SPTRBSC 


2 


EPT 


2 


4 


12 


257 


1 


7302 


73 


SI 


3020 


-1 


23D6 


175 SPTRPLT 


2 


EPT 


2 


4 


12 


257 


1 


7802 


78 


SI 


3020 


-1 


23E1 


176 SECL 


8 


GE0M2 


2 


-4 


9 


-1 





7308 


73 


S2 


1060 


-1 


23E2 


177 SECP 


8 


GE0M2 


2 


-4 


9 


-1 





7408 


74 


S2 


1060 


-1 


23E3 


178 SPTRIA3 


2 


EPT 


2 


-4 


8 


-1 


1 


7602 


76 


SI 


1690 


-1 


23E4 


179 BAR8IR 


8 


GE0M2 





4 


12 


25 


2 








SI 


100 


-1 


23E5 


180 CBAR 


8 


GE0M2 





8 


20 


73 


1 


2408 


24 


SI 


200 


-1 


23E6 


181 PBAR 


2 


EPT 





4 


24 


621 


1 


52 


20 


SI 


300 


-1 


31A1 


182 DAREA 


7 


DYNAMICS 


-2 


4 


8 


101 





27 


17 


S3 


1820 





31A2 


183 DELAY 


7 


DYNAMICS 


-2 


4 


8 


101 





37 


18 


S3 


1820 





31A3 


184 DPHASE 


7 


DYNAMICS 


-2 


4 


8 


101 





77 


19 


S3 


1820 





31 A4 


185 PLFACT 


3 


MPT 


-2 


4 


8 


- 1 


1 


1103 


11 


S3 


1430 


-1 


31 A5 


186 CGENEL 


8 


GE0M2 


2 


-4 


8 


-1 


1 


2008 


20 


S3 


1860 


-1 


31A6 


187 PGENEL 


2 


EPT 


2 


4 


8 


573 





352 


26 


SI 


1870 


-1 


31B1 


188 ELDELE 


13 


F0RCE 


2 


4 


8 


37 





1913 


19 


S3 


1600 


-1 


31B2 


189 MATT3 


3 


MPT 


-2 


4 


16 


525 


1 


1503 


15 


S4 


1020 


-1 


31B3 


190 RF0RCE 


9 


GE0M3 


-2 


8 


12 


109 





5509 


55 


SI 


1900 


-1 


31B4 


191 TABRNDl 


5 


DIT 


-2 


-4 


16 


-1 


1 


55 


25 


S2 


930 





31 B5 


192 TABRND2* 


5 


DIT 


-2 


-4 


16 


-1 


1 


65 


26 


S2 


930 





31 B6 


193 TABRND3* 


5 


DIT 


-2 


-4 


16 


-1 


1 


75 


27 


S2 


930 





31C1 


194 TABRND4* 


5 


DIT 


-2 


-4 


16 


-1 


1 


85 


28 


S2 


960 





31C2 


195 RANDPS 


7 


DYNAMICS 


-2 


4 


12 


782 





2107 


21 


S4 


1950 


-1 


31C3 


196 RANDTl 


7 


DYNAMICS 


-2 


4 


8 


752 





2207 


22 


S4 


1960 


-1 


31C4 


197 RANDT2 


7 


DYNAMICS 


-2 


-4 


8 


-1 


1 


2307 


23 


XX 


XXXX 


-1 


31C5 


198 PL0AD1 


9 


GE0M3 


-2 


- 


- 


- 


- 


6909 


69 


XX 


XXXX 


-1 


31C6 


199 PL(3AD2 


9 


6E0M3 


-2 


4 


9 


774 


6802 


68 


S4 


1990 


-1 


31D1 


200 DTI 


12 


P00L 





-4 


16 


-1 











S2 


2000 





31D2 



4.5-13 '12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

Table 2(a). Bulk Data Cards Processed by IFP Sorted Alphabetically by Card Name. 

The following list gives an explanation of the column headings on the following pages of 
Table 2. 

A = Internal IFP Bulk Data Card Number 

B = Bulk Data Card Name (an asterisk following a name implies the card is not available) 

C = Internal IFP GIN0 Output File Number 

D = Data Block Name 

E = Approach Acceptance Indicator 

-2 = Illegal for the Force Approach 

-1 = Not Used by the Force Approach 

= OK for any Approach 

1 = Not Used by the Displacement Approach 

2 = Illegal for the Displacement Approach 

F = Minimum Number of Words Allowed Per Logical Card (F negative implies an open ended card) 
G = Maximum Number of Words Allowed Per Logical Card 
H = Format Check Pointer Into IFX7BD 
I = Field 2 Uniqueness Check Flag 

= No Check is Made 

1 = Check is Made 

2 = Special 

J = Subroutine L0CATE Code for Card on Output Data Block 

K - Trailer Bit Position 

L = Pointer to Secondary (Card Dependent) Code 

51 = Subroutine IFSIP 

52 = Subroutine IFS2P 

53 = Subroutine IFS3P 

54 = Subroutine IFS4P 

M = F0RTRAN Statement Number in the Card Dependent Subroutines 
N = Conical Shell Problem Flag 
-1 = Illegal for Shell Mode 



4.5-14 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 

Table 2(b). Bulk Data Cards Processed by IFP Sorted Alphabetically by Card Name. 

= OK for Shell Mode 

1 = Puts Card Into Different Data Block 

= Users Map for Data Blocks IFX2BD,.. . ,IFX6BD 

Values for I = 1 ,2 or 3 
J = 1,2 or 3 
H = A.B.C.D or E 
K = 1,2,3,4,5 or 6 

1 = Is Data Statement in the Block Data Program 

J = The Group of A Through E Continuation Card Blocks Within the Ith Data Statement 
H = Alphabetic Character in Col 6 (Continuation Column) in the Jth Group 
K = The Pair Number on Line H Where the Actual Data is 



4.5-15 



MODULE FUNCTIONAL DESCRIPTIONS 



Table 2(c). Bulk Data Cards Processed by IFP Sorted Alphabetically by Card Name. 
B CD EFG HIJ KLMN 



89 


1 







8 


8 


-1 


2 






S2 


890 


144 AXIC 


15 


AXIC 


-2 


4 


8 


93 


515 


5 


S3 


1440 


179 BAR0R 


8 


GE0M2 





4 


12 


25 


2 








SI 


100 -1 


3 BEAMOR* 


8 


GE0M2 


-2 


4 


12 


25 


2 








S3 


300 -1 


180 CBAR 


8 


GE0M2 





8 


20 


73 


1 


2408 


24 


SI 


200 -1 


51 CBEAM* 


8 


GE0M2 


-2 


8 


24 


289 


1 


101 


1 


S3 


3340 -1 


146 CC0NEAX 


15 


AXIC 


-2 


4 


8 


645 


1 


2315 


23 


S3 


1460 


69 CDAMPl 


8 


GE0M2 


-2 


4 


12 


337 


1 


201 


2 


SI 


3620 -1 


70 CDAMP2 


8 


GE0M2 


-2 


4 


12 


397 


1 


301 


3 


SI 


3623 -1 


71 CDAMP3 


8 


GE0M2 


-2 


4 


8 


37 





401 


4 


SI 


3675 -1 


72 CDAMP4 


8 


GE0M2 


-2 


4 


8 


409 





501 


5 


SI 


3698 -1 


73 CELASl 


8 


GE0M2 


-2 


4 


12 


337 


1 


601 


6 


SI 


3620 -1 


74 CELAS2 


8 


6E0M2 


-2 


4 


12 


417 


1 


701 


7 


SI 


3800 -1 


75 CELAS3 


8 


6E0M2 


-2 


A 


8 


37 


801 


8 


SI 


3676 -1 


76 CELAS4 


8 


GE0M2 


-2 


4 


8 


409 





901 


9 


SI 


3699 -1 


186 CGENEL 


8 


GE0M2 


2 


-4 


8 


-1 


1 


2008 


20 


S3 


1860 -1 


65 CMASSl 


8 


6E0M2 


-2 


4 


12 


337 


1 


1001 


10 


SI 


3620 -1 


66 CMASS2 


8 


GE0M2 


-2 


4 


12 


397 


1 


1101 


11 


SI 


3623 -1 


67 CMASS3 


8 


GE0M2 


-2 


4 


8 


37 





1201 


12 


SI 


3674 -1 


68 CMASS4 


8 


GE0M2 


-2 


4 


8 


409 





1301 


13 


SI 


3697 -1 


63 C0NM1 


8 


GE0M2 





8 


28 


349 


1 


1401 


14 


SI 


3580 -1 


64 C0NM2 


8 


GE0M2 





8 


20 


377 


1 


1501 


15 


SI 


3600 -1 


47 C0NR0D 


8 


GE0M2 





8 


12 


277 


1 


1601 


16 


SI 


3260 -1 


6 C0RD1C 




6E0M1 





4 


8 


37 





1701 


17 


SI 


600 -1 


5 C0RD1R 




GE0M1 





4 


8 


37 





1801 


18 


SI 


500 -1 


7 C0RD1S 




GE0M1 





4 


8 


37 





1901 


19 


SI 


700 -1 


9 C0RD2C 




GE0M1 





12 


16 


45 


1 


2001 


20 


SI 


900 -1 


8 C0RD2R 




GE0M1 





12 


16 


45 


1 


2101 


21 


SI 


800 -1 


10 C0RD2S 




GE0M1 





12 


16 


45 


1 


2201 


22 


SI 


1000 -1 


60 CQDMEM 


8 


GE0M2 





8 


12 


325 


1 


2601 


26 


SI 


3460 -1 


59 CQDPLT 


8 


GE0M2 





8 


12 


325 


1 


2701 


27 


SI 


3460 -1 


57 CQUADl 


8 


GE0H2 





8 


12 


325 


1 


2801 


28 


SI 


3460 -1 


58 CQUAD2 


8 


GE0M2 





8 


12 


325 


1 


2901 


29 


SI 


3460 -1 


167 CqUAD3 


8 


GE0M2 


2 


8 


12 


325 


1 


2958 


40 


SI 


3460 -1 


48 CR0D 


8 


GE0M2 





4 


8 


37 





3001 


30 


SI 


3281 -1 


61 CSHEAR 


8 


GE0M2 





8 


12 


337 


1 


3101 


31 


SI 


3540 -1 


104 CT0RDRG 


8 


GE0H2 


-2 


4 


12 


750 


1 


1908 


19 


S4 


1040 -1 


80 CTRAPRG 


8 


GE0M2 


-2 


8 


12 


737 


1 


1808 


18 


S4 


800 -1 


54 CTRBSC 


8 


GE0M2 





8 


12 


313 


1 


3201 


32 


SI 


3360 -1 


52 CTRIAl 


8 


GE0M2 





8 


12 


313 


1 


3301 


33 


SI 


3360 -1 


53 CTRIA2 


8 


GE0M2 





8 


12 


313 


1 


3401 


34 


SI 


3360 -1 


114 CTRIA3 


8 


GE0M2 


2 


8 


12 


313 


1 


3458 


41 


SI 


3360 -1 


79 CTRIARG 


8 


GE0M2 


-2 


8 


12 


738 


1 


1708 


17 


S4 


790 -1 


56 CTRMEM 


8 


GE0M2 





8 


12 


313 


1 


3501 


35 


SI 


3360 -1 


55 CTRPLT 


8 


GE0M2 





8 


12 


313 


1 


3601 


36 


SI 


3360 -1 


49 CTUBE 


8 


GE0M2 





4 


8 


37 





3701 


37 


SI 


3282 -1 


62 CTWIST 


8 


GE0M2 





8 


12 


337 


1 


3801 


38 


SI 


3540 -1 


50 CVISC 


8 


GE0M2 


-2 


4 


8 


37 





3901 


39 


SI 


3283 -1 


182 DAREA 


7 


DYNAMICS 


-2 


4 


8 


101 





27 


17 


S3 


1820 


81 DEF0RM 


4 


EOT 


-2 


4 


8 


157 





104 


1 


SI 


2500 -1 


183 DELAY 


7 


DYNAMICS 


-2 


4 


8 


101 





37 


18 


S3 


1820 


161 DF0RM 


4 


EDT 


2 


4 


8 


101 





204 


2 


S3 


1610 -1 


123 DL0AD 


7 


DYNAMICS 


-2 


4 


8 


-1 


1 


57 


5 


S3 


4060 


119 DMI 


12 


P00L 





-4 


16 


-1 











S2 


1190 


120 DMIG 


14 


MATP00L 


-2 


-4 


12 


-1 





114 


1 


S2 


1200 


184 DPHASE 


7 


DYNAMICS 


-2 


4 


8 


101 





77 


19 


S3 


1820 


143 DSFACT 


3 


MPT 


-2 


4 


8 


.1 


1 


53 


10 


S3 


1430 



IJHK 
13E5 
22D6 
23E5 
11A3 
23E6 
12D3 
22E2 
13B3 
13B4 
13B5 
13B6 
13C1 
13C2 
13C3 
13C4 
31A6 
13A5 
13A6 
13B1 
13B2 
13A3 
13A4 
12C5 
11A6 
11A5 
1181 
11B3 
11B2 
11B4 
12E6 
12E5 
12E3 
12E4 
23C5 
12C6 
13A1 
21 C2 
13D2 
12D6 
12D4 
12D5 
21D6 
13D1 
12E2 
12E1 
12D1 
13A2 
12D2 
31A2 
13D3 
31 A3 
23B5 
22A3 
21E5 
21E6 
31 A4 
22D5 



4.5-16 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 

Table 2(d). Bulk Data Cards Processed by IFP Sorted Alphabetically by Card Name. 
B CD EFGHIJ KLMN 



IJHK 



200 DTI 


12 


P00L 





-4 


16 


-1 











S2 


2000 





31 D2 


160 EDFIR 


13 


F0RCE 


2 


4 


8 


37 





1513 


15 


S3 


1600 


-1 


23B4 


86 EIGB 


7 


DYNAMICS 


-2 


14 


18 


469 


1 


107 


11 


S2 


850 





13E2 


87 EIGC 


7 


DYNAMICS 


-2 


-4 


10 


-1 


1 


207 


2 


S2 


870 





13E3 


158 EIGP 


7 


DYNAMICS 


-2 


4 


8 


561 





257 


4 


SI 


1580 





23B2 


85 EIGR 


7 


DYNAMICS 


-2 


14 


18 


469 


1 


307 


3 


S2 


850 





13E1 


188 ELDELE 


13 


F0RCE 


2 


4 


8 


37 





1913 


19 


S3 


1600 


-1 


31B2 


124 EP0INT 


7 


DYNAMICS 


-2 


4 


9 


794 





707 


7 


S4 


1050 





22A4 


18 F0RCE 


9 


GE0M3 





8 


12 


109 





4201 


42 


SI 


1800 


1 


11C6 


20 F0RCE1 


9 


GE0M3 





8 


12 


121 





4001 


40 


SI 


2000 


-1 


11D2 


22 F0RCE2 


q 


GE0M3 





8 


12 


133 





4101 


41 


SI 


2200 


-1 


11D4 


156 F0RCEAX 


15 


AXIC 


-2 


4 


12 


109 





2115 


21 


S3 


1560 





23A6 


126 FREQ 


7 


DYNAMICS 


-2 


4 


8 


-1 


1 


1307 


13 


S3 


1260 





22A6 


125 FREQl 


7 


DYNAMICS 


-2 


4 


8 


705 





1007 


10 


SI 


1250 





22A5 


166 FREQ2 


7 


DYNAMICS 


-2 


4 


8 


705 





1107 


11 


SI 


1660 





23C4 


28 GENEL 


8 


GE0M2 


-2 


-4 


9 


-1 


1 


4301 


43 


S3 


2800 


_1 


11E4 


26 GRAV 


9 


GE0M3 





8 


12 


165 


1 


4401 


44 


SI 


2600 




11E2 


2 GRDSET 


1 


GE0M1 


, 


4 


12 


13 2 








S3 


200 


_"! 


11A2 


1 GRID 


1 


GE0M1 





4 


12 


1 




4501 


45 


S3 


100 


_1 


llAl 


84 L0AD 


9 


GE0M3 





4 


8 


-1 




4551 


61 


S3 


4060 




13D6 


159 MASSC 


13 


F0RCE 


2 


4 


8 


-1 




3313 


33 


S3 


1590 


_] 


23B3 


77 MATl 


3 


MPT 





4 


20 


429 




103 


1 


SI 


3860 




13C5 


78 MAT2 


3 


HPT 





8 


20 


449 




203 


2 


SI 


3880 


■ I 


13C6 


122 MAT3 


3 


MPT 


-2 


4 


20 


449 




1403 


14 


S4 


1220 


_] 


22A2 


90 MATSl 


3 


MPT 


-2 


4 


16 


545 




503 


5 


S4 


900 


^1 


13E6 


103 MATS2* 


3 


MPT 


-2 


4 


16 


525 




603 


6 


S4 


1020 


_■] 


21C1 


91 MATTl 


3 


MPT 





4 


16 


545 




703 


7 


S4 


900 




21A1 


102 MATT2 


3 


MPT 





4 


16 


525 




803 


8 


S4 


1020 


«] 


21B6 


189 mTT3 


3 


MPT 


-2 


4 


16 


525 




1503 


15 


S4 


1020 


.] 


31B3 


157 M0MAX 


15 


AXIC 


-2 


4 


12 


109 





3815 


38 


S3 


1560 




23B1 


19 M0MENT 


9 


GE0M3 





8 


12 


109 





4801 


48 


SI 


1800 




llDl 


21 M0MEMT1 


9 


GE0M3 





8 


12 


121 





4601 


46 


SI 


2000 


_] 


1103 


23 M0MENT2 


9 


GE0M3 





8 


12 


133 





4701 


47 


SI 


2200 


-I 


11D5 


17 HPC 


10 


GE0M4 


-2 


4 


8 


-1 





4901 


49 


S3 


1700 


_1 


11C5 


83 MPCADD 


10 


GE0H4 


-2 


4 


8 


-1 


1 


4891 


60 


S3 


4020 




13D5 


149 MPCAX 


15 


AXIC 


-2 


4 


8 


-1 





4015 


40 


S3 


1490 





22E5 


127 N0LIN1 


7 


DYNAMICS 


-2 


8 


12 


725 





3107 


31 


SI 


1270 





22B1 


128 N0LIN2 


7 


DYNAMICS 


-2 


8 


12 


725 





3207 


32 


SI 


1280 





22B2 


129 N0LIN3 


7 


DYNAMICS 


-2 


8 


12 


725 





3307 


33 


SI 


1290 





22B3 


130 N0LIN4 


7 


DYNAMICS 


-2 


8 


12 


725 





3407 


34 


SI 


1290 





22B4 


15 0MIT 


10 


GE0M4 


-2 


4 


8 


37 





5001 


50 


SI 


1400 


-1 


11C3 


92 0MIT 


10 


GE0M4 


-2 


-4 


8 


-1 





4951 


63 


S3 


3981 


-1 


21 A2 


150 0KITAX 


15 


AXIC 


-2 


4 


8 


337 


4315 


43 


S3 


1500 





22E6 


82 PARAM 


6 


PVT 





-5 


16 


-1 


2 








S3 


3960 





13D4 


181 PBAR 


2 


EPT 





4 


24 


621 


1 


52 


20 


SI 


300 


-1 


31A1 


32 PBEAM* 


2 


EPT 





8 


24 


197 


1 


102 


1 


SI 


2960 


-1 


12A2 


147 PC0NEAX 


2 


EPT 


-2 


4 


28 


653 


1 


152 


19 


S3 


1470 





22E3 


45 PDAMP 


2 


EPT 


-2 


4 


8 


269 





202 


2 


SI 


3200 


-1 


12C3 


46 PELAS 


2 


EPT 


-2 


4 


8 


497 





302 


3 


SI 


3240 


-1 


12C4 


187 PGENEL 


2 


EPT 


2 


4 


8 


573 





352 


26 


SI 


1870 


-1 


31B1 


185 PLFACT 


3 


MPT 


-2 


4 


8 


-1 


1 


1103 


11 


S3 


1430 


-1 


31A5 


24 PL0AD 


9 


GE0M3 





8 


12 


145 





5101 


51 


SI 


2400 


-1 


1106 


198 PL0AD1 


9 


GE0M3 


-2 


- 


. 


- 


- 


6909 


69 


XX 


XXXX 


-1 


31C6 


199 PL0AD2 


9 


GE0M3 


-2 


4 


9 


774 





6802 


68 


S4 


1990 


-1 


31D1 


11 PL0TEL 


8 


GE0M2 





4 


8 


505 





5201 


52 


SI 


nil 


-1 


11B5 


44 pmss 


2 


EPT 


-2 


4 


8 


269 





402 


4 


SI 


3200 


-1 


12C2 



4.5-17 



MODULE FUNCTIONAL DESCRIPTIONS 

Table 2(e). Bulk Data Cards Processed by IFF Sorted Alphabetically by Card Name. 
B CD EFGHIJ KLMN 



IJHK 



152 P0INTAX 


15 


AXIC 


-2 


4 


S 


517 1 


4915 


49 


S3 


1520 C 


23A2 


41 PQDMEM 


2 


EPT 





4 


8 


237 


502 


5 


SI 


3000 -1 


12B5 


40 PQDPLT 


2 


EPT 





4 


12 


257 


602 


6 


SI 


3020 -1 


12B4 


38 PQUADl 


2 


EPT 





4 


16 


221 


702 


7 


SI 


2980 -1 


12B2 


39 PQUAD2 


2 


EPT 





4 


8 


237 


802 


8 


SI 


3000 -1 


12B3 


168 PQUAD3 


2 


EPT 


2 


-4 


8 


-1 1 


852 


49 


SI 


1690 -1 


23C6 


154 PRESAX 


15 


AXIC 


-2 


4 


12 


61 


5215 


52 


S3 


1540 C 


23A4 


29 PR0D 


2 


EPT 





4 


12 


165 1 


90? 


9 


SI 


2900 -1 


11E5 


42 PSHEAR 


2 


EPT 





4 


8 


237 


1002 


10 


SI 


3000 -1 


12B6 


121 PT0RDRG 


2 


EPT 


-2 


4 


8 


237 


2102 


21 


SI 


3000 -1 


22A1 


35 PTRBSC 


2 


EPT 





4 


12 


257 1 


1102 


11 


SI 


3020 -1 


12A5 


33 PTRIAl 


2 


EPT 





4 


16 


221 1 


1202 


12 


SI 


2980 -1 


12A3 


34 PTRIA2 


2 


EPT 





4 


8 


237 


1302 


13 


SI 


3000 -1 


12A4 


115 PTRIA3 


2 


EPT 


2 


-4 


8 


-1 1 


1352 


24 


SI 


1690 -1 


21 El 


37 PTRMEM 


2 


EPT 





4 


8 


237 


1402 


14 


SI 


3000 -' 


12B1 


36 PTRPLT 


2 


EPT 





4 


12 


257 1 


1502 


15 


SI 


3020 -1 


12A6 


30 PTUBE 


2 


EPT 





4 


12 


177 1 


1602 


16 


SI 


2920 - 


11E6 


43 PTWIST 


2 


EPT 





4 


8 


237 


1702 


17 


SI 


3000 -1 


12C1 


31 PVISC 


2 


EPT 


-2 


4 


8 


189 


1802 


18 


SI 


310 - 


12A1 


108 QDSEP 


8 


GE0M2 


2 


4 


8 


37 


4808 


48 


S4 


1080 - 


21C6 


195 RANDPS 


7 


DYNAMICS 


-2 


4 


12 


782 


2107 


21 


S4 


1950 - 


31C3 


196 RANDTl 


7 


DYNAMICS 


-2 


4 


8 


752 


2207 


22 


S4 


1960 - 


31C4 


197 RANDT2 


7 


DYANMICS 


-2 


-4 


8 


-1 1 


2307 


23 


XX 


XXXX 


31C5 


88 REACT 


8 


GE0M2 


2 


8 


24 


597 1 


5251 


62 


S4 


880 - 


13E4 


190 RFjIRCE 


9 


GE0M3 


-2 


8 


12 


109 


5509 


55 


SI 


1900 


31 B4 


145 RINGAX 


15 


AXIC 


-2 


4 


12 


245 1 


5615 


56 


S3 


1450 22E1 


131 RLSIADl 


7 


DYNAMICS 


-2 


8 


8 


337 1 


5107 


51 


S3 


1310 ( 


3 2?B5 


132 RL0AD2 


7 


DYNAMICS 


-2 


8 


8 


337 1 


5207 


52 


S3 


1310 ( 


] 22B6 


176 SECL 


8 


GE0M2 


2 


-4 


9 


-1 


7308 


73 


S2 


1060 - 


1 23E2 


177 SECP 


8 


GE0M2 


2 


-4 


9 


-1 


7408 


74 


S2 


1060 - 


1 23E3 


153 SECT AX 


15 


AXIC 


-2 


4 


12 


177 1 


6015 


60 


S3 


1530 ( 


3 23A3 


106 SEQD 


8 


GE0M2 


2 


-4 


9 


-1 


7508 


75 


S2 


1060 - 


1 21 C4 


107 SEQDBFE 


8 


GE0M2 


2 


4 


8 


37 


4608 


46 


S2 


1070 - 


1 21C5 


135 SEQEP 


7 


DYNAMICS 


-1 


4 


8 


37 


5707 


57 


SI 


40 - 


1 22C3 


4 SEQGP 


1 


GE0M1 


-1 


4 


8 


37 


5301 


53 


SI 


40 - 


1 11A4 


170 SETR 


8 


GE0M2 


2 


-4 


9 


-1 


7608 


76 


S2 


1060 - 


1 23D2 


116 SETRBFE 


8 


GE0M2 


2 


4 


8 


549 


4708 


47 


SI 


1160 - 


1 2iE2 


25 SL0AD 


9 


GE0M3 


-2 


4 


8 


157 


5401 


54 


SI 


2500 - 


1 llEl 


16 SPC 


10 


GE0M4 


-2 


4 


8 


101 


5501 


55 


SI 


1600 - 


1 11C4 


12 SPCl 


10 


GE0M4 


-2 


4 


8 


-1 


5481 


58 


S3 


3980 - 


1 1186 


13 SPCADD 


10 


GE0M4 


-2 


4 


8 


-1 1 


5491 


59 


S3 


4020 


1 llCl 


148 SPC AX 


15 


AXIC 


-2 


4 


12 


485 


6215 


62 


S3 


1480 


D 22E4 


105 SP0INT 


8 


GE0M2 


-2 


4 


9 


794 


5551 


49 


S4 


1050 - 


1 21C3 


111 SPQDMEM 


2 


EPT 


2 


4 


8 


237 


6302 


63 


SI 


3000 - 


1 21 D3 


112 SPQDPLT 


2 


EPT 


2 


4 


12 


257 


6402 


64 


SI 


3020 - 


1 21D4 


109 SPQUADl 


2 


EPT 


2 


4 


16 


221 


6502 


65 


SI 


2980 - 


1 21D1 


110 SPQUAD2 


2 


EPT 


2 


4 


8 


237 


6602 


66 


SI 


3000 - 


1 21D2 


169 SPQUAD3 


2 


EPT 


2 


-4 


8 


-1 1 


6702 


67 


SI 


1690 - 


1 23D1 


174 SPTRBSC 


2 


EPT 


2 


4 


12 


257 1 


7302 


73 


SI 


3020 - 


1 23D6 


171 SPTRIAl 


2 


EPT 


2 


4 


16 


221 1 


7402 


74 


SI 


2980 - 


1 23D3 


172 SPTRIA2 


2 


EPT 


2 


4 


8 


237 


7502 


75 


SI 


3000 - 


1 23D4 


178 SPTRIA3 


2 


EPT 


2 


-4 


8 


-1 1 


7602 


76 


SI 


1690 - 


1 23E4 


173 SPTRMEM 


2 


EPT 


2 


4 


8 


237 


7702 


77 


SI 


3000 - 


1 23D5 


175 SPTRPLT 


2 


EPT 


2 


4 


12 


257 1 


7802 


78 


SI 


3020 - 


1 23E1 


151 SUPAX 


15 


AXIC 


-2 


4 


8 


337 


6415 


64 


S3 


1500 


23A1 


14 SUP0RT 


10 


GE0M4 


-2 


4 


8 


37 


5601 


56 


SI 


1400 - 


1 11C2 


162 TABDMPl 


5 


DIT 


-2 


-4 


16 


-1 1 


15 


21 


S2 


930 


23B6 


163 TABDMP2* 


5 


DIT 


-2 


-4 


16 


-1 1 


25 


22 


S2 


930 


23C1 



4.5-18 (12-1-69) 



EXECUTIVE PREFACE MODULE IFP (INPUT FILE PROCESSOR) 



Table 2(f). Bulk Data Cards Processed by IFP Sorted Alphabetically by Card Name. 



A B 


C 


D 


E 


F 


G 


H 


I 


J 


K 


L 


M 


N 




IJHK 


164 TABDMP3* 


5 


DIT 


-2 


-4 


16 


_] 




35 


23 


S2 


930 





23C2 


165 TABDMP4* 


5 


DIT 


-2 


-4 


16 


-1 




45 


24 


S2 


960 





23C3 


133 TABLEDl 


5 


DIT 


-2 


-4 


16 


-1 




1105 


11 


S2 


930 





22C1 


134 TABLLDZ 


5 


DIT 


-2 


-4 


16 


-1 




1205 


12 


S2 


930 





22C2 


140 TABLED3 


5 


DIT 


-2 


-4 


16 


-1 




1305 


13 


S2 


930 





22D2 


141 TABLED4 


5 


DIT 


-2 


-4 


16 


-1 




1405 


14 


S2 


960 





22D3 


93 TABLEMl 


5 


DIT 





-4 


16 


-1 




105 


1 


S2 


930 





21A3 


94 TABLEM2 


5 


DIT 





-4 


16 


-1 




205 


2 


S2 


930 





21A4 


95 TABLEM3 


5 


DIT 





-4 


16 


-1 




305 


3 


S2 


930 





21A5 


96 TABL[M4 


5 


DIT 





-4 


16 


-1 




405 


4 


S2 


960 





21A6 


97 TABLESl 


5 


DIT 


-2 


-4 


16 


-1 




3105 


31 


S2 


930 


-1 


21B1 


99 TABLES2* 


5 


DIT 


-2 


-4 


16 


-1 




3205 


32 


S2 


930 


-1 


21B3 


100 TABLES3* 


5 


DIT 


-2 


-4 


16 


-1 




3205 


33 


S2 


930 


-1 


21 B4 


101 TABLES4* 


5 


DIT 


-2 


-4 


16 


-1 




3405 


34 


S2 


960 


-1 


21 B5 


191 TABRNDl 


5 


DIT 


-t- 


-4 


16 


-1 




55 


25 


S2 


930 





31B5 


192 TABRN02* 


5 


DIT 


-2 


-4 


16 


-1 




65 


26 


S2 


930 





31 B6 


193 TABRND3* 


5 


DIT 


-2 


-4 


16 


-1 




75 


27 


S2 


930 





31C1 


194 TABRND4* 


5 


DIT 


-2 


-4 


16 


-1 




85 


28 


S2 


960 





31C2 


27 TEMP 


9 


GE!3M3 





4 


8 


157 





5701 


57 


SI 


2500 


-1 


11E3 


155 TEMPAX 


15 


AXIC 


-2 


4 


8 


237 





6815 


68 


S3 


1550 





23A6 


98 TEMPO 


9 


GE0M3 





4 


12 


269 





5641 


65 


S4 


980 


-1 


21B2 


136 TF 


7 


DYNAMICS 


-2 


8 


12 


-1 





6207 


62 


SI 


1360 





2?C4 


137 TIC 


7 


DYNAMICS 


-2 


4 


12 


713 





6607 


66 


SI 


1370 





22C5 


138 TL0AD1 


7 


DYNAMI6S 


-2 


8 


8 


681 




7107 


71 


S3 


1380 





22C6 


139 TL0AD2 


7D 


DYNAMICS 


-2 


8 


16 


689 




7207 


72 


S3 


1390 





22D1 


142 TSTEP 


7 


DYNAMICS 


-2 


4 


8 


-1 




8307 


83 


SI 


1420 





22D4 


117 VECDN 


13 


F0RCE 


2 


8 


12 


177 




8313 


83 


S4 


1170 


-1 


21E3 


118 VECGP 


13 


FI3RCE 


2 


8 


12 


58£ 




8413 


84 


S4 


1180 


-1 


21 E4 


113 ZI 


13 


F0RCE 


2 


8 


12 


485 





8913 


89 


S4 


1130 


-1 


21D5 



4.5-19 (12-1-69) 



EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 

4.6 EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 

4.6.1 Entry Point : IFP3 

4.6.2 Purpose 

1. To interpret Bulk Data cards unique to an axi symmetric conical shell problem. 

2. To generate and distribute to data blocks GE0M1 , GE0M2, GE0M3, and GE0M4 data cards 
for all harmonics specified in the problem. 

3. To convert the following input Bulk Data cards to the following output Bulk Data cards, 



Input Bulk Data 


Input 


Output Bulk Data 


Outnut 


Card Type 


Data Block 
AXIC 


Card Type 


Data Block 


AXIC 


None 




CC!3NEAX 


AXIC 


CC0NE 


GE0M2 


F0RCEAX 


AXIC 


F0RCE 


GE0M3 


F0RCE 


AXIC 


F0RCE 


GE0M3 


GRAV 


AXIC 


GRAV 


GE0M3 


L0AD 


AXIC 


L0AD 


GE0M3 


M0MAX 


AXIC 


M0MENT 


GE0M3 


MOMENT 


AXIC 


M0MENT 


GE0M3 


MPCADD 


AXIC 


MPCADD 


GE0M4 


MPCAX 


AXIC 


MPC 


GE0M4 


0MITAX 


AXIC 


0MIT 


GE0M4 


P0INTAX 


AXIC 


MPC 
GRID 


GE0M4 
GE0M1 


PRESAX 


AXIC 


PRESAX 


GEMM3 


RINGAX 


AXIC 


SPC 
GRID 


RE0M4 
GE0M1 


SECT AX 


AXIC 


MPC 
GRID 


GE0M4 
GE0M1 


SEQGP 


AXIC 


SEQGP 


GE0M1 


SPCADD 


AXIC 


SPCADD 


GE0M4 


SPCAX 


AXIC 


SPC 


GE0M4 


SUPAX 


AXIC 


SUP0RT 


GE0M4 


TEMP AX 


AXIC 


TEMP 


GE0M3 


TEMPO 


AXIC 


TEMPO 


GE0M3 



4.6-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.6.3 Call ing Sequence 

CALL IFP3. IFP3, a Preface module, is called only from the Preface driver SEMINT. 

4.6.4 Input Data Blocks 

AXIC - Bulk Data Deck cards as output from IFP. 

4.6.5 Output Data Blocks 

GE0M1 - Grid Point Data. 

GE0M2 - Element Connection Data. 

GE0M3 - Loading Data. 

GE0M4 - Constraint Data. 

4.6.6 Parameters 



Not applicable to IFP3. 

4.6.7 Method 

In the following a "card" is defined as the type of card image output by IFP, i.e., with 
the mneumonic stripped off and a card image, in some cases a modified card image, written on 
the output data block. 

4.6.7.1 Initialization and Overall Method 

IFP3 first determines the amount of core available, and then allocates three buffers for 
the SCRATCH, AXIC, and GE0M data blocks. The AXIC data block is opened for input using PREL0C. 
At this point the 21 types of input Bulk Data cards are found, one type at a time, on the AXIC 
data block, using the L0CATE routine. The cards of each type are converted and output to a 
GE0M data block. 

To facilitate the operation, all Bulk Data cards causing output to a particular GE0M 
data block are handled together. Thus the processing is such that all cards affecting GE0M2 
are first converted, and following these all those for GE0M3, then GE0M4, and finally GE0M1 . 

The superscripts s and c in the following refer to the sine and cosine sets respectively. 



4.6-2 



EXECUTIVE PREFACE MODULE IFPS (INPUT FILE PROCESSOR 3) 



4.6.7.2 Conversion of Input Bulk Data Cards to Output Bulk Data Cards for GE0M2. 



1. AXIC card 



■Input Card- 



AXIC Harm 



-Cutout Card- 
(None) 

The AXIC card supplies Harm which is used to compute the number of harmonics, N. 



N = Harm + 1 



(1) 



2. CC0NEAX card 



-Input Card- 



CCS3NEAX 



EL- ID 



Prop-ID 



Ring^ ID 



Ringg ID 



-N Output Cards- 



CC0NE, 



EL-ID 



Prop-ID 



Ring^ ID, 



Ringg ID^ 



where 



EL-ID^ = EL-ID X 1000 + n, 



Ring^ ID^ = Ring^ ID + 1000000 x n, 



Ringg ID^ = Ringg ID + 1000000 x n. 



(2) 
(3) 
(4) 



for n = 1, 2, .... N. 



4.6-3 



MODULE FUNCTIONAL DESCRIPTIONS 



4.6.7.3 Conversion of Input Bulk Data Cards to Output Cards for GE(iM3. 



1. F0RCE card and M0MENT card 



These two cards are output to GE0M3 as input from AXIC. 



2. FCIRCEAX card and M(3MAX card 



-Input Cards- 



FORCEAX 


Set ID 


Ring ID 


Harm ID 


Factor 


Fr 


^ 


\ 














M0MAX 


Set ID 


Ring ID 


Harm ID 


Factor 


\ 


% 


\ 



-Output Cards- 



F0RCE 


Set ID 


Ring ID^ 





Factor 


^ 


^ 


\ 






M0MENT 


Set ID 


Ring ID^ 





Factor 


"r 


9 


z 



where 



Ring IDm = Ring ID + (Harm ID + 1) x 1000000 



"H 



(5) 



If F0RCE cards and FjJRCEAX cards both exist, then the resulting output cards of the F0RCE and 
F0RCEAX cards are merged in sort on Set ID's. This applies to M0MENT and M0MAX cards also. 

3. GRAV card, L0AD card, and TEMPO card 

These three cards are output to GE0M3 as they are input from AXIC. 

4. PRESAX card 

-Input Card- 



PRESAX 



Set ID 


Value 


Ring^ ID 


Ringg ID 


*1 


h 



4.6-4 



EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 



-N Output Cards- 



PRESAXj^ 



Set ID 


Value 


Ring^ID^ 


RingglD^ 


*1 


h 


n 



where 



Ring^ ID = Ring^ ID + 1000000 x n 
Ringg ID^ = Ringg ID + 1000000 x n 



(6) 
(7) 



for n = 1, 2, .... N. 



5. TEMPAX card 



■Input Card- 



TEMPAX 



Set ID 


Ring ID 


*1 


^1 


*2 


^2 


*3 


^3 



-N X 2 Output Cards - 



N-TEMP 



n+1 



Set ID' 



Ring ID^^^ 



N-TEMP 



n+1 



Set ID 



Ring ID^^^ 



where 



Ri 



ing IDp+i = Ring ID + 1000000 x (n+1) 



Set ID 



Set ID 



Set ID + 100000000 



Set ID + 200000000 



(8) 

(9) 

(10) 



Ri 



for n = 0, 1 N-1. 

T^ and T^ are computed as follows. All TEMPAX cards having the same Set ID and 
ng ID are gathered together. The angles <))^ and temperatures T. are arrayed into a two- 



4.6-5 



MODULE FUNCTIONAL DESCRIPTIONS 



dimensional matrix. 



*1 


h 


h 


\ 






h 


\ 



where k is the total number of unique i))'s, and the cji's are converted to radians. 
The matrix is sorted on the <^ column, and duplicate angles are removed. 
For n = 0, we have 



^l - fc.^. (^i^T.,^) U^.T -*i). 



(n) 



and 



t; = Q- 



(12) 



For n > 



1 '^ 

- s 



^ i=l ^*i+l - ^-^ 



(^i^i.l -Ti+1 *i) ,„. 



(sin n(j)._^, - sin ncji.) 



+ — 2 — ^ (cos n^.'+i - cos n(t). + nij)-^-, sin n(|)._|^, - n()). sin n(}).)!> (13) 



and 



T^ = i Z ,,-1 
n TT '■" 



i=l ^"^i+l ^V 



(T.$.,T -T.,^<fr.) 



(-cos ntf).^^ + cos niji.) 



+ — — 2 — ^ (sin n(|).^^ - sin n<ti. - n<|).^^ cos n<}).^i + ncf.. cos n(}).)|. (14) 



4.6-6 



where 



and 



EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 



^k.i = *i ^2-. (15) 



^k.l = h ■ ^''^ 



4.6-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4.6.7.4 Conversion of Input Bulk Data Cards to Output Cards for GE0M4 
1. SPCADD card 

-Input Card- 



SPCADD 


Set ID 


SI 


... 


S9 


-1 


>0pen-e 








-2 Output Cards- 








SPCADD^ 


Set ID^ 


SI 


... 


S9 


101 


-1 
















SPCADD*^ 


Set Id'^ 


SI 


« • • 


S9 


102 


-1 



-ended 



where 



Set ID = Set ID + 100000000 



Set ID = Set ID + 200000000 



(17) 
(18) 



The following 4 mandatory SPCADD cards are also created and put out on GE5IM4 regardless 
of whether there are or are not SPCADD cards present. 



SPCADD 


100000101 


101 


-1 






SPCADD 


200000102 


102 


-1 






SPCADD 


100000000 


101 


-1 






SPCADD 


200000000 


102 


-1 



2. MPCADD card 



All operations performed for the SPCADD card are performed for the MPCADD card. 



4.6-8 



EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 



3. SPCAX card 



where 



and 



where 



4. MPCAX card 



MPCAX 



Set ID 



■Input Card- 



SPCAX Set ID 



Ring ID 



Harm ID 



Comp 



Value 



-3 Output Cards- 



SPCADD^ 


Set ID^ Set ID 


101 


-1 










SPCADD^ 


Set Id'^ 


Set ID 


102 


-1 



Set ID = Set ID + 100000000 , 



Set ID = Set ID + 200000000 ; 



SPC 



Set ID 



Ring ID, 



Como 



Value 



Ring ID„ = Ring ID + (Harm ID + 1) x 1000000. 



-Input Card- 



Ring ID 



Harm ID 



Comp ID 



Value 



-1 



Repeats 



-3 Output Cards- 



MPCADD^ 


Set ID^ Set ID 


101 


-1 










MPCADD^ 


Set ID= 


Set ID 


102 


-1 



Set ID^ = Set ID + 100000000 , 



Set ID^ = Set ID + 200000000 



-1 



(19) 
(20) 



(21) 



Open 
Ended 



(22) 
(23) 



4.6-9 



MODULE FUNCTIONAL DESCRIPTIONS 



and 



MPC Set ID Ring ID^ 



Comp Value 



Repeat Group 



For each 3-word group output. 



Ri 



ing IDj^ = Ring ID + (Harm ID + 1) x 1000000, 



(24) 



5. PJIINTAX card (also processed in GE0M1 section) 



-Input Card- 



POINTAX 



ID 


Ring ID 


<t> 



-12 Output Cards- 



MPcf 


101 


ID 


i 


-1.0 








-cont- 


'^ 


i 


Coef.^ 



N 3-word groups ) s set 
(n=l to N) I i=l to 6 



-cont- 


^^n 


i 


Coef.„ 










-cont- 


-1 


-1 


-1 












MPC^ 


102 


ID 


i 


-1.0 












-cont- 


% 


i 


Coef.^ 



N 3-word qrnuos) c set 
(n=l to N) / i=l to 6 



-cont- 



IDn 


i 


Coef.^ 



-cont- 



-1 


-1 


-1 



4.6-10 



EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 



where the Coef. above are defined by: 
n 



i 


c set-Coef. 


s set-Coef. „ 
n 


1 (u,) 


cos {M) 


sin (n<))) 


2(V 


sin (n<})) 


-cos (ntt)) , = +1 , n = 


3 (u^) 


cos (n(t)) 


sin (n4>) 


4 (e^) 


sin (n(|)) 


-cos (net)), = +1 , n = 


5 (%) 


cos (ncf)) 


sin (ntj)) 


6 (e^) 


sin (nij)) 


-cos (ntf)), = +1 , n = 



and 



ID = Ring ID + (n x 1000000) 



(25) 



6. SECTAX card (also processed in GE0M1 section) 



•Input Card- 



SECTAX 



ID 


Ring ID 


R 


^ 


*2 



•6 Output Cards- 



c? 


101 


ID 


i 


-1.0 












ont- 


^°n 


i 


Coef.^ 



N 3-word qrouDS ) s set 
(n=l to N) / i=l to 3 



-cont- 









I°n 


i 


Coef.^ 



-cont- 



■1 -1 



4.6-11 



MODULE FUNCTIONAL DESCRIPTIONS 



MPC^ 


102 


ID 


i 


-1.0 












-cont- 


'^ 


i 


Coef.„ 



, N 3-word groups \c set 
(n=l to N) f i=l to 3 



-cont- 



ID. 



Coef. 



-cont- 



-1 


-1 


-1 



where the Coef. above are defined by: 
n 



i 


c set-Coef. 


s set-Coef. 


1 
2 

3 


^ (sin{n*2) - s1n(n(ti^)) 
or R(iti2 - 'I'l) for n=0 

- ^ (cosCnfJig) - cos(n<tii)) 
or for n=0 

J (sin(n(t>2) - sin(n*^)) 
or R((J)2 - <(>■,) for n=0 


- - (cos(n<t'2) - cos(n(fi^)) 
or for n=0 

- J (sin(n<^2) " sin(n(t)^)) 
or R(4>2 - 4),) for n=0 

- ^ (cos^iKtig) - cos(n((i^)) 
or 0, for n=0 



and 



ID = Ring ID + (n x 1000000) 



(26) 



7. 0MITAX card 



■Input Card- 



0MITAX Ring ID 



Harm ID 



Comp 



-Output card- 



0MIT Ring ID^ 



Comp 



Ri 



ing ID^ = Ring ID + (Harm ID + 1 ) x 1000000. 



(27) 



4.6-12 



EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 



8. SUPAX card 



-Input Card- 



SUPAX 



Rinq ID 



Harm ID 



Comp 



-Output Card- 



SUP0RT Ring ID^ 



Comp 



Ring ID^^ = Ring ID + (Harm ID + 1) x 1000000. 



(28) 



9. RINGAX card (also processed in GE0M1 section) 



-Input Card- 



RINGAX 


Ring ID 


R 


Z 


Comp 






-2 X N Output Cards- 






SPC^ 
n 


101 


Ring ID^ 


135 








where 



Ring ID^ = Ring ID + 1000000 x n. 



(29) 



for n = 1, 2, ..., N; and 



SPC 



102 


Ring ID^ 


246 






where 



Ring ID*^ = Ring ID + 1000000 x n. 



(30) 



for n = 1, 2, .... N. 



4.6-13 



MODULE FUNCTIONAL DESCRIPTIONS 



4.6.7.5 Conversion of Input Bulk Data Cards to Output Cards for GE0M1 , 



1. P0INTAX card (also processed in GE0M4 section) 



-Input Card- 



P0INTAX 



ID 


Ring ID 


<t> 



-Output Card- 



GRID ID <^ 0.0 0.0 



2. SECTAX card (also processed in GE0M4 section) 



-Input Card- 



SECTAX 



ID 


Ring ID 


R 


*1 


*2 



-Output Card- 



GRID 



ID 





R 


^1 


h 












3. RINGAX card (also processed in GE(3M4 section) 



■Input Card- 



RINGAX Ring ID R 



Comp 



-N Output Cards- 



GRID 



Ring ID^ 





R 


Z 


0.0 





Comp 






where 



Ring ID = Ring ID + 1000000 x n, 



(31) 



for n = 1, 2, .... N. 



4.6-14 



EXECUTIVE PREFACE MODULE IFP3 (INPUT FILE PROCESSOR 3) 

4.6.7.6 Order of Output for Generated Card Images 

IFP3 has the responsibility to output cards in the sort order output by IFP. This causes 
IFP3 to simultaneously process some cards. 

4.6.8 Subroutines 

4.6.8.1 Subroutine Name: IFP3B 

1. Entry Point: IFP3B 

2. Purpose: To process the cards causing output to be created for GE0M4 and GE0M1 . 

3. Calling Sequence: CALL IFP3B 

4.6.9 Design Requirements 

The design requirements are: 

1. To produce card images equivalent to those out out by IFP. 

2. To output those images on GE0M1 , GE0M2, GE0M3, GE0M4 in the prooer sort and order. 

The following C0MM0N blocks are required for data interface between subroutines IFP3 and 
IFP3B. 

1. C0MM0tVIFP3LV/ 

This C0MM0N block contains local variables common between IFP3 
and IFP3B only. 

2. C0MM0N/IFP3BD/ 

This C0MM0N block contains constants common between IFP3 and 
IFP3B and is initialized in the Block Data subprogram AXICBD, 

3. C0MM0N/IFP3ZZ/ 

This C0MM0N block defines the beginning of open-core. 

4.6. 10 Diagnostic Messages 

IFP3 error messages are all user-oriented. They pertain to Bulk Data card errors ^'or the 
axisymmetric conical shell problem, and are output in summary form by IFP3 on the system output 

file. 

4.6-15 



EXECUTIVE PREFACE MODULE XGPI (EXECUTIVE GENERAL PROBLEM miTIALIZATION) 
4.7 EXECUTIVE PREFACE MODULE XGPI (EXECUTIVE GENERAL PROBLEM INITIALIZATION). 

4.7.1 Entry Point: XGPI 

4.7.2 Purpose 

To translate (compile) a DMAP program into an internal form (the 0SCAR) for use by the 
NASTRAN Executive System, and, if restarting the problem, to initialize data blocks and named 
common blocks for proper restart of the problem. See section 2 for format of the 0SCAR. 

4.7.3 Calling Sequence 

CALL XGPI. XGPI is called only by subroutine SEMINT, the Preface driver. 

4.7.4 Method 

XGPI calls XGPIBS to initialize data for the module and to initialize the Link 
Specification table in named common block /XLINK/. Upon return from XGPIBS, XGPI loads the XCSA 
Executive Table into core from the Problem Tape. If restarting the problem, XGPI modifies 
table MEDMSK in named common block /XMDMSK/ if necessary. See discussion of the INM table 
in the description for the XCSA module, in section 4.2.6.2. 

XGPI calls X0SGEN to execute phase 1 of the DMAP program compilation. X0SGEN processes 
the DMAP instructions and generates the skeleton of the Operation Sequence Control Array (0SCAR). 
See section 2.4.2.1 for details on the format of the 0SCAR. 

XGPI calls XFL0RD to execute phase 2 of the compilation. XFL0RD fills in the 0SCAR 
entries with the information needed for allocating files (by SFA) when DMAP modules are 
executed. If restarting a problem, XFL0RD determines which data blocks are needed from the Old 
Problem Tape to restart the problem and, when necessary, turns on execute flags for DMAP 
modules to regenerate missing data blocks. 

At this point, XGPI terminates the job if any errors were found in compilation; if not, 
XGPI writes the 0SCAR onto the Data Pool File. If the problem is a restart, XGPI copies the 
data blocks specified by XFL0RD from the Old Problem Tape onto the Data Pool File and 
initializes various named common blocks. 



4.7-1 



MODULE FUNCTIONAL DESCRIPTIONS 

XGPI calls 0SCDMP to print the 0SCAR if requested by the user via the DIAG card in the 
Executive Control Deck and to position the Data Pool File at the first 0SCAR entry in preparation 
for executing DMAP modules. If checkpointing is requested by the user, the Problem Tape 
Dictionary is initialized and written on the Problem Tape. XGPI then returns to the calling 
routine SEMINT. 

4.7.5 Subroutines 

The following labeled common blocks are used to coranunicate data and constants among the 
complex of XGPI subroutines. 

1. C0MM0N/XGPIC/ - Contains 30 individual cells containing various flags, integer and BCD 
constants, and machine dependent data. Also an additional 40 cell array contains a series 
of required masks. 

2. C0MM(SN/X6PID/ - Contains restart type codes and approach type codes plus masks and flags 
required in 0SCAR generation. 

3. C0MM(8N/X6PI1/ - Defines the beginning of open core for the XGPI module and contains the 
0SCAR as it is generated. 

4. C0MM0N/XGPI2/ - Contains the MPL table (see section 2.4.2.2). 

5. C0MM0N/XGPI2X/ - Contains the default parameters required by the MPL table. 

6. C0MM0N/XGPI3/ - Contains the PVT table (see section 2.4.2.4) prior to it being written 
on the Problem Tape. 

7. C0MM0N/XGPI4/ - Contains individual DMAP cards as they are output from XRCARD plus the 
various flags and pointers required to process each DtW instruction. 

8. C0I4M0N/XGPI5/ - Contains solution, solution subset, approach and start codes along with 
data pertaining to DMAP ALTER numbers. 

9. C0MM0N/XGPI6/ - Contains various pointers into the Module Execution Decision Table, 
MED (see section 1.10). 

10. C0MM0N/XGPI7/ - Contains data pertaining to the IFILE Table (see section 4.7.6.3). 



4.7-2 



EXECUTIVE PREFACE MODULE XGPI (EXECUTIVE GENERAL PROBLEM INITIALIZATION) 



n. C0MM0N/X6PI8/ - Contains pointers into the ICPDPL Table (see section 4.7,6.3). 

Further details regarding these common blocks may be obtained from the source listings for 
XGPIBD and XGPIBS. 



4.7.5.1 X6PIDG 

1. Entry Points: XGPIDG, XGPIMW. 

2. Purposes: For XGPIDG, to write all fatal and non-fatal diagnostic messages for 
module XGPI. For XGPIMW, to write all non-diagnostic messages for module XGPI. 

3. Calling Sequences: 
For XGPIDG: 

CALL XGPIDG (NC0DE,I ,J,K) 

NC0DE - Message code number 

I,J,K - Integer values determined by NC0DE. 

For XGPIMW: 
CALL XGPIMW (MSGN0,I,J,A) 

MSGN0 - Message code number 

I, J, A - Integer values determined by MS6N0 

4.7.5.2 XGPIBS 

1. Entry Point: XGPIBS. 

2. Purpose: To initialize module data and the Link Specification table in named 
common block /XLINK/(see section 2.4). 

3. Calling Sequence: 

CALL XGPIBS 

4.7.5.3 X0SGEN 

1. Entry Point: X0SGEN. 



4.7-3 



MODULE FUNCTIONAL DESCRIPTIONS 



2. Purpose: To execute phase 1 of the compilation by translating the DMAP program 
into a skeleton Operation Sequence Control Array (lasCAR). 



3. Calling Sequence: 
CALL X0SGEN 



4.7.5.4 XLNKHD 



1. Entry Point: XLNKHD. 

2. Purpose: To generate the header section of an 0SCAR entry and for problem re- 
starts, to determine whether or not to set the 0SCAR entry execute flag. 

3. Calling Sequence: 

CALL XLNKHD 



4.7.5.5 XIPFL 

1. Entry Points: XIPFL, X0PFL. 

2. Purpose: For XIPFL, to generate the input data block section of an 0SCAR entry. 
For X0PFL, to generate the output data block section of an 0SCAR entry. 

3. Calling Sequences: 

CALL XIPFL 
CALL X0PFL 

4.7.5.6 XPARAM 

1. Entry Point: XPARAM. 

2. Purpose: To generate the parameter section of an 0SCAR entry. 

3. Calling Sequence: 

CALL XPARAM 

4.7.5.7 XSCNDM 

1. Entry Point: XSCNDM, 

2. Purpose: To scan all DMAP instructions and return to the cc'lling program each 
item in an instruction along with its identification (i.e., delimiter, BCD name. 



4.7-4 



EXECUTIVE PREFACE MODULE XGPI (EXECUTIVE GENERAL PROBLEM INITIALIZATION) 

value or end of instruction) as it is requested, 

3. Calling Sequence: 
CALL XSCNDM 



4.7.5.8 XFL0RD 



1. Entry Point: XFL0RD. 

2. Purpose: To compute the LTU (Last Time Used) and NTU (Next Time Used) values 
for the input and output sections of 0SCAR entries, and for problem restarts, to 
determine which data blocks are needed from the Old Problem Tape to restart the 
problem, 

3. Calling Sequence: 

CALL XFL0RD 



4.7.5.9 XFLDEF 



1. Entry Point: XFLDEF. 

2. Purpose: To search the Old Problem Tape reF+="'^- dictionary for a requested data 
block name and flag name if found; and if not round, and if restart is modified and the 
calling routine requests it, to attempt to regenerate the data block by turning on the 
proper 0SCAR execute flags. 

3. Calling Sequence: 

CALL XFLDEF (NAMI, NAM2. N0FIND) 

NAM1,NAM2 - Data block name (8 characters, 4 characters/word). 

N0FIND - For input, N0FIND< indicates that the calling m'ii-ine wants 
the data block regenerated if it is not in restart dictionary. 
N0FINDiO indicates no regeneration is desired. For output, 
N0FIND indicates to the calling routine what XFLDEF did. 
N0FIND < 0, the data block was regenerated. N0FIND =0, the 
data block was in the restart dictionary and was flagged for 
use in restarting the problem. N0FIND > 0, the data block 
was not found and was not regenerated. 



4.7-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4,7.5.10 0SCDMP 

1. Entry Point: (3SCDMP. 

2. Purpose: To print the 0SCAR on the system output file if requested by user, and 
to position the Data Pool File at the first 0SCAR entry. 

3. Calling Sequence: 

CALL (SSCDMP (FILP0S) 
FILP0S - The number of file marks to skip over in order to be positioned at 
beginning of the 0SCAR . 

4.7.6 Design Requirements 

4.7.6.1 Open Core Layout 

The OSCAR array in named common block /XGPIl/ defines the first location in open core. 
All other arrays to be put in open core are equivalenced to 0SCAR and are offset from 0SCAR(1) 
by an amount determined at execution time. This dynamic allocation of arrays in open core 
optimizes the space available on a given machine, which means that any restrictions on data 
(except those noted below) are due to the machine's core size and not the program. 

The diagrams below show the order in which tables reside in open core during phase 1 and 
phase 2 of the compilation. 



Phase 1 



Phase 2 



0SCAR 



DMPCRD 



0SCAR 



PTDIC 



LbLTBL 



MED 



FNM 



IBUFR 



ICPDPL 



MED 



FNM 



IBUFR 



In phase 1 the final sizes of the arrays 0SCAR and LBLTBL are not known until the Df'lAP 
program has been completely scanned by X0SGEN. These two arrays request space as needed 
until it runs out. At this time the user is informed that the DMAP should be shortened or 



4.7-6 



EXECUTIVE PREFACE MODULE XGPI (EXECUTIVE GENERAL PROBLEM INITIALIZATION) 



core storage should be increased. 



4.7.6.2 Data Necessary For Operati 



on 



The Problem Tape provides Executive Tables XCSA, XALTER, PVT, and for restarts. XPTDIC 
(see section 2.4 for details). Data in named common blocks is initialized by the BLOCK DATA 
routines XMPLBD. XGPIBD and XBSBD or common block data is initialized by routine XGPIBS. 

4.7.6.3 Table Formats 

1. 0SCAR: Located in named common block /XGPIl/. See section 2.4.2.1 for format. 

2. MED, CNM, FNM: Equivalenced to the 0SCAR table. See ISl , INM and JNM table 
descriptions in XCSA Module Functional Description (4.2.6.2). 

3. PTDIC, ICPDPL: Equivalenced to 0SCAR array. 
Sample entry: 



Word 1 
2 

3 



DBN 




- 





eq' 


"et 


er 


RU 


R 

2B n 


— 


F 


- — 


S 


Jl 


30 


29 


1 6 


1 



Word 



1.2 



Item 



DBN 



R.F 



EQ 



ET 



Description 
Data block name (BCD) of the data block from the restart 
dictionary. Note, a data block name appears only once in 
the table except for table VPS where it appears twice. 

Reel number and file number where the data block is last 
located on Old Problem Tape. For XVPS there is an entry 
(the first in PTDIC) which indicates where the first XVPS 
data block is located on the Old Problem Tape. For purged 
or not-generated data blocks, R = and F = 0. 

Equivalence flag. EQ = Indicates the data block is 
equivalenced to another data block. 

End of tape flag. ET = 1 indicates that the data block is 
split across two reels of the Old Problem Tape. 

4.7-7 



Word 



MODULE FUNCTIONAL DESCRIPTIONS 

Item Description 

ER End of logical record flag. ER = 1 indicates that the 

complete logical record was written out prior to changing 

reels when ET = 1 . 
RU Reuse flag. RU = 1 indicates that this data block is to be 

used to restart the problem. 
Table ICPDPL contains all entries from PTDIC which had the RU flag set. 

4. MPL: The MPL is located in named common block /XGPI2/. See section 2.4.2.2 for details 

5. IS3RDNL: Equivalenced to MPL, the I0P.DNL table is used in phase 2 when the MPL is no 
longer needed. Data block names are entered into I0RDNL in the order that they are 
output from functional modules and IFP. 
Sample entry: 



Word 



1 
2 

3 



DBN 



"1 



[B I ^^]^^} 



AP LTU 

3 1 30 1 'I 



Word 

1,2 

3 



Item 

DBN 

LSTUSE 



TF 



LTU 



AP 



Description 
Data block name (BCD) 
Pointer to input or output section entry 
0' a functional module 0SCAR entry where the data 
block was last referenced. LSTUSE is used to fill in 
MTU's (Next Time Used) in 0SCAR entries. 
Tape flag. TP = 1 if the data block was declared TAPE 
in a FILE DMAP instruction. 

Last time used. Record number of 0SCAR entry beyond which 
the data block need not be saved for input. 
Append flag. AP = 1 if the data block was declared 
APPEND in a FILE DMAP instruction. 



6. PVT: Located in named common block /XGPI3/, 



4.7-8 



EXECUTIVE PREFACE MODULE XGPI (EXECUTIVE GENERAL PROBLEM INITIALIZATION) 



Sample entry: 



M 



CN 



PVT File 



see section zA.ZA for details. 



MN - Maximum number of words In PVT (integer). 
CN - Current number of words being used (integer). 

7. IFILE: Located in named common block /XGPI7/. The purpose of IFILE is to save 
information from FILE DMAP instructions. 





Word 


1 
2 

3 





DBN 











AP 

3 1 


TP 

1 6 


SV 

1 




Word 


Item 






Description 


1.2 


DBN 






Data block name (BCD) 


3 


SV 
TP 






SAVE flag 
TAPE flag 




AP 










APPEND flag 



4.7.6.4 Restrictions on Data 

There are only three fixed length tables which might be overflowed by excess user data. 
These tables are PVT, IFILE and I0RDNL. 

4.7.7 Diagnostic Messages 

Every effort is made to detect syntactical and logical errors in the DMAP program, and, for 
restarts, to make sure that the problem is being restarted correctly. All tables are checked 
for overflow. 

The N0G0 flag in named common block /SYSTEM/ is set according to the severity of the 
errors found. N0G0 = 1 indicates compilation is to be discontinued after phase 2. N(2G!3 = 2 



4.7-9 



MODULE FUNCTIONAL DESCRIPTIONS 



indicates a serious error and causes XGPI to terminate the program immediately. 

See the Diagnostic Message section of the User's Manual (section 6.2) for a detailed dis- 
cussion of XGPI diagnostic messages. XGPI messages include numbers 1 thru 53. 



4.7-10 



EXECUTIVE PREFACE MODULE UMFEDIT (USER MASTER FILE EDITOR) 



4.8 EXECUTIVE PREFACE MODULE UMFEDIT (USER MASTER FILE EDITOR) 



4.8.1 Entry Point : UMFEDT 



4.8.2 Purpose 



To create and manipulate User Master Files. 



4.8.3 Call ing Sequence 



CALL UMFEDT. UMFEDT is called only by SEMINT, the Preface Driver. 



4.8.4 Method 



UMFEDIT functions as a post-processor to Executive Module XS0RT. Its nrimary task is to 
generate a User Master File by repeatedly transferring sorted bulk data decks generated by XS^^RT 
from the New Problem Tape (NPTP) to the New User Master File (NUMF) based on control cards read 
from the System Input File. See section 2 of the User's Manual for a description of these 
control cards and how they control the contents of the NUMF. 

In addition to creating a User Master File, UMFEDIT is used to list and/or punch Bulk Data 
Decks from an existing User Master File (UMF). Control cards read from the System Input File 
also control this process. 

4.8.5 Subroutines 

The UMFEDIT module has no auxiliary subroutines but uses XRCARD (see section 3.4 for a 
description) . 

4.8.6 Design Requirements 

1. Open core is defined at /UMFXXX/ and is utilized as follows: 

C0MM0N/UMFXXX/ 



GIN0 


Buffer 


for 


UMF 


GIN0 


Buffer 


for 


UMF 


GINf5 Buffer 


for 


NPTP 




Unused core 



4.8-1 



MODULE FUNCTIONAL DESCRIPTIONS 

2. The Block Data subprogram UMFZBD fills /UMFZZZ/. 

3. UMFEDIT operates only in the Preface environment. The Bulk Data Deck must have been 
processed by XS0RT and accepted by the Input File Processor (IFP). 

4.8.7 Diagnostic Messages 

Bad Bulk Data Decks (indicated by AB0RT = .TRUE.) will not be accepted by UMFEDIT for 
inclusion on the NUMF. Subsequent Bulk Data Decks will be included, however, if acceptable. 

Other errors detected in UMFEDIT will result in appropriate diagnostic messages being 
written on the System Output File and termination via PEXIT. These messages are: 1703 through 
1716, 1718, 1719. 1721, 1722, 1723, and 1725 through 1737. 



4.8-2 



EXECUTIVE MODULE XSFA (EXECUTIVE SEGMENT FILE ALLOCATOR) 

4.9 EXECUTIVE MODULE XSFA (EXECUTIVE SEGMENT FILE ALLOCATOR) 

4.9.1 Entry Point : XSFA 

4.9.2 Purpose 

The Segment File Allocator (SFA) manages the data block to physical file relationships 
throughout a NASTRAN problem. Since, in general, the number of data blocks required for 
problem solution far exceeds the number of physical files available, allocation of files to 
data blocks is done dynamically as the module sequence proceeds. The SFA will allocate 
forward for as many modules as possible. A group of modules allocated by one operation of 
the SFA is termed a segment. 

4.9.3 Calling Sequence 

CALL XSFA (0SCP0S) 

0SCP0S - When input to XSFA, this integer argument is the current position (record 
number) within the 0SCAR. Upon return from XSFA, (1) if allocation was 
successful, 0SCP0S is the 0SCAR position of the end of the segment as defined 
above; (2) if allocation was unsuccessful, the input argument is set negative. 

4.9.4 Method 

SFA is called by GNFIST (see section 3.3.9 for a description of 6NFIST) when GNFIST fails 
to find the necessary data block names in the FIAT table to construct a complete FIST table 
for the next operating module (see section 2.4 for descriptions of the FIST and FIAT). 
The FIST table must contain an entry for each input, output, and scratch data block required by 
the module. SFA operates by processing the 0SCAR from its present position (next module to be 
operated) through all remaining modules. Only functional module and output processor 
(3SCAR entries flagged for execution are processed. The 0SCAR is read and processed by an 
internal subroutine named XS0SGN (Serial 0SCAR Sequence Generator) and the S|3S table is 
formed. From this table all allocation is performed. Following XS0SGN, another internal 
subroutine named XCLEAN operates. XCLEAN acts to "clean up" the FIAT and DPL tables nrior 
to the basic allocation procedure. This clean-up involves deleting data block names not 
needed for subsequent modules, removing equivalence flans if one member of an equivalent 



4.9-1 



MODULE FUNCTIONAL DESCRIPTIONS 

pair is deleted, and closing up gaps in the FIAT caused by deletions. Following operation of 
XCLEAN. basic allocation begins. Allocation is accomplished during two passes through the S0S 
table. 

Pass one first checks to see if each data block from the S0S is already in the FIAT. If so, 
it is considered allocated; otherwise the possibility of data block stacking is investigated. 
Stacking is defined as assigning two or more data blocks to the same physical file by con- 
sidering their use span. The various use span attributes available are: First-Time-Used (FTU), 
Next-Time-Used (NTU), and Last-Time-Used (LTU). Data block A may use (be stacked on) the same 
file as data block B it the first use (FTU) of data block B is subsequent to the last use (LTU) 
of data block A. Thus many data blocks may be allocated to use the same physical file if their 
use spans do not overlap. Following pass one, if any data blocks within S0S remain un-allocated, 
pass two is begun. 

Pass two first checks for files within the FIAT currently not assigned to any data block. 
These files are considered empty and are assigned to the un-allocated data blocks. Once the 
empty files are exhausted a check is made to determine if the next module to be operated has 
all its data blocks allocated to files. If the next module (at the least) is allocated, 
basic allocation is completed. If the next module has not been completely allocated, the 
second part of pass two will force pooling of sufficient data blocks to provide the necessary 
empty files for allocation of the remaining data blocks needed for the next module. Pooling 
is accomplished by flagging the data blocks for copying onto a separate file called the 
Data Pool File. The Data Pool File will therefore contain many different data blocks where 
all other files contain only one data block at a time. Data blocks are chosen for pooling 
by checking the next- time-used (NTU) attribute. The data block with the greatest NTU will 
be pooled first. Data blocks pooled are considered un-allocated; when they are subsequently 
re-allocated to their own file, they will be flagged for unpooling. 

Following basic allocation, subroutine XPUNP (Pool-Unpool ) is operated. All data blocks 
flagged for pooling are copied to the Pool File followed by all data blocks flagged for unpooling 
being copied from the Data Pool File. Lastly subroutine XDPH (Data Pool Housekeeper) operates 
to clean-up and if necessary re-copy the Data Pool File. SFA then returns control to GNFIST 
with the calling argument set negative if it was un-able to allocate the next module. Figure 1 
illustrates the functional flow. 



4.9-2 



EXECUTIVE MODULE XSFA (EXECUTIVE SEGMENT FILE ALLOCATOR) 



4.9.5 Subroutines 



XSFA performs basic allocation and its entry point, purpose and calling sequence are given 
above. Below, it should be noted that XPLEQK and XFILPS are secondary entry points in XP0LCK. 

4.9.5.1 Subroutine Name: XS0SGN (Serial 0SCAR Sequence Generator) 

1. Entry Point: XS0SGN 

2. Purpose: XS0SGN reads the 0SCAR and creates the S0S (Serial 0SCAR Sequence) and MD 
(Module Descriptor) tables. The S0S table contains the data block names and various 
attributes, while the MD table contains the 0SCAR sequence numbers and the number of 
input, output, and scratch data blocks required by each module. 

S0S Table 



# Entries 



Data Block 
Name 



a!a 
l!p 



iT ; 
LTU 1 ! NTU 
30 w! leiis 



Entry 



AL = Allocation Flag, set on by SFA 
when data block is allocated. 

AP = Append Flag, set on by module 
XGPI if data block is to be 
added to. 

LTU = Last-Time-Used, created by 

XGPI as a data block attribute. 

T = Tape Request Flag, set by XGPI 
to indicate a physical tape file 
is requested for data block. 

NTU = Next-Time-Used, created by XS0SGN 
as a data block attribute. 



MD Table 




# Entries 


0SCAR Sequence # 




# Inputs 




# Outputs 




# Scratches 


— 




" V 



' Entry 



# = Full word integer 
values for items 



4.9-3 



MODULE FUNCTIONAL DESCRIPTIONS 

Note : Items created or set by XGPI are passed via 0SCAR. 
These tables are contained within the /XSFAl/ common block. 
3. Calling Sequence: CALL XS0SGN 

4.9.5.2 Subroutine Name: XCLEAN (FIAT and DPL Clean-up) 

1 . Entry Point: XCLEAN 

2. Purpose: XCLEAN deletes data block names from the FIAT and DPL when they are no 
longer needed (their LTU has been reached). Following these deletions, equivalenced 
data blocks flags within FIAT are checked for continuing validity. If, for examole, 
one member of an equivalenced pair has been deleted, the equivalence flag on the 
remaining member is removed. Finally, empty spaces within FIAT are removed by closino 
up the table. XCLEAN also regenerates and stores various parameters into the extended 
FIAT table. Since this table is non-resident and exists only during SFA operation, 
values such as NTU and the on/off switches must be restored. 





Word 

1 




Extended FIAT 






0; 


j^ i NTU 

UX^iJJ 5 _± 


\ 




2 

3 


-N = 
+N = 


Pool rl»^ 

Unpool "^9 


1 




-1 



if" Current Module 
No 


\ Sample entry 




4 


-1 




'" Current Segment 


I (one for each FIAT entry) 




5 
6 

Item 




Allocation Type 






(Unused) 


/ 










Word 


Description 





•ITU 



On/off switch, data block is turned off following stacking 
to prevent double stacking. 

Tape request flag, copied from S0S when allocated. 

'lext-Time-Used; copied from S0S when allocated, regenerated 
by XCLEAN for data blocks remaining from previous allocation. 



4.9-4 



EXECUTIVE MODULE XSFA (EXECUTIVE SEGMENT FILE ALLOCATOR) 

Word Item Description 

2 -M Flags XPUNP to pool data block, N = number of equivalent 

names for data block (Equals 1 if data block not equi valenced) . 

+N Flags XPUNP to unpool data block, N = Data Pool File number 
of data block. 

3 Flag set yes if data block allocated for module currently 
being allocated - cleared between module allocations. 

4 Flag set yes if data block allocated for module within current 
segment - i.e., all data blocks allocated during one SFA 
operation. 

5 Allocation type - 1 = data block match, name already in FIAT 

2 = data block stackinci, name on file with 

another 

3 = empty file used for data block 

5 = data block using file freed bv nooling 
another data block 

7 = same as 5 except pooled data block is 
equi valenced 

6 Unused 

This table is contained within the /XSFAl/ common block. 

4.9.5.3 Subroutine Name: XPUNP (Pool-Unpool ) 

1. Entry Point: XPUNP 

2. Purpose: XPUNP checks the Pool and Unpool flags within the extended FIAT and performs 
the 1/0 operations necessary to copy data blocks from their separate files to the Data Pool 
File and vice-versa. Data block trailers are copied from the FIAT onto the Data Pool File 
as an additional record during pooling and are reolaced from this record during unoooling. 
All requested pooling operations are performed prior to any unpool i no operations. As data 
blocks are added to the Data Pool File, appropriate entries are added to the Data Pool 
Dictionary (DPL). The extended FIAT (4.9.5.2) is contained within the /XSFAl/ common block. 

3. Calling Sequence: CALL XPUNP 



4,9-5 



MODULE FUNCTIONAL DESCRIPTIONS 
4.9.5.4 Subroutine Name: XDPH (Data Pool Housekeeper) 

1. Entry Point: XDPH 

2. Purpose: XDPH scans the Data Pool Dictionary (DPL) to determine the number and size of 
the data blocks on the Data Pool File which have been flagged as no longer needed. If a 
sufficient quantity of data is flagged, a complete housekeeping operation is performed. 
This complete process involves re-copying the Data Pool File onto a scratch file while 
skipping those data blocks flagged for removal. Following the re-copy, the scratch file 
becomes the new Data Pool File and the old Data Pool File is released as a scratch file. 
XDPH will also perform a partial housekeeping if a (several) flagged data block(s) apoears 
as the last data block on the Data Pool File. For this oartial operation only the DPL 
entries are modified to release the pool space, no re-copy is necessary. 

3. Calling Sequence: CALL XDPH 

4.9.5.5 Subroutine Name: XP0LCK (Data Pool Dictionary Check) 

1. Entry Point: XP0LCK 

2. Purpose: XP0LCK scans the Data Pool Dictionary for a particular data block name. If 
found, the position within the dictionary and the Data Pool file number are returned to 
the calling program. 

3. Calling Sequence: CALL XP0LCK (DBNl ,DBN2,FN,L) 

where: 

DBNl, DBN2 - Request data block name (8 characters), 4 characters in each word, 
left justified and filled with blanks (if necessary). 

(0, if data block not on the Data Pool File. 



FN - \ 

(n, if data block on the Data Pool File; N = Data Pool File number. 

L - Position of data block entry within the dictionary if data block found. 
4.9.5.6 Subroutine Name: XPLEQK (Data Pool Equivalence Check) 
1 . Entry Point: XPLEQK 



4.9-6 



EXECUTIVE MODULE XSFA (EXECUTIVE SEGMENT FILE ALLOCATOR) 

2. Purpose: XPLEQK scans the Data Pool Dictionary for any equivalence to the called data 
block name. If found, a copy of the equivalent names is moved from the Data Pool 
Dictionary to the FIAT. 

3. Calling Sequence: CALL XPLEQK (P00LX,FIATX) 
where: 

P00LX - Position of data block entry within the dictionary (see argument L within 
XP8ILCK). 

FIATX - Position of same data block entry within the FIAT. 
4.9.5.7 Subroutine Name: XFILPS (Data Pool File Positioner) 

1. Entry Point: XFILPS 

2. Purpose: XFILPS positions the Data Pool File to the beginning of a requested data 
block. (The Data Pool File is a multi-file file). 

3. Calling Sequence: CALL XFILPS (FNEW) 
where: 

FNEIJ - The file count of the requested position. The current or old file nosition 
is stored in the /XSFAl/ common block, 

4.9.6 Design Requirements 

1. Open core is used only for GIN0 buffers (2 maximum). The open core origin is 
common block /ESFA/ located following all SFA subroutines. 

2. SFA communicates data internal to the module subroutines via common block /XSFAl/. 
The S0S, MD and extended FIAT tables reside in /XSFAl/. 

3. The 0SCAR must be at the entry where allocation is to begin. Following allocation, 
that initial USCAR position is restored. 

4. BLOCK DATA subprogram defines the lengths of tables in /XSFAl/. 



4.9-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4.9.7 Diagnostic Messages 

Special DMAP routing may cause the warning 3022 message to be printed by SFA. 

Fonowing output of this message, SFA flags the data block as allocated (although it will 
not appear in the FIAT) and continues. Since SFA cannot predict conditional DMAP routing, the 
data block in question may not be required and the problem will proceed satisfactorily. If the 
data block is required, the problem will terminate in the requesting module. Under these circum- 
stances the DMAP routing should be studied. 

All other error messages generated by SFA are fatal in nature and indicate serious 1/0 
malfunctions or executive table overflow. See section 6 of User's Manual for listinq and 
explanation of these messages. XSFA messages include numbers 1001 through 1004, 1011 through 
1014, 1021, 1031 through 1035, 1041, and 1351. 



4.9-8 



EXECUTIVE MODULE XSFA (EXECUTIVE SEGMENT FILE ALLOCATOR) 




lA 



XSFA 




r ENTER J 

/ Can \ 
\ XS0SGN / 




nr 




/ Can \ 
\ XCLEAN / 


Next 


V 


Module 


Set anoc range to 






first/next module 



Next 
Data Block 



Pass 1 



Pick-up first/next data 
block within module 




Stack data block 
on the same file 



No 




Set data block 
as allocated 




2A 



Next 
Data Block 

► 



Yes 
Pass 2 



Pick-up first/next 
data block within module 



i 




Figure l.(a) Flowchart for module XSFA. 



4.9-9 



MODULE FUNCTIONAL DESCRIPTIONS 




Yes 




No 



-►r* 



Find the data block 
with the largest 
NTU not required 
in this module 



Use empty 

file for 

data block 




Call 
XPUNP 



No 



Set the pooling flag 
for this data block 



I 



1 



I 



Call 

XDPH 



Set ARC. NEG. 

indicating 
alloc, incomp. 



Use this now empty file 
for new data block 



c 



RETURN 



} 



Set new data block 
as allocated 




Figure l.(b) Flowchart for module XSFA. 
4.9-10 



EXECUTIVE DMAP MODULE CHKPNT (CHECKPOINT) 

4.10 EXECUTIVE DMAP MODULE CHKPNT (CHECKPOINT) 

4.10.1 Entry Point : XCHK 

4.10.2 Purpose 

To save, on the Problem Tape, specified data blocks along with other data necessary 
for restarting a problem. 

4.10.3 DMAP Calling Sequence 

CHKPNT DB1,DB2 DBN $ 

where DBl, DB2 DBN (N 2 1) are data blocks to be copied onto the Problem Tape for 

use in restarting a problem. 

4.10.4 Method 

The Problem Tape Dictionary (XPTDIC), see section 2.4.2.3, is brought into core from the 
Problem Tape, and the data block list in the CHKPNT 0SCAR entry is scanned. Data blocks that have 
been generated are entered into the local DICT table (see discussion below) along with all data 
blocks equivalenced to them. Data blocks that are purged, or have not yet been generated, 
are entered in the local PURGE table. The data blocks are assigned file numbers and are 
placed in the EDICT table. Data blocks are then copied onto the Problem Tape according to 
their file number unless the data block is equivalenced and is already in the Problem Tape 
Dictionary. Core resident data necessary for restart is also written on the Problem Tape as 
the VPS Executive Table. Entries from FDICT and PURGE are entered into the Problem Tape 
Dictionary, and the new checkpoint entries are punched for user submittal in the Executive 
Control Deck upon problem restart. The updated Problem Tape Dictionary is written back on the 
Problem Tape, and the Problem Tape is positioned to the beginning of the last file (i.e., XPTDIC) 
in preparation for the next execution of the CHKPNT module. 

4.10.5 Subroutine 

Module XCHK has no auxiliary subroutines. 



4.10-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.10.6 Design Requirements 

4.10.6.1 Open Core Layout 

Named common block /ESFA/ defines the start of the open core area. The use of open core 
1s optimized by origining arrays GBUF, PTDIC and I0BUF at /ESFA/ and computing their offset 
from the origin at execution time. The diagram below shows how the arrays are placed in open 
core. 



C0MM0N /ESFA/ 





Problem Tape Dictionary 




Utility buffer 




Data Block GIN0 buffer 




Data Pool File GIN0 buffer 




Problem Tape GIN0 buffer 



PTDIC(PTDt0P) 

I0BUF(I0PNT) 

■GBUF(FPNT) 

GBUF{DPPNT) 

GBUF(NPTPNT) 



4.10.6.2 Data Necessary for Operation 

The data blocks, named common blocks and files needed by the CHKPNT module are listed 
below, along with type of access required (i.e. fetch and/or store data) and reasons for use. 

1. Data Pool File - fetch data blocks to be copied onto the Problem Tape. 

2. Problem Tape - fetch and store data blocks. 

3. Executive Table XPTDIC - fetch and store. Used to generate new checkpoint entries 
which are then added to XPTDIC. 

4. Cornnon /XFIST/ - store temporary entry in FIST for copying data blocks. 

5. Common /0SCENT/ - fetch. CHKPNT i^SCAR entry resides here. 

6. Common /XCEITB/,/XVPS/ and /SYSTEM/ - fetch. Contains data to be written in VPS 
Executive Table. 

7. Common /XFIAT/ and Common /XDPL/ - fetch. Contains data block names of data blocks 
to be copied. 

8. Common /0UTPUT/ - store. Prints out page heading for Checkpoint Dictionary printout. 

9. Cornnon /STAPID/ - fetch and store. Used to write Problem Tape ID file on new reel of 
of the Problem Tape when an end of reel is encountered. 



4.10-2 



EXECUTIVE DMAP MODULE CHKPNT (CHECKPOINT) 

4.10.6.3 Formats of Local Arrays 

1. DICT table 

The purpose of the DICT table is to hold preliminary data to be used in generating the 
FDICT table. 

Sample DICT entry: 



Word 
1.2 



Item 



DBN 



EQ 



FA 



DP 



FP 



ID 



Word 1 
2 

3 



2. FDICT table 



EQ 


FA 


DP 

30 


DBN 
FP 


ID 

_L6_.. 



Description 

BCD name (8 characters, 2 words) of the data block whose status is 

generated and is to be checkpointed. 

Equivalence flag. EQ = 1 indicates all data blocks equivalenced to 

this data block also reside in DICT table. 

File number assigned flag. FA = 1 indicates that an FDICT entry has 

been generated for this DBN and that a file number of where the data block 

will reside on the Problem Tape has been assigned. 

Data pool flag. DP = 1 indicates that the data block is on the Data Pool 

File. 

Varies according to DP flag. For DP = 1, FP is not used. For DP = 0, 

FP is a pointer to the FIAT entry containing DBN or equivalenced DBN. 

Varies according to DP flag. For DP = 1 , ID is the file number where 

the data block resides on the Data Pool File. For DP = 0, ID is the file 

(unit) identifier. For the IBM 7094, ID is the unit control block pointer 

for the file. For machines using the F0RTRAN GIN0, ID is the F0RTRAN 

logical unit number assigned to the file. 



The purpose of the FDICT table is to hold final data to be used in generating XPTDIC entries 
for data blocks whose status is generated. 

4.10-3 



MODULE FUNCTIONAL DESCRIPTIONS 



Sample FDICT entrv: 

Word 1 
2 



DBN 


— _ 


Tq~1t' 


ER 


R 


- — 


F 


i. . 


^1 


ii. 


J9 17 


16 


-.i 



Word Item Description 

1,2 DBN BCD name of data block. 

EQ Equivalence flag. EQ = 1 indicates all data blocks equivalenced to 

this data block also reside in the FDICT table. 

ET End-of-tape flag. ET = 1 indicates that the data block is split 

across two reels of Problem Tape. 

ER End-of-logical -record flag. ER = 1 indicates that the complete 

logical record was written out prior to changing reels when ET = 1 . 
3 R,F Reel number and file number where the data block will be written on 

the Problem Tape. 

4.10.6.4 Restrictions 

XPTDIC cannot be written across two reels of Problem Tape (i.e. a fatal error occurs if 
an end-of-tape is encountered while writing XPTDIC). 

4.10.7 Diagnostic Messages 

See Diagnostic Message section of User's Manual (section 6.2) for a detailed discussion of 
CHKPNT module diagnostic messages. XCHK messages include numbers 1101 through 1109. 



4.10-4 



EXECUTIVE DMAP INSTRUCTION REPT (REPEAT A GROUP OF DMAP INSTRUCTIONS) 

4.11 EXECUTIVE DMAP INSTRUCTION REPT (REPEAT A GROUP OF DMAP INSTRUCTIONS) 

4.11.1 Entry Point : XCEI 

The XCEI module executes the DMAP control instructions: REPT, EXIT, C0ND and JUMP. 

4.11.2 Purpos e 

To repeat a group of DMAP instructions a specified number of times. 

4.11.3 DMAP Calling Sequence 

REPT n.c S 
where: 

1. n is a BCD name appearing in a LABEL instruction which specifies the location of th-. 
beginning of the group of DMAP instructions to be repeated. 

2. c is an integer constant which specifies the number of times to repeat the 
instructions. 

4.11.4 Example 
BEGIN $ 



LABEL LI $ 

M0DULE1 A/B/V,Y,P1 $ 



M0DULEN B/C/V,Y,PN $ 
REPT LI, 3 $ 



END 



4.11-1 



MODULE FUNCTIONAL DESCRIPTIONS 

The DMAP instructions from MjIDULEl to M0DULEN will be repeated 3 times. Note that REPT 
is placed at the end of the group of instructions to be repeated. 

4.11.5 Method 

Executive Table CEITBL in named common block /XCEITB/ (see section 2.4 for format) is 
Huched for the REPT entry and the entry is updated after determining whether or not to repeat 
Uie loop again. If the loop is not to be repeated, a return is made to the calling routine. If 
d repeat of the loop is to be executed, the Problem Tape Dictionary (XPTDIC) is read into core 
from the Problem Tape, and dictionary entries created inside the loop are deleted. The updated 
XPTDIC is written back on the Problem Tape. Data blocks that are referenced only inside the loop 
and which have not been declared saved in a FILE DMAP instruction have their status changed to 
not-generated (i.e. data block trailers within FIAT are cleared and if the data block name appears 
in the DPL it is removed). The 0SCAR on the Data Pool Tape is positioned to the top of loop and 
a return is made to the calling routine. 

4.11.6 Subroutine 

4.11.6.1 Subroutine Name: XCEI. 

1. Entry Point: XCEI 

2. Purpose: To execute DMAP Control modules REPT, JUMP, C0ND, and EXIT as described 

in the respective Executive DMAP Module Descriptions in this section and in sections 4.12, 
4,13 and 4.14. 

3. Calling Sequence: 

CALL XCEI 

4.11.7 De sign Requrements 
4.11.7.1 Open Core Layout 

Named coimon block /ESFA/ defines the start of the open core area. The following 
diagram shov/s the layout. 

C0MM0N/ESFA/ 



Data Pool File GIN|3 buffer area. 



Problem Tape GINO buffer area. 



Problem Tape Dictionary (XPTDIC). 



4.11-2 



EXECUTIVE DMAP INSTRUCTION KEPT (REPEAT A GROUP OF DMAP INSTRUCTIONS) 
4.11.7.2 Data Necessary For Operation 

The tables, named common blocks and files needed by the control modules are listed 
below, along with type of access required (i.e. fetch and/or store data) and reasons for use. 

1. Data Pool File - XCEI must re-position the 0SCAR to the correct entry when a 
transfer is to be executed. 

2. Problem Tape - fetch and store the Problem Tape Dictionary when looping. 

3. Data Block XPTDIC - fetch and store. The Problem Tape Dictionary must be updated 
when looping, 

4. C0MMi3N /XVPS/ - fetch. 

/XVPS/ contains the C0ND instruction parameter value. 

5. C0MM(3N /XCEITB/ - fetch and store. 

/XCEITB/ contains control parameters for REPT and EXIT instructions. 

6. C0MM0N /0SCENT/ - fetch. 

/0SCENT/ contains the Control Module 0SCAR entry. 

7. C0MM(3N /XFIAT/ - fetch and store. 

Must be updated when looping. 

8. C0MM8)N /XDPL/ - fetch and store. 

Must be updated when looping. 



4.11-3 



EXECUTIVE DMAP INSTRUCTION JUMP (UNCONDITIONAL DMAP TRANSFER) 

4.12 EXECUTIVE DMAP INSTRUCTION JUMP (UNCONDITIONAL DMAP TRANSFER) 

4.12.1 Entry Point : XCEI 

4.12.2 Purpose 

To alter the normal order of execution of DMAP modules by unconditionally transferring 
program control to a specified location in the DMAP program. 

The normal order of execution of DMAP modules is the sequential order of occurrence of 
the modules as DMAP instructions in the DMAP program. 

4.12.3 DMAP Calling Sequence 
JUMP n $ 

where n is a BCD name appearing on a LABEL instruction which specifies where control is to be 
transferred. 

4.12.4 Method 

If control is being transferred to a previous DMAP module in the 0SCAR (i.e., looping), 
the Problem Tape Dictionary is read into core from the Problem Tape and dictionary entries 
created inside the loop are deleted. The updated Problem Tape Dictionary is written back out on 
the Problem Tape. Data blocks that are referenced only inside the loop and which have not 
been declared saved in a FILE DMAP instruction have their status changed to not-generated. 
The 0SCAR is positioned to the specified location. Table CEITBL in named corrnion block /XCEITB/ 
is searched for REPT entries and the loop count is zeroed if the jump is transferring control 
from inside the loop to outside the loop. A return is then made to the calling program. 

If control is being transferred to a subsequent DMAP module in the 0SCAR, the 0SCAR is 
positioned to the specified location and a return is made to the calling program. 

See description of the Executive DMAP instruction REPT (see section 4.11) for further details. 



4.12-1 



EXECUTIVE DMAP INSTRUCTION C0ND (CONDITIONAL TRANSFER) 

4.13 EXECUTIVE DMAP INSTRUCTION C0ND (CONDITIONAL TRANSFER) 

4.13.1 Entry Point : XCEI 

4.13.2 Purpose 

To alter the normal order of execution of DMAP modules by conditionally transferring 
program control to a specified location in the DMAP program. 

4.13.3 DMAP Calling Sequence 

C(3ND n.V $ 
where: 

1. n is a BCD name appearing on a LABEL instruction which specifies where conti ol is to r,o 
transferred. 

2. V is a BCD name of a variable parameter whose value indicates whether or not to £.;.-ociii-p 
the transfer. If V < 0, the transfer is executed. 

4,13.4 Example 
BEGIN $ 



C0ND Ll.K $ 

M0DULE1 A/B/V,Y,P1 $ 



LABEL LI $ 
M0DULEN X/Y/ $ 



END $ 

If Ki 0, M0DULE1 is executed. If K< control is transferred to LI and M0DULEM is 

executed. 



MODULE FUNCTIONAL DESCRIPTIONS 



The parameter value for the C0ND instruction is examined. If the value is greater 
,yn or equal to zero, a return is made to the calling routine. If the value is less than 
:;o, the C0ND instruction is executed exactly like the JUMP instruction. See description 
f the Executive DMAP instruction JUMP (section 4.12) for further details. 



4.13-2 



EXECUTIVE DMAP INSTRUCTION EXIT (TERMINATE DMAP PROGRAM) 

4.14 EXECUTIVE DMAP INSTRUCTION EXIT (TERMINATE DMAP PROGRAM) 

4.14.1 En try Point : XCEI 

4.14.2 Purpose 

To terminate a NASTRAN job. 

4.14.3 DMAP Calling Sequence 

EXIT c $ 

where c is an integer constant which specifies the number of times the instruction is to 
be ignored before terminating the program. If c = the calling sequence may be shortened 
to EXIT $. 

4.14.4 Example 
BEGIN $ 



LABEL LI $ 
M0DULE1 A/B/V,Y,P1 



EXIT 3 $ 
REPT LI, 3 $ 



END $ 



The EXIT instruction will be executed the third time the loop is repeated (i.e., the 
instructions within the loop will be executed four times). 



4.14-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.14.5 Method 

A determination is made whether or not to terminate the job by examining the loop count cf 
the EXIT entry in named common block /XCEITB/. If the job is to be terminated, routine PEXIT 
is called; if not. the loop count in the EXIT entry is incremented, and a return is made to the 
calling program. 

See description of the Executive DMAP instruction REPT (section 4.11) for further details. 



4.14-2 



EXECUTIVE DMAP MODULE SAVE (SAVE VARIABLE PARAMETER VALUES) 
4.15 EXECUTIVE DMAP MODULE SAVE (SAVE VARIABLE PARAMETER VALUES) 

4.15.1 Entry Point : XSAVE 

4.15.2 Purpose 

To specify which variable parameter values are to be saved from the preceding functional 
module for use by subsequent modules. 

4.15.3 DMAP Calling Sequence 
SAVE VI, V2 VN $ 

where V1.V2,...,VN (Nil) are the BCD names of some or all of the variable parameters which 
appear in the immediately preceding functional module DMAP instruction. A SAVE DMAP instruction 
must immediately follow the functional module instruction wherein the parameters being saved 
are generated. 

4.15.4 Method 

The specified parameter values are transferred from blank common to the VPS Executive 
Table located in named common block /XVPS/. See description of the 0SCAR in section 2.4.2.1 
for the format of a SAVE 0SCAR entry. 

4.15.5 Subroutine 

The XSAVE module has no auxiliary subroutines 

4.15.6 Design Requirements 

SAVE must access blank common and named common blocks /XVPS/ and /0SCENT/. 



4.15-1 



EXECUTIVE DMAP MODULE PURGE (EXPLICIT DATA BLOCK PURGE) 

4.16 EXECUTIVE DMAP MODULE PURGE (EXPLICIT DATA BLOCK PURGE) 

4.16.1 Entry Point : XPURGE 

4.16.2 Purpose 

To flag a data block so that it will not be allocated to a physical file and so that 
modules attempting to access it will be signaled. 

4.16.3 DMAP Calling Sequence 

PURGE DBN1A,DBN2A,D3N3A/PARMA/DBN1B.DBN2B/PARMB $ 

Note : The number of data block names (DBNia) prior to each parameter (PARMa) and the 
number of sets of data block names and parameters in a particular calling 
sequence is variable. 

4.16.4 Input Data Blocks 

DBNIA, DBN2A, etc. - Any data block names appearing within the DMAP sequence. 

4.16.5 Output Data Blocks 

(None specified or permitted) 

4.16.6 Parameters 

PARMA, etc. - One required for each data block name or set of names. 

4.16.7 Method 
4.16.7.1 Summary 

The data blocks (within the DMAP calling sequence) are purged if the value of the asso- 
ciated parameter is < 0. If the data blocks are already purged and the parameter value is > 0, 
the purged data blocks are unpurged so that they may be subsequently reallocated. If the data 
blocks are not purged and if the parameter value is > 0, no action is taken. 



4.16.1 



ion 



MODULE FUNCTIONAL DESCRIPTIONS 

4.16.7.2 Functional Flow 

PURGE operates by modifying entries within the FIAT (File Allocation Table) and DPL 
(Data Pool Dictionary). The FIAT contains an upper section (unique part) and a lower sectic 
(tail part). Both parts contain entries structured as described in the Executive Table 
description for the FIAT, section 2.4.1.2. The length of the unique part is defined by the unique 
files available count in the FIAT header. The tail part is defined as the remainder of the 
FIAT. The unique part contains one entry for each unique (separate) file available for allo- 
cation, and the file ID's within these entries are not modified through a NASTRAN run. The 
tail part contains entries for stacked files (see description for Executive ModuleXSFA, section 4.9) 
purged files, and members of equivalenced sets. An entry within the FIAT is purged by flagging 
(setting all bits on) its file ID. Therefore, if a data block within the unique part is to 
be purged, its name is moved to the tail. A data block entry within DPL is purged by removing 
its entry from the DPL. A data block which is already purged is unpurged by removing the flagged 
entry from the FIAT so that it may be subsequently allocated to a physical file. Figure 1 
illustrates the logic flow. 

4.16.8 Design Requirements 

1. No open core is required by this module. 

2. The 0SCAR record containing the DMAP purge request must reside in the labeled 
common block /0SCENT/. 

3. The validity of all data block names and controlling parameters is checked during 
NASTRAN initialization by module XGPI. 

4.16.9 Diagnostic Messages 

PURGE may produce the following System Fatal messages: 

1201, FIAT 0VERFL0W 

1202, DPL 0VERFL0W 

Both of these messages indicate that the assembled size of the particular table has 
been exceeded. Although it is unlikely that either message will occur, a study of the 
erroneous problem's operation along with diagnostic prints of the FIAT and DPL, obtained 
via the DIAG Executive Control card (see User's Manual, section 2), should indicate some 

4.16-2 



EXECUTIVE DMAP MODULE PURGE (EXPLICIT DATA BLOCK PURGE) 

corrective action. Possible corrective actions include: increasing the basic table size 
through re-assembly; providing more physical files to the NASTRAN system; and altering the 
DMAP operations. 



4.16-3 



MODULE FUNCTIONAL DESCRIPTIONS 



PURGE 



c 



ENTER 



I 



3 



Pick-up data block 

name from purge 

entry in 0SCAR 



Search total 

FIAT for data 

block name 



Set purge 
flag on 




Clear data block 

name from unique 

part of FIAT 



Unique 



Yes 





Create a 

purged entry 

for the data 

block in the 

FIAT tail 




Unpurge 
(Remove data block 
name from FIAT) 



Remove data block 
name from the DPL 




Are there^ 

more data 

^block names in the purge^ 

entry in 

0SCAR 



<: 



Go back 
to ENTER 



) 



No 



RETURN 



1 



Figure 1. Flowchart for module PURGE. 



4.16-4 



EXECUTIVE DMAP MODULE EQUIV (DATA BLOCK NAME EQUIVALENCE) 

4.17 EXECUTIVE DMAP MODULE EQUIV (DATA BLOCK NAME EQUIVALENCE) 

4.17.1 Entry Point : XEQUIV 

4.17.2 Purpose 

To attach one or more equivalent (alias) data block names to an existing data block so that 
module accesses to data by equivalenced names will be identical. 

4.17.3 DMAP Calling Sequence 

EQUIV DBN1A,DBN2A,DBN3A/PARMA/DBN1B,DBN2B/PARMB $ 

Note : The number of data block names (DBNia) prior to each parameter (PARMa) and the 
number of sets of data block names and parameters in a particular calling sequence are 
variable. 

4.17.4 Input Data Blocks 

DBNIA, DBN2A, etc. - Any data block names appearing within the DMAP sequence. The 1st 
data block name in each series (DBNIA and DBNIB) is primary and the 2nd, etc. data block 
names become equivalent to the primary. 

4.17.5 Output Data Blocks 

(None specified or permitted) 

4.17.6 Parameters 

PARMA, etc. - One required for each set of data block names. 

4.17.7 Method 

4.17.7.1 Summary 

The data block names are made equivalent if the value of the associated parameter is < 0. 
If a set of data blocks is already equivalenced and the parameter value is ^ 0, the equivalence 
is broken and the data block names again become unique. If the data blocks are not equivalenced 
and if the parameter value is > 0, no action is taken. 



4.17-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.17.7.2 Functional Flow 

EQUIV operates by modifying entries within the FIAT (File Allocation Table) and DPL (Data 
Pool Dictionary). The FIAT contains an upper section (unique part) and a lower section (tail 
part). Both parts contain entries structured as described in the Executive Table descriotlon 
for the FIAT, section 2.4. The length of the unique part is defined by the unique files 
available count in the FIAT header. The tail part is defined as the remainder of the FIAT. 
The unique part contains one entry for each unique (separate) file available for allocation 
and the file ID'S within these entries are not modified through a NASTRAN run. The tail part 
contains entries for stacked files (see description for Executive Table XSFA). purged files and 
members of equlvalenced sets. Entries within the FIAT and DPL are made equivalent by setting 
their EQUIV flags (sign bit within an entry) and making their file ID's identical. Since a data 
block within the unique part of the FIAT must have a unique file ID. only one member of an equiva- 
lence set may reside within the unique section, all others will be placed In the FIAT tall. Thus, 
if two cata blocks occupying unique physical files are equlvalenced. one will be moved to the 
FIAT tail. Data blocks previously equlvalenced are un equlvalenced (broken) by removing the 
EQUIV flags and the secondary entries. When two or more data blocks are equlvalenced, the first 
data block of the set is considered the primary data block. All others are considered secondary. 
The file containing the primary data block Is logically attached to all data blocks in the set: 
primary and secondary. Data on files attached to secondary data blocks prior to equivalenclno 
is lost upon equivalence. If the primary data block is purged, the secondary(s) will be nurged. 
Figure 1 illustrates the logic flow. 

4.17.8 Design Requirements 

1. No open core is required by the module. 

2. The S3SCAR record containing the DMAP EQUIV request must reside in the labeled 
common block /(3SCENT/ . 

3. The validity of all data block names and controlling parameters is checked during 
NASTRAN initialization by XGPI. 

4. XEQUIV is an entry point in XPURGE. 



4.17-2 



EXECUTIVE DMAP MODULE EQUIV (DATA BLOCK NAME EQUIVALENCE) 

4.17.9 Diagnostic Messages 

EQUIV may produce the following System Fatal Messaoes: 

1201 FIAT 0VERFLQIW 

1202 DPL eiVERFL0W 

Both of these messages indicate that the assembled size of the particular table has been 
exceeded. Although it is unlikely that either message will occur, a study of the erroneous 
problem's operation along with diagnostic prints of the FIAT and DPL obtained, via the DIAG 
Executive Control card (see User's Manual, section 2), should indicate some corrective action. 
Possible corrective actions include: increasing the basic table size through re-assembly; 
providing more physical files to the NASTRAN system; and altering the DMAP operations. 



4.17-3 



MODULE FUNCTIONAL DESCRIPTIONS 



ENTER 



EQUIV 



Pick-Up Data Block 
Name from EQUIV 
Entry in (3SCAR 



Search Total FIAT 
for Data Block Name 




RETURN 



Figure 1. (a) Flowchart for EQUIV module 
4.17-4 



,•// 



EXECUTIVE DMAP MODULE EQUIV (DATA BLOCK NAME EQUIVALENCE) 




Set Primary Data 

Block EQUIV Flag 

in FIAT 




Set Primary Data 

Block EQUIV Flag 

in DPL 




Unequivalence 

(Clear Secondary 

Data Block from 

FIAT) 




Clear Stacked 

Data Block Names 

from FIAT 




Yes 



Clear Data Block 
from DPL 




lA 




lA 



Figure 1. (b) Flowchart for EQUIV module 



4.17-5 



MODULE FUNCTIONAL DESCRIPTIONS 





3B 



Tail 



Equivalence 

Secondary Data 

Block to Primary 



Unique 



Clear Data Block 

Name from Unique 

Part of FIAT 



Add Secondary 

Data Block Entry 

in FIAT Tail 




Clear Secondary 

Data Block Name 

from DPL 




lA 



Figure 1. (c) Flowchart for EQUIV module 



4.17-6 



EXECUTIVE DMAP INSTRUCTION END (END OF DMAP PROGRAM) 

4.18 EXECUTIVE DMAP INSTRUCTION END (END OF DMAP PROGRAM) 

4.18.1 Entry Point : XCEI 

The XCEI module executes the DMAP control instructions: REPT, EXIT, C0ND, and JUMP. 

4.18.2 Purpose 

To denote the end of a DMAP program. This DMAP instruction performs a function 
similar to an END statement in a F0RTRAN compilation, i.e., to signal the end of the 
source program. 

4.18.3 DMAP Calling Sequence 

END $ 

Note : An END DMAP instruction is operationally equivalent to an EXIT $ or EXIT $ 
DMAP instruction. 

4.18.4 Method 

The END instruction is translated during a DMAP program compilation in module XGPI 
into an EXIT $ Instruction, (see section 4.14). 



4.18-1 



EXECUTIVE DMAP MODULE PARAM (PARAMETER PROCESSOR) 



4.19 EXECUTIVE DMAP MODULE PARAM (PARAMETER PROCESSOR) 



4.19.1 Entry Point : QPAFAM 



4.19.2 Purpose 



To perform specified arithmetic and logical operations on DMAP parameters. 



4.19.3 DMAP Calling Sequence 



PARAM //C.N,0P/V,M,0UT/V.N,irn/V,N,IN2 $ 



where the following operations (0P) are available: 



0P 


0UT 


INI 


IN2 


AND 


-1 


< 


< 




+1 


< 


> 




+1 


^ 


< 




+1 


2. 


2. 


0R 


-1 


< 


< 




-1 


< 


>. 




-1 


> 


< 




+ 1 


2 


> 


ADD 


IN1+IN2 






SUB 


IN1-IN2 






MPY 


IN1*IN2 






DIV 


IN1/IN2 






N0T 


-INI 




* 


IMPL 


-1 


< 


< 




+ 1 


< 


> 




-1 


> 


> 




-1 


>. 


2 C 


N0P 


^UT 


* 


* 



Integer Arithmetic 



4.19-1 



MODULE FUNCTIONAL DESCRIPTIONS 

Notes : 

1 . *not used. 

2. PARAM does its own SAVE; therefore, a DMAP SAVE Instruction is not needed 
following the module. 

3. PARAM has no input or output data blocks. 

4.19.4 Examples 

1. PARAM //C,N,N0P/V,N,P1=5 $ - this example sets the value of parameter PI to 5 
and saves it in the VPS. 

2. PARAM //C,N,N0T/V,N,XYZ/V,N,N0XYZ $ - this example changes the sense of 
parameter N0XYZ which may be useful for the C0ND or EQUIV instructions. Alternatively, 
XYZ could have been set in the following way: 

PARAM //C,N,MPY/V.N,XYZ/V,N,N0XYZ/C,N,-1 $ 

4.19.5 Method 

QPARAM performs the indicated parameter operation and stores the result in the VPS 
(/XVPS/). 

4.19.6 Diagnostic Messages 

0PERATI0N C0DE N0T DEFINED F0R M0DULE PARAM. EXECUTI0N TERMINATED. 

The listed operation code was not recognized by PARAM. 



4.19-2 



EXECUTIVE DMAP MODULE SETVAL (SET VALUES) 

4.20 EXECUTIVE DMAP MODULE SETVAL (SET VALUES) 
4.20.1 Entry Point : SETVAL 
4 . 20 . 2 Purpose 

To set DMAP parameters equal to other DMAP parameters or to constants. 

4 . 20 . 3 DMAP Calling Sequence 

SETVAL //V,N,X1/V,M,Y1/V.N,X2/V.N,Y2/V,N.X3/V,N,Y3/V,N,X4/V,N,Y4/V,N,X5/V,N.Y5 $ 

4.20.4 Input Data Blocks 
None. 

4 . 20 . 5 Output Data Blocks 
None. 

4.20.6 Parameters 

XI, X2, X3, X4, X5 - Output-integers-no default values. 
Y1, Y2, Y3, Y4, Y5 - Input-integers-default values = -1. 

4.20.7 Method 

This module does nothing except set XI = Yl , X2 = Y2, X3 = Y3, X4 = Y4, and X5 = Y5. 
Only two parameters need be specified in the calling sequence (XI and Yl ) . 

4.20.8 Subroutines 

SETVAL has no auxiliary subroutines. 

4.20.9 Design Requirements 

SETVAL should reside in the root segment in all links. 

4.20.10 Diagnostic Messages 
None. 



4.20-1 



FUNCTIONAL MODULE GP1 (GEOMETRY PROCESSOR - PHASE 1) 

4.21 FUNCTIONAL MODULE GPl (GEOMETRY PROCESSOR - PHASE 1) 

4.21.1 Entry Point : GPl. 

4.21.2 Purpose 

GPl performs basic geometry processing for the model. A list of all grid and scalar points 
is assembled and placed in internal order. Coordinate system transformation matrices are computed, 
and all grid points are transformed to the basic coordinate system. 

4.21.3 DMAP Calling Sequence 

GPl GE0M1 ,GEOM2/GPL,EQEXIN,6PDT,CSTM,BGPDT,SIL/V,N,LUSET/V,N,N0CSTM/V,N,K!3GPDT $ 

4.21.4 Input Data Blocks 

GEJ8M1 - Grid point, coordinate system, sequence data. 
GE0M2 - Element connection data. 

4.21.5 Output Data Blocks 

GPL - Grid Point List. 

EQEXIN - Equivalence between external grid or scalar numbers and internal numbers. 

GPDT - Grid Point Definition Table. 

CSTM - Coordinate System Transformation Matrices. 

BGPDT - Basic Grid Point Definition Table. 

SIL - Scalar Index List. 

Note: No output data block may be purged. 

4.21.6 Parameters 

LUSET - Output, integer, no default. Total degrees of freedom in the g displacement set. 

N0CSTM - Output, integer, no default. Number of coordinate systems defined in the Bulk Data 
Deck, -1 if no coordinate systems defined. 

N0GPDT - Output, integer, no default. -1 if no grid or scalar ooints defined in Bulk Data 
Deck, +1 otherwise. 



4.21-1 



MODULE FUNCTIONAL DESCRIPTIONS 



4.21.7 Method 



4.21.7.1 Construction of the GPL and First Logical Record of the EQEXIN. 

The SP0INT cards and the scalar element cards (CELASi, CDAMPi. CMASSi, i = 1,2,3,4) are 
read from GE0M2, and a list is made of all referenced scalar points. The GRID cards are read from 
GE0M1, and a merged list of all grid and scalar points is constructed and written on SCRl , a 
scratch file. The list is expanded to pairs of numbers. The first number is the identification 
number, ID, the second is the resequenced number which is given on the SEQGP cards or is 1000*ID 
if not given on SEQGP cards. The paired list is sorted by S0RT on the sequence numbers. The 
resulting set of first numbers is written as the first logical record in the GPL (Grid Point List). 
These are the point identification numbers in order of their sequence numbers. The sequenced 
paired list is written as the second logical record of the GPL data block. The second numbers in 
the sequenced paired list are replaced by the indices 1, 2, 3,..., accordinq to oosition. The 
list is sorted again, this time using the first number of each pair (the identification number). 
The resulting paired list is the first logical record of the EQEXIN data block which is used to 
convert external numbers, given by the first number of a pair, to the internal grid point indices, 
given by the second number in the pair. 

4.21.7.2 Formats of GPDT, BGPDT and CSTM. 

The geometry data blocks are the GPDT, the BGPDT and the CSTM. Their formats, although 
described in section 2.3.3, are repeated here since the following terms will be referenced in the 
discussion below on the construction of the CSTM. 

GPDT - There is one entry for each grid or scala' point. The order of the entries 
is by the internal (sequenced) order. Each entry contains: 

1. Internal sequence number. 

2. Locating coordinate system ID. 

3. x,y,z for a rectangular system. 

4. r,e,z for a cylindrical system. 

5. p,Q,4> for a spherical system. 

6. Global coordinate local coordinate system ID. 

7. Permanent single-point constraint coordinate (1 = x, 2 = y, etc.). 



4.21-2 



FUNCTIONAL MODULE GPl (GEOMETRY PROCESSOR - PHASE 1) 

For scalar points, word 2 = -1 and words 3 through 7 are zero. The data is essentially 
a duplicate of the GRID bulk data card except that the identification number is renlaced by 
the internal sequence number. 

BGPDT - Contains one entry for each grid- or scalar point. The contents are: 

1. Local coordinate system ID for global coordinate definition. 

2. x-"] Locations of point 

3. y • > in basic coordinate 

4. z.) system. 

CSTM - The CSTM contains one entry for each local coordinate system. The order is by 
coordinate system identification numbers. Each entry contains 14 words: 

Word Item 

1 N - the coordinate system ID. 

2 Type^j - the coordinate system type (rectangular, cylindrical or 
spherical) . 

3-5 ^'^nN^ " ^'^^ location of the system origin in basic coordinates. 

6-14 l^^nN-' " *^'^ three-by-three matrix defining the orientation of the 

coordinate system principal axes. 

4.21.7.3 Construction of the GPDT. 

The GPDT data block is formed in core sized groups. The grid and scalar data are read one 
entry at a time from SCRl . EQEXIN (in core) is searched to find the internal number, and the grid 
data are stored (if possible) in the internal position allocated in core. If core will not hold 
the GPDT, the data are written on SCR2, and S0RT is called to sort and write the data on the GPDT. 

4.21.7.4 Construction of the CSTM. 

Sixteen words are alloted for each local coordinate system, and five words are ailoted for 
each referenced grid point. The C^RDij data is read from GE0M1 and stored in core. External 
point ID'S on C0RDij cards are replaced with internal numbers. A C0RD1J card references three 
grid points. It may be converted to a CSTM entry if these grid points have their locations 
reduced to basic coordinates. A C0RD2J card references another local coordinate system. It may 



4.21-3 



MODULE FUNCTIONAL DESCRIPTIONS 

be converted to a CSTM entry if that referenced system has been reduced to a CSTM entry. The 
basic logic is to make repeated passes over the coordinate system data, each time reducinq one or 
more coordinate systems and, when possible, converting referenced grid points to basic system 
location. 

A C0RD1J card image references three grid points - a, b and c. If the locations of these 
points in basic coordinates are the vectors {R^}, {R^}, {R^}, the solution for coordinate system 
N is 



{R0N> = ^Ra> . 



(1) 



{V,} = {R,} - {R^}. 



(2) 



(V,} 



{R^} - {R^} , 



(3) 



{k} 



^V 



u\j } [ (unit "z" vector), 



(4) 



U) 



{k} X {V^} 



(unit "y" vector). 



|{k} X {V^}| 
{i} = {j} X (k) (unit "x" vector). 



(5) 
(6) 



Point a is the origin, point b lies on the z (or polar) axis, point c lies in the x-z plane 
(e = or (fi = 0). The three- by- three matrix [Tj,.] is defined as: 



[T,] = 



il JT 



Ip Jp '^2 



^3 '^3 "^3 



(7) 



N, type^j, {Rqi^} and [T^] form the CSTM entry for the coordinate system. 



4.21-4 



FUNCTIONAL MODULE GP1 (GEOMETRY PROCESSOR - PHASE I] 



A GRID point (j) referenced to coordinate system (N) may be reduced to basic coordinates 
(X , Y , Z ) by the equations: 



1. If type,^ = Rectangular (R), X., Y. and Z. are given by 



oj |Xj 

W = ^"^hmJ + [TJ i\^\ . (8) 

fz. 



o( "ON ^'N-" ) J| 

Z, 



2. If type|y = Cylindrical (C), r, 6 and Z are given by 



Xj = r cos e, (9) 



Yj = r sin 6. (10) 



Zj = z. 01) 



X , Y and Z are calculated as in Equation 8. 

3. If type,^ = Spherical (S), p, 6 and ij> are given by 



-N 

X. = p sin e cos (fi, (12) 

•J 

Y. = p sin e sin (fi, (13) 

Zj = p cos e. (14) 

X , Y and Z are calculated as above. 

When the basic location of a grid point has been calculated, the entry in the list is changed such 
that the reference coordinate system (entry No. 2) is zero and the three values are X , Y , Z . 



4.21-5 



MODULE FUNCTIONAL DESCRIPTIONS 

The C0RD2J card image references another coordinate system and defines three points in the 
referenced system: a, b and c. If system number N is defined by system number M, the solution is 

1. If type^^ = rectangular, the numbers defining the three points are the vectors: 
{a}, {b}, and {c}. 

2. If type^ = cylindrical, the numbers are r, 6 and z. The equations to convert these 
to rectangular vectors are 

iaA [r^ cos 6," 

J k 

^o\ = <>"= sin 9,\ = {a} . (15) 

^3) (^a 

The {b} and {c} vectors are calculated similarly. 

3. If typeu = spherical, the numbers given for the points are p, 9, and ij). We calculate 

^a, "^ I'ap sin 9 cos (}>^ 



Zap sin 



[i^y = <ap sin 9 sin <J>> = {a) (16) 

a, ) [ap cos 9 

and similarly for points b and c. 

4. The definition of the new system is that point a is the origin, point b lies on 
the 2 (or polar) axis and point c lies in the x-z (or 6 = 0) plane. The equations for 
the CSTM data are 

%N> = t^OM> ' C%3 ^^>- (17) 

In system M the vectors defining the axes of system N are 

{V^} = {b} - (a); (18) 

{k} = -mpjr . ("z" unit vector); (19) 



{V.} = {c} - {a}; (20) 



4.21-6 



FUNCTIONAL MODULE GPl (GEOMETRY PROCESSOR - PHASE 1) 



{k} X {V^} 



^JJ = [ { ! <} X {V.y \ ' ^"^" ""^^ vector); 



(21) 



{i} = {j} X {k} . ("X" unit vector), 
The orientation of the axes is defined by the matrix 



(22) 



tTfiN] = [Tqm] 



'ON 



^'l 



^1 



"1 



^3 ^3 "^3 



(23) 



5. On each pass of the C0RDij data at least one new system must be converted. After 
each pass the referenced GRID data is checked and converted. The resulting C0RDij data 
will be the CSTM data block with each entry reduced from 16 to 14 words. 

4.21.7.5 Construction of the BGPDT, the SIL and the Second Logical Record of the EQEXIN. 

The BGPDT and the SIL data blocks are formed simultaneously. The SIL data block is simoly 
a list of the first scalar index for each grid or scalar point. A grid point has six scalar 
indices (or degrees of freedom), and a scalar point has one scalar index. Every degree or freedom 
in the problem has a scalar index, but since the six degrees of freedom for a grid point are con- 
secutive, only the first one is listed. 

The GPDT data are read a point at a time. The basic location coordinates of the point are 
formed using Equation 8 through Equation 14 and these data are written on the BGPDT file. The SIL 
value for the next point is calculated by incrementing the last value by six (grid point) or by 
one (scalar point). 

Finally the second logical record of EQEXIN is written. This record contains pairs of ex- 
ternal numbers, 10*scalar index + type where type = 1 for a grid point, 2 for a scalar point. 

4.21.8 Subroutines 

GPl has no auxiliary subroutines. 



4.21-7 



MODULE FUNCTIONAL DESCRIPTIONS 



4.21.9 Design Requirements 
4.21.9.1 Allocation of Core Storage 

During the assembly of the GPL, space for 2*(number of grid points dIus number of scalar 

points) plus two GIN0 buffers is required. During the assembly of the CSTM, core storage is 

allocated as follows: 

C0MM0N/GPA1/Z(1) 
1 ' 



ICSDT 



ILIST 



BUFl 



External point number 



Internal number 



Coordinate system ID 



1 = rectangular 
Coordinate system type -J2 = cylindrical 

spherical 



lli 



Coordinate system defini 



tion Ig 



= CjJRDlj 
= CS3RD2J 



Reference coordinate system ID 



Two words per entry 
one entry per grid or 
scalar point 



or 



Internal grid number 



Defining coordinate system ID 



Sixteen words per entry 
one entry per coordinate 
system 







GIN0 buffer 



Five words per entry 
one entry for each grid 
point referenced on a 
C0RDl,i card. 



4.21-8 



FUNCTIONAL MODULE GPl (GEOMETRY PROCESSOR - PHASE 1) 

Total storage requirements during this phase, therefore, equals 2*(number of grid + number 
of scalar points) + 16*(number of coordinate systems) + 5*(number of grid points referenced on 
C0RD1J cards) + one GIN0 buffer. 

4.21.9.2 Environment 

Open core for GPl is defined by /GPAl/. The table /GPTAl/ must be in core when GPl is 
executed. GPl uses two scratch files. 

4.21.10 Diagnostic Messages 

The following diagnostic messages may be issued by GPl: 
2001, 2002, 2003, 2004, 2005, 2006, 2012 



4.21-9 



FUNCTIONAL MODULE GP2 (GEOMETRY PROCESSOR - PHASE 2) 

4.22 FUNCTIONAL MODULE GP2 (GEOMETRY PROCESSOR - PHASE 2) 

4.22.1 Entry Point : GP2 

4.22.2 Purpose 

GP2 processes element connection data and converts external point numbers to internal 
numbers . 

4.22.3 DMAP Calling Sequence 
GP2 GE(i)M2,EQEXIN/ECT $ 

4.22.4 Input Data Blocks 

GEI8M2 - Element connection data. 

EQEXIN - Equivalence between external grid or scalar numbers and Internal numbers. 

Note : EQEXIN may not be purged. 

4.22.5 Output Data Blocks 

ECT - Element Connection Table. 
Note : ECT may not be purged. 

4.22.6 Parameters 
None 

4.22.7 Method 

The first data record of EQEXIN (containing pairs of external point identification and 
internal index) is read into core. GE{)M2 is opened, and the header record is skipped. The ECT 
is opened, and the header record is written. The following process is repeated for each logical 
record in GE0M2. 

1. The 3-word header is read. If an end-of-file is encountered, sten (4) is executed. Other- 
wise, /GPTAl/ (see description in section 2.5) is searched for a match. If found, step (2) 
is executed. If not found, an internal table, CARDS, which defines additional cards processed 



4.22-1 



MODULE FUNCTIONAL DESCRIPTIONS 

by GP2 (e.g. GENEL) is searched. If a match is found, step (3) is executed. Otherwise, 
the record is skipped, and step (1) is repeated. 

2. The 3-word header from GE0M2 is written on the ECT. Parameters defining the element are 
fetched from /GPTAl/. If the number of words per element is less than 5, the sort flag in 
the GE0M2 trainer is fetched. Each element card of the current type on GE0M2 is read. 

Each external grid identification is converted to an internal index by performing a binary 
search in the EQEXIN table. If the point is not in the table, an error message is queued 
and the N0G0 flag is turned on. If the data is not to be sorted, the element is written 
directly on the ECT. Otherwise it is saved in core (or written on a scratch file if core is 
full). When all elements of a given type have been processed, the sort flag is again tested. 
If off, the ECT record is closed and return to step (1) is made. Otherwise, the data are 
sorted by S0RT and the ECT record is then written. 

3. For GENEL, SEQBFE and QDSEP data (the latter two are Force Method only), each entry is 
read, all external point identifications are converted to internal indices as in (2) and the 
entry is written on the ECT. When the logical record on GE0M2 is exhausted, the ECT record 
is closed and return to step (1) is made. 

4. The ECT trailer is written, and all files are closed. If the N0G0 flag was turned on, 
PEXIT is called. Otherwise, a normal exit is made. 

4.22.8 Subroutines 



The module GP2 consists of one subroutine, GP2. 
4.22.9 Design Requirements 

4.22.9.1 Allocation of Core Storage 

GP2 requires space for 2*(number of grid points + number of scalar points) + three GIN0 
buffers. 

4.22.9.2 Environment 

Open core is defined by /GPA2/. The table /GPTAl/ must be in core when GP2 is executed. 
GP2 uses up to four scratch files. 



4.22-2 



FUNCTIONAL MODULE GP2 (GEOMETRY PROCESSOR - PHASE 2) 

4.22.10 Diagnostic Messages 

The following diagnostic messages may be issued by GP2: 
2007, 2059, 2060, 2061 



4.22-3 



FUNCTIONAL MODULE PLTSET (PLOT SET DEFINITION PROCESSOR) 

4.23 FUNCTIONAL MODULE PLTSET (PLOT SET DEFINITION PROCESSOR) 

4.23.1 Entry Point : DPLTST 

4.23.2 Purpose 

To generate the structural element sets to be used by the structural plotter 
(functional module PL0T). 

4.23.3 DMAP Calling Sequence 

PLTSET PCDB,EQEXIN,ECT/PLTSETX,PLTPAR.GPSETS,ELSETS/V,N,NGP/V.N.NPSET $ 

4.23.4 Input Data Blocks 

PCDB - Plot Control Data Block for the structure plotter. 

EQEXIN - Equivalence between external grid or scalar numbers and internal numbers. 

ECT - Element Connection Table. 

Note : If PCDB is purged, nothing is done in this module. However, if PCDB is not purged, 
neither EQEXIN nor ECT may be purged. 

4.23.5 Output Data Blocks 

PLTSETX - User error messages related to the definition of element plot sets for the 
structure plotter. 

PLTPAR - Plot parameters and plot control table. 

GPSETS - Grid point sets related to the element plot sets. 

ELSETS - Element plot set connection tables. 

Note: None of these data blocks may be pre-purged unless PCDB is also purged. 

4.23.6 Parameters 

NGP - Output-integer-no default. Total number of grid points. 

NPSET - Output-integer-default value = -1. Number of element plot sets (set to -1 if 
none) . 



4.23-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.23.7 Method 

Each logical card in the plot control data block (PCDB) is read. If the first entry on a 
card is not "SET", the card is assumed to be a plot parameter or control card meaningful only 
to the PL0T module. In this case, the logical card is copied onto the PLTPAR data block. 

If the first entry on a card is "SET", it is assumed to be a definition of a new element 
plot set. As each entry on the card is read, it is decided whether a list of elements (by type, 
range or explicit id's) or a list of grid points (by range or explicit id) is being included or 
excluded. Each element type which is specified is inserted into a table (TYP, 100 words long). 
If a range of elements or an explicit element id is specified, it is inserted into the beginning 
of open core (the EL array). And finally, if a range of grid points or an explicit grid point id 
is specified, it is inserted into the end of open core (the GP array). When a set has been 
completely specified, it is written out onto a scratch file (MSET) in the following format: 

Word 1 = NEL (number of entries in the EL array). 

Word 2 to NEL+1 = the entries in the EL array. 

Word 1 = NTYP (number of entries in the TYP array). 

Word 2 to NTYP+1 = the entries in the TYP array. 

Word 1 = NPT (number of entries in the GP array). 

Word 2 to NPT+1 = the entries in the GP array. 

After all the SET cards have been processed, subroutine CiJMECT is called to set up a 
shortened element connection table (ECTX). For each element type, the table is as follows: 

Word 1 = two character BCD element type symbol (left justified) 

Word 2 = number of grid points per element. 

for each element ^ Word 3 = element id. 

of this type ( Word 4, = internal grid point numbers of the grid points connected 

etc. 

by this element 



4.23-2 (12-1-69) 



49f 



FUNCTIONAL MODULE PLTSET (PLOT SET DEFINITION PROCESSOR) 

This table, in conjunction with MSET, is used by subroutine CNSTRC to create the 
GPSETS and ELSETS data blocks. The ELSETS data block is simply a duplicate of ECTX for each 
plot set, except that only those elements which are in the set are included. The GPSETS 
data block for each plot set is simply a list of indices into the subset of grid points which 
pertain to this set. 

4.23.8 Subroutines 

Utility routines CLSTAB, FREAD, G0PEN, INTGPX, INT6PT, INTLST, RDMi3DX. RDMJIDE and RDW0RD are 
used by PLTSET. See section 3.4 for their descriptions. 

4.23.8.1 Subroutine Name: SETINP 

1. Entry Point: SETINP 

2. Purpose: To create the plot parameter and control data block (PLTPAR) and interpret 
the plot set definition cards from the Plot Control Data Block (PCDB). 

3. Calling Sequence: CALL SETINP 

C0MM0N/EDES/NTYPES,ENAM{2,5O) - see EDESBD Block Data description below (section 4.23.9.2). 

4.23.8.2 Subroutine Name: C0MECT 

1. Entry Point: CjSMECT 

2. Purpose: To create a shortened form of the Element Connection Table (ECT). 

3. Calling Sequence: CALL C0MECT 
C(3MM0N/EDES/NTYPES,ENAM(2,5O),EC0D(2,5O).EWRD(5O),ENGP(5O) - see EDESBD Block Data description. 

4.23.8.3 Subroutine Name: CNSTRC 

1. Entry Point: CNSTRC 

2. Purpose: To construct the element and grid point plot set data blocks (ELSETS, GPSETS). 

3. Calling Sequence: CALL CNSTRC (GP.ELE.BUF.HAX) 
C0MM0N/EDES/NTYPES - see EDESBD Block Data description, section 4.23.9.2. 



4.23-3 



MODULE FUNCTIONAL DESCRIPTIONS 



Where: 



GP 

ELE 
BUF 
MAX 



NGP locations used to set up the grid point index list for the grid 
point set data block (GPSETS), 

MAX locations used to set up the element set data block (ELSETS). 

Location of 3 GIN0 buffers. 

Amount of core available for the ELE array (open core). 



4.23.9 Design Requirements 

4,23.9.1 Open Core Design (Common Block XXPSET) 



1. Subroutine SETINP 



C(3MM0N/XXPSET/ 



EL(i; 



i 



EL(NEL) 
GP(NPT) 



I 



GP(1) 
XC(1) 



Element id's and ranges 



Grid point id's and ranges 



5 GIN0 buffers 



2. Subroutine CNSTRC 

For this subroutine, open core is partitioned by the calling program as follows: 



GP(1) 

i 

GP(NG) 
ELE(l) 



i 



ELE(MAX) 
BUF(1) 



Grid point index table 



Plot set element id's 



3 GIN!3 buffers 



4.23-4 



FUNCTIONAL MODULE PLTSET (PLOT SET DEFINITION PROCESSOR) 
4.23.9.2 Block Data Interface (EDESBD-Element Description Table) 

C0MM0N /EDES/NTYPES,ENAM(2,5O),EC0D(2,5Q),EWRD(5O),ENGP(5O),ESYM(5O) 
Where: 

NTYPES = number of element types defined in this table. 

ENAM = two word BCD name of the element type. 

EC0D = two word subroutine L0CATE code of the element type for the EC- data block. 

EWRD = number of wordi. per element on the ECT data block. 

ENGP = number of grid point connections per element. 

ESYH = two character BCD element type symbol (left justified) 

Note: The element types defined in this table are the only ones which can be plotted by 
the structural plotter. 

4.23.10 Diagnostic Messages 

A fatal message occurs in SETINP if a set specification is so large that open core is filled 
(i.e., array EL meets array GP). All other diagnostics are non-fatal and are written on the 
PLTSETX data block for printing by the PRTMSG module. These messages are all quite self- 
explanatory and straightforward. 



4.23-5 (12-1-69) 



FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 

4.24 FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 

4.24.1 Entry Point : DPL0T 

4.24.2 Purpose. 

To draw structural shapes on a variety of different plotters. 

4.24.3 DMAP Calling Sequence 

PL0T PLTPAR,GPSETS,ELSETS.CASECC,BGPDT,EQEXIN,SIL.PLTDSP1,PLTDSP2/PL0TX/V,N,NGP/ 
V,N,LSIL/V,N,NPSET/V,N,PLTFLG/V,N,PLTNUM $ 

4.24.4 Input Data Blocks 

PLTPAR - Plot parameters and plot control table. 

GPSE'^S - Grid point sets related to the element plot sets. 

ELSETS - Element plot set connection tables. 

CASECC - Case Control Data Table. 

BGPDT - Basic Grid Point Definition Table. 

EQEXIN - Equivalence between external grid or scalar numbers and internal numbers. 

SIL - Scalar Index List. 

PLTDSPl - Translational displacements (statics). 

PLTDSP2 - Translational displacements (dynamics). 

Notes : 

1. Only SIL, PLTDSPl, and PLTDSP2 may be purged. If this is the case, only undeformed 
shapes may be drawn. 

2. If either PLTSDPl or PLTDSP2 is purged, that type of deformed shape will not be 
drawn. 

3. If either PLTDSPl or PLTDSP2 is not purged, SIL may not be purged. 
4.24.5 Output Data Blocks 

PL0TX - User messages. 

ilote: PL0TX may not be purged. 



4.24-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.24.6 Parameters 

NGP - Integer-input-no default value. Number of grid points. 
LSIL - Integer-input-no default value. Last scalar index value. 
NPSET - Integer-input-no default value. Number of element plot sets. 
PLTFLG - Integer-input/output-default value = 1. Displacement plot flag. 

= 1 if undeformed shapes have not yet been drawn. 

= -1 if undeformed shapes have been drawn. 
PLTNUM - Integer-input/output-default value = 0. Plot number. 

4.24.7 Method 

Subroutine PARAM reads each card in the plot parameter and control table (PLTPAR). If 
the first entry on a card is not 'FIND' or 'PL0T'. it is assumed to be a plot parameter 
card to be processed within PARAM (e.g.. PR0JECTI0N. PLOTTER, etc.). Within PARAM, an implied 
'FIND' card is initially set up to automatically find an origin, vantage point, and scale. In 
addition this same implied "FIND" card is set up each time a new projection is defined as a 
'PL0TTER' card is encountered. At the same time, the view angles are re-initialized to their 
default values, the regions pertaining to each origin are reset to full pictures, and all pre- 
viously defined origins are nullified. 

When a 'FIND' card is encountered, subroutine FIND is called both to interpret the card 
and act upon its requests. And finally, when a 'PL0T' card is encountered, subroutine PL0T 
is called both to interpret the card and to act upon its requests. However, in this case. If 
the implied 'FIND' card set up by subroutine PARAM still exists (i.e., if no origin, scale, 
or vantage point has been defined) the FIND subroutine is called to satisfy these needs before 
subroutine PL0T is called. 

In subroutine FIND, after the interpretation of the 'FIND' card is completed, a coordinate 
system rotation matrix is calculated relative to the current view angles, and then the vantage 
point, scale factors, and the origin requested are calculated as needed. 

In subroutine PL0T, after the interpretation of the 'PL0T' card is completed, a list of 
messages to the plotter operator is generated. Then all plots requested on the plot card are 
generated by calling subroutine DRAW for each plot request. 



4,24-2 



FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 

Subroutine DRAW generates one plot. It sets up the region of the plot, rotates the grid 
points based upon the current viewing angles, applies the latest scale factor to the structural 
coordinates, and translates these coordinates to the origin specified for this plot. It also 
controls the various aspects of a plot as specified on the 'PL0T' card, e.g., drawing a shape, 
labeling grid points, etc., for both undeformed and deformed structures (superimposition if 
called for). 



4.24-3 (12-1-69) '^ 



MODULE FUNCTIOHAL DESCRIPTIONS 

4.24.8 Subroutines 

The following utility routines are called by PL0T: CLSTAB,FREAD.G0PEN,(INTGPX,INTGPT) , 
INTLST,(RDM0DX,RDM0DY,RDM0DE,RDW0RD). See the subroutine descriptions in section 3. The 
subroutines FNDSET, MINtlAX, PERPEC and PROCES are support subroutines used by more than 
one of the following subroutines. 

4.24.8.1 Subroutine Name: PARAM 

1. Entry Point: PARAM 

2. Purpose: To interpret the plot parameter cards and to detect the 'FIND' and 'PL0T' 
plot control cards. In addition, it serves as a driver for subroutine FIND and PL0T. 

3. Calling Sequence: CALL PARAM (SETID.X) 

C0MM0N/XXPARM/ - See XXPARM table description below (section 4.24.9.2). 
C0MM0N/PLTDAT/ - See PLTDAT miscellaneous table description (section 2.5). 
Where: 

SETID = Various plot set id's created in the PLTSET module. (Record 1 of GPSETS). 

X = Open core. 

4. Method: All plot parameters are inserted in the XXPARM table. Any parameter which 
is not recognizable causes a message to be created to this effect, and the parameter 

is then ignored. 

5. Additional Subroutines Required: FIND,PL0T 

4.24.8.2 Subroutine Name: FIND 

1. Entry Point: FIND 

2. Purpose: To interpret a 'FIND' card and to calculate the parameters requested on 
the card. 

3. Calling Sequence: CALL FIND (M0DE, SETID.X) 

C0MM0N/ XXPARM/ - See XXPARM table description below (section 4.24.9.2). 
C0MM0N/PLTDAT/ - See PLTDAT miscellaneous table description (section 2.5). 
Where: 

M0DE = Current value of the XRCARD mode value as read and modified by subroutine 



4.24-4 



FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 

RDM0DX. 
SETID = Various plot set id's created in the PLTSET module (record 1 of GPSETS). 
X = Open core. 

4, Method: After interpreting the 'FIND' card, the coordinate system rotation matrix 
is calculated (based upon the current view angles), the vantage point, scale factor, and 
desired origin are calculated. 

5. Additional Subroutines Required: FNDSET.MINMAX,PR0CES,PERPEC. 
4.24.8.3 Subroutine Name: PL0T 

1. Entry Point: PL0T 

2. Purpose: To interpret the 'PL0T' card, and produce all the plots requested on the card 
by acting as a driver to subroutine DRAW. 

3. Calling Sequence: CALL PL0T (M0DE, SETID, X) 

C0MM0N/XXPARM/ - See XXPARM table description below (section 4.24.9.2). 
C0MM0N/PLTDAT/ - See PLTDAT miscellaneous table description (section 2.5). 
Where: 

M0DE = Current value of the XRCARD mode value as read and modified by subroutine 
RDM0DX. 

SETID = Various plot set id's created in the PLTSET module (record 1 of GPSETS). 

X » Open core. 

4. Method: After interpreting the deformed structure plot requests (there may be many 
on one 'PL0T' card), the rest of the 'PL0T' card is read into memory. For each deformed 
structure request, the appropriate displacement data block (PLTDSPl or PLTDSP2) is 
searched for a matching subcase id. If one is found, (this search does not occur if only 
the undeformed requests are being serviced), then the rest of the plot card is interpreted 
for the various plotting options. Subroutine DRAW is then called to service these 
options and to draw the corresponding picture for each plot element set listed on the 
'PL0T' card. 

5. Additional Subroutines Required: HEAD, FNDSET,GETDEF, DRAW. 



4.24-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.24.8.4 Subroutine Name: GETDEF 

1. Entry Point: GETDEF 

2. Purpose: To read the translational components of a set of displacements (in the basic 
coordinate system). 

3. Calling Sequence: CALL GETDEF (DFRM.GPT.D) 

CjIMMUN/XXPARM/ - See XXPARM table description below (section 4.24.9.2). 

where: 

DFRM = Displacement data block to be read (pre-positioned at the set of displacements 

to be read). 
GPT = List of grid point indices defining a subset of grid points. 
D = Array into which the displacement components are to be read (3 per grid 
point - X.Y.Z). 

4. Method: The scalar index list (STL data block) is used to determine at which grid 
point a particular displacement component is specified. While reading the components, 
a maximum absolute component (HAXDEF) is determined. 

4.24.8.5 Subroutine Name: PLTiSPR 

1. Entry Point: PLT0PR 

2. Purpose: To generate printed output to be used by the plotter operator in setting 
up the plotting equipment, and to generate output informing the user of the plotting 
parameters used to generate the plots. 

3. Calling Sequence: CALL PLT0PR 

CiaMMUN/PLTDAT/ - See PLTDAT miscellaneous table description (section 2.5). 
C0MM0N/XXPARM/ - See XXPARM table description below (section 4.24.9.2). 

4. Method: All output is written on the PL0TX data block for subsequent processing by 
the PRTMSG module. The resulting output can be used by the user to alter certain 

plot parameters on a subsequent run, if he desires, in order to slightly alter the plots 
produced. 



4.24-6 



FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 

4.24.8.6 Subroutine Name: DRAW 

1. : Entry Point: DRAW 

2. Purpose: To service the many possible plotting options and generate the corresponding 
picture. 

3. Calling Sequence: CALL DRAW (GPLST,X,U,S,DEF0RM,STERE0) 

C0MM0N/PLTDAT/ - See PLTDAT miscellaneous table description (section 2.5). 
C0MM0N/XXPARM/ - See XXPARM table description below (section 4.24.9.2). 
C0MM0N/RSTXXX/ - See RSTXXX table description below (section 4.24.9.2). 
C0MM0N/DRWDAT/ - See DRWDAT table description below (section 4.24.9.2). 
where: 

GPLST = List of indices (one for each structural grid point) into the subset of grid 
points which pertain to the element set appropriate to this plot. 

X = Coordinates of the grid points in this element set (3 per grid point - r,s,t). 

U = Deformation components for each grid point in this element set (3 per grid 
point - x.y.z). 

S = Location into which the s and t deformed structure grid point coordinates are 
to be placed. 

, ... an undeformed structure plot is requested. 
DEF0RM ' 



i= if 
U 1 if 



a deformed structure plot is requested. 

if the left image of a stereo plot is to be generated. 
STEREfJ { 

1 if the right image of a stereo plot is to be generated. 

4. Method: Initially, the grid points are rotated based upon the current viewing angles, 
translated to the selected plot origin, and converted to plotter units using the current 
scale factor, and the deformation components are reduced to the specified maximum deformation 
value. Then the undeformed structural plot is generated. 

Next, the deformed structural shape (if requested) is drawn. Then the deformation vectors 
(as requested) are drawn. 



4.24-7 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

5. Additional Subroutines Required: MINMAX.PR0CES.PERPEC.INTVEC.SHAPE.GPTSYM,GPTLBL.DVECTR. 

ELELBL 
4.24.8.7 Subroutine Name: INTVEC 

1. Entry Point: INTVEC 

2. Purpose: To interpret the user supplied deformation vector plot request. 

3. Calling Sequence: CALL INTVEC (VECT0R) 

where: 

VECT0R = BCD characters specified in the deformation vector request (any 

combination of the characters R, X, Y, Z). Input and Output. On input, 
VECT0R is integer (=0) or BCD. On output, VECT0R is integer (=0. if = 
upon input) . 

4. Method: The result is stored into VECT0R, as follows: 



X = 2 
Y = 2 

2 

Z = 2 

R = 2 (if VECT0R = 'R' only, it is treated as if 
VECT0R = RXYZ). 
4.24.8,8 Subroutine Name: SHAPE 

1. Entry Point: SHAPE 

2. Purpose: To draw a structural shape. 

3. Calling Sequence: CALL SHAPE (GPLST,X,U,PEN,DEF0RM) 

where: 

GPLST = List of indices into the subset of grid points pertaining to the shape 

to be drawn. 
X = Corresponding grid point coordinates of the undeformed structure (3 per 

grid point - r, s, t) . 
U = Corresponding grid point coordinates of the deformed structure (2 per grid 

point - s, t) . 

4.24-8 (12-1-69) 



FUNCTIOHAL MODULE PL0T (STRUCTURAL PLOTTER) 

PEN = Pen number or line density to be used to draw the shape. 
if the undeformed shape is to be drawn. 



DEF0RMi 

1 if the deformed shape is to be drawn. 

4. Method: The structural shape to be drawn is defined as a compact element connection 
table on the ELSETS data block (assumed open and positioned at the correct element set). 
As each element is read, it is drawn, taking into account whether the element is one or 
two dimensional . 

4.24.8,9 Subroutine Name: GPTSYM 

1. Entry Point: GPTSYH 

2. Purpose: To type a special symbol at each of a subset of grid points. 

3. Calling Sequence: CALL GPTSYM (GPLST,X,U,SYM,DEF0RM) 

Where: 

GPLST = List of indices defining the subset of grid points. 

X = Corresponding grid point coordinates of the undeformed structure (3 per 

grid point - x,s,t). 
U = Corresponding grid point coordinates of the deformed structure (2 per 

grid point - s,t). 
SYM = Two indices to be used to construct the special symbol. 

if the undeformed grid points are to be used. 



DEF0RM 

= 1 if the deformed grid points are to be used. 

4.24.8.10 Subroutine Name: GPTLBL 

1. Entry Point: GPTLBL 

2. Purpose: To type the external grid point id of each of a subset of grid points. 

3. Calling Sequence: CALL GPTLBL (GPLST, X,U,DEF0RM) 

C0MM0N/PLTDAT/ - See the PLTDAT miscellaneous table description (section 2.5). 

Where: 

GPLST » List of indices defining the subset of grid points. 

X = Corresponding grid point coordinates of the undeformed structure (3 per 



4.24-9 



MODULE FUNCTIONAL DESCRIPTIONS 

grid point - r,s,t). 
U = Corresponding grid point coordinates of the deformed structure (2 per 
grid point - s,t) . 

!0 if the undeformed grid points are to be used. 
= 
1 if the deformed grid points are to be used. 

4. Method: The Internal and external id of each structural grid point is read from the 
EQEXIN data block. If the grid point is part of the specified subset, then the external 
id is printed to the immediate right of the grid point. 

4.24.8.11 Subroutine Name: DVECTR 

1. Entry Point: DVECTR 

2. Purpose: To draw deformation vectors. 

3. Calling Sequence: CALL DVECTR (GPT.X.U.PEN) 
Where: 

GPT = List of indices defining the subset of grid points at which vectors are to 

be drav^n. 
X = Corresponding grid point coordinates of the undeformed structure (3 per 

grid point - x,s,t) . 
U = Corresponding grid point coordinates of the deformed structure (2 per 

grid point - s,t) . 
PEN = Pen number or line density to be used to draw the vectors. 

4.24.8.12 Subroutine Name: FNDSET 

1. Entry Point: FNDSET 

2. Purpose: To find the subset of grid points pertaiiiing to a set of elements, and to read 
the corresponding grid point coordinates from the BGPDT data block. 

3. Calling Sequence: CALL FNDSET (SET, GRID, X) 

Where: 

SET = Element plot set index, 

GRID - Array into which the list of indices defining the subset of grid points 



4.24-10 



FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 

is to be read. 

X = Array into which the corresponding coordinates are to be read (3 per grid 
point - x,y,z). 

4. Method: If SET = 0, the grid point set index data block (GPSETS) is assumed positioned 
at the correct record. Otherwise, GPSETS is first positioned correctly (record SET+1). 
The indices are then read into GPID, and the corresponding coordinates are read from 
BGPDT into X. 

4.24.8.13 Subroutine Name: MINMAX 

1. Entry Point: MINMAX 

2. Purpose: To initialize the minimum and maximum grid point coordinates to a very 
large and small number, respectively. 

3. Calling Sequence: CALL MINMAX 

C0MMi)N/RSTXXX/ - See the RSTXXX table description below (section 4.24.9.2). 

4.24.8.14 Subroutine Name: PERPEC 

1. Entry Point: PERPEC 

2. Purpose: To calculate the vantage point and/or translate the grid point coordinates 
to the vantage point. 

3. Calling Sequence: CALL PERPEC (X,STERE0) 

C0MM0N/XXPARM/ - See XXPARM table description (section 4.24.9.2). 
C0MM0M/RSTXXX/ - See the RSTXXX table description (section 4.24.9.2). 
where: 

X = = Set of grid point coordinates to be translated (3 per grid point - r,s,t) 
(0 if the coordinates of the left image for stereo are to be calculated. 



jo if 

n if 



STEREO 

the coordinates of the right image for stereo are to be calculated. 

4, Method: After the vantage point is calculated (if required), each grid point is 
translated. In the process, unless the projection is stereo, the minimum and maximum 
s and t coordinates are calculated. Finally, the differences between these minima and 

4.24-11 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

maxima, and their averages, are calculated. 

4.24.8.15 Subroutine Name: PR0CES 

1. Entry Point: PR0CES 

2. Purpose: To exchange coordinate axes (as requested) and rotate the grid point coordi- 
nates based upon the current view angles. 

3. Calling Sequence: CALL PR0CES (X) 

COMMSIN/XXPARM/ - See the XXPARM table description below (section 4.24.9.2). 

C0MM|aN/RSTXXX/ - See the RSTXXX table description below (section 4.24.9.2). 
where: 

X = Grid point coordinates (3 per grid point - x,y,z). 

4. Method: In addition to its primary purpose, this subroutine calculates the minimum and 
maximum rotated grid point coordinates, and the differences and averages of these minima and 
maxima. 

4.24.8.16 Subroutine Name: ELELBL 

1. Entry Point: ELELBL 

2. Purpose: To type the element identification number of each element in a subset of 
elements. 

3. Calling Sequence: CALL ELELBL (GPLST,X,U,DEF0RM) 

C0MM0N/CHAR94/ - See the CHAR94 miscellaneous table description (section 2.5). 

C0MM0N/PLTDAT/ - See the PLTDAT miscellaneous table description (section 2.5). 

where: 

GPLST = List of indices defining the set of grid points associated with the elements 
to be labeled. 

X = Corresponding grid point coordinates of the undeformed structure. 

U = Corresponding grid point coordinates of the deformed structure. 



4.24-12 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



(0 if the undeformed grid points are to be used 
DEF0RM = < 

(l if the deformed grid points are to be used 



4, Method: The compact element connection table (ELSETS) is read. As each element id is 
read, it is typed at the center of the element. The two character symbolic name of the 
element type is appended to the element id. 



4.24-12a (12-1-69) 



FUNCTIOi-JAL MODULE PL0T (STRUCTURAL PLOTTER) 



4.24.9 Design Reqjiremen ts 



4.24.9.1 Open Core Design (Common Block XXPLj3T) 

Define NPSET = Number of eleiiient plo- sets. 
NGP = Total number of grid po'nts. 
NGPSET = Kumber of grid points in an element. 

1. Subroutine DPL0T partitions open core for subroutine PARAM as foT 

C(3MM0N/XXPL0T/ 
X(0) 



X(NPSET) 



X(BUF) 



Element plot set id's 



Open Core 



3 G:N0 buffers 



2. Subroutine FIND partitions open core for subroutines FNDSET, PERPEC, ard PR3C£S 
fol lows: 



X(0) 



X(NGP) 



X(NGP+3*NGPSET) 



X(NGP+4*NGPSET) 





Gr- 
of 


GPLST(NGP) 
d point indices into 
grid points 


a subset 


Coc 
in 

's' 
the 


X(3, NGPSET) 
)rdi nates of the grid 
the subset 


points 


XR(NGPSET) 
grid point coordinates for 
right image of a stereo pair. 


Rest of open core 



4.24-13 



MODULE FUNCTIONAL DESCRIPTIONS 

3. Subroutine PLiJT partitions open core for subroutines FNDSET, GETDEF, 
and DRAW as follows: 



DEFLST(O) 

DEFLST(NDEF) 
DEFLST(NDEF+N) 

DEFLST(NDEF+N+NGP) 

DEFLST (NDEF+N+NGP+3*NGPSET ) 

DEFLST {NDEF+N+NGP+4*NGPSET ) 

DEFLST(NDEF+N+NGP+7*NGPSET) 

DEFLST(NDEF+N+NGP+9*NGPSET) 
DEFLST(Bl) 



DEFLST(NDEF) 

List of specified deformation 
subcases 



PLTCRD(N) 
Rest of the 'PLj»T' card 



GPLST{NGP) 
Grid point indices into a subset 
of grid points 



X(3,NGPSET) 

Coordinates of the grid points 
in the subset 



XR(NGPSET) 

's' grid point coordinates for 
the right image of a stereo 
pair 



U(3,NGPSET) 

Coordinates of the deformed grid 
points in the subset 



S(2,NGPSET) 

's' and 't' coordinates of the 
deformed grid points 



Rest of open core 



4 GIN0 Buffers 



4.24-14 



FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 

4.24.9,2 Block Data Interface 

1. C0MM0N/DRWDAT/ SET, LABEL, 0RIGIN, PEN, SHAPE, SYMB0L(2) ,SYM(6) ,VECT0R 

SET - Element plot set index. 

LABEL - Grid point label option. 

0RIGIN - Origin index. 

PEN - Pen number or density value. 

) Integer 
SHAPE - Structural shape drawing option. 

SYMB0L - Grid point symbol indices. 

SYM - Symmetry options. 

VECT0R - Deformation vector options. 

2. C0MM0N/RSTXXX/ CSTM(3,3) ,MIN(3) ,MAX(3) .0(3) .AVER(3] 
CSTM - 3x3 coordinate system rotation matrix. 
MIN - Minimum rotated grid point coordinates. 
MAX - Maximum rotated grid point coordinates. \ Real 
D - Differences between the minima and maxima. 
AVER - Averages of the minima and maxima. 

3. C0MM0N/XXPARM/ PBUFSZ, CAMERA, BFRAMS, PLTMDL(2) .TAPDEN, 

NPENS.PAPSIZ(2) ,PAPTYP(2) .PENSIZ(8) ,PENCLR(8,2) ,"SKIP(1 )" , 
SCALE, 0BJM0D,FSCALE,MAXDEF,DEFMAX, 
AXIS(3),DAXIS(3).VANGLE(3),BETA0S,BETAP."SKIP(4)", 
FVP,R0,S0L,S0R,T0,D0,D02,D03,PRJECT,S0S 
F0RG,0RG,N0RG.0RIGIN(ll),EDGE(n,4),XY(n,3) 

In the following descriptions, the value(s) in parentheses to the right of the variable name, 
the default value, and the letter in parentheses to the right of the explanation 
pertain to the type of the variable (I implies integer and R implies real). 
PBUFSZ(O) = Plot tape buffer size (I) 



4.24-15 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Plotter Data 

CAMERA(2) 
BFRAMS(l) 
PLTMDL (4020,0) 
TAPDEN(O) 

Pen and Paper Data 

NPENS(8) 

PAPSIZ(8,5,11.) 

PAPTYP(VELLUMbb) 

PENSIZ.{1) 

PENCLR. ,(BLAC) & PENCLR. „(Kbbb) 

Scaling Data 

SCALE 

0BJM|}D(1.) 

FSCALE(l) 

MAXDEF(0.) 

DEFMAX 

Viewing Data 

AXIS (1,2,3) 
DAXIS(1,2,3) 

VANGLE(0.,-1.10^°, 34.27) 
BETA(}S(23.17) 

BETAP(0.) 



Plotter camera number (I). 

Number of blank frames between plots (I). 

Plotter model (BCD or I or R). 

Plot tape density (I). 

Maximum number of pens (I). 
Paper size in inches (R). 
Paper type (BCD). 
Pen sizes (I). 
Pen colors (BCD). 



= Object-to-plotter or model-to-plotter 
(stereo only) scale factor (R). 

= Object-to-model scale factor (R-stereo only), 

= Find scale factors option (I). 

= Forced value of the largest deformation 
component (R). 

= Actual largest deformation component (R). 



Undeformed structure axis orientation (I). 

Deformed structure axis orientation (I). 

View angles (R-alpha, beta, gamma). 

Orthographic and stereo default value for the 
"beta" view angle (R). 

Perspective default value for the "beta" view 
angle (R). 



4.24-16 (12-1-69) 



FUNCTIONAL MODULE PL0T (STRUCTURAL PLOTTER) 



Projection Data 

FVP(l) 

RO 

SOL 

SOL.SOR 
TO 
DO 
D02(l.) 

D03(2.) 

PRJECT(I) 

S0S(2.756) 

Origin Data 

F0RG{1) 

|3RG(0) 

N0RG{1O) 

0RIGIN 

EDGE. ,(0.) & EDGE. ,(0.) 

EDGE.^jd.) & EDGE.^^Cl.) 

XY.^^ &XY.^2 
4.24,9.3 Common Storage Requirements 



= Find vantage point option (I). 

= "r" component of the vantage point (R). 

= "s" component of the perspective vantage 
point (R). 

= "s" components of the stereo vantage point (R). 

= "t" component of the vantage point (R). 

= Projection plane separation value (R). 

= Perspective default projection plane separation 
value (R). 

= Stereo default projection plane separation 
value (R). 

= Projection type (I, l=orthographic, 2 = per- 
spective, 3 = stereo). 

= Ocular separation value (R). 

= Find origin point option (I). 

= Number of active origins (I). 

= Maximum number of active origins (I). 

= Active origin id's (I). 

= Lower left corner of the region specified 
for the ith origin (R). 

= Upper right corner of the region specified 
for the ith origin (R). 

= X component of the i origin (R). 

= y component of the i origin (R). 

" left and right x components of the i origin 
for stereo projection (R). 



1. /XXPL0T/ - Open core. 

2. /PLTDAT/ - Plotter data (see miscellaneous table description - section 2.5). 

3. /XXPARM/ - Plotting parameters, 

4. /RSTXXX/ - Plot co-ordinate system calculations. 

5. /DRWDAT/ - Drawing data. 



4,24-17 



MODULE FUNCTIONAL DESCRIPTIONS 

4.24.10 Diagnostic Messages 

A non-fatal message, number 3008, CALL MESAGE (8,x,x), will be generated by subroutine PL0T if 
not enough core is available for the grid point data needed for a specific element plot set. If 
this occurs, this set will not be used to generate a plot. 

All other diagnostics are non-fatal and are written onto the PL0TX message data block 
for printing by the PRTMSG module. These messages are all quite self-explanatory and 
straightforward, and do not have any external message numbers. 



4.24-18 



FUNCTIONAL MODULE GP3 (GEOMETRY PROCESSOR - PHASE 3) 

4.25 FUNCTIONAL MODULE GP3 (GEOMETRY PROCESSOR - PHASE 3) 

4.25.1 Entry Point : GP3 

4.25.2 Purpose 

GP3 processes static loads and temperature data. Static load data are collected by load 
set, and external numbers are converted to internal numbers. Similarly, temperature data are 
collected by temperature set and external numbers are converted to internal numbers. 

4.25.3 omP Calling Sequence 

GP3 GE0M3,EQEXIN,GE0M2/SLT,GPTT/V,N,N0L0AD/V,N,N0GRAV/V.N,N0TEMP $ 

4.25.4 In put Data Blocks 

GEUM3 - Static loads and temperature data. 

EQEXIN - Equivalence between external grid and scalar numbers and internal numbers. 

GE0M2 - Element connection data. 

Note : EQEXIN may not be purged. 

4.25.5 Output Data Blocks 

SLT - Static Loads Table. 

GPTT - Grid Point Temperature Table. 

4.25.6 Parameters 

N0L0AD - Output-integer-no default. -1 if no static loads (i.e. SLT is not created), 
+1 otherwise. 

N0GRAV - Output-integer-no default. -1 if no GRAV cards in the Bulk Data Deck, 
+1 otherwise. 

N0TEMP - Output-integer-no default. -1 if no TEMP or TEMPO cards in Bulk Data Deck 
(or if GPTT is purged), +1 otherwise. 



4.25-1 



MODULE FUNCTIONAL DESCRIPTIONS 



4.25.7 Method 

Subroutine GP3 is the control program for the module. It executes each of the major 
subroutines of GP3 (GP3C, GP3A, GP3B) depending on the status of the data blocks. A flow 
chart for GP3 is included in Figure 1. 

4.25.8 Subroutines 

4.25.8.1 Subroutine Name: GP3 

1. Entry Point: GP3 

2. Purpose: Module control program. 

3. Calling Sequence: CALL GP3 

4.25.8.2 Subroutine: GP3C 

1. Entry Point: GP3C 

2. Purpose: To convert PLt)AD2 data to PL0AD format, merge PL0AD2 data with PLfJAD 
data (if present) and write the resulting data on SCR2, a scratch file. 

3. Calling Sequence: CALL GP3C 

4. Method: PL0AD2 cards are read into core from GE0M3. Six words are used for each 
entry. The first word (set identification) is set negative and the sixth word of 
each entry is set to zero. GE0M2 is opened and the header record is skipped. The 
following steps occur for each record on GE0H2. 

1. The 3-word header is read. /GPTAl/ (see section 2.5) is searched for a match. If 
no match is found, the record is skipped and the process is repeated. If an end-of- 
file is encountered, step (3) is executed. If a match is found, a test on element 
type is made. If a one-dimensional element, the record is skipped and the process 
repeated. Otherwise, step (2) is executed. 

2. An entry of the current element type is read. A linear search through the PLj)AD2 
data in core is made to find a match on element identification (3rd word of each 
PL0AD2 entry). If no match is found, the next entry is read. For each match which 
is found, the grid identification numbers which connect the element are stored 



4.25-2 



FUNCTIONAL MODULE GPS (GEOMETRY PROCESSOR - PHASE 3) 

in the corresponding PL0AD2 entry and the first word of the PL0AD2 entry is set 
positive. When all data for the current element type has been read, a return to 
step (1) is made. 

3. A pass through each entry in the PL0AD2 data is made. For each entry for which 
the first word is negative, an error message is queued and the N0G0 flag turned on. 
Upon completion of the pass, PEXIT is called if the N0G0 flag was turned on. 
Otherwise step (4) is executed. 

4. L0CATE is called to position GE0M2 to PL0AD data. If none exists, step (5) is 
executed. Otherwise, the PL0AD data is read into core following the PL0AD2 data. 
The combined list is sorted by S0RT on set identification number. 

5. The data in core is written as one logical record on SCR2. A return to 6P3 is given. 
Allocation of core storage in GP3C is as follows: 

C0MM0N/GP3C0R/Z{1) 



Before conversion 



After conversion 



NPLD2 



BUFl 



PL0AD2 set ID 



Scale factor 



Element ID 



Same format as 1st 
entry 



GIN0 buffer 



Six words 
per 

PL0AD2 
Icard 



Last 

■ PL0AD2 

entry 



NPLD2 



BUFl 



+ PL0AD2 or PL0AD 


set 


ID 


Seal 


B factor 








Grid 


point ID, 








Grid 


point I Dp 








Grid 


point IDg 








Grid 


point ID. 


or 







; 


Same 


format as 


1st 


entry 


GIN0 buffer 



[Six words 
[per entry 



4.25-3 



MODULE FUNCTIONAL DESCRIPTIONS 

4.25.8.3 Subroutine: GP3A 

1. Entry Point: GP3A 

2. Purpose: To assemble to Static Loads Table (SLT). 

3. Calling Sequence: CALL GP3A 

4. Method: GP3A assembles the SLT by making two passes on the load cards (F0RCEi, M0MENTi, 
etc). On the first pass each of the cards is read from GE0M3, (or SCR2 for PL0AD 
data), unique set identifications are extracted and saved in core, all external 

point identifcations are converted to internal indices by performing a binary search 
in the EQEXIN table, the data are written on SCRl , and pointer tables are accumulated. 
These tables are as follows: 



STATUS 



Pointer in LIST table to first entry of card type 



NTYPES 




2 words/entry 



1 entry per 
card type 



Last Entry 



Note: entry = (-1, -1) if card type not present 



4.25-4 



FUNCTIONAL MODULE GPS (GEOMETRY PROCESSOR - PHASE 3) 





C|3MM0N/GP3C0R/Z(1) 


1 


External point ID 




Internal index 


NEQX 


I 


ILIST 


Load set ID 




Pointer to data in set 




No. of data words in set 




; 


NLIST 






• 




Set IDg 


ISET 


Set ID, 


BUF2 


GIN0 buffer 


BUFl 


GIN0 buffer 



2 words/entry 



3 words/entry 



Last entry 
in table 



|. 1 word/entry 



EQEXIN Table 
(1 entry per 
point in model) 



LIST Table 

(1 entry per set 

per card type) 



Set LIST 

(1 entry per set 

per card type) 



Note: 



Set IDs are stored backward in core. ISET points to first entry, 
ISET-1 to record entry, etc. 



4.25-5 



MODULE FUNCTIONAL DESCRIPTIONS 



At the end of the first pass, the LIST table is moved to the beginning of open core. 

The set list is sorted, and duplicate set identifications are discarded. The resulting 

list is stored immediately following the LIST table. If all data for the load cards 

will fit in the remaining core, this data is read from SCRl . Core storage is as 

follows: 

C0MM0tVGP3C0R/Z(l) 



ILIST=1 



NLIST 
ISET 



ITABL=NSET 



BUFl 



Set ID 


Pointer to data in 


set 


No. of data 


words 


in set 






Set ID, 


; 


Set ID^ 


Load data 


GIN0 buffer 



>3 words/entry 



)LIST Table 



Last entry 
U word/entry 

Last entry 



Set LIST 



4.25-6 



FUNCTIONAL MODULE GP3 (GEOMETRY PROCESSOR - PHASE 3) 

The SET list is written in the header record on the SLT. For each set ID in the 
SET list, the LIST table is searched for a match. When found, the pointer 
to the data is fetched. The data are sorted on the applied point (except GRAV and 
PL0AD data) and the data written on the SLT. As a result, each logical record of 
the SLT contains all data for one set. Finally, if combination load cards are 
present, they are copied from GE0M3 to the last record of the SLT. 

If core will not hold the entire load data, the logic is similar to above except 
that SCRl is passed once for each set and only data belonging to a single card 
type within a set are read into core. 

4.25.8.4 Subroutine Name: GP3B 

1. Entry Point: GP3B 

2. Purpose: To assemble the Grid Point Temperature Table (GPTT). 

3. Calling Sequence: CALL GP3B 

4. Method: EQEXIN is read into core. A list of default temperatures (TEMPO cards 
if present) is read from GE0M3. The temperature data (TEMP cards) are read to 
determine the number of temperature sets, the set identifications and the number 
of entries in each temperature set. For each temperature set, a three-word entry 
is written in the header record of the GPTT: 

Word 1 = Set ID 

Word 2 = default temperature (real) or -1 (integer) 

Word 3 = record number in GPTT of temperature data for the set or zero if only 
default temperature is defined. 

GE0M3 is backspaced one logical record. The temperature data are re-read. Each 
point identification is converted to an internal index by performing a binary search 
in the EQEXIN table. When all temperature data for a set have been read into core, 
the data are sorted on internal index and written as one logical record on the GPTT. 
This process is repeated for each temperature set. 

Allocation of core storage for GP3C is as follows: 



4.25-7 



MODULE FUNCTIONAL DESCRIPTIONS 



C0MM0N/GP3C0R/Z(1) 



ITEMPD 



External point ID 



Internal index 



Temperature Set ID 



Default Temperature 



2 words/entry 



2 words/entry 



ITABL+1 



Nl 



Number of data words in set 1 



Point ID 



Temperature 



BUF2 
BUFl 



GIN0 buffer 



GINi3 buffer 



'■ 1 word/entry 



2 words/entry 



EQEXIN Table 
(1 entry per 
point in model) 

Default temperature 
1 entry per set 

Definition of data 
in temperature sets 

Temperature data 
for one set 



4.25-8 



FUNCTIONAL MODULE GP3 (GEOMETRY PROCESSOR - PHASE 3) 

4.25.9 Design Requirements 

4.25.9.1 Allocation of Core Storage 

The core storage maps presented in the method sections of GP3A, GP3B and GP3C provide 
detailed storage requirements. A summary is presented here. 

GP3C: Maximum requirement = 6* (number of PL0AD2 + number of PL0AD cards) + one 
GIN0 buffer. 

GP3A: Let NPTS = number of grid + number of scalar points and NSETS = (number of load 
sets) * (number of card types per load set) and SYSBUF = one 6IN0 buffer. 

Then maximum storage requirement equals MAX ( (2*NPTS+4*NSETS+2*SYSBUF) , (4*NSETS + MAX 
(number of words for one set of one card type) + SYSBUF)). 

6P3B: See storage map. 

4.25.9.2 Environment 

1. Block Data 

The block data program GP3BD initializes /GP3C0M/ with GIN0 file names, data defining 
the load cards and other miscellaneous data. It must be resident in core when GP3 is 
executed. 

2. General 

/GPTAl/ is used by GP3C and must be core resident when GP3 is executed. Open core is 
defined by /GP3C0R/. The normal overlay is to include GP3BD, GP3, GP3C, GP3A, GP3B in 
one segment. GP3 uses two scratch files. 

4.25.10 Diagnostic Messages 

The following messages may be issued by &P3: 

2008. 2009, 2015. 3008. See section 6 of the User's Manual for details. 



4.25-9 



HODULE FUNCTIONAL DESCRIPTIONS 



GP3 



ENTER 



— ^ [Read Trail 



Read Trailer 
.'-on SLT 




Figure 1. Flowchart for module GP3 



4.25-10 



FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 

4.26 FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 

4.26.1 Entry Point : TAl 

4.26.2 Purpose 

TAl processes element connection data, element property data and geometry. These data are 
merged in two different sorts for efficiency in later processing. The Element Summary Table 
contains, for each element, connection, property and geometry data. The Element Connection 
and Properties Table contains, for each grid or scalar point in the model, connection, property 
and geometry data for all elements connected to the point. Element temperature data are also 
included for both data blocks where applicable. Additionally, general elements are processed 
and the GEI (General Element Input) data block is assembled. 

4.26.3 Df^P Calling Sequence 

TAl, ECT,EPT,BGPDT,SIL,GPTT,CSTM/EST,GEI,ECPT,GPCT/V,N.LUSET/V,N,NSIL/V,N,N0SIMP 
/C,N,O/V,N,N0GENL/V,N,GENEL $ 

4.26.4 Input Data Blocks 

ECT - Element Connection Table. 

EPT - Element Properties Table. 

B6PDT - Basic Grid Point Definition Table. 

SIL - Scalar Index List. 

GPTT - Grid Point Temperature Table. 

CSTM - Coordinate System Transformation Matrices. 

Note : The ECT, BGPDT and SIL data blocks may not be purged. 

4.26.5 Output Data Blocks 

EST - Element Summary Table. 

GEI - General Element Input. 

ECPT - Element Connection and Properties Table. 

GPCT - Grid Point Connection Table. 

Note : No output data block may be purged. 



4.26-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.26.5 Parameters 

LUSET - Input-integer-no default. Degrees of freedom in the g-displacement set. 

NSIL - Output-integer-no default. Number of grid points plus number of scalar points 

in the model . 
N0SIMP - Output-integer-no default. Number of elements in the model (exclusive of 

general elements) or -1 if no elements. 
N0GENL - Output-integer-no default. Number of general elements in the model or -1 

if no general elements. 
GENEL - Output-integer-no default. GENEL = -N0GENL. 

4.26.7 Method 

4.26.7.1 General Comments 

The purpose of the Table Assembler Module is to combine all of the element data in a 
convenient form for the generation of the structural matrices (ECPT) and for the calculation of the 
element stresses and forces (EST). The complete description of an element requires: (1) the 
locations of the connected grid points, (2) necessary orientation data and end conditions, 
(3) element properties, (4) a material reference, (5) transformations from the basic system 
to the global coordinate system and (6) element temperature. Scalar elements require no 
geometric or material data. General elements may require geometric data. 

Four data blocks are formed in this module, "me ECPT data block is used in structural 
matrix generation. It contains all element data for each grid point or scalar point in the 
order of the sequenced grid point numbers (internal grid point indices). The EST data block 
contains element data in groups of element type and with sequential element I.D. numbers 
within each group. It is used to calculate element stresses and forces in a convenient order 
for output. The GEI data block contains the general element flexibility and support matrices. 
The GPCT data block is used to allocate storage in the structural matrix assemblers. 

The reason for assembling the ECPT and EST tables rather than generating functions such 
as element stiffness matrices and stress functions is the expected size of the problems. The 
computing time used to recalculate certain data is expected to be compensated for by the time 
savings that result from sorting and merging smaller tables. 



4.26-2 



FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 

Subroutine TAl is the main control program for the module. It executes each of the 
major routines of the Table Assembler (TAIA to assemble the EST, TAlB to assemble the ECPT 
and GPCT, and TAIC to assemble the GEI) depending on the status of the data blocks and data 
for the problem. A flow chart of TAl is included as Figure 1. 

4.26.7.2 TATA 

Assembly of the Element Summary Table is performed in two steps. For the first step, 
the EPT is read into core one property type at a time. The ECT is read one element at a time. 
For each element the referenced property data are found by performing a binary search in the 
EPT in core. The ECT and EPT data are written on SCRl , a scratch file, one element at a time, 
one logical record per element type. 

To initiate the second step, the BGPDT and SIL data blocks are read into core. If a 
temperature set is selected, the appropriate temperature data from the GPTT are read into core. 
Data from SCRl are read one element at a time. Internal indices for the grid points are used 
as pointers into the BGPDT and SIL tables. The temperature of the element is computed by 
averaging the temperatures of the referenced grid points. Each temperature is found by 
performing a binary search in the GPTT with the interna.! index of the grid point. If the entry 
is not found in the GPTT, the default temperature for the set is substituted. The internal 
indices are now replaced witn corresponding scalar index values. A line comprising ECT, EPT, 
BGPDT and GPTT data for the element is written on the EST. Each logical record of the EST 
comprises all data of one element type. 



4.26-3 



MODULE FUNCTIONAL DESCRIPTIONS 



Allocation of core storage during the second step is as follows: 

C0MM0N/TAA1/Z(1) 
L?ICBGP=1 " 



NBGP 
NBGP+1 



ITMP 



BUF2 
BUFl 



Coordinate system ID 



SIL, 



SIL, 



Internal index 



Temperature 



GIM0 buffer 



GIN0 buffer 



4 words/entry 



} 1 word/entry 



2 words/entry 



BGPDT table 

one entry per point 

in problem 



SIL table 

one entry ner noint 

in oroblem 

GPTT table 
one entry per 
defined point 



4.26.7.3 TAIB 

The ECPT data block is assembled in TAIB. Each logical record m the ECPT corresponds to a 
grid or scalar point in the model. For each point, the data for each element connected to the 
point are listed. The data for each elen^nt are identical to the EST data. Each set of element 
data will be listed in the ECPT "n" times, where "n" is the number of grid points connected by the 
element. A sample of the ECPT is given in Table 1. The logical phases of the operation are as 
follows: 

A list is formed in core giving the relative locations of the elements in the ECT data 
in the order which they will be placed in the ECPT data block. Storage is allocated by 



4.26-4 



FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 

forming the GPC (Grid Point Counter) and then replacing the GPC by a running sum of 

elements connected to points. A sample is: 

Irr.pl ied GPC GPCS 

Grid Point Number of Sum of Previous 

internal index Connected Elements Elements 

(1) 5 

(2) 3 5 

(3) 1 8 

(4) 2 9 

(5) 6 11 

17 



The GPC is formed as follows. An area of core equal to the number of grid and scalar 
points of the model is set to zero. The ECT is read one element at a time. The storage 
location corresponding to the internal index of each referenced grid point is incremented by 
one. When each element in the ECT has been processed, a running sum of the core table is 
formed. 

The contents of each word in the GPC now provide a pointer to the first storage location 
where a second pointer to the element data will be stored. Since the total number of connected 
elements may exceed available core storage, spill logic is provided. A band of entries in the 
GPC is determined. The ECT is read one element at a time. The position of each element of 
a given element type is determined by summing the number of words for each entry for the 
element (i.e. if m = number of words per ECT entry, then the position of the element in the 
ECT record = (i-l)*m where i = entry number in the ECT record). For each point referenced by 
the element (which is in the band currently being processed), the contents of the associated 
position in the GPC is fetched. The element position and its type are stored at the indicated 
locations. 

The location in the GPC is incremented by one. When a pass of the ECT is complete, the 
skeleton ECPT is written, one logical record per point in the band of the current pass. Each 



4.26-5 



MODULE FUNCTIONAL DESCRIPTIONS 



logical record consists of pairs of {-1, element pointer). The number of pairs equals the 
number of elements connected to the point. Example: 

C0MM0N/TAA2/Z(1) 



lECPTO 



code for element 
type (1 = BAR) 



1 



r 



y_l 



15 



36 



80 



16 



GPC 



Storage for the 
3 element pointers 
connected to grid point 1 

Storage for the 
2 element pointers 
connected to grid point 2 



position of element in ECT record 



Skeleton ECPT data is written on a scratch file: 



-1 


1 1 

1 







-1 


15 1 
1 




36 


-1 


3 1 

1 




80 


-1 


1 1 

1 




16 


-1 


1 I 
1 









• 





Logical record 1 

(all elements connected 

to grid point 1 ) 



Logical record 2 

(data for grid point 2) 



4,26-6 



FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 

When all entries of the 6PC have been processed, the skeleton ECPT is complete. 
An area of core equal to two words per element type is set to zen.-. The ECT is read into core 
following the above table until either the ECT is exhausted or core is filled. A pointer to 
the beginning of data for each element type is stored in the table. The skeleton ECPT is 
now read one pair of words at a time. If the data to which the element pointer points are 
currently in core, they are written out on a second scratch file. The first word of the entry 
contains the number of words in the ECT data. If the data are not in core, the pair (-1, 
element pointer) is written on the second scratch file. This process is repeated until the 
skeleton has been exhausted. If all the ECT is in core, the new skeleton ECPT is complete. 
Otherwise, the files for old and new skeleton ECPT are switched, and the process continues by 
reading more of the ECT data into core. Storage allocation at this point follows: 



C0MM0N/TAA2/Z(ll 



N21 



Pointer to ECT data for 1st element type 



Sum of ECT words read on previous passes 



ECT data for 1st element type 



ECT data for 2nd element type 



2 words/entry jone entry 
per 

element 
type 



4.26-7 



MODULE FUNCTIONAL DESCRIPTIONS 

The remainder of the ECPT assembly is very similar to the EST construction. The 
principal difference is that the entire EPT is held in core. A pointer table similar to the 
ECT table is formed (two entries per element type). The EPT is read into core, and the first 
position of each EPT type is stored in the table along with the number of EPT entries of that 
type. If the BGPDT, SIL and GPTT can be held in core with the EPT, the ECPT is assembled 
in one pass. Otherwise, two passes are made. The skeleton ECPT is read one entry at a time. 
For each element, the property data are attached by performing a binary search in the associated 
property table in core. If one pass, the BGPDT, SIL and GPTT data are attached as in TAIA. 
Otherise the ECT and EPT data are written on a scratch file, and a second pass is made to attach 
the BGPDT, SIL and GPTT data. Table 1 contains sample ECPT contents. 

During the final pass of the ECPT assembly, the 6PCT is constructed. The GPCT is 
comprised of one logical record per point (same as ECPT). Each logical record consists of the 
pivot point and all other points connected to the pivot by means of element connections. 



4.26-8 



FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 



Table 1, Sample ECPT Data Contents. 



Reference Grid Point First Scalar Index 
(Pivot Point) 



235 



1st Element Type 



9 (Triangular membrane) 



Connected Grid Point First Scalar Indices 
(From ECT and SIL) 

Anisotropic Angle (From ECT) 
Material Number (From EPT) 



625 
235 
535 

0.0 



1st Element Properties (From EPT) 



0.5 
0.0 
1.0 



Location and Orientation Data for Grid 

Points 

(From BGPDT) 

Element Temperature (From GPTT) 



5, 10.0, 100,0, 0.0 
5, 11.0, 100.0, 0.0 
0, 235.0. 50.0, 25.0 

15.5 



2nd Element Type 



34 (Bar) 



etc. 



Last Element Type (for point 235) 



1 (Rod) 



End of Logical Record (new grid point) 

Reference Grid Point First Scalar Index 
(Pivot Point) 



etc. 



etc. 



241 



4.26-9 



MODULE FUNCTIONAL DESCRIPTIONS 

4.26.7.3 TAIC 

The General Element flexibility and support matrices are assembled in TAlC. The data, 
given in the ECT data block, consist of the following sections for each General Element: 

1. A list of the independent degrees of freedom, u-, in terms of grid points and 
components and/or scalar points. 

2. A list of supporting degrees of freedom, u ,, given by grid and scalar points 
(May be null ) . 

3. A flexibility matrix [Z] with rows and columns corresponding to the list of given 
u. points. 

4. A support matrix [S] with rovs corresponding to the u. points and columns 
corresponding to the u. points. (May be null). 

The tasks of TAIC are to (1) convert the lists of u. and u, to scalar indices and sort 
them by increasing scalar index, (2) rearrange the matrices to correspond to the sorted lists 
of u^ and u^ degrees of freedom, and (3) on user option calculate the support matrix from grid 
point geometry. 

These tasks are accomplished as follows: 

1. For each set of coordinates (u. and u,) of length n, a 4xn table is formed where 
the four entries corresponding to each degree of freedom are: 

a) The position as given (1, 2, 3 ...n) 

b) The internal position (zero initially) 

c) The grid or scalar point I.D. (Internal index) 

d) The grid point component (1 = x, 2 = y, etc) 

2. The list is sorted on the third and fourth position. If a point I.D. in the third 
position is duplicated, the duplicates are sorted on the components in the fourth 
position. The list now corresponds to the desired order of increasing scalar indices, 

3. The SIL data block is read, and each of the points in the list is converted to its 
SIL value. (The position of a SIL number is its internal point index.) The SIL 
value and the component c. determine the scalar index, N., of a degree of freedom by: 



4.26-10 



FUNCTIONAL MODULE TmI (TABLE ASSEMBLER) 

N. = SIL + (c. - 1) (1) 



for grid points and 

N. = SIL (2) 

for scalar points. 

The list of scalar indices is written on the GEI data block file. 

4. In order to rearrange the matrices to correspond to the proper sequence of degrees 
of freedom the above list is modified as follows: 

a) The internal position number is placed in the second position of each entry in 
the list. The first entry uses 1, the second, 2, etc. 

b) The list is sorted again to return the original order as given on the input card 
images. The first position of each entry supplies this order. The internal 
position of a term in a matrix is now given by the second numbers in each entry. 

5. Steps (1) through (4) are repeated for both the u. and u, sets. 

6. The [Z] and [S] matrices are rearranged according to the sorted lists of degrees 
of freedom. The row and column numbers are converted by the algorithm: 

a) For a term of 1.., where i and j are the row and column as given by the matrix 

' J 

order, the position i of the u. irternal number list gives i., the new 
column number. 

b) For a term of S. ., where i and j are the external row and column numbers, the 
row number i is converted using the u. list. The column number j uses the 

u, list. 

If a matrix is small enough to fit in core, the new row and column numbers 
are used to place the term in its correct position in core. If the matrix 
will be larger than core, the new row and column indices and the term itself 
are written on a scratch file. When all terms are processed, the file is 
sorted to form a sequenced matrix. The terms of the matrix are written on 
the GEI file in full matrix form. 



4.26-11 



MODULE FUNCTIONAL DESCRIPTIONS 

4.26.7.4 TAICA 

The [S] matrix must be generated if the user inputs a list of six u, points and does 
not supply an [S] matrix. This is accomplished in subroutine TAICA as follows: 

The BGPDT and CSTM data are read into core. (SIL is already in core). 

A six by six matrix [d ] is formed, where each row corresponds to a u. scalar index (j). 

[D ] is a six by six matrix which transforms the three translations and three rotations 

in the basic coordinate system to the six rigid body u. degrees of freedom: 



\\i\ - I' 



(3) 



xo 

^zo 



basic 



The steps for generation of each row of [D] are as follows: 

1. X.| Y,, Z. the BGPDT location vector for the grid point containing scalar point j is 
found. 

2. [T.] the 3x3 global-to-basic transformation matrix for the grid point containing j 

J 

is fetched using subroutine MAT. 

3. If scalar j is a translation, define: 



N 



1 











h 


-^ 





1 





-^j 





h 








1 


h 


-^j 






(4) 



The column of [T.] corresponding to the degree of freedom j is defined as the 

J 

row vector { V. } ^. The row vector of [D ] corresponding to point j is: 



4.26-12 



FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 

(D,.}^ = ^V.f [E.]. (5) 

4. If scalar j is a rotation, the column of [T.] corresponding to the degree of 

J 

freedom j is defined as the row vector {V.} . The row vector of [D ] corresponding to 
point j is: 

When all 6 rows [D^] have been generated, the matrix is inverted: 

tHdoJ = CDo^"^ (7) 

[Hjjj] transforms the u^ displacements to rigid body motions about the basic 
coordinate system, i.e.: 

^ ^0 



h 



xo 



tHdo^ ^"d> (8) 



yo 
^zo /basic 

If the matrix is ill-conditioned, a fatal error exists. 

The [S] matrix may now be calculated a row at a time. The list of u. points, (s.). is 
read one at a time, and the [S] matrix is formed a row at a time. Call each row {S.}^. 

The steps for generation of each row are as follows: 

1. Using the basic coordinates X., Y^ , Z^ for the grid point corresponding to scalar s., 
the global-to-basic transformation matrix [T. ] is fetched. 

2. The column of [T.] corresponding to the scalar coordinate of u. is defined as the row 
vector {V.} . 



4.26-13 



MODULE FUNCTIONAL DESCRIPTIONS 



3. If u. is a translation, we form 



[E] 



1 



■^i 



(9) 



and 



(s^}-^= {v^}T[e] [hJ 



(10) 



4. If u. is a rotation: 



{S^}"^ = |0 0: \l]\ [hJ 



(ii; 



4.26.8 Subroutines 

4.26.8.1 Subroutine Name: TAl 

1. Entry Point: TAl 

2. Purpose: Module driver. 

3. Calling Sequence: CALL TAl 

4.26.8.2 Subroutine Name: TAIA 

1. Entry Point: TAIA 

2. Purpose: To assemble the EST. 

3. Calling Sequence: CALL TAIA 

4.26.8.3 Subroutine Name: TAIB 

1. Entry Point: TAIB 

2. Purpose: To assemble the ECPT and GPCT. 

3. Calling Sequence: CALL TAIB 

4.26.8.4 Subroutine Name: TAIC 
1. Entry Point: TAIC 



4.26-14 



FUNCTIONAL MODULE TAT (TABLE ASSEMBLER) 

2, Purpose: To assemble the 6EI. 

3. Calling Sequence: CALL TAIC 

4.26.8.5 Subroutine Name: TAICA 

1. Entry Point: TAICA 

2. Purpose: To calculate the general element support matrix [S] . 

3. Calling Sequence: CALL TAICA 

4.26.8.6 Subroutine Name: TAIF 

1. Entry Point: TAIF 

2. Purpose: To assemble the super quadrilateral portion of the SEST 
(Force Method only) . 

3. Calling Sequence: CALL TAIF 

4.26.8.7 Subroutine Name: TAIG 

1. Entry Point: TAIG 

2. Purpose: To assemble the final EST (Force Method only). 

3. Calling Sequence: CALL TAIG 

4.26.9 Design Requirements 

4.26.9.1 Allocation of Core Storage 

TAIA. Step (1): Maximum core storage equals all property data for one element type 
plus three GINj) buffers. 

Step (2): Maximum core storage equals 5* (number of grid and scalar points in 
model) plus 2* (number of grid point temperatures in selected set) plus two 
GIN0 buffers. 

TAIB. The initial steps of TAIB are open ended. The final assembly of the ECPT requires 
that all EPT data be held in core at one time. At another time the same storage 
requirement as TAIA exists plus additional storage to hold a list of the maximum 
number of points connected to any one point by means of element connections. 

4.26-15 



MODULE FUNCTIONAL DESCRIPTIONS 

TAIC. The maximum storage requirement equals 5* (number of grid and scalar points 

in the model) plus the CSTM table plus 4* (number of u. + number of u. points) 
plus three GIN0 buffers. 

4.26.9.2 Environment 

TAl is designed to allow each of the major phases of the module to be in a separate 
overlay segment. Open core for each is defined as follows: 



TAl A: 


/TAAl/ 


TAIB: 


/TAA2/ 


TAIC: 


/TACl/ 



GIN0 file names and DMAP parameters are communicated through blank C0MM0N. No block 
data program is used. Communication between TAIC and TAICA occurs through /TAICAX/ and /TACl/. 

4.26.10 Diagnostic Messages 

The following messages may be issued by TAl: 

2010, 2011, 2013, 2014, 2015, 2044, 2045, 2063, 2082 



4.26-16 



FUNCTIONAL MODULE TAl (TABLE ASSEMBLER) 



TAl 



c 



ENTER 



3 



Initialize 

GIN0 File 

Names 



RDTRL 



Read Trailer 
on GCPT 



Set Flag 

for 
Approach 



RDTRL 



Read Trailer 
on ECT 



Set flag 

for general 

elements 



Displacement 




Force 



Assemble 
EST 



Assemble 
ECPT.GPCT 



laff 



Assemble 
GEI 



Set Flag 

for Each 

Super 

Element 

Type 




Present 




Assemble 
EST 



Assemble 
GEI 



Figure 1(a). Flowchart for module TAl 



4.26-17 



MODULE FUNCTIONAL DESCRIPTIONS 




[Assemble 1 
, '[initial ESTj 



J" Assemble] 
'lECPT J 



fAssemble ] 

iPortion of SEStJ 



Absent 



Present fAssemble 

IPortion of SEST 




Figure 1(b). Flowchart for module TAl 



4.26-18 



FUNCTIONAL MODULE SHAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

4.27 FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

4.27.1 Entry Point : SMAl 

4.27.2 Purpose 

To generate the stiffness matrix exclusive of general elements, [K^n^' ^^^ structural 
damping matrix, [K^J, and the Grid Point Singularity Table, GPST. 

4.27.3 DMAP Calling Sequence 

SMAl CSTM,MPT,ECPT,GPCT.DIT/KGGX,K4GG,GPST/V,N,N0GENEL/V,N,N0K4GG $ 

4.27.4 Input Data Blocks 

CSTM - Coordinate System Transformation Matrices. 

MPT - Material Properties Table. 

ECPT - Element Connection and Properties Table. 

GPCT - Grid Point Connection Table. 

DIT - Direct Input Tables. 

Notes : 1. The CSTM may be purged. 

2. The ECPT and the GPCT cannot be purged, or else a fatal error will occur, 

3. If some element references a material property, the MPT cannot be purged. 

4. If some material property is temperature dependent, DIT cannot be purged. 

4.27.5 Output Data Blocks 

K6GX - Partition of stiffness matrix exclusive of general elements - g set. 
K4GG - Partition of structural damping matrix - g set. 
GPST - Grid Point Singularity Table. 

Notes : 1. Neither KGGX or GPST may be pre-purged. 

2. If K4GG is pre-purged, K4GG will not be generated. 

3. If N0GENL > (see below) the GPST will not be generated. 

4.27.6 Parameters 



N0GENL - Input- integer-no default value. N0GENL is the number of general 



4.27-1 



MODULE FUNCTIONAL DESCRIPTIONS 

elements in the model. If N0GEML >0 then GPST will not be generated. 

N0K4G6 - Output-integer-no default value. If K4GG has been pre-purged or is the 
zero matrix, N0K4GG is set equal to -1. Otherwise N0K4GG is set = +1. 

4.27.7 Method 

Matrix generation modules such as SMAl , SMA2, DSMGl and PLA4 all use the ECPT(or a 
variation thereof in the case of PLA4) and its companion data block, the GPCT, as the basic 
data blocks for generation of stiffness and structural damping matrices (SMAl), mass and 
viscous damping matrices (SMA2), the differential stiffness matrix (DSMGl), and the non- 
linear stiffness matrix (PLA4). The central role of the ECPT data block in these modules 
Is discussed in section 1.8. 

Subroutine SMAl is the module driver. Its tasks are: to set up GINf) buffers and matrix 
control blocks for the output matrices; to determine if the CSTM data block exists, and, 
if It does, to read it into open core and call the initialization routine PRETRD; to call 
the material properties initialization routine PREMAT, where material property cards and 
tables are read into open core; to open and position all files so that input data blocks 
are ready to be read and output data blocks are ready to be written; to call subroutine SMAIA, 
the module "workhorse", which will create the output data blocks. Upon return from SMAIA, 
files are closed and trailers are written. Subroutine descriptions for PRETRD and PREMAT 
can be found in section 3.4.37 and 3.4.36 respectively. 

Subroutine SMAIA consists entirely of a loop in which, during each pass of the loop, a 
record of the GPCT and a record of the ECPT are processed In a complementary manner. Each 
pass through this principal loop creates either one or six rows (or columns since [K^ ] and 
[Kg ] are symmetric of the stiffness matrix, KGGX, (and the structural damping matrix, K4GG, 
If called for in the DMAP calling sequence). One row will be generated if the pivot point, 
the first word of both the GPCT record and the ECPT record, is a scalar point; six rows will 
be generated if the pivot point is a grid point. The latter case holds in the majority of 
cases. The loop is terminated when an end-of-file is sensed on the file containing the GPCT. 

The loop begins by attempting to read the first two words of the current GPCT record. 
If the second non-standard return from subroutine READ occurs, It implies the current pivot 
point has no elements connected to it so that one or six null rows must be output for the 



4.27-2 



FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

matrices. This non-standard return, it should be noted, does not occur in the majority of cases. 
A normal return from READ implies a normal path through the principal loop. The remainder of the 
GPCT record is read into core, and a pointer table is constructed. This pointer table relates 
the scalar index numbers of the GPCT record, which are the column indices of the (possible) non- 
zero terms of the generated matrices, to locations in core in which the correspondim submatrices 
will reside. The pointer table is defined recursively as follows: 

P] = 1 (1) 

Pi = Pi-i + q, i > 1 (2) 

where q is 6 if the point (i-1) is a grid point and q is 1 if the point (i-1) is a scalar point. 

It is then determined if all the submatrices corresponding to the current pivot point 
can be held in open core. If they can, there is no problem. If they cannot, spill logic 
is provided only if the structural damping matrix is not called for. Rather than compute all 
submatrices, store them on a scratch file, retrieve them when computations have been completed 
and sort them, the following approach was adopted. It is determined what the maximum number 
of rows that can be held in core is: 3, 2 or 1. The element submatrices are computed in 
their respective routines (i.e. KR0D, KBAR) and passed to the "insertion" subroutine, SMAIB, 
which "inserts" into the correct open core positions only those rows which can be contained. 

When the ECPT record is exhausted, the link vector, LINK, (see discussion below of the 
LINK variable in /SMAICL/) is searched to determine if any structural element entries in the 
ECPT were skipped because the corresponding element subroutine did not reside in the link 
(element subroutine overlay segment) currently in core. If there did exist such an element, 
the ECPT file is backspaced and the ECPT record is reprocessed such that all element sub- 
matrices not computed on the previous pass(es) of the ECPT record will be computed. If 
(or when) the LINK array is Identically zero, signifying that all element submatrices 
corresponding to the current pass of the ECPT record have been computed, the DETCK subroutine 
is called if the input parameter N0GENL sO. DETCK generates the GPST by examining the 
"translational" and "rotational" diagonal 3X3 submatrices of the 6 rows of the KGGX matrix 
currently in core. If the total number of rows to be computed (6 or 1) for the current ECPT 
record is not in core due to spill problems, DETCK stores those elements of the 3 X 3 sub- 



4.27-3 



MODULE FUNCTIONAL DESCRIPTIONS 

matrices currently in core in local variables and then processes the entire 3x3 submatrices on 
the last pass of the ECPT record (see definitions of the variables LR0WIC and NR(JWSC in /SMAICL/ 
below). 

After DETCK returns, the number of rows in core are packed onto the KGGX (and, if called 
for, the K4GG) data block(s) using the standard matrix packing routines BLDPK, ZBLPKI and 
BLDPKN. If the last row in core is not equal to the total number of rows to be computed, 
the ECPT file is backspaced and the record is processed again, this time the next set of 
3, 2 or 1 rows being output. If the last row in core ^s equal to the total number of 
rows to be computed, the processing of the ECPT record is complete and a transfer is made 
to the top of the "GPCT and ECPT processing" loop to process the next record of the GPCT and 
ECPT. The loop terminates when an end-of-file is encountered while attempting to read the 
GPCT. Upon loop termination, SMAIA returns to SMAl. 

It should be noted that the most difficult logic of the routine involves the LINK 
vector and the spill logic. The programmer is advised that the LINK vector logic will not be 
used on any of the current hardware/software configurations because 1) the routine residing 
in segment (link) 2, KC0NE, cannot be used in conjunction with any other structural element 
routine and 2) the axi symmetrical element routines KTRIRG, KTRAPR and KTdRDR cannot (from a 
mathematical modeling point of view) be used in conjunction with any other structural element 
routines. The spill logic is very seldom entered since for the majority of cases the geometry 
of the mathematical model is such that the number of words in any GPCT record - and hence the 
number of (potentially) non-zero columns in any six rows of the matrix - is generally quite 
small. A high upper limit for the number of words in any GPCT record would be 40. 



4.27-4 



FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

4.27.7.1 Determining Grid Point Singularities in Subroutine DETCK 

Let the pivot point be a grid point with scalar index p in the following discussion. 
Let [Q] be the "translational" or "rotational" 3x3 symmetric submatrix along the diagonal 
of the stiffness matrix, [Kgg], i.e., the rows and columns of the "translational" [Q] matrix 
would correspond to scalar index numbers p, p+1 , and p+2; and the rows and columns of the 
"rotational" [Q] matrix would correspond to scalar index numbers p+3, p+4, and p+5. 

The following steps comprise the algorithm for determining the presence or absence of 
grid point singularities. The discussion assumes [Q] is the "translational" 3x3 matrix but the 
same algorithm holds for the "rotational" [Q]. 

1. The matrix [Q] is scaled by the magnitude of the largest term, Q : 

^ ' ^max 

[B] = ^. (3) 

^max 

If the largest term is non-positive, the singularity is of order 3, and the scalar index 
numbers p, p+1 and p+2 are written on the GPST. 

2. The vector magnitudes of 3x1 columns (rows) are calculated: 



n. 2 2~ 

)i = ^/B + B + B 

^11 12 13 



(4) 



^ 21 



+ b' + b' , (5) 

22 23 



=V^ 



+ B + B . (6) 

32 33 



3. For each b^ = 0, the singularity order counter I0RDER is increased by one. 

4. If two b. are zero, the order of the singularity is two, and the scalar index numbers 
j and k corresponding to these two rows of [B] are written on the GPST. 



4.27-5 



MODULE FUNCTIONAL DESCRIPTIONS 

5. If one b. is zero, and i is the row such that b. = 0, define j and k as the other rows 
of [B] and calculate: 



m = det 



B.. B.. 
J J .Ik 



L^kj ^kk. 



(7) 



' - {'h ' Kt) (Bjk ^ «kk) 



(8) 



If ?r < 10"^, the order of the singularity is 2 and the GPST contains the paired scalar 

index values for i, j, k in the order (1) (i.j) if B,^,^ > or (2) (i.k) if B^^ > 0. 

If ^ > io"2, the order of the singularity is one and only the SIL value for 1 is written 

K "*~ 

on the GPST. 

6. If all b. > 0, we calculate 



D = det [B] 



(9) 



If D > .5 X 10"^ X (b,b2b2), there are no singularities, and DETCK returns if Tq] is the 

"rotational" matrix, or. if [Q] is the "translational" matrix, the "rotational" [Q] is 

input to the algorithm, 

7, If D < .5 x 10"^ X (b,b2b3), one or more singularities exist. The following terms are 

calculated: 



mi 



det 



B22 B23 
B32 B33 



(10) 



m2 ~ 



det 



Bi 1 Bi 3 
B31 B33 



(n: 



ma 



det 



Bi 1 Bj 2 
B2 1 B2 2 



(12) 



4.27-6 



FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

Ri = \JiB^ + B^ ) (B^ + B^ ) , (13) 

'22 23 3133 

R2 = J(F~rFTTB^~TTn . (14) 

'1113 3 133 ' 

R2 = yJ{B' + B^ ) (B^ + B^ ) . (15) 

'1112 2122 

8. Determine i, j, k such that: 



m. m. m. 



tn.. 2 



9. If ^ < 10 , the singularity is of order 2, Redefine i, j, k such that B.. < B.. < B^. . 

The SIL values for the paired indexes (j,k), (i,k) and (i.j) are written on GPST only if the 

corresponding B is greater than zero. For instance if B.. is zero, the SIL pair (i.j) is not 

written on the GPST. 

""i -2 
10* ^^ r7 *^ 10 . (see step 8) the singularity is of order 1. The SIL values are written 

on the GPST in the order 

""i -2 
1 since B~ > 10 " , (17) 

•^i 

""i -? 
d If ^> 10 ^ . (18) 

'"i -2 
k if ,^> 10 "^ . (19) 



4.27-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4.27.8 Subroutines 

The utility routines PRETRD and PREMAT are called in SMAl for initialization purposes 
so that the structural element subroutines can call the entry points TRANSD of PRETRD and MAT 
of PREMAT to fetch Coordinate System Transformation Matrices (CSTM) data and material 
properties data respectively. GMMATD is used by element routines as a general matrix multiply 
routine, and INVERD is used for inversion of small in-core (order usually < 12) matrices. It 
should be noted that all matrices referenced in the structural element subroutines are stored by 
rows and are double precision. See the subroutine descriptions for these routines in section 3. 

The principal means of communicating an element entry of the ECPT to an element stiffness 
matrix generation routine is through /SMAIET/. This fact is not explicitly stated in each 
of the descriptions of the element routines (e.g. KR0D) given below. Since much of the mathematics 
peeded for generating: (1) element stiffness matrices (module StlAl); (2) element mass and damping 
matrices (module SMA2) ; (3) element contributions to load vectors (module SSGl); (4) element 
stress (and force) data recovery (module SDR2); (5) element differential stiffness matrices 
(module DSMGl); (6) element stress (and force) data recovery for non-linear elements in a 
Piecewise Linear Analysis Rigid Format problem (module PLA3) ; and (7) element stiffness 
matrices for non-linear elements in a Piecewise Linear Analysis problem (module PLA4) , is 
similar or even identical, detailed mathematical algorithims are grouped by element in 
section 4.87. 

It should be noted that routines DKI,DKK,DKM,DKINT,DKJ,DKEF,DK89,DK100,KFAC,DKJAB, 
DK219,DK211,R0MBDK,D4K,D5K,D6K and DMATRX are used only (directly or indirectly) by the 
axi symmetric shell element routines KTRIRG, KTRAPR and KT0RDR. 

4.27.8.1 Subroutine Name: SMAl 

1. Entry Point: SMAl 

2. Purpose: See discussion above. 

3. Calling Sequence: CALL SMAl 

4.27.8.2 Subroutine Name: SMAIA 
1. Entry Point: SMAIA 



4.27-8 



FUNCTIONAL MODULE SMA1 (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

2. Purpose: See discussion above. 

3. Calling Sequence: CALL SMAIA 

4.27.8.3 Subroutine Name: SMAIB 

1. Entry Point: SMAIB 

2. Purpose: This routine, called by the module's element stiffness matrix generation 

routines such as KR0D, KBAR, etc., adds a double precision 6 x 6 or 1 x 1 matrix, [K^], to 

X 4 
the "submatrix" of [K ] or [K ] corresponding to the current pivot point. 

3. Calling Sequence: CALL SMAIB (KE,J,II,IFILE,DAMPC) 

KE - Row-stored double precision 6 x 6 or 1 x i matrix to be added to the 
submatrix in core - double precision - input. 

J - The column index of the [K^^] or [K^^] matrix which corresponds to the 
first column of the [K^] matrix - integer - input. 

II - If II is 0, the [K^] matrix is 6x6. If II is greater than zero, it i<: 

X 4 
the row index of the [K^ ] or [K^ ] matrix corresponding to the 1 x 1 

yy yy 

matrix [K®] to be added - integer - input. 

IFILE - GIN0 file number of the matrix In core being added to - KGGX or K4GG - 
integer - input. 



DAMPC 



- If [K ] is 6 X 6 and the [K ] matrix is called for, the input matrix [K®] is 
multiplied by DAMPC before being added to the submatrix of [K^ ] in core. 

gg 

4.27.8.4 Block Data Program Name: SMAIBD 

1. Entry Point: SMAIBD 

2. Purpose: Block data program which sets GIN0 file numbers, 1/0 parameters, and SMAl 
overlay parameters. 

3. Calling Sequence: None 

4.27.8.5 Subroutine Name: DETCK 
1. Entry Point: DETCK 



4.27-9 



MODULE FUNCTIONAL DESCRIPTIONS 

2. Purpose: This routine generates the Grid Point Singularity Table by examining the 
3x3 "translational" and "rotational" diagonal submatrices of the KGGX matrix. This 
routine is called after the submatrix for each pivot point has been completed. 

3. Calling Sequence: CALL DETCK (JARG) 
If JARG = 0, the pivot point has elements connected to it. 
If JARG = -1, the pivot point is a scalar point and no elements are 

JARG - ( connected to it. 

If JARG = 1, the pivot point is a grid point and no elements are connected 
to it. 

4.27.8.6 Subroutine Name: KR0D 

1. Entry Point: KR0D 

2. Purpose: To generate the element stiffness matrix for a R|3D element. 

3. Calling Sequence: CALL KR0D 

4.27.8.7 Subroutine Name: KBAR 

1. Entry Point: KBAR 

2. Purpose: To generate the element stiffness matrix for a BAR element. 

3. Calling Sequence: CALL KBAR 

4.27.8.8 Subroutine Name: KTUBE 

1. Entry Point: KTUBE 

2. Purpose: To generate the element stiffness matrix for a TUBE element. 

3. Calling Sequence: CALL KTUBE 

4.27.8.9 Subroutine Name: KPANEL 

1. Entry Point: KPANEL 

2. Purpose: To generate the element stiffness matrix for a SHEAR or TWIST panel element. 

3. Calling Sequence: CALL KPANEL (lARG) 



4.27-10 



FUNCTIONAL MODULE SMAl (STRUCTURAL rWRIX ASSEMBLER - PHASE 1) 

lARG i^^^^ " ^ "^^^ ^°^ generation of the matrix for a shear panel; 
(lARG = 5 implies a twist panel. 

4.27,8.10 Subroutine Name: KTRMEM 

1. Entry Point: KTRMEM 

2. Purpose: To generate the element stiffness matrix for a TRMEM element. 

3. Calling Sequence: CALL KTRMEM (I) 

( - Do complete triangular membrane. 

I 1 - Return 3 transformed 3x3 matrices only for pivot point. If I = 1, 
KTRMEM is called by KQDMEM. 

4.27.8.11 Subroutine Name: KQDMEM 

1, Entry Point: KQDMEM 

2, Purpose: To generate the element stiffness matrix for a QDMEM element. 

3, Calling Sequence: CALL KQDMEM 

4.27.8.12 Subroutine Name: KTRBSC 

1. Entry Point: KTRBSC 

2. Purpose: To generate the element stiffness matrix for a basic bending triangle 
element. 

3. Calling Sequence: CALL KTRBSC (I) 

!0 - Do complete element computation for basic bending triangle 
1 - Form only the [K^] 9x9 matrix. 
2 - Form only the [K^^] 9x9 matrix but save the [HT^ and [S] matrices. 
4.27.8.13 Subroutine Name: KTRPLT 

1. Entry Point: KTRPLT 

2. Purpose: To generate the element stiffness matrix for a triangular plate element. 

3. Calling Sequence: CALL KTRPLT 



4.27-11 



MODULE FUNCTIONAL DESCRIPTIONS 

4.27.8.14 Subroutine Name: KQDPLT 

1. Entry Point: KQDPLT 

2. Purpose: To generate the element stiffness matrix for a quadrilateral plate element. 

3. Calling Sequence: CALL KQDPLT 

4.27.8.15 Subroutine Name: KTRIQD 

1. Entry Point: KTRIQD 

2. Purpose: To generate the element stiffness matrix for any of the following elements: 
TRIA1JRIA2.QUAD1,QUAD2. 

3. Calling Sequence: CALL KTRIQD (lARG) 

il - TRIAl element. 
2 - TRIA2 element. 
3 - QUADl element. 
4 - QUAD2 element. 

4.27.8.16 Subroutine Name: KELAS 

1. Entry Point: KELAS 

2. Purpose: To generate stiffness matrix contributions from the ELASl ,ELAS2,ELAS3 and 
ELAS4 elements and structural damping matrix contributions from the ELASl ,ELAS2 and 
ELAS3 elements. 

3. Calling Sequence: CALL KELAS (lARG) 

lARG - Indicates the type of element being processed. It can take on the values 

1,2,3 and 4 denoting the ELASl .ELAS2,ELAS3 and ELAS4 elements respectively. 
Integer-input. 

4.27,8.17 Subroutine Name: KBEAM 

1. Entry Point: KBEAM 

2. Purpose: To generate the element stiffness matrix for a BEAM element. 

3. Calling Sequence: CALL KBEAM 



4.27-12 



FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

4.27.8.18 Subroutine Name: KC0NE 

1. Entry Point: KC0NE 

2. Purpose: To generate the element stiffness matrix for a conical shell problem. 

3. Calling Sequence: CALL KC0NE 

4.27.8.19 Subroutine Name: KTRIRG 

1. Entry Point: KTRIRG 

2. Purpose: To calculate an element stiffness matrix for a triangular cross-section 
ring, TRIARG, element. 

3. Calling Sequence: CALL KTRIRG 

4.27.8.20 Subroutine Name: KTRAPR 

1. Entry Point: KTRAPR 

2. Purpose: To calculate an element stiffness matrix for a trapezodial cross-section 
ring, TRAPR6, element. 

3. Calling Sequence: CALL KTRAPR 

4.27.8.21 Subroutine Name: KT0RDR 

1. Entry Point: KT0RDR 

2. Purpose: To calculate an element stiffness matrix for a toroidal thin shell ring. 
T0RDRG, element. 

3. Calling Sequence: CALL KT0RDR 

4.27.8.22 Function Name: OKI 

1 . Entry Point: DKI 

2. Purpose: To evaluate integrals in double precision for the triangular and 
trapezoidal cross-section rings in subroutines KTRIRG and KTRAPR. 

3. Calling Sequence: DP = DKI (I.J,K,L.M,N,IP,IQ,R,Z) 



4.27-13 



MODULE FUNCTIONAL DESCRIPTIONS 

I.J - The subscripts of R defining two lines on the limit of integration, 

integer-input. 
K. L . The subscripts of R, Z defining another line on the limit of integration, 

integer-input. 
M, U - The subscripts of R, Z defining the fourth line on the limit of 

integration, integer-input. 
IP.IQ - Integers that define the power of the r and z variables respectively, 

- input. 
R,Z - Vectors of the r and z coordinates of all points used to describe the 

area of integration, double precision - input. 

4.27.8.23 Function Name: DKK 

1. Entry Point: DKK 

2. Purpose: To calculate the slope of a line given two points in function DKI. 

3. Calling Sequence: DP = DKK (I.J.R.Z) 

I.J - The subscripts of R, Z defining the two points. 
R. Z - Vectors of the r and z coordinates. 

4.27.8.24 Function Name: DKM 

1. Entry Point: DKM 

2. Purpose: To calculate the y-intercept of a line given two points in function DKI. 

3. Calling Sequence: DP = DKM (I,J,R,Z) 

I, J - The subscripts of R, Z defining the two points. 

R, Z - Vectors of the r and z coordinates. 

4.27.8.25 Function Name: DKINT 

1. Entry Point: DKINT 

2. Purpose: To evaluate the following function in the F0RTRAN function routine DKI: 



4.27-14 



where 



and 



FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 



1 w 
fi(A,B) = -L z CPEF . A^ • B*^'^ • AJ (20) 

" t=0 



h ±i|±i for t ^ 
s=i s 

C0EF '\ (21) 

1 for t = 



RfJl (w+v-t+1) p,,, (w+v-t+1) 

^^ ^ ^ , f[^l 1 for (w+v-t+1 ) / 

^"'^tlfy-' ^°^ (w+v-t+i) = 



AJ 



3. Calling Sequence: DP = DKINT (I,J,A,B,V,W,R,Z) 
I, J - The subscripts of R, Z. 

A, B - The arguments of the function f in Equation 20. 
V, W - Integer parameters of the function. 
R. Z - Vectors of the r and z coordinates. 

4.27.8,26 Function Name: DKJ 

1. Entry Point: DKJ 

2. Purpose: To evaluate the following function in function DKINT. 

r R(j) ^^-^^^ -R(i) ^'^^^ , ,, , „ 

l-i— ^ g ^ ] ^ for s+1 ^ 

DKJ = < 

(ln[|^] for s+1 = 



3. Calling Sequence: DP = DKJ (I.J.R.S) 
I.J - The subscripts of R 



(22) 



(23) 



4.27-15 



MODULE FUNCTIONAL DESCRIPTIONS 

R - Vector of the r coordinates. 

S - Integer parameters of the function. 

4.27.8.27 Function Name: DKEF 

1. Entry Point: DKEF 

2. Purpose: To evaluate the following function in function DKINT 

^ w=sli for t ?* Q 
s=l s 

I] for t = 0. 

3. Calling Sequence: DP = DKEF (T.W) 

Xj W - Integer parameters of the function. 

4.27.8.28 Function Name: DK89 

1. Entry Point: DK89 

2. Purpose: To evaluate the following function in function DKI. 



DKEF= <'-' ' (24) 



T ^ <^ f25l 

DK89(I.A.B) = -4^ Z M! {-A)' • d , ^ ' 

b" ' s=0 



where 



d = 



| (M-S)! SKM+1-N-S) ^°'^ ^"^' N b) ^ u 

hn(|A + B-R(I)I) f-r (M+l-N-S) = 
' (M+ 1 -N)! (N-1)! ^°^ ^" ' ^' 



3. Calling Sequence: DP = DK89 (I,A,B,M,N,R) 

I - The subscript of R. 

A, B - The arguments of the function. 

M, N - Integer parameters of the function. 

R - Vector of the r coordinates 

4.27.8.29 Function Name: DKIOO 

1. Entry Point: DKIOO 

4.27-16 



(26) 



FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

2. Purpose: To evaluate the following function in subroutine DKI. 

, M+N-2 
DKlOOd.A.B) = (f^;^.^) I (M+N-2) !-d , (27) 



where 



(A+B-R(I})^^-^-^^-(-B)^ for (M-l-S) / 

(M+N-2-S)! S! (M-l-S)-R(I)'""^"^^ 
d = ( (28) 

A+B R(i; 



Mtlnn( 



,,, ROT 
(M-1)!(N-1)! 



for (M-l-S) = 



3. Calling Sequence: DP= DKIOO (I ,A,B,M,N,R) 

I - The subscript of R. 

A, B - Ihe arguments of the function. 

H, U - Integer parameters of the function. 

R - Vector of the r coordinates. 

4.27.8.30 Function Name: KFAC 

1. Entry Point: KFAC 

2. Purpose: To evaluate the factorial function in functions DK89 and DKIOO. 

3. Calling Sequence: K = KFAC (N) 

N - The integer argument of the function. 

If N < 2, the functional value is set to 1. 

4.27.8.31 Function Name: DKJAB 

1. Entry Point: DKJAB 

2. Purpose: To evaluate the following function in F0RTRAN function DKI using the 
function evaluated in F0RTRAN function DK89. 

DKJAB(I.A.B) = R(I)^1n(|A^B.R(I)|) _B .p^3g(^^^^3^_ 



4.27-17 



(29) 



MODULE FUNCTIONAL DESCRIPTIONS 

3. Calling Sequence: DP= DKJAB (I,A,B,M,N,R) 

I - The subscript of R. 

A, B - The arguments of the function. 

M, N _ Integer parameters of the function. 

R - Vector of the r coordinates. 

4.27.8.32 Function Name: DK219 

1. Entry Point: DK219 

2. Purpose: To evaluate the following function in F0RTRAN function DKI using the 
function evaluated in FORTRAN function OKI 00. 

0K219 (l.A.B) = -MlAiimil (30) 

M.R(I)'^ 

+ ^ • DKIOO (I.A.B) 

3. Calling Sequence: DP= DK219 (I.A.B.M.N.R) 

I - The subscript of R. 

A, B - The arguments of the function. 

M, N - Integer parameters of the function. 

R - Vector of the r coordinates. 

4.27.8.33 Function Name: DK211 

1. Entry Point: DK211 

2. Purpose: To evaluate the following function in F0RTRAN function DKI. 

iO for B-R(I) = A 

^ln(|2-B-R(I)|)]^ for B-R(I)?«A. [B-R(I)]^=A^ 

[ln|A|].[!n|R(I)|] - tfi p[^:^^]^ for [B-R(I)]^ < A^ ^^l) 

iln(|B-R{I)|)]^ + E ir -A f for [B-R(I)]^ > A^ 
'- t=i ^ Lb-r(I)J 



4.27-18 



FUNCTIONAL MODULE SMA1 (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

3, Calling Sequence: DP = DK211 (I.A.B.R) 

I - The subscript of R. 
A, B - The arguments of the function. 
R - Vector of the r coordinates. 

4.27.8.34 Subroutine Name: R0MBDK 

1. Entry Point: R0MBDK 

2. Purpose: To evaluate integrals in double precision for the toroidal thin shell 
ring in subroutine KT0RDR. 

3. Calling Sequence: CALL R0MBDK (A, B,N0SIG, PRECIS, NUM. ITD!aNE,FINTG,K0DE,FUNCT,X) 

A, B - Lower and upper limit of integration respectively. 

N0SIG - Number of correct significant digits desired. 

PRECIS - Actual number of significant digits attained. 

NUM - Maximum number of halvings of the interval [A,B] to be made. 

ITD0NE - Actual number of halvings of the interval [A,B]. 

FINTG - Resultant value of integral. 

K0DE - Print control (not used). 

FUNCT - Function subprogram used to evaluate the integral. 

X - Vector of parameters used by function subprogram. 

4.27.8.35 Function Name: D4K 

1. Entry Point: D4K 

2. Purpose: To evaluate the following function to be integrated by subroutine R0MBDK. 

D4K = ;^^-sin'^ ^_ (32) 

Ri-R -sin oii+R -sin ai-cos ({)+R -cos oi-sin^ * 

r r r 

3. Calling Sequence: DP = D4K (X) 

X - Vector of function parameters. 

X(l) - 

X(2) - R„ 



P 
X(3) - R 



1 

4.27-19 



MODULE FUNCTIONAL DESCRIPTIONS 

X(4) - cos aj 
X(5) - s1n oi 
X(6) - J + 1 

4.27.8.36 Function Name: D5K 

1. Entry Point: D5K 

2. Purpose: To evaluate the following function to be integrated by subroutine R0MBDK. 



D5K = <{)'^-2-sin(j)-coS(j) . (33) 

Ri-R -sinai + R -sinai cosi^i + R-cosai -si n(|) 



3. Calling Sequence: DP= D5K (X) 



X 


- 


Vector of function parameters 


X(l) 


- 


<t> 


X(2) 


- 


\ 


X{3) 


- 


^^ 


X{4) 


- 


cos ai 


X(5) 


- 


sin ai 


X(6) 


- 


J + 1 



4.27.8.37 Function Name: D6K 

1. Entry Point: D6K 

2. Purpose: To evaluate the following function to be integrated by subroutine R0MBDK. 

J 2 

rjCi' - t]) cos (j) /jA) 

Ri-R -sinai + R -sinai •coscfi + R •cosai-sincf) 

r r r 

3. Calling Sequence: DP = D6K (X) 

X - Vector of function parameters. 

X(l) - <!> 

X(2) - Rp 

X(3) - R^ 

X(4) - cos ai 



4.27-20 



FUNCTIONAL MODULE St4Al (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

X(5) - sin ai 
X(6) - J + 1 

4.27.8.38 Subroutine Name: DMATRX 

1. Entry Point: DMATRX 

2. Purpose: To form the element stiffness matrix in field coordinates for the toroidal 
thin shell ring in subroutine KT0RDR. 

3. Calling Sequence: CALL DMATRX (D,V,C,CA,CA2,VA,DM,DB,YI) 

D - Resultant stiffness matrix. 

V.CCA, 

CA2,VA, - Terms used in the evaluation of the stiffness matrix. 

DM.DB 

YI - Array of integral values. 
4.27.9 Design Requirements 
4.27.9.1 Open Core Design 

The open core common block for module SMAl is defined by the following F0RTRAN statements; 

1. D0UBLE PRECISION DZ(1) 

2. INTEGER IZ(1) 

3. C0MM0N /SMAIX/ Z(l) 

4. EQUIVALENCE (Z(l ) ,IZ(1 ) ,DZ(1 )) . 

The open core layout is given in Figure 1. 



4.27-21 



MODULE FUNCTIONAL DESCRIPTIONS 



ICSTM 
IMATl 



IGPCT 



IP0INT 



I6X6K 




IGGPST 

IGGPCT 

IGECPT 

IG4GG 

IGKGG 



C0MH0N /SMAIX/ 



CSTM Data 



MPT and DIT 
read in core by 
PREMAT and fetched 
by MAT 



GPCT Data 



Pointer table defined 
ir Equations 1 and 2 



Subma trices for KGGX 
and K4GG for the current 
pivot point. 



GIN0 buffer for GPST 



GIN0 buffer for GPCT 



GIN0 buffer for ECPT 



GIN0 buffer for K4GG 



GIN0 buffer for KGGX 



Figure 1. Open core layout for module SMAl. 



4.27-22 



FUNCTIONAL MODULE SMAl (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

The definition of the variables is as follows: 

ICSTM - The zero pointer to the CSTM portion of open core; defined to be zero. 

IMATl - The zero pointer to the MPT and DIT data read into core by subroutine PREMAT; 
defined to be ICSTM + NCSTM, where NCSTM is the length of the CSTM portion 
of open core. 

IGPCT - The zero pointer to the 6PCT portion of open core; defined to be IMATl + MATCR, 
MATCR being the length of open core used by subroutine PREMAT. 

IP0INT - The zero pointer to the pointer table in open core. The pointer table is used 
as a dictionary to relate the GPCT to the submatrices in core; defined to be 
IGPCT + NGPCT, NGPCT being the length of the GPCT. 

I6X6K - The zero pointer to the submatrices of KGGX; I6X6K = (IP0INT + NP0INT -1)/ 
2+2 where NP0INT = NGPCT is the length of the pointer table. The extra 
arithmetic to define I6X6K is necessary because the submatrices are double 
precision numbers. While the above indices are single precision indices, 
I6X6K is a double precision index. 

16X64 - The zero pointer to be submatrices of K4GG; 16X64 = I6X6K + N6X6K, where 

N6X6K is the number of double precision numbers in the submatrices of KGGX. 
16X64 is a double precision Index. 

The pointers for the GIN0 buffers, IGGPST, IGGPCT, IGECPT, I64GG and IGKGG are, 
unlike the above, 'one' pointers. It should be noted that the lengths NCSTM and MATCR are 
constant throughout the module operation, while the length of the GPCT data will vary from pivot 
point to pivot point as the ECPT and GPCT data blocks are processed serially. (Hence it is 
probable that for a pivot point with a relatively small number of elements connected to it the 
entire submatrix may be held in core, while spill logic will be entered only when a pivot point 
has a great many elements connected to it.) 

4.27.9.2 Block Data Subprogram 

The block data program SMAIBD sets GIN0 file numbers, 1/0 parameters and SMAl overlay 
parameters in common blocks /SMAl 10/ and /SMAlCL/. 

4.27.9.3 Common Storage Requirements 

Blank common is used only tor DMAP parameters. The following common blocks are used 
throughout the module: /SMAl 10/, /SMAlBK/, /SMAlCL/, /SMAIET/ and /SMAl DP/. They are given 
in detail here since other matrix assembler modules such as SMA2 and DSMGl are designed similarly. 
All common block variables are integer except (1) D0DET in /SMAlCL/ which is a logical variable; 
(2) the array in /SMAIET/ which is a mixed (integer and real) array; and (3) the double 
precision array in /SMAl DP/. 

4.27-23 



MODULE FUNCTIONAL DESCRIPTIONS 

1. The SMAl 1(2 common block is 36 words in length and is used for SMA1 input/output 
parameters. 

Definition 

GIN0 file number for the CSTM data block. 

GIN0 file number for the MPT data block. 

GIN0 file number for the DIT data block. 

Undefined. 

GIN0 file number for the ECPT data block. 

GIN0 buffer pointer for the ECPT. 

GIN0 file number for the GPCT data block. 

GIN0 buffer pointer for the GPCT. 

Undefined. 

GIN0 file number for the KGGX data block. 

GIN0 buffer pointer for KGGX. 

GIN0 file number for the K4GG data block. 

GIN0 buffer pointer for K4GG. 

GIN0 file number for the GPST data block. 

GIN0 buffer pointer for the GPST. 

Input with rewind option for subroutine 0PEN. 

Output with rewind option for subroutine 0PEN. 

Close without rewind option for subroutine CL0SE. 

Close with rewind option for subroutine CL0SE. 

No end-of-record indicator for subroutine READ. 

End-of-record indicator for subroutine READ. 

Matrix control block for the KGGX matrix. 

Matrix control block for the K4GG matrix. 

2. The SMAIBK common block is 10 words in length and is used -For SMAl open core bookkeeoing 
parameters. It contains zero pointers and lengths for the various sub-arrays in open core. 



Word Number 


Variable 


1 


IFCSTM 


2 


IFMPT 


3 


IFDIT 


4 


IDUMl 


5 


IFECPT 


6 


IGECPT 


7 


IFGPCT 


8 


IGGPCT 


9-10 


IFGEI.IG 


11 


IFKGG 


12 


IGKGG 


13 


IF4GG 


14 


IG4GG 


15 


IFGPST 


16 


IGGPST 


17 


INRW 


18 


0UTRW 


19 


CLSNRW 


20 


CLSRW 


21 


NE0R 


22 


E0R 


23-29 


MCBKGG 


30-36 


MCB4GG 



4.27-24 



FUNCTIONAL MODULE SMAl (STRUCTURAL- MATRIX ASSEMBLER - PHASE 1) 



Word Number Variable 



ICSTM 



2 


NCSTM 


3 


IGPCT 


4 


NGPCT 


5 


IP0INT 


6 


NP0INT 


7 


I6X6K 


8 


N6X6K 


9 


16X64 


10 


N6X64 



Definition 

Zero pointer to the CSTM sub-array in open core. For 
example the first location of this sub-array is referenced 
as IZ (ICSTM +1). 

Length of the CSTM sub-array in open core. 

Zero pointer to the GPCT sub-array in open core. 

Length of the GPCT sub-array. 

Zero pointer to the POINT sub-array in open core. 

Length of the P0INT sub-array. 

Zero pointer to the 6x6 submatrices of KGGX. 

Number of words allocated to the 6x6 submatrices of KGGX. 

Zero pointer to the 6x6 submatrices of K4GG. 

Undefined. 



3. The SMAICL common block is 133 words in length and is used for module control parameters. 



Word Number Variable 

1 I0PT4 

2 K4GGSW 

NPVT 
LEFT 
FR0WIC 



LR0WIC 



NR0WSC 
TNR0WS 



Definition 

Indicator used by element routines denoting whether or not 
the K4GG matrix will be generated. I0PT4 = 0, implies no 
generation; I0PT4 = 1 implies generation. 

Indicator set to -1 initially. If I0PT4 = 1, then element 
routines will set K4GGSW = 1, when a non-zero element 
structural damping matrix is generated. 

The scalar index which is the pivot point. This is the first 
word of every record of the ECPT data block. 

The number of words of open core remaining after all sub- 
airays in open core have been allocated. 

The first row of the submatrices in core. If all six rows 
o-f the matrices to be generated cannot be held in core, spill 
logic is initiated, and 3, 2 or 1 rows of the submatrices are 
generated during each pass of the ECPT record for the pivot 
point which causes the spill. FR0WIC can take on the values 
1,2,3,4,5 or 6. 

The last row of the submatrices in core. LR0WIC is defined as 
FR0WIC + NR0WSC -1, where NR0WSC is the number of rows in core. 
If there are no spill problems, then LR0WIC = 6 if the pivot 
point is a grid point, and LR0WIC = 1 if the pivot point is a 
grid point. 

The number of rows of the submatrices currently in core. 

Total number of rows of the submatrices to be generated. 
TNR0WS = 6 if the pivot point is a grid point and TNR0US = 1 
if the pivot point is a scalar point. This definition holds 
whether or not the K4GG matrix is to be generated. (In 
actuality, if the K4GG is generated the total number of rows 



4.27-25 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

Word Number Variable Definition 

generated for any ECPT record is 12 or 2). 

9 JMAX The number of columns of KGGX (and K4GG) to be generated with 

the current ECPT record. 

10 NLINKS The number of machine links (overlay segments) necessary to 

contain the module's element routines. Currently NLINKS is 
defined to be 3. This variable is used in conjunction with 
the LINK array defined below. For machines with large 
memories, it is desirable to have all element routines in one 
link, for when in any ECPT record there are elements which 
reside in different links, overlay overhead can be very costly 
(particularly on second generation computing systems). 

11-50 IjJVRLY Array of length 40 which defines in which link an element 

routine resides. I0VRLY(I) = 1,2 or 3 defines the link, 1 , 2 or 
3, in which the Ith element routine resides. Currently element 
numbers 2 and 35, the BEAM and the C0NE, reside in link 2; 
element numbers 36,37 and 38, the TRIARG, TRAPRG and the 
T0R0DRG reside in link 3; all other elements, except element 
numbers 31,32,33,39 and 40 which are not defined for the dis- 
placement method, reside in link 1. 

51-90 LINK Before the current ECPT record is read for the first time, the 

LINK array is set to -1 for LINK(I), 1=1, ...NLINKS. When 
the first element is read from the ECPT, the proper element 
routine is called, thereby loading the link in which that 
element routine resides. The variable LINC0R, the link in core, 
is defined as LINC0R = I0VRLY(ITYPE) , where ITYPE is the ele- 
ment's internal number, e.g., R0D = 1, BEAM = 2, etc. For the 
next element read from the ECPT, it is determined in what link 
it resides. If it resides in the link which is in core, the 
element routine is called. If the routine does not reside in 
the link currently in core, it is determined whether (a) the 
link has already been processed or (b) the link has not been 
processed in which case a "to-be-processed-later" flag is 
set. For case (a) LINK (ITEMP) is 1; for case (b) LINK(ITEMP) 
is set = 0, where ITEMP = I0VRLY(ITYPE). When an end-of- 
record is sensed for the ECPT, LINK(LINC0R) is set to 1 and 
LINK array is searched for zeros. If there are no zeros, the 
processing of the ECPT record is complete. If there are zeros, 
that is, links to be processed, the file corresponding to the 
ECPT is backspaced and processing of the record is repeated. 

91-130 NW0RDS NW0RDS(ITYPE) is the number of words in an ECPT entry for an 

element routine whose internal number is ITYPE. For ITYPE =1 
(a R0D), NW0RDS(1) = 17, for ITYPE = 34 (a BAR), NW0RDS(34) = 
42, etc. 

131 N0G0 Flag used to indicate if a user fatal error message occurred 

in the processing of any element. N0G0 = 1 indicates an error. 
Execution is terminated upon completion of the processing of 
the GPCT. N0G0 = indicates no error. Continue execution. 

132 IDETCK Used as a first pass indicator in the DETCK subroutine. There 

will be multiple passes through the DETCK routine, for each 
ECPT record, only if there are spill problems, i.e., the total 
number of rows to be generated for the ECPT record will not fit 
in core. 



4.27-26 (7/1/70) 



FUNCTIONAL MODULE SMA1 (STRUCTURAL MATRIX ASSEMBLER - PHASE 1) 

133 D0DET Logical variable which if true implies the DETCK routine will 

be called and if false will not be called. If the input para- 
meter, M0GENL, is greater than zero, implying general elements 
exist, then D0DET is set false. Otherwise D0DET is true. 

4. The common block SMAIET is 100 words in length and is used as the means of communicatina 
the element data from the ECPT data block to the element subroutines. 

5. The common block SMAIDP defines an array of 300 double precision words . This block is 
used as "scratch" storage by element routines. Those variables which in most FORTRAN 
programs would be local subroutine variables are defined in /SMAIDP/ by the module's element 
routines in order to preserve core storage and hence increase open core. 

4.27.9.4 Arithmetic Considerations 

All floating point arithmetic operations are carried out in double precision. Both 

[K^ ] and [K* ] are double precision matrices, 
yy yy 

4.27.10 Diagnostic Messages 

The module has a variety of "fail-safe" error checks. If any of these checks fails, it 
implies an obsure program design error or a computer operating system/hardware failure. 
Diagnostic messages 2022, 2023, 2034 are of this type. 

User fatal error messages 2025, 2026, 2031. 2032, 2033, 2035, 2036, 2037, 2038, 2039 
and 2040 occur when one of the structural element routines encounters some user data which 
makes generation of an element matrix impossible. Examples would include a user defining 
a R0D or BAR element of zero length; a user defining the four points of a SHEAR panel element 
not in the proper cyclical order; a user defining TRPLT data so that a matrix in an algorithm 
is non-singular; etc. Whenever this type of user fatal error occurs, the module queues all error 
messages and finishes processing all the data before terminating execution with a call to PEXIT. 

Detailed descriptions of these error messages can be found in section 6 of the User's Manual 



4.27-27 (7/1/70) 



FUNCTIONAL MODULE SMA2 (STRUCTURAL MATRIX ASSEMBLER - PHASE 2) 

4.28 FUNCTIONAL MODULE SMA2 (STRUCTURAL MATRIX ASSEMBLER - PHASE 2) 

4.28.1 Entry Point : SMA2 

4.28.2 Purpose 

To generate the mass matrix [M„„] and the damping matrix [B ]. 

99 r S U ggj 

4.28.3 DMAP Calling Sequence 

SMA2 CSTM,MPT,ECPT.GPCT,DIT/MGG,BGG/V,Y,WTMASS=1.O/V.N,N0MGG/V,N,N0BGG/V,Y, 
C0UPBAR=-1 $ 

4.28.4 Input Data Blocks 

CSTM - Coordinate System Transformation Matrices. 

MPT - Material Properties Table. 

ECPT - Element Connection and Properties Table. 

GPCT - Grid Point Connection Table. 

DIT - Direct Input Tables. 

Notes : 

1. The CSTM may be purged. 

2. If some element references a material property, the MPT cannot be purged. 

3. Neither the ECPT nor the GPCT may be purged. 

4. If some material property is temperature dependent, DIT cannot be purged. 

4.28.5 Output Data Blocks 

M6G - Partition of mass matrix - g set. 
BGG - Partition of damping matrix - g set. 

Notes : 

1. MGG cannot be pre-purged. 

2. BGG can be pre-purged. 



4.28-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.28.6 Parameters 

WTMASS - Input-real-default value (in DMAP calling sequence) = 1.0. WTMASS is the scalar 
value by which the generated mass matrix will be multiplied before the columns 
are packed onto the output file. WTMASS is the ratio of mass to weight. 

NiJMGG - Output-integer-no default value. N0MGG is set equal to -1 if the generated 
mass matrix is the zero matrix. Otherwise it is set = +1. 

NjJBGG - dutput-1nteger-no default value. If the BGG matrix is either pre-purged or is 
generated as the zero matrix, NjZBGG is set = -1. Otherwise it is set = +1. 

C0UPBAR- Input-integer-default value = -1. If C0UPBAR = -1, "consistent" mass matrices for 
all BAR elements will not be generated; if C0UPBAR > 0, "consistent" mass matrices 
for all BAR elements will be generated. 

4.28.7 Method 

SMA2 is structured similarly to module SMAl. A separate module was written to generate 
the mass and damping matrices in order to maximize the amount of open core space available 
for element matrices during matrix generation. This core space was especially critical on 
the development computer, the IBM 7094-7040 DCS. Since SMA2 is so similar to SMAl, the 
details of the similarities will not be repeated here; the differences will be pointed out. 
The reader 1s referred to the Module Functional Description (MFD) for SMAl (section 4.27). 

When all rows (or. In the case of spill, the number of rows in core) for each pivot 
point have been computed, each matrix element of [M ] is multiplied by WTMASS before being 
packed onto the output data block MGG. 

4.28.8 Subroutines 

SMA2, like SMAl, uses the utility routines PRETRD, PREMAT and GMMATD. 

The principal means of communicating an element entry of the ECPT to an element mass or 
damping matrix generation routine is through /SMA2ET/. This fact is not explicitly stated in 
each of the descriptions of the element routines (e.g., MR0D) given below. 



4.28-2 



FUNCTIONAL MODULE SMA2 (STRUCTURAL MATRIX ASSEMBLER - PHASE 2) 

The following list gives a correspondence between SMAl and SMA2 routines that are used only 
{directly or indirectly) by the axi symmetric shell element routines TRIARG and TRAPRG. All 
of the SMA2 routines are the same as their SMAl counterparts except for name. The reason for 
duplicating these routines with different names was to maximize open core for element matrices 
in SMAl and SMA2, which both reside in the same NASTRAN link. For details on each of the 
routines, see the corresponding SMAl counterpart (section 4.27.8). 

SMAl SMA2 

DKI DMI 

DKK DMK 

DKM DMM 

DKINT DMINT 

DKJ DMJ 

DKEF DMEF 

DK89 DM89 

DKIGO DM100 

KFAC MFAC 

DKJAB DMJAB 

DK219 DM219 

DK211 DM211 



4.28-3 



MODULE FUNCTIONAL DESCRIPTIONS 

4.28.8.1 Subroutine Name: SMA2 

1. Entry Point: SMA2 

2. Purpose: The module driver which parallels SMAl . For further details see the 
method section of the MFD for SMAl (section 4.27.7). 

3. Calling Sequence: CALL SMA2 

4.28.8.2 Subroutine Name: SMA2A 

1. Entry Point: SMA2A 

2. Purpose: To generate [M ] and [B ]. This routine parallels SI'IAIA. See the MFD 
for SMAl for details on SMAIA (section 4.27.8). 

3. Calling Sequence: CALL SMA2A. 

4.28.8.3 Subroutine Name: SMA2B 

1. Entry Point: SMA2B 

2. Purpose: To add a double precision 6 by 6 or 1 by 1 matrix [K®] to the "submatrix" of 
[M ] or [B ] corresponding to the current pivot point. 

3. Calling Sequence: CALL SMA2B (KE.J.II.IFILE.DOMDP) . 
KE.J.II are as defined for subroutine SMAIB (see section 4.27.8). 

IFILE - GIN0 file number of the matrix in cere being added to [M ] or [B ]-integer-input. 

DUMDP - A dumtty double precision argument added so that the calling sequence to 
SMA2B would conform to that of SMAIB. 

4.28.8.4 Block Data Program Name: SMA2BD. 

1. Purpose: To set GIN0 file numbers, 1/0 parameters and SMA2 overlay parameters in 
/SMA2I(5/ and /SMA2CL/. 



4.28-4 



FUNCTIONAL MODULE SMA2 (STRUCTURAL MATRIX ASSEMBLER - PHASE 2) 

4.28.8.5 Subroutine Name: MR0D 

1. Entry Point: MR0D 

2. Purpose: To generate the element mass matrix for a R0D element. 

3. Calling Sequence: CALL MR0D. 

4.28.8.6 Subroutine Name: MTUBE 

1. Entry Point: MTUBE 

2. Purpose: To generate the element mass matrix for a TUBE element. 

3. Calling Sequence: CALL MTUBE 

4.28.8.7 Subroutine Name: MASSTQ 

1. Entry Point: MASSTQ 

2. Purpose: To generate an element mass matrix for any of the two-dimensional 
structural elements listed under the Calling Sequence. 

3. Calling Sequence: CALL MASSTQ{IARG) 

4 = TRMEM 

1 = QDMEM 
3 = TRBSC 

3 = TRPLT 
7 = QDPLT 

5 = TRIAl 

4 = TRIA2 

2 = QUADl 
1 = QUAD2 

6 = SHEAR 
6 = TWIST 



lARG 



4,28-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.28.8.8 Subroutine Name: MBAR 

1. Entry Point: MBAR 

2. Purpose: To generate the "diagonal" (uncoupled) element mass matrix for a BAR 
element. 

3. Calling Sequence: CALL MBAR 

4.28.8.9 Subroutine Name: MCBAR 

1. Entry Point: MCBAR 

2. Purpose: To generate the "consistent" (coupled) element mass matrix for a BAR 
element, 

3. Calling Sequence: CALL MCBAR 

4.28.8.10 Subroutine Name: MC0NMX 

1. Entry Point: MCjJNMX 

2. Purpose: To generate an element mass matrix for either of the two concentrated- 
mass-elements listed under Calling Sequence. 

3. Calling Sequence: CALL MC0NMX(IARG) 

!1 " C0NM1 
2 = C0NM2 

4.28.8.11 Subroutine Name: MC0NE 

1. Entry Point: MC0NE 

2. Purpose: To generate an element mass matrix for the axisymmetric conical shell 
element (C(JNE). 

3. Calling Sequence: CALL MCjilNE 



4.28-6 



FUNCTIONAL MODULE SMA2 (STRUCTURAL MATRIX ASSEMBLER - PHASE 2) 
4.28.8.12 Subroutine Name: MASSD 

1. Entry Point: MASSD 

2. Purpose: To generate! by 1 element mass matrices for scalar elements MASS1, 1 = 1,2,3,4; 
and 1 by 1 element damping matrices for scalar dancing elements DAMPi , 1 = 1,2,3,4. 

3. Calling Sequence: CALL MASSD(I) 

1 - Generate element mass matrix for a MASSl element, 

2 - Generate element mass matrix for a MASS2 element, 

3 - Generate element mass matrix for a MASS3 element, 

4 - Generate element mass matrix for a MASS4 element, 

5 - Generate element damping matrix for a DAMPI element, 

6 - Generate element damping matrix for a DAMP2 element, 

7 - Generate element damping matrix for a DAMP3 element, 

8 - Generate element damping matrix for a DAMP4 element. 

4.28.8.13 Subroutine Name: MTRIRG 

1. Entry Point: MTRIRG 

2. Purpose: To generate an element mass matrix for a triangular cross-section ring, 
TRIARG, element. 

3. Calling Sequence: MTRIRG. 

4.28.8.14 Subroutine Name: MTRAPR 

1. Entry Point: MTRAPR 

2. Purpose: To generate an element mass matrix for a trapezoidal cross-section ring, 

TRAPRG, element. 

3. Calling Sequence: CALL MTRAPR. 

4.28.8.15 Subroutine Name: MT0RDR 
1. Entry Point: MT(3RDR 



4.28-7 



MODULE FUNCTIONAL DESCRIPTIONS 

2. Purpose: To generate an element mass matrix for a toroidal thin shell ring, TjJRDRG, 
element. 

3. Calling Sequence: CALL MT0RDR. 

4.28.8.16 Subroutine Name: BVISC 

1. Entry Point: BVISC 

2. Purpose: To generate an element damping matrix for a VISC element. 

3. Calling Sequence: Call BVISC 

4.28.8.17 Subroutine Name: MBEAM 

1. Entry Point: MBEAM 

2. Purpose: To generate an element mass matrix for a BEAM element. 

3. Calling Sequence: CALL MBEAM 

4.28.8.18 Subroutine Name: MCR0O 

1. Entry Point: MCR(3D 

2. Purpose: To generate the "consistent" (coupled) element mass matrix for any of the 
elements listed under calling sequence. 

3. Calling Sequence: CALL MCR0D (lARG) 

1 - R0D 
lARG = <; 1 - C0NR0D 
3 - TUBE 

4.28.8.19 Subroutine Name: MTRBSC 

1. Entry Point: MTRBSC 

2. Purpose: To generate the "consistent" (coupled) element mass matrix for a basic bending 
triangle element. 

3. Calling Sequence: CALL MTRBSC 



4.28-8 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

4.28.8.20 Subroutine Name: MTRPLT 

1. Entry Point: MTRPLT 

2. Purpose: To generate the "consistent" (coupled) element mass matrix for a triangular 
plate element. 

3. Calling Sequence: CALL MTRPLT 

4.28.8.21 Subroutine Name: MQDPLT 

1. Entry Point: MQDPLT 

2. Purpose: To generate the "consistent" (coupled) element mass matrix for a quadrilateral 
plate element. 

3. Calling Sequence: CALL MQDPLT 

4.28.8.22 Subroutine Name: MTRIQD 

1. Entry Point: MTRIQD 

2. Purpose: To generate the "consistent" (coupled) element for any of the following 
elements: TRIAl , TRIA2, QUADl , QUAD2. 

3. Calling Sequence: CALL MTRIQD (lARG) 

1 - TRIAl element. 

2 - TRIA2 element. 
lARG = 

'3 - QUADl element. 

4 - QUAD2 element. 



4.28-8a (12-1-69) 



FUNCTIONAL MODULE SMA2 (STRUCTURAL MATRIX ASSEMBLER - PHASE 2) 

4.28.9 Design Requirements 

4.28.9.1 Open Core Design 

The open core design for SMA2 is the same as that in SMAl with the exception that /SMA2X/ 
defines the beginning of open core and only four buffers are needed, one each for MGG, BGG, 
ECPT and GPCT. 

4.28.9.2 Common Storage Requirements 

The common storage requirements for SMA2 are similar to those in SMAl. The common blocks 
/SMA2i;j/, /SMA2BK/, /SMA2CL/, /SMA2ET/ and /Sf1A2DP/ of SMA2 correspond to /SMAl 10/, /SMAIBK/, 
/SMAICL/, /SMAIET/ and /SMAIDP/ of SMAl. See the MFD for SMAl (see section 4.27.9). The 
following differences are worthy of note. 

1. In /SMA2I0/, words 15 and 16 are undefined and words 23 through 36 define matrix 
control blocks for MGG and BGG. 

2. /SMA2CL/ is only 131 words in length, the last two words of /SMAICL/ being reserved 
for variables unique to SMAl. 

4.28.9.3 Arithmetic Considerations 

Floating point arithmetic operations are carried out in double precision. Both [M ] 

99 

and [B ] are real symmetric double precision matrices. 

4.28.10 Diagnostic Messages 

See the diagnostic message section in the MFD for SMAl (section 4.27.10). 



4.28-9 (7/1/70) 



FUNCTIONAL MODULE GPWG (GRID POINT WEIGHT GENERATOR) 

4.29 FUNCTIONAL MODULE GPWG (GRID POINT WEIGHT GENERATOR) 

4.29.1 Entry Point : GPWG 

4.29.2 Purpose 

To compute the center of mass of the structure and find the principal inertias about a 
given point. 

4.29.3 DMAP Calling Sequence 

GPWG BGPDT,CSTM,EQEXIN,MGG/0GPWG/V,Y,GRDPNT/V,Y,WTMASS $ 

4.29.4 Input Data Blocks 

BGPDT - Basic Grid Point Definition Table. 

CSTM - Coordinate System Transformation Matrices. 

EQEXIN - Equivalance between external grid or scalar numbers and Internal numbers. 

MGG - Partition of mass matrix - g set. 

Notes: 1. BGPDT, EQEXIN and MGG cannot be purged. 

2. CSTM must be present if some grid point of the model is not in basic 
coordinates. 

4.29.5 Output Data Blocks 

0GPWG - Grid Point Weight Generator Output Table. 
Notes: This data block cannot be purged. 

4.29.6 Parameters 



GRDPNT - Input-integer-default = -1. GRDPNT selects the grid point about which the 

inertias will be calculated. If GRDPNT is not the external ID of a geometric 
grid point, the basic origin is used. 

WTMASS - Input-real-default = 1.0. WTMASS gives the ratio of mass to weight for the 
structure. All output quantities are in weight units. 



4.29-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.29.7 Method 

The Grid Point Weight Generator module calculates the masses, centers of gravity, 
and inertias of the general mathematical model of the structure. The data are extracted from 
the [M ] matrix by using a rigid body transformation calculation. Global coordinate dis- 
placements are converted to translations and rotations about a reference point. 

Because of the scalar mass effects, the total mass may have directional properties, 
and the center of gravity may not be a unique location. This effect is shown in the output 
by giving for each of the three masses its own direction and center of gravity. The inertia 
terms are calculated by using the directional mass effects. The axes about which the inertia 
terms are calculated may not intersect. However, these axes are those which provide un- 
coupled rotation and translation effects. This is the significance of the term "center of 
gravity". If the structural model has been constructed using only real masses, the three masses 
printed out will be equal, the center of gravity will be unique, and the axes of the inertia 
terms will intersect at the center of gravity. 
The actual computation proceeds in 4 parts. 

1. Computation of the [of matrix takes place in subroutine GPWGIA. Six vectors are formed 
which describe the six motions about the reference point. The matrix [D] formed from the 
vectors will describe rigid body displacements in global coordinates in terms of motion 
at the reference point: 

(u } = [D] {u } (reference point). (1) 

The method of generation is as follows: 

EQEXIN is placed in core and searched for GRDPNT to obtain its internal sequence 

number. If GRDPNT is not in EQEXIN or points to a scalar point, the basic origin is used. 

Assuming GRDPNT is a physical grid point, BGPDT is read to obtain {R^} for the reference 

point. The BGPDT file is then rewound. CSTM (if present) is placed in core and readied for u 

by subroutine PRETRS. Each grid point in the BGPDT is considered in order. If it is a 

scalar point, zero is stored in each of the six columns of [D] . 



If it is a grid point, 

{r.} = {R^} - {Rq} =|'"2| ' ^2) 



4.29-2 



FUNCTIONAL MODULE GPWG (GRID POINT WEIGHT GENERATOR) 



,th 



is computed where {R^} is the location of the i grid point and {R } is the location of 
the reference point. 

The transformation matrix to the grid point, 



[T,] 



rg -r^ 



■•"3 ^1 
L^2 -•'l . 



(3) 



is formed. Subroutine TRANSS calculates the 3x3 transformation matrix [T.] from global 
coordinates to basic coordinates for the grid point. The matrix 



[d] = 



T.' ' T.' T 
1 I 1 r 



° : ^i' 



(4) 



is computed. The rows of [d] form the columns of [D]^ and are packed out onto a scratch 
file. 

2. If all points were scalar points, GPWG returns; otherwise subroutine TRANPl is 
called to form [D] from [D]^. 

3. [M ] is computed by two calls to subroutine SSG2B, 



[Mq] = [D]^ [Mgg] [D]. 



4. Output quantities are computed as follows: 



Mq is unpacked, output and partitioned as follows: 



[M,]= 






(The matrix is symmetric). 

A check is made for inconsistent scalar masses. Let 

5 = |det [M*]|, 
and 



(5) 



(6) 



(7) 



E =• V2:(FT.J)2 i ^ J. 



(8) 



4.29-3 



MODULE FUNCTIONAL DESCRIPTIONS 

If _£ > 10"^, the coordinates should be rotated. Otherwise [S] = [I]. If rotation 

6 

is necessary, the eigenvectors of [M*], {e^} , {e2} , and {63}, are determined by the 
Jacobi technique. Define 

[S] = [ {e^} . {62} . {63} ]. (9) 

The [S] matrix is output, [M*], [m""] and [M^""] are computed as follows: 

[M*] = [sf [M*] [S], (10) 

[M^""] = [sf [Ff*""] [S], (11) 

[m""] = [Sf [M^] [S], (12) 

The follovt'ing terms are calculated and output: the mass terms: 

(13) 
(14) 

(15) 

i. jj 

and the "centers of gravity": 

t = 11 Y = — li— 7 = J^ (16) 

X A A 

Mo^ ^To -^Ti 

The inertias are: 

h^ - "n - ^ ^y - ^ 'I ' ^''^ 

^21 = X2 - "z h \ ' ^20) 

h^ = < - ^^h' ^21) 

^22 = ^22 - ^ '^z - \ i ' (22) 



4,29-4 



\ 


= 


^11- 


^ 


= 


M22. 


^ 


= 


M53. 



FUNCTIONAL MODULE GPWG (GRID POINT WEIGHT GENERATOR) 

^23 = -"23 - \ \ \ . (23) 

I33 = "53 - W^ - y/ ' (24) 

These terms form the symmetric matrix [I], 
For principle inertias eigenvalues and eigenvectors are found such that: 



Ml tP 

22 

iP 
^33 



[Q]^ [I] [Q]. (25) 



[Q] contains the normalized eigenvectors (the directions of the principal inertias), and 
the iP. terms are the eigenvalues. The matrices [S] and [Q] are actually coordinate 
rotation matrices and show the directions of the principal masses and inertias. 

4,29.8 Subroutines 

Utility Subroutines PRETRS.TRANSS.TRANPl ,SSG2B and GMMATS are used. See subroutine 
descriptions, section 3. 

4.29.8,1 Subroutine Name: GPWGIA 

1. Entry Point: GPWGIA 

2. Purpose: To form the [D]^ matrix. 

3. Calling Sequence: CALL GPWG1A(P0INT,BGPDT,CSTM,EQEXIN,DT,N0G0) 

P0INT - External grid point id of reference point - integer - input. 

BGPDT - GIN0 file number of 0GPWG - integer - input, 

CSTM - GIN0 file number of CSTM - integer - input. 

EQEXIN - cm file number of EQEXIN - integer - input. 

°^ - "^INU file nutitoer of file on which [D]^ will be written - integer - input. 

N0Gia - Flag for all scalar problem - integer - output. N0G0 = implies all 
scalars. 

4.29.8.2 Subroutine Name: GPWGIB 

1. Entry Point: GPWGIB 



4.29-5 //t> 



MODULE FUNCTIONAL DESCRIPTIONS 

2. Purpose: To form output quantities as given in paragraph 4 of section 4.29.7. 

3. Calling Sequence: CALL GPWGIB (M0,0GPWG,WTMASS,IP) 

Mj8 - GIN0 file number of [M^^] matrix - integer - input. 

0GPWG - GIN0 file number of 0GPVJG - integer - input. 

ViTMASS - Mass to weight ratio parameter - real - input. 

IP - External grid point id of reference point (=0 if basic origin was used) 

- integer - input. 

4.29.8.3 Subroutine Name: GPW61C 

1. Entry Point: GPWGIC 

2. Purpose: To compute eigenvectors and values of a 3 by 3 matrix by the classical Jacobi 
method. 

3. Calling Sequence: CALL GPWGIC (B.E.EV.IFLAG) 

B - 3 by 3 input matrix - real - input. 
E - 3 by 3 matrix of eigenvectors - real - output. 
Ev - 3 eigenvalues - real - output. 

IFLAG - Error termination flag - integer - output. If IFLAG > 0. GPWGIC could 
not converge. 



4.29.9 Design Requirements 

GPUG requires four scratch files. Open core for GPWGIA is defined at /GPWGAl/. Open 
core for GPWGIB is defined at /GPWGBl/. 

The layout of open core is as follows: 

C0MM0N /GPWBGl/ 



CSTM 



1 BGPDT entry 



CSTM Data Block 
16 words per entry 

GIN0 buffer 



4.29-6 



FUNCTIONAL MODULE GPWG (GRID POINT WEIGHT GENERATOR) 



C0MM0N /GPWGAl/ 




36 words for 5 by 6 matrix 



GIN0 buffer 



4,29.10 Diagnostic Messages 



The following fatal error messages may occur: 3007, 3008. 



4.29-7 



FUNCTIONAL MODULE SMA3 (STRUCTURAL MATRIX ASSEMBLER - PHASE 3) 

4.30 FUNCTIONAL MODULE SMA3 (STRUCTURAL MATRIX ASSEMBLER - PHASE 3) 

4.30.1 Entry Point : SMA3 

4.30.2 Purpose 

To generate the final stiffness matrix, [K ], by generating a matrix of order g for each 
general element in the model, and successively adding this matrix to [K^ ], the stiffness matrix 
exclusive of general elements. 

4 . 30 . 3 DMAP Calling Sequence 

SMA3 GEI,KGGX/KGG/V,N,LUSET/V,N,N0GENL/V,N,N0SIMP $ 

4.30.4 Input Data Blocks 

GEI - General Element Input. 

KGGX - Partition of stiffness matrix exclusive of general elements - g set. 

Note : 

1. GEI cannot be pre-purged. 

2. KGGX may be pre-purged. This implies that the model consists entirely of general 
elements (i.e., there are no simple elements). 

4.30.5 Output Data Blocks 

KGG - Partition of stiffness matrix - g set. Contains contributions from all elements 
in the model, including general elements. 

Note : KGG may not be pre-purged. 

4.30.6 Parameters 

LUSET - Input-integer-no default value. LUSET is the total number of degrees of 
freedom in the g displacement set. It is the order of the [k'' 1 and [K 1 

gg gg 

matrices. 

N0GENL - Input-integer-no default value. N0GENL is the number of general elements in 
the GEI data block. 



4.30-1 



MODULE FUNCTIONAL DESCRIPTIONS 



N0SIMP - Input-integer-no default value. If N0SIMP < 0, [K ] does not exist, i.e., all 
elements of the model are general elements. If N0SIMP > 0, [K^ ] does exist, 

4.30.7 Method 



4.30.7.1 Mathematical Considerations 

Two matrices can be used to form a stiffness matrix for each general element in the GEI 
data block: a flexibility influence coefficient matrix, [Z], and a rigid body matrix, [S]. 
The former must be present and must be non-singular; the latter may or may not be present. 
The set of degrees of freedom (scalar index numbers) used by [Z] is designated the "u-" set; 
the set of degrees of freedom used by [S] is designated the "u^" set. Call the length of the 
u. set m, and call the length of the u^ set n. [Z] is m by m, and [S] is m by n. 

For each general element in the model, the stiffness matrix correspondinn to the general 
element, [K^^J, is made up of four partitions if the u^ set exists. They are: 

■,-1 



[K.,] 



[z]- 



tS-d^ 



-It 



- [z]-'[s] , 



(0 

(2) 
(3) 
(4) 



The four matrices must be merged such that 1): 



[k9^] 



^i i ^d 



"di 



^ddJ 



(5) 



and 2) the rows and columns of [K^^] must correspond to a merged list of both u- and u^ 
coordinates in order of ascending scalar index numbers. 



If the u . set does not exist, then 



[K^^] = [K,-i] 



[z]- 



(6) 



4.30-2 



FUNCTIONAL MODULE SMA3 (STRUCTURAL MATRIX ASSEMBLER - PHASE 3) 

4.30.7.2 Initialization 

The GEI data block is opened, and the header record is skipped. It is determined whether 
the number of general elements, f, is even or odd. This is done to insure that the result of 
the final matrix addition, 

where 



[k'^'] = LC] + 'l [k9^^] . (8) 

yy 1=1 
and [K^^ ] is the final general element matrix, will be written on the output data block, KGG. 

If [K ] does not exist, and there is only one general element, then the GIN0 file number 
(201) for the KGG data block is stored in IFA, the variable which contains the GIN0 file number of 
the file onto which the current [K^^] matrix will be packed. 

The principal logic of the module driver, SMA3. is carried out in a loop in which, during 
each pass of the loop, a [K^^] matrix is generated and added, using subroutine SSG2C, to the 
running sum matrix, [K*"^]. 

4.30.7.3 Generation and Addition of a General Element Matrix 

The steps involved in the principal loop of the program are as follows: 

1. The loop counter is incremented. 

2. The first three words of the next logical record are read from GEI: the element id; 
the length of the u^- set, m; and the length of the u . set, n. 

3. The matrix control blocks for the scratch files IFB and IFC are interchanged 
provided that: 

a. this is not the first pass through the loop; 

b. this is not the second pass through the loop and^ the number of nereral element 
is odd and there are only general elements in the model; 

and 

c. this is not the second time through the loop and [K^ ] exists. 



4.30-3 



MODULE FUNCTIONAL DESCRIPTIONS 

4. It is determined whether the orders of the [Z] and [S] matrices are such that the 
in-core matrix routines GMMATD and INVERD can be used. This is accomplished as follows. 
Define 

p = 2{m + n + m^ + n^ + 2mn) , (9) 

q = 2(m + n + m^) + 3m , (10) 

and 

r = max(p,q) . (11) 

p is the number of computer words needed to store: 1) the u^. and u^ sets in two 
different sorts; 2) the double precision m by m [Z] matrix; 3) the double precision 
n by n [S]^[Z]"^[S] matrix; and 4) the double precision m by n [S] matrix and the double 
precision m by n [Z]" [S] matrix. 

q is the number of computer words needed to store: 1) the u^ and u^ in two different 
sorts; 2) the double precision m by m [Z] matrix; and 3) 3m cells of scratch storage 
to be used by subroutine INVERD. 

If r is less than the available amount of core, the in-core routine, SMA3A, is called 
to compute [K^®]. Otherwise: 1) SMA3B generates [Z] and - [S]^; 2) FACT0R decomposes 
[Z] into its triangular factors; 3) SSG3A computes [Z]"'; 4) SSG2B computes - [S] [Z]; 
5) TRANPl transposes - [S]^; 6) SSG2B computes -[Z][S]^; 7) SSG2B computes [S]^[Z]' [S]; 
and 8) SMA3C builds the final [K^^] matrix of order g by g. 

5. The matrix [K^^] having been generated as in step 4, SSG2C is called to add [K^^] to 

4.30.8 Subroutines 

Utility routines GMMATD, INVERD, FACTOR. SSG3A, SSG2B, TRANPl and SSG2C are used in this 
module. 



'1 9 ' 

4.30-4 ' "~ 



FUNCTIONAL MODULE SMA3 (STRUCTURAL MATRIX ASSEMBLER - PHASE 3) 

4.30.8.1 Subroutine Name: SMA3A 

1. Entry Point: SMA3A 

2. Purpose: To build a g by g general element matrix, [K^^], using the in-core matrix 
routines GMMATD and INVERD. 

3. Calling Sequence: CALL SMA3A (MCBA) 

C0MM0N /GENELY/ - see description below (section 4.30.9.2). 

MCBA - The matrix control block corresponding to [K^^]. Word 1 is input; words 
2 through 7 are output. 

4. Method: The u^ set and the u. set (if present) of scalar index numbers are read into 
core, and a list L is formed of length m + n, such that L(k) = l implies the il^*^ entry 

of the string: <^>J-j ]."•,- 2 "im'"dr"d2" " "'"dn^ ^^ *^® smallest. The m single 

precision elements of [Z] are read and stored at double precision locations. [Z]" is 
computed using INVERD. [S], if present, is read and stored at double precision locations. 
GMMATD is called twice to compute [Z]"^[S] and [S]^[Z]"^[S]. The elements of [K^^], as 
defined in Equation 5, are output to the GIN0 file corresponding to MCBA(l) with non-zero 
terms in the row and column positions specified by the u- and u» sets. The list L 
determines the sequence of elements to be output for any one column. 

4.30.8.2 Subroutine Name: SMA3B 

1. Entry Point: SMA3B 

2. Purpose: To create [Z] and [S] from the GEI data. 

3. Calling Sequence: CALL SMA3B (IFLAG) 

C!JMM0N /GENELY/ - see description below (section 4.30.9.2). 

IFLAG _il'''-AG = -1 implies [S] does not exist.) ,„4.»n»- «.,+„.,+ 
^^^'^^ ) IFLAG = 1 implies [S] exists. J - integer - output. 

4. Method: The GEI data block is read for the row numbers and non-zero terms of [Z]. 
These are output in standard NASTRAN matrix format by subroutine BLDPK. - [S]^ is generated 
in a similar manner. (- [S] is created rather than [S] for computational ease in subse- 
quent calculations - see paragraph 4 in section 4.30.7.3 above). 



4,30-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.30.8.3 Subroutine Name: SMA3C 

1. Entry Point: SMA3C 

2. Purpose: To create the [K^^] matrix from [Z]-\ - [Z]"^[S], - [sf [Z]"'' and [sf [Z]"'' [S]. 

3. Calling Sequence: CALL SMA3C (IFLAG, KE) 

C0MM0N /GENELY/ - see description below (section 4.30.9.2). 
C0I#I(3N //LUSET - size of problem. 

IFLAG is as described in SMA3B. Here it implies [K^^] = [Z]' . 
KE - Matrix control block for [K^^] - integer - input/output. 

4. Method: A matrix of g size is created from [Z]'\ - [Z]"^[S], - [S]^[Z] and [S]^[Z]"^[S] 
with the non-zero terms in the row and column positions specified by the u^ and u^ lists. 
This matrix can be added to the existing [k""^] to reflect the stiffness terms of this 
general element. 

4.30.8.4 Block Data Subprogram: SMA3BD 

Purpose: To initialize the GIN0 file numbers and GIN0 options indicators in /GENELY/, 
which is discussed below. 

4.30.9 Design Requirements 

4.30.9.1 Open Core Design 

The open core common block for the module driver SMA3 and subroutine SMA3A is defined by 
the following F0RTRAN statements: 

1. D(3UBLE PRECISION DQd) 

2. INTEGER IQ{1) 

3. DIMENSION Q(l) 

4. C0MM0N /GENELX/ Q 

5. EQUIVALENCE (iq(l ) ,DQ(1 ) ,Q(1 )) 

SMA3 uses open core only for one GIN0 buffer, which is reserved for the GEI data block while 
SMA3A, SMA3B, or SMA3C is executing, and which is reserved for use by SSG2C when this routine 
adds [K^^] to [k""^] at the end of the principal loop in the driver. 



4.30-6 



FUNCTIONAL MODULE SMA3 (STRUCTURAL fWRIX ASSEMBLER - PHASE 3) 

SMA3A uses low order open core as outlined in paragraph 4 in section 4.30.7 above. 

The open core for subroutine SMA3B is defined at /SMAB3/ and is used for two GIN0 buffers 
in high order open core. 

The open core for subroutine SMA3C is defined at /SMAC3/ and is used for: 1) the u. and u. 
sets in low order open core and 2) six GIN0 buffers in high order open core. 

4.30.9.2 Comnwn Storage Requirements 

The common block /GENELY/ is used for; 1) GIN0 file numbers; 2) GIN0 option indicators; 
3) matrix control blocks; and 4) zero pointers to sub-arrays in /GENELX/ when SMA3A executes. 
It is defined as follows: 

C0MM0N /GENELY/ IFGEl ,IFKGGX,IF(3UT,IFA,IFB,IFC,IFD,IFE,IFF,INRV;,0UTRW,CLSR!-J,CLSNRW,EPIR, 

NE0R,MCBA(7),MCBB(7),MCBC(7),MCBE(7),MCBF(7),MCBKGG(7),IUI,IUD,IZI,IS,IZIS,ISTZIS,IBUFF3(3), 

LEFT 



Variable 
IFGEI,IFKGGX,IF(3UT 

I FA 

IFB.IFC 

IFD.IFE.IFF 
INRW,0UTRW,CLSRW,CLSNRW,E0R,NE0R 

MCBA.MCBB MCBF.MCBKGG 

lUI.IUD.IZI.IS.IZIS.ISTZIS 



IBUFF3(3) 
LEFT 



Definition 



GIN0 file numbers for the two input data blocks 
and the output data block respectively. 

GIN0 file number for the current [K^^] being 
computed. 

GIN0 file numbers for [k""^] and [k""^] + [K^^] 
matrices. They are "flip-flopped" such that 
IFC = IF0UT for the final matrix addition. 

GIN0 file numbers for scratch files which are 
used in subroutine SMA3C. 

GIN0 option indicators as defined in section 
4.27.9.3. 

Matrix control blocks for the matrices corres- 
ponding to IFA, IFB IFF, and IFKGXX. 

Zero pointers to the sub-arrays in /GENELX/ , 

corresponding to: 1) u^. set; 2) u^ set; 3) [Z]" 

4) [S]; 5) [zr^[S] and 6) [sf [Z]-''[S]. Note 
that IZI, IZIS, ISTZIS are zero pointers into 
double precision arrays. 

Three word buffer which contains the general 
element id, m and n. 

The number of computer words currently remaining 
in /GENELX/. 



4.30-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4.30.9.3 Arithmetic Considerations 

All floating point arithmetic operations are carried out in double precision. 
4.30.10 Diagnostic Messages 

In SMA3A, system fatal error 2028 can occur. See section 6 of the User's Manual for details. 



4.30-8 



FUNCTIONAL MODULE GP4 (GEOMETRY PROCESSOR - PHASE 4) 

4.31 FUNCTIONAL MODULE GP4 (GEOMETRY PROCESSOR - PHASE 4) 

4.31.1 Entry Point : GP4 

4.31.2 Purpose 

GP4 assembles the various displacement sets and builds the displacement set definition 
table (USET). Additionally, for statics problems, GP4 analyzes subcases based on single-point 
and multipoint constraint sets, and sets parameters to control execution of the Rigid Format. 

4.31.3 DMAP Calling Sequence 

GP4 CASECC,GE(3M4.EQEXIN,SIL,6PDT/RG,YS,USET/V,N,LUSET/V,N,MPCF1/V,N,MPCF2/V,N. SINGLE/ 
V,N,!3MIT/V,N,REACT/V,N,NSKIP/V,N,REPEAT/V,N.N0SET/V,N,N0L/V,N,N0A $ 

4.31.4 Input Data Blocks 

CASECC - Case Control Data Table. 

GE0M4 - Displacement set definitions. 

EQEXIN - Equivalence between external grid or scalar and internal numbers. 

SIL - Scalar Index List. 

GPDT - Grid Point Definition Table. 

Note : Only GE0M4 may be purged. 

4.31.5 Output Data Blocks 

RG - Multipoint constraint equations matrix. 
YS - Constrained displacement vector(s) set. 
USET - Displacement set definition table. 

Note : YS may be purged. 

4.31.6 Parameters 

LUSET - Input-integer-no default. Degrees of freedom in the g-displacement set. 
MPCFl - Output-integer-no default. +1 if the current subcase contains multipoint 
constraints, -1 otherwise. 



4.31-1 



MODULE FUNCTIONAL DESCRIPTIONS 

IIPCFZ - Output; integer, no default. +1 if the current subcase contains a different 

multipoint constraint set from last the subcase, -1 if no new multipoint constraint 
set or no multipoint constraints in the current subcase. 

SINGLE - Output, integer, no default. +1 if the current subcase contains single-point 
constraints, -1 otherwise. 

(3MIT - Output, integer, no default. +1 if the model contains omitted coordinates, 
-1 otherwise. 

REACT - Output, integer, no default. +1 if the model contains supports, -1 otherwise. 

NSKIP - Input and output, integer, default = 0. Number of records to skip to reach 
the first record in the Case Control Data Block for the next subcase. 
(NSKIP = for the first subcase). 

REPEAT - Output, integer, no default. -1 if the current subcase is the last subcase in the 
problem, +1 otherwise. 

N0SET - Output, integer, no default. -1 if MPCFl = -1 and SINGLE = -1 and 0MIT = -1 
and REACT = -1 , +1 otherwise. 

N0L - Output, integer, default = +1. -1 If aJJ_ degrees of freedom in the model 

belong to dependent displacement sets (i.e. no degree of freedom belongs to 
an independent set), +1 otherwise. 

N0A - Output, integer, default = +1 . -1 if MPCFl = -1 and SINGLE = -1 and 0MIT = -1, 
+1 otherwise. 

4,31.7 Method 

CASECC is read for each case and subcase. Parameters are set to control the return 
point for the next subcase. The user-requested constraint set numbers are extracted and 
saved for control of the following steps. 

The multi-point constraint cards (MPC) each define a row of a constraint matrix equation: 

For each requested MPC set, the MPC card images are read from GE0M4, and tne grid points 
and their scalar coordinates (or scalar points) are converted to the scalar degree of freedom 

4.31-2 



FUNCTIONAL MODULE GP4 (GEOMETRY PROCESSOR - PHASE 4) 

numbers. The EQEXIN and SIL data blocks are placed in core, the point "id" number is found as the 
first entry of a pair in the first record of EQEXIN, the corresponding number in the second entry 
of the pair is the internal grid point index. The i position of the SIL contains the value of 
the scalar degree of freedom number for the first degree of freedom of point i. The SIL value, 
SIL , for the component c, (c=l,2 6) of a grid point p is found by the equation: 



SIL^ = SILp + (c - 1) . (2) 

The SIL of a point is the scalar index of its first degree of freedom. The point "id's" 

and components given on the MPC cards are converted to scalar index numbers, a sorted list is 

formed of the u scalar indices, (see defintion belovj of the sets defined in USET) , and the 

m 

data are written on SCRl , a scratch file. Each term in the equation is paired with a packed 
word giving its equation number and its SIL value. The equation data are now sorted to group 
the data by each scalar index number in order of increasing dependent u point number. This 
essentially creates a column stored matrix [R ] . Each row in the matrix corresponds to 
a u point. Each column corresponds to a unique scalar index (u point). 

The SUP0RT (u ) and jiMIT (u ) card images are read from GE0M4. The grid and component 

numbers are sorted and written on SCRl. The 6PDT is read, and a list is formed of the permanent 

single-point constraints (u ) which were identified on the GRID bulk data cards. This list is 
written on SCRl . 

The SPCADD, SPCl and SPC bulk data card images identify the sets of single-point 
constraints used as boundary points (u . ) and include any possible constrained displacement 
values (Y ). The user-requested sets of SPC cards are extracted from the CASECC data block 
and the SPCADD cards. The requested SPC and SPCl card images are read, the grid and component 
"id" numbers are converted to scalar indices, and a paired list of scalar indices and their 
corresponding displacement values is written on SCRl. The non-zero Y values formed in the 
previous step form a packed vector with indices given by their position in the list. This is 
the YS data block, a vector packed relative to the u set. 

The USET data blocl; contains one coded word for each scalar degree of freedom in the 
entire structure. The word is coded to identify the set or sets of coordinates to which 
the scalar degree of freedom belongs (see section 2.3.13). An area of core is set equal to 



4.31-3 



MODULE FUNCTIONAL DESCRIPTIONS 



zero, and the lists of u„, u„, u„ and u, points are read from SCRl. The scalar index of a 

' m r s '^ 

coordinate corresponds to a position in core. The word in that position is modified to 

identify the set to which that scalar index belongs. With the u , u , u and u paints 

known, the u„, u„, u,, u, and u. points may be identified. The "nesting" of these sets 
g n T a x* 

follows the scheme: 



"m 



"s 



U. I I /-g 



"a 



USET is written as one logical record on the USET data block. 

The final operation is to process each degree of freedom in USET to insure that the 
displacement set definitions are consistent. The governing rule (as may be noted in the 
nesting scheme) is that each degree of freedom may belong to at most one dependent subset. 
If any inconsistant definitions are found, they are written on SCRl. When each point has 
been analyzed, EQEXIN and SIL are read into core. Then SCRl is read, and, for each entry, 
an error message is queued. PEXIT is then called to abnormally terminate GP4. 

4.31.7.1 Definitions of the Sets Defined in USET 

u - All structural degrees of freedom defined by grid and scalar points. 

u - Dependent coordinates used in the multipoint constraint equations. Defined 
as the first degree of freedom of a MFC card. 

u - All structural degrees of freedom except u . 

u - All fixed points. The u points are defined by the GRID cards and have a dis- 
placement of zero. The u . points are defined by the SPC cards and may have a 
constrained displacement. 



4.31-4 



FUNCTIONAL MODULE GP4 (GEOMETRY PROCESSOR - PHASE 4) 

u, - An degrees of freedom in the structure except u and u , 

u - These are "omitted coordinates" defined by 0MIT and 0Mm cards. In statics, 
the structural matrix is partitioned, and these degrees of freedom are solved 
separately. In dynamics, the displacements of these points are approximated by 
their static displacements under mass loads. 

u - These are the unconstrained degrees of freedom of the system. They include 
a 

rigid body modes in dynamics. 

u - These are fictitious supports defined by the SUP0RT cards. In dynamics and 

inertia relief the elastic displacements are measured relative to these points. 

u. - This set includes all degrees of freedom not defined by the u , u , u and u^ 
points. The stiffness matrix defined by these points is used for the solution 
of displacements versus loads. 

4.31.8 Subroutines 

The module GP4 consists of one subroutine, GP4. 

4.31.9 Design Requirements 

The maximum storage requirement for GP4 is one word per degree of freedom (i.e., LUSET = 6* 
(number of grid points) + number of scalar points) plus one GINj) buffer. Its open core is 
defined by /GP4C0R/. Two scratch files are used by GP4. 

4.31.10 Diagnostic Messages 

The following messages may be issued by 6P4: 

2047, 2048, 2049, 2050, 2051, 2052, 2053, 2101, 3008 



4.31-5 



FUNCTIONAL MODULE GPSP (GRID POINT SINGULARITY PROCESSOR) 

4.32 FUNCTIONAL MODULE GPSP (GRID P0INT SINGULARITY PR0CESS0R) . 

4.32.1 Entry Point : GPSP. 

4.32.2 Purpose 

The GPST data block contains data on possible stiffness matrix singularities. These singu- 
larities may be removed through the application of single or multipoint constraints. The GPSP 
module checks each singularity against the list of constraints, and if the singularity is not 
removed, writes data for warning the user. 

4.32.3 OMAP Calling Sequence 

GPSP GPL, GPST, USET,SIL/0GPST $ 

4.32.4 Input Data Blocks 

GPL - Grid Point List. 

GPST - Grid Point Singularity Table. 

USET - Displacement set definitions table. 

SIL - Scalar Index List. 

Note: No input data block can be purged. 

4.32.5 O utput Data Blocks 

0GPST - Unremoved Grid Point Singularities. This data block will be processed by the {!)rP 
(Output File Processor) module. 

4.32.6 Parameters 
None. 

4.32.7 Method 

USET is read into core. The USET data block contains one word for each degree of freedom in 
the structural model. This word identifies the displacement coordinate sets to which the coordi- 
nate belongs. Each entry in the GPST data block contains the order of the singularity and the 
scalar index numbers of the degrees of freedom involved. The logic of the algorithm depends on 
the order of the singularity. For each type the logic is: 

1. If order =1, the contents of the GPST data are: 

a. (3RDER = 1 



4.32-1 



MODULE FUNCTIONAL DESCRIPTIONS 



b-. Number of words following 

c. Ni 

d. Uz\ 



may not appear 
e. N,; 

Ni, N2 and N3 are the scalar Indices of the degrees of freedom which will remove the 
singularity if constrained. If the singularity is not removed, the 0GPST data is output. 

2. If order - 2: 

a. 0RDER "' 2 

b. Number of words following 

c. Nil 

d. N21 

e. N12 

f. N22 

g. Ni3 
h. N23 



may not appear 



Each pair of Indices identifies two degrees of freedom which cause the singularity. If 
both indices for any pair belong to the USET (UM or US), the singularity is removed. If 
only one of the degrees of freedom in a pair is constrained by a u or u coordinate, the 
singularity order is now 0RDER =1. The numbers listed are not unique, and more than one 
of the N^ . indices may belong to the u^ or u^^ sets. Keeping the same sequence, the 
unconstrained scalar indices in each partially constrained pair is listed in the 0GPST in 
the form for 0RDER - 1. 

3. If order = 3: 

a. 0RDER " 3 

b. Number of words following 

c. Ni 

d. N2 

e. N3 

All three indices (Ni, N2, and N3) must belong to the u^ or u^^^ sets to remove the 



4.32-2 



FUNCTIONAL MODULE GPSP (GRID POINT SINGULARITY PROCESSOR) 

singularity. If one or two of the coordinates are constrained, the order is two or one, and 
the remaining scalar indices or index is listed in the 0GPST. 

If any singularities are unremoved, a message is given to this effect. Also the SIL 
values must be converted to external grid point-component notation for user readability. 
The first time an unremoved singularity is detected, SIL is read into core beneath USET, and 
GPL is placed beneath SIL. Each SIL value is looked up in SIL for a pointer into GPL to the 
external grid point ID. Scalar points are differentiated from grid points. Data is 
output to the 0GPST in the order: grid point ID, type, singularity order and components. 
When all entries in the GPST have been processed, the routine returns. 

4.32.8 Subroutines 
None. 

4.32.9 Design Requirements 



Open core is defined at /GPSPA/. 

CgMMgN /GPSPS/ 



USET 



SIL 



GPL 



06PSP 
Buffer 



GPSP 
Buffer 



Scratch 

Buffer- 

USET,GPL,SIL 



LUSET (Length of USET) 

LSIL+1 (Length of SIL+1) 
Last cell has LUSET stored 

L6PL (Length of GPL) 



GIN0 buffer 
6IN0 buffer 

GIN0 buffer 



4.32.9.1 Allocation of Core Storage 

If no singularities exist, USET plus two GIN0 buffers must be held in core. If singularities 
exist, USET, SIL, SPL plus three GIN0 buffers must be held in core. 



4.32-3 



MODULE FUNCTIONAL DESCRIPTIONS 



4.32.10 Diagnostic Messages 

The following diagnostic messages may occur: 3007 (if the GPST does not contain legal SIL 
numbers, indicating a progranming error); 3008 (if the core storage requirements given in section 
4.32.9.1 are not met). 



4.32-4 



FUNCTIONAL MODULE MCEl (MULTIPOINT CONSTRAINT ELIMINATOR - PHASE 1) 

4.33 FUNCTIONAL MODULE MCEl (MULTIPOINT CONSTRAINT ELIMINATOR - PHASE 1) 

4.33.1 Entry Point : MCEl 

4.33.2 Purpose 

MCEl partitions [R ] into [R^] and [R^] and then solves the matrix equation [Rj iCi^'] = 
-[R„] for [G„]. 

4.33.3 DMAP Calling Sequence 
MCEl USET,RG/GM $ 

4.33.4 Input Data Blocks 

USET - Displacement set definitions table. 
RG - Multipoint constraint equations matrix. 

Note: Neither USET nor RG may be purged. 

4.33.5 Output Data Blocks 

GM - Multipoint constraint transformation matrix - m set. 
Note : GM may not be purged. 

4.33.6 Parameters 
None 

4.33.7 Method 

[Rg] Is a matrix with each row defining a constraint equation. The row scalar indices 
correspond to the u^^^ set of coordinates and the column indices correspond to the u set. The first 
operation of MCEl is to partition [Rg] into ik^} and [R^]. MCEIA performs this operation by 
initializing /PARMEG/ and calling PARTN (see section 3.5.6 for PARTN details). 

The second operation of MCEl is to solve the matrix equation 

CSn^Gj = -[Rn^ (1) 



4.33-1 



MODULE FUNCTIONAL DESCRIPTIONS 

for [G ]. If [R J is diagonal, the operation is straightforward. In this case MCEID is 
called. The terms -r.^ are stored in core, the [R^^] matrix is read interpretively by 
INTPK, and the terms of [G^^] are formed from the equation 

where the terms in the numerator belong to [R^] and those in the denominator belong to [Rj^j]. If 
[R^] is not diagonal. Equation 1 is solved by deconposition and forward-backward substitution. 
In this case, MCEIB is called. MCEIB performs an unsymmetric decomposition of [R^^] by 
initializing /DC^MPX/ and calling DEC0MP. MCEIC is then called by MCEl, MCEIC performs a 
forward-backward substitution to solve for [Gj^j] by initializing /GFBSX/ and calling GFBS. 

See section 3.5.15 and 3.5.19 for further details on DECJJMP and GFBS, respectively. 

4.33.8 Subroutines 

4.33.8.1 Subroutine Name: MCEIA 

1. Entry Point: MCEIA 

2. Purpose: To partition [R ] into [R^j^] and [R^]. 

3. Calling Sequence: CALL MCEIA 

4.33.8.2 Subroutine Name: MCEIB 

1. Entry Point: MCEIB 

2. Purpose: To decompose [R ] into lower and upper triangular factors. 

3. Calling Sequence: CALL MCEIB 

4.33.8.3 Subroutine Name: MCEID 

1. Entry Point: MCEID 

2. Purpose: To solve the matrix equation [R|^] [G^^] = [R^^] for [G^^] where [R|^] is 
diagonal. 

3. Calling Sequence: CALL MCEID 

4.33.9 Design Requirements 

4,33-2 



FUNCTIONAL MODULE MCEl (MULTIPOINT CONSTRAINT ELIMINATOR - PHASE 1) 



4.33.9.1 Allocation of Core Storage 

The maximum core storage requirement in the module is one double precision vector in 
the u^ displacement set plus three GIN0 buffers. 

4.33.9.2 Environment 

Communication of GIN0 file names to each of the phases of MCEl occurs through blank 
C0MM0N. The four phases are designed so that each may be in a separate overlay segment. Open 
core for each of the phases is as follows: 



MCEIA 


/MCEAl/ 


MCEIB 


/MCEBl/ 


MCEIC 


/MCECl/ 


MCEID 


/MCEDl/ 



4.33.10 Diagnostic Messages 

The following messages may be issued by MCEl; 
3005, 3016 



4.33-3 



^d 



FUNCTIONAL MODULE MCE2 (MULTIPOINT CONSTRAINT ELIMINATOR - PHASE 2) 

4.34 FUNCTIONAL MODULE MCE2 (MULTIPOINT CONSTRAINT ELIMINATOR - PHASE 2) 

4.34.1 Entry Point : MCE2 

4.34.2 Purpose 

MCE2 partitions the stiffness matrix [K ] into [K^^^], IK^^] and [K^] and then performs 
the matrix reduction [K^J = [1<„J . [G^]T [K^^] + [K^^f [GJ + [0^]^ [k_^] [g^] 

Similar partitions and reductions are performed on [M ], [B ] and [K^ ] if these matrices 
are not purged. 

4.34.3 DMAP Calling Sequence 

MCE2 USET,GM,KGG,MGG,BGG,K4GG/KNN,MNN,BNN,K4NN $ 

4.34.4 Input Data Blocks 

USET - Displacement set definitions table. 

GM - Multipoint constraint transformation matrix - m set. 

KGG - Partition of stiffness matrix - g set. 

MGG - Partition of mass matrix - g set. 

B6G - Partition of damping matrix - g set. 

K4GG - Partition of structural damping matrix - g set. 

Note : MGG, BGG and K4GG may be purged. 

4.34.5 Output Data Blocks 

KNN - Partition of stiffness matrix - n set. 

MNN - Partition of mass matrix - n set. 

BNN - Partition of damping matrix - n set. 

K4NN - Partition of structural damping matrix - n set. 

Note : MNN, BNN or K4NN may be purged only if MGG, BGG or K4GG is purged. 

4.34.6 Parameters 
None 



4.34-1 



MODULE FUNCTIONAL DESCRIPTIONS 



4.34.7 Method 

Using subroutine UPART to generate row and column partitioning vectors and subroutine 
MPART to perform the actual partitioning, [K ] is partitioned as follows; 

99 



t^g^=> 



'1^ I K "■ 

nn_ '_ _ nm_ 

Y ' :" Y ' 

mn I mm 



(1) 



Subroutine ELIM 1s called to perform the following matrix reduction: 

[K„„] = [!<„„] ^ [GjT l^^l . [K„„]^ [GJ . [GJ^ [KJ [GJ. (2) 

For each of the data blocks corresponding to the matrices [M.-]. [^ ], [K J which is not 
purged, the above partitioning and matrix reductions are performed. 

4.34.8 Subroutines 

Calls are made to the following matrix utility routines: 
UPART see section 3.5.9 for details 
MPART see section 3,5.9 for details 
ELIM see section 3.5.22 for details 

4.34.9 Design Requirements 

4.34.9.1 Allocation of Core Storage 

The maximum storage requirement for MCE2 is four times the number of degrees of freedom 
1n the u displacement set plus one GIN|3 buffer. 

4.34.9.2 Environment 

The module MCE2 consists of one subroutine, MCE2. Calls are made to the matrix utility 
routines as indicated above. Six scratch files are used. 



4.34-2 



FUNCTIONAL MODULE SCE1 (SINGLE-POINT CONSTRAINT ELIMINATOR) 

4.35 FUNCTIONAL MODULE SCEl (SINGLE-POINT CONSTRAINT ELIMINATOR) 

4.35.1 Entry Point : SCEl 

4.35.2 Purpose 

To reduce the n set matrices to f set matrices by removing the single-point constraints. 

4.35.3 DMAP Calling Sequence 

SCEl USET,KNN,MNN.BNN,K4NN/KFF,KFS,KSS,MFF,BFF,K4FF/ $ 

4.35.4 Input Data Blocks 

USET - Displacement set definitions table. 

KNN - Partition of stiffness matrix - n set. 

MNN - Partition of mass matrix - n set. 

BNN - Partition of damping matrix - n set. 

K4NN - Partition of the structural damping matrix - n set. 

Notes: 1. USET cannot be purged. 

2. KNN, MNN, BNN and K4NN can be purged. 

3. At least one degree of freedom must belong to the f and s sets. 

4.35.5 Output Data Blocks 

KFF - Partition of stiffness matrix after single-point constraints have been 
removed - f set. 

KFS - Partition of stiffness matrix after s1ngle-po1nt constraints have been 
removed. 

KSS - Partition of stiffness matrix after single-point constraints have been 
removed - s set. 

MFF - Partition of mass matrix after single-point constraints have been removed - 
s set. 

BFF - Partition of damping matrix after single-point constraints have been removed - 
f set. 

K4FF - Partition of structural damping matrix with single-point constraints removed - 
f set. 

4.35-1 



MODULE FUNCTIONAL DESCRIPTIONS 



4.35.6 Parameters 



None 



4.35.7 Method 

The matrices are partitioned using USET(UN,UF,US) as follows (see section 1.7 for details); 



1 If [K 1 exists: 



t^n^ =-> 



_^ff I'^fj 



(1 



The [K,.], [K.J and [K ] partitions are generated and saved. 



NffJ. L-fsJ 



2. If [M^^] exists: 



[M ] =N 



'ff 



'sf 



'fs 



ss 



(2) 



3. If [B^^] exists: 



t^nn^ => 



Bff Ijfs 
V1 hs 



(3) 



4. If [kJ;^] exists: 



t<„3 



=> 



^ff 



"sf 



"fs 



ss 



(4) 



For the [M ], [B ^] and [kJ^] matrices, only the "ff" partition is generated and saved. 
One call to UPART followed by 4 calls to MPART accomplishes the above tasks. 



4.35-2 



FUNCTIONAL MODULE SCE1 (SINGLE-POINT CONSTRAINT ELIMINATOR) 

4.35.8 Subroutines 

UPART and MPART are called. See subroutine description in section 3.5.9. 

4.35.9 Design Requirements 

One scratch file is necessary. 



4.35-3 



FUNCTIONAL MODULE SMPl (STRUCTURAL MATRIX PARTITIONER - PHASE 1) 

4.36 FUNCTIONAL MODULE SMPl (STRUCTURAL l>1ATRIX PARTITIONER - PHASE 1) 

4.36.1 Entry Point : SMPl 

4.36.2 Purpose 

SMPl partitions [K^^] into [K^^]. [K^^] and [K^^]. The matrix equation [K ] [G ] = - [K ] 
is solved for [G^], [K^^] is then reduced by the matrix equation [K ] = [I? ] + [1< ]^ [G ]. 
If [Mff] is not purged, it is reduced by the equation [M, J = [M ] + [G 1^ [M 1 + [M 1^ [G 1 

' ' ad dd OS Ocl 

+ [G^f [Mqq] [Gq]. Similarly, [B^^] and [kJ^] are reduced. 

4.36.3 DMAP Calling Sequence 

SMPl USET,KFF,MFF,BFF,K4FF/G0.KAA,K00B,L00,U00,MAA,M00B,M(aAB,3AA,K4AA $ 

4.36.4 Input Data Blocks 

USET - Displacement set definitions table. 

KFF - Partition of stiffness matrix - f set. 

MFF - Partition of mass matrix - f set. 

BFF - Partition of damping matrix - f set. 

K4FF - Partition of structural damping matrix - f set. 

Note : MFF, BFF or K4FF may be purged. 

4.36.5 Output Data Blocks 

G0 - Structural matrix partitioning transformation matrix. 

KAA - Partition of stiffness matrix - a set, 

K00B - Partition of stiffness matrix - o set. 

L00 - Lower triangular factor of K00B - o set. 

U00 - Upper triangular factor of K00B - o set. 

MAA - Partition of mass matrix - a set. 

M00B - Partition of mass matrix - a set. 

M0AB - Partition of mass matrix. 

BAA - Partition of damping matrix - a set. 

K4AA - Partition of structural damping matrix - a set. 



4.36-1 



MODULE FUNCTIONAL DESCRIPTIONS 



Note: 



1. U00 is not a standard upper triangular factor. Its format is compatible only 
for input to subroutine FBS. 

2. MM, M00B, M0AB, BAA or K4AA may be purged only if MFF, BFF or K4FF are purged. 



4.36.6 Parameters 



None 



4.36.7 Method 



Using subroutine UPART to generate row and column partitioning vectors and subroutine 
MPART to perform the actual partitioning, [K^^] is partitioned as follows: 

I 



[K,,]-^ V- 



Tf 



'^aa I "^ao 



'^oa i '^00 



(1) 



Subroutine FACTOR is called to decompose [K^^] into triangular factors. Subroutine 
S0LVER is called to perform a forward-backward substitution solving for [G^] in the matrix 
equation 

[K^^nV = -[K,,3. (2) 

and computing [K,,] from the equation 

aa 



[K,J = [K^,3 + [K^,] [G^]. 



aa-' 



(3) 



For each of the data blocks [M^f]. [BffJ. [Kff] which is not purged, the above 
partitioning operation is performed and the matrix reductions: 

tMaa^ = ^V ^ tG„]' [M„,] - i^,}' [G,] + [G^]^ [M^^] [G^]. 

tBaa^ = ^^aa^ ' ^^^' ^B^a^ ' ^B^a^' ^''o^ ' ^G^^^ ^B^o^ ^G,^. 
tKa\] = <^ ' tG,]^ C1<J,] ^ [1^,]^ [G,] ^ [G^f [Ej„] [G^]. 
are performed by subroutine ELIM. 



(4) 
(5) 
(6) 



4.36-2 



FUNCTIONAL MODULE SMPl (STRUCTURAL MATRIX PARTITIONER - PHASE 1) 

4.36.8 Subroutines 

Calls are made to the following matrix utility routines: 
UPART See subroutine descriptions - section 3.5.9 for details 
MPART See subroutine descriptions - section 3.5.9 for details 
FACT0R See subroutine descriptions - section 3.5.23 for details 
S0LVER See subroutine descriptions - section 3.5.20 for details 
ELIM See subroutine descriptions - section 3.5.22 for details 

4.36.9 Design Requirements 

4.36.9.1 Allocation of Core Storage 

The maximum storage requirement for SMPl is four times the number of degrees of freedom 
in the u^ displacement set plus one GIN0 buffer. 

4.36.9.2 Environment 

The module SMPl consists of one subroutine, SMPl. Calls are made to the matrix utility 
routines indicated above. Six scratch files are used. 



4.36-3 



FUNCTIONAL MODULE RBMG1 (RIGID BODY MATRIX GENERATOR - PHASE 1) 

4.37 FUNCTIONAL MODULE RBMGl (RIGID BODY MATRIX GENERATOR - PHASE 1) 

4.37.1 Entry Point : RBMGl 

4.37.2 Purpose 

RBMGl partitions [K^^] into [K^^}, [K^^] and [K^^]. If [M^^] is not purged, it is 
partitioned similarly. 

4.37.3 DMAP Calling Sequence 

RBMGl USET,KAA,MAA/KLL,KLR,KRR,MLL,MLR,MRR $ 

4.37.4 Input Data Blocks 

USET - Displacement set definitions table. 
KAA - Partition of stiffness matrix - a set. 
MM - Partition of mass matrix - a set. 

Note : USET may not be purged. 

4.37.5 Output Data Blocks 

KLL - Partition of stiffness matrix - i set. 

KLR - Partition of stiffness matrix. 

KRR - Partition of stiffness matrix - r set. 

MLL - Partition of mass matrix - Z set. 

MLR - Partition of mass matrix. 

MRR - Partition of mass matrix - r set. 

Note: Output data blocks may be purged only if the corresponding input data block is 
purged. 

4.37.6 Parameters 



None 
4.37.7 Method 

Using subroutine UPART to generate row and column partitioning vectors and subroutine 



4.37-1 



MODULE FUNCTIONAL DESCRIPTIONS 



MPART to perform the actual partitioning, [K ] is partitioned as follows 



tKaa^-> 



Hi [ Hr 
Ha ' "^rr 



(1) 



Similarly, if CM„] is not purged, it is partitioned. 

act 

4.37.8 Subroutines 

RBMGl calls the following matrix utility routines: 

UPART ) 

\ see section 3.5.9 for details. 

MPART I 

4.37.9 Design Requirements 

4.37.9.1 Allocation of Core Storage 

Storage requirements for RBMGl are minimal since no unpacked vectors are held in core. 

4.37.9.2 Environment 

The module RBMGl consists of one subroutine, RBMGl. Calls are made to the matrix 
utility routines indicated above. One scratch file is used. 



4.37-2 



FUNCTIONAL MODULE RBMG2 (RIGID BODY MATRIX GENERATOR - PHASE 2) 

4.38 FUNCTIONAL MODULE RBMG2 (RIGID BODY MATRIX GENERATOR - PHASE 2) 

4.38.1 Entry Point : RBMG2 

4.38.2 Purpose 

RBMG2 decomposes [K j^] into its triangular factors [L^^j^] and [U^j^^]. 

4.38.3 DMAP Calling Sequence 

RBMG2 KLL/LLL,ULL/V,N,P0WER/V,N,DET $ 

4.38.4 Input Data Blocks 

KLL - Partition of stiffness matrix - a set. 
Note : KLL may not be purged. 

4.38.5 Output Data Blocks 

LLL - Lower triangular factor of KLL - i set. 
ULL - Upper triangular factor of KLL - I set. 

Notes 

1. LLL and ULL may not be purged. 

2. ULL is not a standard upper triangular matrix. Its format is compatible only 
for input to subroutine FBS. 

4.38.6 Parameters 

P0WER - Output-integer-default = 1. Power of 10 in the determinant of KLL. 
DET - Output-real-default = 1.0. Magnitude of determinant of KLL, i.e., 
det [K^^-] = DET*10''''"^'^ 

4.38.7 Method 

RBMG2 calls subroutine FACT0R to perform the decomposition of [K.^j^] into l^^^l and [Uj^j]. 

4.38.8 Subroutines 

RBMG2 calls the matrix utility routine FACT0R (see section 3.5.23 for FACTOR details). 

4.38-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.38.9 Design Requirements 

For allocation of core storage, see subroutine SDC0MP (section 3.5.14). The module RBMG2 
consists of one subroutine, RBMG2. Three scratch files are used. 

4.38.10 Diagnostic Messages 

Message number 3005 may be issued by RBMGl. 



4.38-2 



FUNCTIONAL MODULE RBM63 (RIGID BODY MATRIX GENERATOR - PHASE 3) 

4.39 FUNCTIONAL MODULE RBMG3 (RIGID BODY MATRIX GENERATOR - PHASE 3) 

4.39.1 Entry Point : RBMG3 

4.39.2 Purpose 

RBMG3 solves for the rigid body transformation matrix [D] from the equation 

[Kj^^] [D] = -[K^^] . (1) 

The rigid body error ratio, e, is computed from 

||[K^,] + [K^/ [D]!| 
£ = . (2) 

l|[K,,]|i 

4.39.3 DMAP Calling Sequence 

RBMG3 LLL,ULL,KLR,KRR/DM $ 

4.39.4 Input Data Blocks 

LLL - Lower triangular factor of KLL -Z set. 

ULL - Upper triangular factor of KLL - s. set. 

KLR - Partition of stiffness matrix. 

KRR - Partition of stiffness matrix - r set. 

N ote: Input data blocks may not be purged. 

4.39.5 Output Data Blocks 

DM - Rigid body transformation matrix. 

Note: The DM data block corresponds to the matrix [D] and may not be purged. 

4.39.6 Parameters 
None 



4.39-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.39.7 Method 

Subroutine SILVER is called to perform the operations in Equation land 2, 

4.39.8 Subroutines 

RBMG3 calls the matrix utility routine S(5LVER and has no auxiliary subroutines. See section 
3.5.20 for SILVER details. 

4.39.9 Design Requirements 

For allocation of core storage, see subroutines FBS (section 3.5.17) and MPYAD (section 3.5.12). 
Two scratch files are used. 



4.39-2 



FUNCTIONAL MODULE RBMG4 (RIGID BODY MATRIX GENERATOR - PHASE 4) 

4.40 FUNCTIONAL MODULE RBMG4 (RIGID BODY MATRIX GENERATOR - PHASE 4) 

4.40.1 Entry Point : RBMG4 

4.40.2 Purpose 

RBMG4 computes the rigid body mass matrix [m^] from the matrix equation 

[m,] = [M,,] + [of [M^^] + [M,^f [D] + [of [M^^,] [D]. (l] 

4.40.3 DM AP Calling Sequence 
RBMG4 DM,MLL.MLR,MRR/MR $ 

4.40.4 Input Data Blocks 

DM - Rigid body transformation matrix. 

MLL - Partition of mass matrix - 2. set. 

MLR - Partition of mass matrix. 

MRR - Partition of mass matrix - r set. 

Notes : 

1. No input data block may be purged. 

2. The DM data block corresponds to the matrix [D] In Equation 1. 

4.40.5 Output Data Blocks 

MR - Rigid body mass matrix - r set. 

4.40.6 Parameters 
None 

4.40.7 Method 

Subroutine ELIM is called to compute [m ] as in Equation 1 (see section 3.5.22 for ELIM 
details). 



4.40-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.40.8 Subroutines 

RBHG4 consists of one subroutine, RBMG4. 

Matrix utility routine ELIM (section 3.5.22) is called by RBMG4. 

4 . 40 . 9 Design Requirements 

For allocation of core storage, see subroutine MPYAD (section 3.5.12). Three scratch files 
are used. 



4.40-2 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

4.41 FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

4.41.1 E ntry Point : SSGl 

4.41.2 Purpose 

To compute the static loads, thermal loads, and enforced deformation loads selected by the 
user. 

4.41.3 DMAP Calling Sequence 

SSGl SLT,BGPDT,CSTM,SIL,EST,MPT,GPTT,EDT,MGG,CASECC,DIT/PG/V,N,LUSET/V,N,NSKIP $ 

4.41.4 Input Data Blocks 

SLT - Static Loads Table. 

BGPDT - Basic Grid Point Definition Table. 

CSTM - Coordinate System Transformation Matrices. 

SIL - Scalar Index List. 

EST - Element Summary Table. 

MPT - Material Property Table. 

GPTT - Grid Point Temperature Table. 

EDT - Element Deformation Table. 

MGG - Partition of mass matrix - g set. 

CASECC - Case Control Data Table. 

DIT - Direct Input Tables. 



Notes: 



1. SLT, BGPDT, SIL cannot be purged if external static loads or LOAD cards are selected 
in CASECC. 

2. CSTM cannot be purged if any grid point or load references a coordinate system other 
than basic. 

3. EST, MPT cannot be purged if thermal or element deformation loads are selected. 

4. GPTT cannot be purged if thermal loads are applied. 

5. EDT cannot be purged if element deformation loads are selected. 



4.41-1 



MODULE FUNCTIONAL DESCRIPTIONS 

6. MGG cannot be purged if GRAVITY or RF(3RCE loads are applied. 

7. CASECC cannot be purged. 

8. DIT cannot be purged if temperature dependent materials are loaded. 

4.41.5 Output Data Blocks 

PG - Static load vector matrix giving static loads - g set. 
Note : PG can never be purged. 

4.41.6 Parameters 

LUSET - Input-integer-no default. LUSET defines length of PG. 

NSKIP - Input-integer-no default. One static load is built for each CASECC record 
starting with NSKIP + 1 as long as the boundary conditions are constant. 

4.41.7 Overview of the Method Used in SSGl 



The purpose of the first phase of static solution calculation (module SSGl) is the generation 
of the load vectors on the whole structure. The structure may be loaded in three different ways: 

1. Simple applied loads and moments may be given to grid and scalar points. Pressure 
loads may be applied to an area defined by three or four grid points. Centrifugal force 
fields may also be defined. 

2. Thermal and enforced deformation loads are generated by using the structural element 
characteristics. The loads on the connected grid points are equivalent to fixing the 
displacements and replacing the element by the load it would apply to the points. 

3. Gravity loads are dependent on the mass characteristics of the structure. A gravity 
load is produced by generating a vector of accelerations on all grid noints in the structure 
and pre-multi plying the vector by the structural mass matrix. 

The details on load vector generation for these three different types of loading are given in 
sections 4.41.8, 4.41.9 and 4.41.10 below. The function of module SSGl is to read the case control 
data and extract the necessary load set data, calculate load vectors for each requested load set, 
and combine these sets to produce the loads requested for all subcases using the same boundary, 
condition. 



4.41-2 



FUNCTIONAL MODULE SSG1 (STATIC SOLUTION GENERATOR - PHASE 1) 

4.41.7.1 Module Initialization 

Common block /L0ADX/, which contains GIN0 file numbers for input data files and position 
pointers, is initialized. 

A list of all external load sets is extracted from the SLT. (This must be less than 101.) 
CASECC is skipped forward NSKIP records (in case several boundary conditions are being solved in 
one run). For each succeeding record which is not an eigenvalue record, not a syrmietry record, 
not a differential stiffness record, and for which the boundary conditions are those for the 
current loop (SRC and MFC sets), a list is made of each thermal or enforced deformation load. The 
external loads selected are marked in the above list. If a selected external load is not in the 
above list, the L0AD cards are read in and their component id's searched. A L0AD card may cause 
additional members to be selected. A composite list is created which contains: 




External load id's 
selected ones marked <_ 100 

Thermal load id's ± 100 

Enforced deformation load id's < 100 



< 100 



If there is no record which allows construction of a load, SSGl aborts. If a selected external 
load id does not exist either as a L0AD card or simple load set, SSGl aborts. (Subroutine SSGIA). 

4.41.7.2 Individual Load Vector Generation 

Each requested set of loads is used to generate a {P^} load vector. The vectors are generated 
one at a time in core and written on the PG temporary file, a scratch file. Files PG temporary, 
SLT, BGPDT, CSTM and SIL are opened. The vector generation depends on the type of load and type 
of input data. Details are given in sections 4.41.8, 4.41.9 and 4.41.10 below. 



4.41-3 



MODULE FUNCTIONAL DESCRIPTIONS 

4.41.7.3 Subcase Load Vector Generation 

Each simple load set, j, produces a {P^} load vector, and each subcase may be a combination 
of various simple load sets. As each load set vector is formed, it is written on PG temporary. 
When all sets have been generated, the CASECC data block and the L0AD card images are read again. 
A table is formed for each subcase consisting of the required set number and the scale factor for 
each set if given on a L^IAD card. The file containing the load vectors for the sets is read for 
each subcase, c, and added to a {P^} load vector. The {P^} load vectors are oacked and written 
as the PG data block in standard NASTRAN matrix form. 

4.41.8 Direct Applied Loads 

Dir.ict loads are applied to the structural model by means of F0RCE, F|3RCE1 , FiiRCEZ, GRAV, 
M0MENT, MfilMENTl, M0MENT2, PL0AD, PL0AD2, RF0RCE, and SL0AD Bulk Data Cards and the PRESAX card 
which is used for the axisymmetric conical shell problem only. 

4.41.8.1 F0RCE and M0MENT Card Processing 

The data described by a F0RCE or M0MENT data card are given as follows: 

N = Grid point index; 
P 

N = Coordinate system number; 
S = Scalar factor; and 



{?} = ^2} ■ (1) 

The BGPDT data for the point are determined. If the global coordinate number, N , for the point 
equals N , the vector is 

{Pg} = S {P} , (2) 

where the row index is determined from SIL. If N f N , [T ] and [T ] are calculated using the 

y c g c 

location coordinates and the two local coordinate systems (subroutines 6LBBS and BASGLB). The 



4.41-4 



FUNCTIONAL MODULE SSG1 (STATIC SOLUTION GENERATOR - PHASE 1) 

load in global coordinates is: 

{Pg} = S [TgfET^] {P} . (3) 

If a F0RCE card is used, the loads are added to the first three positions for the grid point in 
the load vector. If a M0MENT card is used, the loads are added to the last three positions. 
(Subroutine DIRECT). 

4.41.8.2 F0RCE1 and M0MENT1 Card Processing 

The data described by F0RCE1 or M0MENT1 card are given as follows: 

N = Application point number; 

S = Load magnitude; 

N, ,Np = Grid point numbers describing the 
vector direction of the load. 

The basic coordinates of the points N, , Np and N are found in the BGPDT. (Subroutines 
PERMUT and FNDPNT). If {R,} and {Rj} are the vectors corresponding to N, and N2, the load 
direction is: 

{Rz} - {Ri} 
^'^ - |(R.}-(R.}| - ^'^ 

The coordinate transformation [T ] for point N is calculated (Subroutine BASGLB). The load 
vector in global coordinates is: 

{Pq} = S [Tgf {d} . (5) 

If a F0RCE1 card was used the values are added to the first three coordinates, starting with the 
SIL number, in the load vector. If a M0MENT1 card was used, the values are added to the last 
three (subroutine TP0NT). 

4.41.8.3 Fi2IRCE2 and M0MENT2 Card Processing 

The data on a F0RCE2 or M0MENT2 card are as follows: 

N = Application point number; 
S = Load magnitude; 

4.41-5 



MODULE FUNCTIONAL DESCRIPTIONS 

Ni,N2,N2tN. are such that the direction of the force is 
determined by Equation 6 below. 

The algorithm is similar to the one for the F0RCE1 and M0MENT1 case except that four basic 
coordinate system vectors, {Ri), {R2}. {R3}. {R^}, are formed for the four points and: 



({R2} - {Ri>) X ({R^} - (Ra)) 
^•^^ = |({R2} - (fti}) X ({kj - {fta})! ' 



(6) 



(Subroutine FP(3NT), 



4.41.8.4 PLjJAD and PL0AD2 Card Processing 



The data contents for a PL0AD card are (a PL0AD2 card is transformed into a PLEIAD card by 



GP3); 



p = Pressure value; 

N-j.Np.No.N. = Points describing area over 

which pressure load is acting. 
(N^ is optional .) 

For each of the four points, N., the basic coordinate system vector, {Rj}, is formed. 
If N. =0, the load on each point is: 

{F} = - I [{{RJ - {R2}) X ({R3} - {R2})] . 



(7) 



The load vector in global coordinates for each point is: 



{P„ } = [T.f {F} 



(8) 



If N^ f 0, the quadrilateral is subdivided into four triangles as shown. 




=) 





4.41-6 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

For each triangle {P } is calculated for the three connected points using a pressure value 
'i 
p-p = 1/2 p. The equations are the same as the previous case except that the points are inter- 
changed each time the triangle calculation is done. (Subroutine PL0AD.) 

4.41.8.5 SL0AD Card Processing 

The data contents for a SL0AD card are: 

N = Scalar point id and 
S = Load on point. 

The scalar index is computed by subroutine FNDSIL, and S is added in, (Subroutine SL0AD.) 

4.41.8.6 RF0RCE Card Processing 

The data contents for an RF0RCE card are: 

N = Index of grid point through which 
P rotation vector passes; 

N = Coordinate system number defining 
the rotation vector; 

A = Factor for vector; 

R ,R ,R are components of rotation vector in cps. 
X y z 

The following sequence of operations comprises RF0RCE card processing which is carried out 
in subroutine RF0RCE. 

1. The local to basic coordinate transformation matrix, [T ], for the reference coordinate 
system N^ is extracted from the CSTM data block. 

2. The rotation vector in basic coordinates, and in radians per second, is; 

V = 2-a[t^]|r;;| (9) 

3. Define the basic location vector of the reference point N„ as {r„}. If N =0, set 

P P P 

{rp} = {0}. 



4.41-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4. Extract the basic coordinate system vector {r.} for each point from BGPDT. 

5. Using {r.} and the local coordinate system referenced by the point, calculate the 
global-to-basic transformation matrix [T.]- 

6. For the six columns of the mass matrix [M ] corresponding to the grid point i, the 6x6 
matrix partition on the diagonal is extracted. Define this as [M ]. 

7. Partition the 6x6 matrix into 3x3 matrices 



[M^']=» 



m: 



rt 



M. 



tr 



(10) 



and transform the rotational velocity vector to global coordinates 



{(.g} = [T^]' {CO^} . 



8. Calculate the forces and moments on the grid point by the equations: 

{F} = -{cOg} X [MJ] [T.f ({(ojj} x [{r.} - {r^}]) - {a)g} x [M^J.] {o)g} 

{M} = -{ojg} x [M^J] [T.f ({c^} X [{r.} - {r^}]) - {oig} x [mJ] {oj^} 

9. The load vector partition in global coordinates Is: 



<'i> ■ (1} 



(11) 



(12) 
(13) 



(14) 



4.41.8.7 PRESAX Card Processing 

The data contents for a PRESAX card (which applies only to pressure loading of an 
AXISYMMETRIC shell) are: 



P 
N. 



\- 



P2 - 

n = 



Pressure; 

Index value of harmonic Ring A; 

Index value of harmonic Ring B; 

(degrees); 

(degrees); 

Harmonic number of harmonic being added. 



4.41-8 (12-1-69) 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

The algorithm given in the following steps is performed in subroutine PRESAX. 

1. (jji and <|)2 are converted to radians. 

2. BGPDT data are extracted for both RINGA and RINGS, giving {r} and {z}. 

3. The calculations for harmonic n are: 

sin * = ^^ , (16) 

cos ^p = -^ . (17) 

For the cosine case, if n = 0, we calculate: 

^io = P^ (-T-'"-6-)(*2 - "^i) "s * . (18) 

^20 = -P^ (t^^-6^)^*2 - *') si" * • (19) 



If n > 



Ppn = P f (j^ + ^) (sin (n())2) - sin (n<l)i)) cos ^ . 
^zn " '^ n (t" ^ /) ^^^" ^^^^^ " ^^" ("*^)) ^^'" "^ • 



(20) 



(2i; 



4.41-9 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 



For the sine case, 1f n > 0, 

pi » _ pi(_L + -i) (cos (n<t>2) - cos (.Hi)) cos ii, (22) 

rn n \3 / 

p'' = P- (y- + ^) (cos (ncfiz) - cos (n((ii)) sin 'p. (23) 

4. The above equations are solved for i = a, i = b and i = b, i = a. The loads are added 
to the corresponding grid point location in the PG load vector 

'I 



\ ° 

(Subroutine PRESAX). 
4.41.8.8 GRAV Card Processing 

Each GRAV input card describes a uniform acceleration field with the following oarameters: 

N = Coordinate system ID; 

G = Scale factor; 

{V} = Vector of load in coordinate 
system N. 

The gravity vector in basic coordinates is: 

{gt,} = G [Tq^] {V} (25) 

where [T«^,] is the 3x3 orientation matrix of coordinate system N. (Subroutines GRAV, FDCSTM, 
MPYL). This vector {g. } is saved for later processing. Subroutine EXTERN then returns, noting 
the number of gravity loads listed. 



4.41-10 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

4.41.9 Thennal and Enforced Deformation Loads 

The thennal and enforced deformation loads are calculated using the stiffness properties of 
the structural elements. The GPTT or EDT data for each load set and the MPT, DIT and SIL data 
blocks are placed in core. The EST data block is read one element at a time, and the loads produced 
by that element are placed in the PG load vector. The actual algorithms for generating element 
loads are given in section 4.87. 

4.41.10 Gravity Loads 

Acceleration vectors are computed for each gravity load by two means, one for an axisvmmetric 
shell problem, the other for non-shell problems. 

4.41.10.1 Gravity Loads for an Axisymmetric Shell Problem 

m (number of rings) and n (number of harmonics) are extracted from the /SYSTEM/ common block. 
The first m points in the BGPDT define the "zero" harmonic. The second m entries define the "one" 
harmonic etc. The acceleration vectors are calculated by the formulae: 



= /g^ + Sy + Sz . (26) 



^xy = ^?^. (27) 



g 
cos e„ = -^ , (28) 

g g 



g 
sin 9g = -f- . (29) 



% 
3 ^xy 



cos *g = 1^ . (31) 

** ^xy 



4.41-11 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



The vectors {a) for harmonics n = and n = 1 are defined for load set cosine by: 



!0' 
Oj 
1 1 
Q> (all rings), 
o| 
0. 



(32) 



{a^} 



g sin eg cos *g X op 



(33) 



and for load set sine by: 



(all rings) 



{a,} = 9 sin 9„ sin y^ xq 

01 




(34) 



These vectors are used as in the normal case. They are merged into {a } which in turn is pre- 
multiplied by [M ] to give the {P } vector (subroutine GRAVL3). 

4.41.10.2 Gravity Loads for Non-Shell Problems 

The acceleration vector must be transferred to the global coordinate system at each grid 
point and expanded to a vector acting on the u coordinates. For each grid point (i) the BGPDT 
data is read, and using the CSTM data, a 3x3 basic to global transformation matrix [T.] is 
formed. The acceleration at the point i in basic coordinates is: 



{ab = [T.] {g,}. 



(35) 



where {g. } is the gravity vector saved in Equation 25. The vector {aV is placed in the total 
acceleration vector in positions SIL-, SIL.+l, and SIL.+2. No values are calculated for scalar 
points or rotation coordinates (Subroutine GRAVLl). 

When all {a } vectors have been calculated for the whole structure, they are pre-multiplied 
by the structural mass matrix to produce a load vector: 



tPg> = [Mgg] tag} . 



(36) 



4.41-12 



FUNCTIOUAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

(subroutine SSG2B). 

The gravity vectors are appended to the other load vectors, and scalar points are zeroed in 
case interaction occurred. Gravity loads on scalar points are not supported. 



4.41-13 



MODULE FUNCTIONAL DESCRIPTIONS 

4.41.11 Subroutines 

4 . 41 . 1 1 . 1 Subrouti ne Name : SSGl A. 

1. Entry Point: SSGIA. 

2. Purpose: To build a list of external loads, thermal loads and enforced deformation loads 
selected by the user in CASECC. 

3. Calling Sequence: CALL SSGIA (Nl .ILIST.NEDT, NTEMP.NCENT, CASECC, IHARM) 
Nl - Number of external loads present - integer - output. 

ILIST - List of load ID's with selected load ID's set negative - integer - output. 

NEDT - Number of enforced deformation loads - integer - output. 

NTEMP - Number of thermal loads - integer - output. 

NCENT - Not used (set to zero) - integer - output. 

CASECC - GIN0 number of Case Control Data Block - integer - input. 

IHARM - Boundary conditions for axi symmetric shell problem. 
1 = sine, 2 = cosine - integer - output. 

C0MM(9N//XX,L0ADNN 

L0ADNN - Number of records in CASECC to skip before beginning to build loads - integer - 

input. 
C(JMM(!IN/L(»ADX/ 
L|»ADX - See description of /L0ADX/ conmon block below (section 4.41.11.8). 

4.41.11.2 Subroutine Name: EXTERN. 

1. Entry Point: EXTERN 

2. Purpose: To compute user-selected external loads. 



4.41-14 



FUNCTIONAL MODULE SSG1 (STATIC SOLUTION GENERATOR - PHASE 1) 

3. Calling Sequence: CALL EXTERN (NLIST.NGRAV.GVECT.ILIST.PG.Nl .IHARM) 

NLIST - Number of load id's in ILIST array - integer - input. 

NGRAV - Number of gravity loads selected - integer - output. 

GVECT - Array of gravity vectors, 3 numbers per vector - real - output. 

ILIST - List of all load id's - integer - input. 

PG - Matrix control block for file on which external loads will be written - integer 
input/output. 

Nl - Number of external load id's - integer - input. 

IHARM - Boundary condition for axi symmetric shell problem 
1 = sine, 2 = cosine, 

C0MM0N//LUSET 

LUSET - Length of PG - integer - input. 

C0MM8IN/L0ADX/ - See /L0ADX/ description in section 4.41.11.8. 

4.41.11.3 Subroutine Name: TEMPL. 

1. Entry Point: TEMPL 

2. Purpose: To compute thermal loads for each element. 

3. Calling Sequence: CALL TEMPL (NTEMP. ILIST (Nl+1) ,PG(1)) 
NTEMP - Number of thermal loads - integer - input. 
ILIST(N1+1) - Beginning of thermal load list - integer - input. 

PG - Matrix control block for load file - integer - input/output. 

C0MM0N/L0ADX/ - See /LiaADX/ description in section 4.41.11.8. 
C0MM0N//LUSET 

LUSET - Length of PG - integer - input. 



4.41-15 



MODULE FUNCTIONAL DESCRIPTIONS 

4.41.11.4 Subroutine Name: EDTL. 

1. Entry Point: EDTL 

2. Purpose: To compute enforced deformation loads for each element. 

3. Calling Sequence: CALL EDTL (NEDT,ILIST(N1+1 ) ,PG(1)) 

NEDT - Number of enforced deformation loads - integer - input. 
The remainder of the variables has the same meaning as in TEMPL (section 4.41.11.3). 

4.41.11.5 Subroutine Name: GRAVLl . 

1. Entry Point: GRAVLl 

2. Purpose: To build acceleration vectors for gravity loads. 

3. Calling Sequence: CALL GRAVLl (NGRAV.GVECT.SCRl .IHARM) 
NGRAV - Number of gravity loads selected - integer - input. 

GVECT - Array of gravity vectors, three words per gravity vector - real - input. 

SCRl - GIN0 file number on which to build the acceleration vectors - integer - input. 

IHARM - Boundary condition for axisyttmetric shell problem. 
1 = sine, 2 = cosine - integer - output. 

4.41.11.6 Subroutine Name: GRAVL2. 

1. Entry Point: GRAVL2 

2. Purpose: To add gravity loads onto previously generated load vectors and check scalar 
points. 

3. Calling Sequence: CALL GRAVL2 (N6RAV,PGG,PG(1)) 
NGRAV - Number of gravity vectors - integer - input. 

PGG - GINjS file number of gravity loads - integer - input. 

P6 - Matrix control block for all other (non-gravity) loads - integer - input/output. 

CUMM0N/L0ADX/ 

L0ADX - See /L0ADX/ common block (section 4.41.11.8). 



4.41-16 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

C0MM0N//LUSET 

LUSET - Length of PG vector - integer - input. 

4.41.11.7 Subroutine Name: C0MBIN. 

1. Entry Point: C0MBIN 

2. Purpose: To combine subloads into subcase loads. 

3. Calling Sequence: CALL C(3MBIN (PG.ILIST.Nl) 
PG - Matrix control block for PG vector - integer - input/output. 
ILIST - List of all load ID's - integer - input. 
Nl - Number of entries in ILIST - integer - input. 
CI3MM0N/L0ADX/ 

L0ADX - See /L0ADX/ description, section 4.41.11.8) 
C0MM(3N//LUSET 

LUSET - Length of PG vector - integer - input. 
C0MM0N/L0ADS/NL0ADS , I ARY( 300 ) 
NL0ADS - Number of loads to build. 

lARY - For each load: Number of subloads 

Subload ID ) 

? repeated for each subload 

Scale Factor) ( repeated for 

, each load 
Subload ID 

Scale Factor 

4.41.11.8 Common Block L0ADX. 

1. Purpose: To transmit file numbers and pointers. 

2. Variable List: C0MM0N/L0ADX/LC,SLT,BGPDT,0LD,CSTM,SIL,ISIL,EST,MPT,GPT,EDT,IMPT,IGPTT, 

IEC.L0ADF,MGG,N0BLD,DIT,ICM 



4.41-17 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

SLT,BGPDT,CSTM,SIL,EST,MPT,GPTT,EDT,MGG,DIT - GIN0 file numbers for respective data 

blocks - integer - input. 

LC - Length of open core - integer - input. 

0LD - Current grid point position of the BGPDT - integer - input. 

ISIL - Current SIL position - integer. 

L0ADF - GIN0 file number of load file - integer - input. 

N0BLD - Build-nobuild flag for direct load routines - integer. 

I MPT - 

IGPTT - } Unused at present. 

lEC 

4.41.11.9 Subroutine Name: DIRECT. 

1. Entry Point: DIRECT 

2. Purpose: To apply loads due to F0RCE and M0MENT cards. 

3. Calling Sequence: CALL DIRECT 
C0MM0N/L0ADX/ 
L0ADX - See description of /L0ADX/ above (section 4.41.11.8). 

4.41.11.10 Subroutine Name TP0NT. 

1. tntry Point: TP0NT 

2. Purpose: To apply loads due to F0RCE1 and M0MENT1 cards. 

3. Calling Sequence: CALL TP0NT 
C0MM0N/L0ADX/ 
L(i)ADX - See description of /LOADX/ above (section 4.41.11.8), 



4.41-18 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

4.41.11.11 Subroutine Name: FP0NT. 

1. Entry Point: FP0NT 

2. .^urpose: To apply loads due to F0RCE2 and M0MENT2 cards. 

3. Calling Sequence: CALL FP0NT 
C0MM0N/L0ADX/ 

L0ADX - See description of /L0ADX/ above (section 4.41.11.8). 

4.41.11.12 Subroutine Name: SL0AD. 

1. Entry Point: SL0AD 

2. Purpose: To apply loads due to SL0AD cards. 

3. Calling Sequence: CALL SL0AD 
C0MM0N/L0ADX/ 

L0ADX - See description of /L0ADX/ above (section 4.41.11.8). 

4.41.11.13 Subroutine Name: PL0AD. 

1. Entry Point: PL0AD 

2. Purpose: To apply loads due to PL0AD cards. 

3. Calling Sequence: CALL PL0AD 
C0MM0N/L0ADX/ 

L0ADX - See description of /L0ADX/ above (section 4.41.11.8). 

4.41.11.14 Subroutine Name: RF0RCE. 

1. Entry Point: RF0RCE 

2. Purpose: To apply loads due to RF0RCE cards. 

3. Calling Sequence: CALL RF0RCE (LC0RE) 

LC0RE - Current buffer top - integer - input. 

C0MM0N/L0ADX/ 

L0ADX - See description of /L0ADX/ above (section 4.41.11.8). 

4.41-19 



MODULE FUNCTIOMAL DESCRIPTIONS 

4.41.11.15 Subroutine Name: PRESAX. 

1. Entry Point: PRESAX 

2. Purpose: To apply loads due to axisynmetric pressure loads. 

3. Calling Sequence: CALL PRESAX (IHARM) 

IHARM - Ax i symmetric boundary condition - integer - input. 

C0MM0N/L0ADX/ 

L0ADX - See description of /L(3ADX/ above (section 4.41.11.8). 

4.41.11.16 Subroutine Name: GRAV. 

1. Entry Point: GRAV 

2. Purpose: To extract gravity vector and convert to basic coordinates. 

3. Calling Sequence: CALL GRAV (NGRAV,GVECT,NEX,ILIST.NL00P) 
NGRAV - Number of gravity loads - integer - outout. 
GVECT - Array of gravity vectors - real - output. 

NEX - Number of external loads - integer - input. 

ILIST - List of external load ID's - integer - input/output. 

NL00P - Current pointer into ILIST. 

C0i-iM0N/L0ADX/ 

L0ADX - See description of /L0ADX/ above (section 4.41.11.8). 

4.41.11.17 Subroutine Name: PERMUT. 

1. Entry Point: PERMUT 

2. Purpose: To reorder a list of grid point ID's to allow the most efficient extraction 
of these grid points from the BGPDT. 

3. Calling Sequence: CALL PERMUT (P|3NT.i;5RD.NP.0LD) 
P0NT - List of points - integer - input. 



4.41-20 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

I0RD - Pointers to P0NT, i.e., I0RD (1) contains subscript of P5INT which should be 
extracted first from the BGPDT - integer - output. 

NP - Number of points - integer - output. 

0LD - Current position of BGPDT - integer - input. 

4.41.11.18 Subroutine Name: FNDPNT. 

1. Entry Point: FNDPNT 

2. Purpose: To extract BGPDT data from the BGPDT. 

3. Calling Sequence: CALL FNDPNT (BGPDD,P0NT) 

BGPDD - Four-word BGPDT entry - output. 

P0NT - Grid point id of desired BGPDT entry - integer - input. 

4.41.11.19 Subroutine Name: CR0SS. 

1. Entry Point: CR0SS 

2. i^urpose: To compute the cross product of two vectors. 

3. Calling Sequence: CALL CR(3SS (V1,V2,V3) 

VI - Three-word vector - real - input. 
V2 - Three-word vector - real - input. 
V3 = VI X V2 - real - output. 

4.41.11.20 Subroutine Name: N0RM. 

1. Entry Point: N0RM 

2. Purpose: To normalize a vector. 

3. Calling Sequence: CALL N0RM (VI, XLV) 

VI - Three-word vector - real - input/output. 
XLV - Norm of VI . 

VI on output = Vl/XL unless XL = 0.0, then VI = VI . 



4.41-21 



MODULE FUNCTIONAL DESCRIPTIONS 

4.41.11.21 Subroutine Name: FNDSIL. 

1. Entry Point: FNDSIL 

2. Purpose: To find the SIL value of a particular grid point id. 

3. Calling Sequence: CALL FNDSIL (GPID) 

GPID - Grid point id on input, SIL value on output - integer - inout/outnut. 

C(3MM0N/L0ADX/ 

LjlADX - See description of /L0ADX/ above (section 4.41.11.8). 

4.41.11.22 Subroutine Name: BASGLB. 

1. Entry Point: BASGLB 

2. Purpose: To convert a vector from the basic to the global coordinate system. 

3. Calling Sequence: CALL BASGLB (VIN,V0UT.GRDPNT,CSYS) 

VIN - Three-word input vector - real - input. 
VjlUT - Three-word output vector - real - output. 

VIN may equal VfilUT. 

GRDPNT - Location of grid point at which vector is to be anolied (not used unless 
coordinate system type is spherical or cylindrical) - real - input. 

CSYS - Coordinate system id - integer - input. 

C0MMjtN/L0ADX/ 

L0ADX - See description of /L0AOX/ above (section 4.41.11.8). 

4.41.11.23 Subroutine Name: GLBBAS. 

1. Entry Point: GLBBAS 

2. Purpose: To convert a vector from global to basic coordinates. 

3. Calling Sequence: CALL GLBBAS (VIN. V0UT, GRDPNT, CSYS) 
Where the variables have the same names as in BASGLB. 



4.41-22 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

4.41.11.24 Subroutine Name: MPYL. 

1. Entry Point: MPYL 

2. Purpose: To multiply two in-core matrices together: [A] • [B] = [C]. 

3. Calling Sequence: CALL MPYL (A,B,NC0LA,NR0WA,NC0LB,C) 

A (NC0LA,NR0WA) matrix | 

B (NC0L8,NC0LA) matrix > These matrices are stored row-wise. 

C (NC!2ILB,NR0WA) matrix ) 

Note : A or B ;* C 

4.41.11.25 Subroutine Name: MPYLT. 

1. Entry Point: MPYLT 

2. Purpose: To multiply two in-core matrices together [A] • [B] = [C]. 

3. Calling Sequence: CALL MPYLT (A.B,NR0WB,NC0LA,MC0LB,C) 

A (NC0LA,NR0!JB) matrix \ 

B (NC0LB,NR0i';B) matrix > These matrices are stored row-wise. 

C (NC0LB.NC0LA) matrix ) 

4.41.11.26 Subroutine Name: FDCSTM. 

1. Entry Point: FDCSTM 

2. Purpose: To extract the orientation matrix from the CSTM. 

3. Calling Sequence: CALL FDCSTM (ICSTM) 
ICSTM - Coordinate system id desired. 
C0MM0N/TRANX/XX(5) ,T0(3,3) 

T0 - 3x3 orientation matrix. 

C0MM0N/L0ADX/ 

L0ADX - See description of /L0ADX/ above (section 4.41.11.8). 



4.41-23 



MODULE FUNCTIONAL DESCRIPTIONS 

4.41.11.27 Subroutine Name: FGPTT. 

1. Entry Point: FGPTT 

2. Purpose: To find temperature in the GPTT. 

3. Calling Sequence: CALL FGPTT (SILAR.TAR.NP) 

SILAR - Array of SIL's for which temperatures are desired - integer - input. 
TAR - Array of temperatures at SIL's - real - output. 
NP - Number of entries in SILAR. 

C0m0N/FPT/T0,NSIL,NGPTT,NR0WSP 

T0 - Default temperature - real - input. 

NSIL - Number of SIL entries - integer - input. 

NGPTT - Length of GPH. 

NROWSP - Beginning of SIL table - integer - input. 

4.41.11.28 Subroutine Name: FEDT. 

1. Entry Point: FEDT 

2. Purpose: To extract one enforced deformation from the EDT given one element id. 

3. Calling Sequence: CALL FEDT (EID, DELTA, IDEFM) 

IID - Element id - integer - input. 

DELTA - Deformation of element EID - real - output. 

IDEFM - Set id of current deformation set. 

4.41.11.29 Subroutine Name: GRAVL3. 

1 . Entry Point: GRAVL3 

2. Purpose: To compute an acceleration vector for an axisymmetric shell problem. 

3. Calling Sequence: CALL GRAVL3 (NGRAV.GVECT.AG.IHARM) 

NGRAV - Number of gravity vectors - integer - input. 

GVECT - Gravity vector array - real - input. 

AG - GINSI file number of acceleration vector - integer - input. 



4.41-24 



FUNCTIONAL MODULE SSG1 (STATIC SOLUTION GENERATOR - PHASE 1) 

IHARM - Boundary condition flag 
1 = sine, 2 = cosine 

C0MMI3N//LUSET 

LUSET - Length of PG vector. 

C0MM0N/SYSTEM/IX(26),MN 

MN - Packed word giving number of rings/number of harmonics. 

4.41.11.30 Subroutine Name: TTRIRG 

1. Entry Point: TTRIRG 

2. Purpose: To calculate an element thermal load vector for a triangular cross-section 
ring in the SSGl module. 

3. Calling Sequence: CALL TTRIRG (TI.PG) 

TI - Array of four temperatures at the four points of the ring - real - input. 
PG - Load vector array - real - input. 

C0MM0N/TRIMEX/ 

TRIMEX - This contains the EST entry for the element. 

4.41.11.31 Subroutine Name: TTRAPR. 

1. Entry Point: TTRAPR 

2. Purpose: To calculate an element thermal load vector for a trapezoidal cross-section 
ring in the SSGl module. 

3. Calling Sequence: CALL TTRAPR (TI, PG) 
CJ3MM0N/TRIMEX/ 

The arguments are the same as in TTRIRG. 



4.41-25 



MODULE FUNCTIONAL DESCRIPTIONS 

4.41.11.32 Subroutine Name: TT0RDR. 

1. Entry Point: TT0RDR 

2. Purpose: To calculate an element thermal load vector for a toroidal thin shell ring 
in the SSGl module. 

3. Calling Sequence: CALL TT0RDR (TI.PG) 
C0MM!3N/TRIMEX/ 

The arguments are the same as those in TTRIRG (section 4.41.11.30). 

4.41.11.33 Subroutine Name: FCURL. 

1. Entry Point: FCURL 

2. Purpose: To form the element thermal load matrices in field coordinates for the 
toroidal thin shell ring in subroutine TT0RDR. 

3. Calling Sequence: CALL FCURL (FMEO.FMEl ,FFE0,FFE1,YI,S,LAM1 ) 

^^^°' ^p^] The resultant thermal load matrices. 

YI - Array of integral values. 

S, LAMl - Terms used in the evaluation of the thermal load matrices. 

4.41.11.34 Subroutine Name: C0NE. 

1. Entry Point: C0NE 

2. Purpose: To calculate an element thermal load vector for an axisymtnetric shell in 
the SSGl module. 

3. Calling Sequence: CALL C0NE (TI.PG) 
C0MM0N/TRIMEX/ 

The arguments are the same as in TTRIG (section 4.41.11.30). 



4.41-26 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 1) 

4.41.11.35 Subroutine Name: QDMEM. 

1. Entry Point: QDMEM 

2. Purpose: To calculate an element thermal load vector for quadrilateral elements in 
the 3SG1 module. 

3. Calling Sequence: CALL QDMEM (TI.PG) 
C0HM0N/TRIMEX/ 

The arguments are the same as in TTRIR6 (section 4.41.11.30). 

4.41.11.36 Subroutine Name: TRIMEM. 

1. Entry Point: TRIMEM 

2. Purpose: To calculate an element thermal load vector for triangular elements in 
the SSGl module. 

3. Calling Sequence: CALL TRIMEM (TYPE.TBAR.PG) 

C0MM0N/TRIMEX/ 

TYPE - Flag indicating normal entry (0) or subelement call from a QDMEM (1) - integer 
input. 

TBAR - Average temperature over the element - real - input. 
PG and /TRIMEX/ are as in TTRIRG (section 4.41.11.30). 

4.41.11.37 Subroutine Name: BAR. 

1. Entry Point: BAR 

2. Purpose: To calculate an element thermal load vector or deformation load vector for 
the bar element in the SSGl module. 

3. Calling Sequence: CALL BAR (PG, IDEFM, ITEMP, IDEFT) 
C0MM0N/TRIMEX/ 

IDEFM - if element deformation load vector is not to be computed - integer - inout. 
ITEMP - if element thermal load vector is not to be computed - integer - input. 



4.41-27 



MODULE FUNCTIONAL DESCRIPTIONS 

IDEFT - Set ID of the element deformation set. This is used only if IDEFM f- 

integer - input. 
PG./TRIMEX/ are as in section 4.41.11.30. 



4.41-28 



FUNCTIONAL MODULE SSGl (STATIC SOLUTION GENERATOR - PHASE 11 



4.41.12 Design Requirements 

Three scratch files are needed. 

Open core is defined as follows: 

1. /SSGAIX/ during EXTERN phase 

C0MM0N/SSGA1X/ 



PG 




MGG 


Buffer 


SIL 


Buffer 


CSTM Buffer 


BGPDT Buffer 


SLT 


Buffer 


PG 


Buffer 



JLUSET 



,Used if RF0RCE 
cards present 



6 GIN0 buffers 



2. /SSGBIX/ during EDTL, TEMPL phase 

C(3MM0N/SSGB1X/ 



PG 


} LUSET 


PREMAT Tables 




SIL 




GPTT 








Scratch Buffer 


I 


GPTT or EDT Buffer 


1 


CSTM Buffer 


> 5 GIN0 buffers 


EST Buffer 


I 


PG Buffer 


1 



100 L0AD ID'S maximum. 



4.41-29 



MODULE FUNCTIONAL DESCRIPTIONS 

4.41.13 Diagnostic Messages 

If the core storage requirements as depicted in the above diagrams are not met, SSGl will 
issue fatal error message 3008. 



4.41-30 



FUNCTIONAL MODULE SSG2 (STATIC SOLUTION GENERATOR - PHASE 2) 

4.42 FUNCTIONAL MODULE SSG2 (STATIC SOLUTION GENERATOR - PHASE 2) 

4.42.1 Entry Point : SSG2 

4.42.2 Purpose 

To reduce the applied load vectors and enforced displacements into equivalent load 
vectors applied to the independent displacement coordinate sets. 

4.42.3 DMAP Calling Sequence 

SSG2 USET,GM,YS,KFS,G0,DM,PG/QR.P0,PS,PL/ $ 

4.42.4 Input Data Blocks 

USET - Displacement set definitions table. 

GM - Multipoint constraint transformation matrix - m set. 

YS - Constrained displacements - s set. 

KFS - Partition of stiffness matrix after single-point constraints have been removed. 

G0 - Structural matrix partitioning transformation matrix. 

DM - Rigid body transformation matrix. 

PG - Static load vector matrix giving static loads - g set. 

Notes: 1, USET must be present. 

2. GM must be present if m set is not null. 

3. YS must be present if s set is not null. 

4. KFS must be present if s set is not null. 

5. G0 must be present If o set is not null. 

6. DM must be present 1f r set is not null. 

7. PG must be present. 

4.42.5 Output Data Blocks 

QR - Determinate support forces matrix - r set. 

P9 - Partition of the load vector matrix giving loads due to static force - o set. 

PS - Partition of load vector matrix givlrig loads in s set. 

PL - Partition of load vector matrix giving static loads on ^ set. 



4.42-1 



MODULE FUNCTIONAL DESCRIPTIONS 

Notes: 1. QR must be present if r set is non-null. 

2. P0 must be present if o set is non-null. 

3. PS must be present if s set is non-null. 

4. PL must be present if i set is non-null. 

5. If the problem has no sets, SSG2 will return. 

4.42.6 Parameters 



None 

4.42.7 Method 

The fifth word of the USET trailer control block is analyzed to determine the presence of 
m's, s's, o's, or r's. 

Each of the following steps is omitted if the appropriate set is null. The following 
steps indicate the operations on one load set vector. The actual algorithm uses all vectors 
in each step by performing matrix operations. 

1. If m's are present, the PG vectors are partitioned using USET (UG.UN.UM) and sub- 
routines CALCV and SSG2A: 

The loads on the u set are calculated as: 
n 

^'r? = t^> ' tG/ {P,} , (2) 

by calling subroutine SSG2B. 

2. If s's are present, the {P } load vectors are partitioned using USET (UN.UF.US) and 
subroutines CALCV, and SSG2A: 

(P,}=>)-p-[-( (3) 

The {P } vectors are output in data block PS. The loads on the \i. set are calculated as: 



4.42-2 



FUNCTIONAL MODULE SSG2 (STATIC SOLUTION GENERATOR - PHASE2) 

The JY I vector normally is zero. If more than one load vector is being reduced, 

<Y I is expanded to have N identical columns such that the above matrix equation 

is dimensionally consistent. This is accomplished in subroutine SSG2B1 (see below). 

3. If o's are present, the {P^} vectors are partitioned using USET (UF,UA,U0) and 
subroutines CALCV and SSG2A: 

|p I vectors are written on data block P0. 



The equivalent loads on the u, set are calculated as: 

a 

Subroutine SSG2B is called to perform this operation. 

4. If r's are present, the {P } vectors are partitioned using USET (UA,UL,UR) 
and subroutines CALCV and SSG2A: 

I I h( 

] P [ vectors are written on data block PL. 

The reaction vectors on the support points are: 

iT 



jq,[ = - jP,} - [D,]' jP,| 



(8) 



where [D ] corresponds to the data block DM. {q } vectors are written on data block QR. 
4.42.8 Subroutines 



SS62 uses matrix subroutines CALCV and SSG2A for matrix partitioning operations and 
subroutine SSG2B to drive subroutine MPYAD. See section 3 for details. 



4.42-3 



MODULE FUNCTIONAL DESCRIPTIONS 

4.42.8.1 Subroutine Name: SSG2B1 

1. Entry Point: SSG2S1 

2. Purpose: SSG2B1 is exactly like SSG2B. It computes [A] [B] + [C] = [D] except 
YS is first expanded onto SCRl which then plays the role of [b] . 

3. Calling Sequence: CALL SSG2B1 (A.SCRl ,C.D,T,PREC,ISIGN,YS,SCR2) 

The variables have the meaning as SSG2B except for YS, which is the GIN0 file number of the 
YS data block - integer - input. See 3.5.13 for SSG2B details. 

4.42.9 Design Requirements 

/SSG2X/ is open core for CALCV. Four scratch files are used. 
SSG2B1 is an entry point in SSG2B. 



4.42-4 (7/1/70) 



FUNCTIONAL MODULE SSG3 (STATIC SOLUTION GENERATOR - PHASE 3) 

4.43 FUNCTIONAL MODULE SSG3 (STATIC SOLUTION GENERATOR - PHASE 3) 

4.43.1 Entry Point : SS63 

4 . 43 . 2 Purpose : 

To perform the actual static solutions. A displacement solution is produced for each 
applied load and tested for possible matrix decomposition errors. 

4.43.3 DMAP Calling Sequence 

SSG3 LLL,ULL,KLL,PL,L0ja,U00,K00B,P0/ULV,U00V,RULV,RU0V/V,N,0MIT/V.Y.IRES $ 

4.43.4 Input Data Blocks 

LLL - Lower triangular factor of KLL - l set. 

ULL - Upper triangular factor of KLL - I set. 

KLL - Partition of stiffness matrix - i set. 

PL - Partition of the load vector matrix giving static loads on H set 

L00 - Lower triangular factor of K00B - o set. 

U00 - Upper triangular factor of K00B - o set. 

K00B - Partition of stiffness matrix - o set. 

P0 - Partition of the load vector matrix giving loads due to static forces - o set. 

Notes : 1. ULL, LLL and PL must be present. 

2. KLL can be purged if RULV is purged. 

3. U00, L00, P0 can be purged if 0MIT< 0. 

4. K00B can be purged if 0MIT<O or RU0V is purged. 

4.43.5 Output Data Blocks 

ULV - Partition of the displacement vector matrix giving displacements - i set. 

U00V - Partition of the displacement vector matrix giving displacements - o i>et. 

RULV - Residual vector matrix for the i set. 

RU0V - Residual vector matrix for the o set. 

Notes: 1. ULV must be present. 



4.43-1 



MODULE FUNCTIONAL DESCRIPTIONS 

2. U00V can be purged if 0MIT< 0. 

3. RULV and RU0V can be purged. 

4. [RULV] = [KLL] [ULV] - [PL]. 
[RU0V] = [K00B][U(30V] - [P0]. 

4.43.6 Parameters 

0MIT - Input-integer-no default. 0MIT controls operations on o-set matrices. 

IRES - Not used-integer-no default. IRES is a user-controlled parameter that he may set 

to +1 on a Bulk Data PARAM card so that residual vectors may be printed. It is 

included here to define an initial value for IRES. 

4.43.7 Method 

4.43.7.1 Solution Algorithim 

For normal statics problems PL and P0 vectors are used; for inertia relief problems 
the PLI and P0I vectors are generated in the SSG4 module and used instead of PL and P0. The 
equations to be solved are: 



[KoJ {u,} = iPJ, (1) 



and if o's are present (0MIT >^ 0) 



'iJ, 



[^0^ tu°„] = (P,}. (2) 



where 

^hi^ - tL,,] [U,,] . (3) 

[K,„] = [L„„] [U„^] . (4) 

[Ljj] and [L ] are lower traingular matrices. [Uj,^] and [U ] are upper triangular matrices. 
The equations are solved in the following manner: 

[L] [U] {u} = {P}. (5) 

or 



4.43-2 



FUNCTIONAL MODULE SSG3 (STATIC SOLUTION GENERATOR - PHASE 3) 

[L] {y} = {P} . (6) 

In turn the solution for the displacement vector is: 

[U] {u} = {y} . (7) 

4.43.7.2 Error Check Algorithm 

If RULV is not purged, an error check is made. Since it is possible for the stiffness 
matrices to be nearly singular or ill-conditioned, the module calculates the following error 
analysis terms for both the {u„} and {u } solutions: 

X. 

(•SP^} = {P^} - [K^^] {u^} , (8) 

{u }T {69} 

{6Pj^} forms data block RULV or RU(3V. e, is printed for each solution. 

4.43.8 Subroutines 

SSG3A - is the only auxiliary subroutine in module SSG3 (see section 3.5.18 for description), 

4.43.9 Design Requirements 

Two scratch files are needed. 



4.43-3 



FUNCTIONAL MODULE SSG4 (STATIC SOLUTION GENERATOR - PHASE 4) 

4.44 FUNCTIONAL MODULE SSG4 (STATIC SOLUTION GENERATOR - PHASE 4). 

4.44.1 Entry Point : SSG4 

4 . 44 . 2 Purpose 

The purpose of this module is to calculate mass loads in a Static Analysis with Inertia 
Relief problem. The rigid body accelerations are functions of the reactions on the fictitious 
supports. The inertia loads on the structure are proportional to these accelerations. 

4.44.3 DMAP Calling Sequence 

SSG4 PL,qR,P0,MR,MLR,DM,MLL,M0|2IB,M0AB,G0,USET/PLI,P0I/V,N,!3MIT $ 

4.44.4 Input Data Blocks 

PL - Partition of the load vector matrix giving static loads - I set. 

QR - Determinate support forces matrix - r set. 

P0 - Partition of the load vector matrix giving loads due to static force - o set. 

MR - Rigid body mass matrix - r set. 

MLR - Partition of mass matrix. 

DM - Rigid body transformation matrix. 

MLL - Partition of mass matrix - i set. 

M00B - Partition of mass matrix - o set. 

M0A3 - Partition of mass matrix. 

G0 - Structural matrix partitioning transformation matrix. 

USET - Displacement set definitions table. 

Note : All matrices must be present if their appropriate set is non-null. 

4.44.5 Output Data Blocks 

PLI - Partition of load vector for inertia relief matrix giving loads due to static and 
inertial forces on i set. 



4.44-1 



MODULE FUNCTIONAL DESCRIPTIONS 

P|8I - Partition of load vector for inertia relief matrix giving loads due to inertia! and 
static forces on o set. 

Note : Both matrices must be present if their appropriate set is non-null. 

4.44.6 Parameters 

(JMIT - Input-integer-no default. If 0MIT > 0, the o set is non-null. 

4.44.7 Method 

1. The accelerations of the u degrees of freedom are: 

{a^} = - [m^]"^ {q^}. (1) 

[m ] corresponds to data block MR. Subroutines FACT0R and SSG3A are used to solve for {a^}, 

2. The total load vectors on the structure are: 

^Pi> = tV-^K3tD].[M,^]] {a^}. (2) 

[D] corresponds to data block DM. Subroutine SSG2B is used to drive MPYAD, 

3. If 0MITa 0: 

^Pi> = ^"o^ ' Ho^ t'^o^ ' tM„,]] [-?-] {a^}. (3) 

The product -j-J {a^} is formed by merging columns of [D] {a^} with (a } using USET (UA.UL.UR). 
Subroutine SDRIB is used to drive MERGE, and SSG2B for the matrix products. 

4.44.8 Subroutines 

SSG2B - See subroutine description, section 3.5.13 
SSG3A - See subroutine description, section 3.5.18 
SDRIB - See subroutine description, section 3.5.8 

4.44.9 Design Requirements 

Five scratch files are necessary. 



4.44-2 



FUNCTIONAL MODULE SDRl (STRESS DATA RECOVERY - PHASE 1) 
4.45 FUNCTIONAL MODULE SDR] (STRESS DATA RECOVERY - PHASE 1) 

4.45.1 Entry Point : SDRl 

4.45.2 Purpose 

The SDRl module utilizes solution vectors to produce displacements, eigenvectors, 
velocities, accelerations, applied loads and reaction loads. The vectors input to SDRl are 
in the form of packed matrices with each column a solution vector for a different subcase, 
eigenvalue, frequency/ load, or transient output time. The row position of each term in a 
vector corresponds to a degree of freedom in a unique displacement set. The relative position 
of the term must be converted to a relative position in the vector which includes all dis- 
placement components in the system. The dependent components of the displacement vector 
are recovered and merged to produce a complete vector describing all degrees of freedom in 
the structural or dynamics model. In the Static Analysis or Static Analysis with Inertia 
Relief Rigid Formats, SDRl collects solutions for each boundary condition onto a single file, 
convenient for the solution of symmetry problems. 

4.45.3 DMAP Calling Sequence 

SDRl USET,PG,ULV,U00V,YS,G0,GM,PS,KFS,KSS,QR/UGV,PGG,QG/V,N.APPEND/V,N,F0RMAT $ 

4.45.4 Input Data Blocks 

USET - Displacement set definitions table. 

PG - Static load vector matrix giving static loads - g set. 

ULV - Partition of the displacement vector matrix giving displacements -i set. 

U00V - Partition of the displacement vector matrix giving displacements in the o set. 

YS - Constrained displacements - s set. 

G0 - Structural matrix partitioning transformation matrix. 

GM - Rigid body transformation matrix. 

PS - Partition of load vector matrix giving loads in s set. 

KFS - Partition of stiffness matrix after single-point constraints have been 

removed - s set. 

KSS - Partition of stiffness matrix after single-point constraints have been 

removed - s set. 

QR - Determinate support forces matrix - r set. 



4.45-1 



MODULE FUNCTIONAL DESCRIPTIONS 

Notes: 1. USET must always be present. 

2. PG may or may not be present. 

3. ULV must always be present. 

4. um must be present unless the o set is null or F0RMAT = DYNAMICS (see below). 

5. YS may or may not be present. 

6. G0 must be present unless the o set is null. 

7. GM must be present unless the m set is null. 

8. PS may or may not be present. 

9. KFS must be present unless the s set is null or QG is not present. 

10. KSS must be present unless YS 1s absent or the s set is null or QG is not present. 

11. QR may or may not be present. 

4.45.5 Output Data Blocks 

UGV - Displacement vector matrix giving displacements in the g set. 

PGG - Static load vector appended to include all boundary conditions - g set. 

QG - Single-point constraint forces and determinate support forces matrix - g set. 

Notes: 1. If PG is present, PGG must be present. 

2. UGV must be present. 

3. QG must be present. 

4. If APPEND ^ 1, UGV, PGG, QG will be appended to the data already on these files. 

4.45.6 Parameters 

APPEND - Input-integer- no default. See note 4 above. 

FORMAT - Input-BCD-no default. Format indicates the problem type. 
STATICS - Statics type problem. 
REIGEN - Real eigenvalue problem. 
DYNAMICS - Dynamic problem. 

4.45.7 Method 

The following steps are performed by the SDRl module in the most general case. Most 
problems, however, do not use all of the constraint options. In these cases certain steps 



4.45-2 



FUNCTIONAL MODULE SDRl (STRESS DATA RECOVERY - PHASE 1) 

are skipped. The task SDRl performs also varies from Rigid Format to Rigid Format. 

1. If PG is present, it is copied or appended onto PGG. (Subroutine SDR1A). 

2. If r's are present and the problem type is not DYNAMICS or REIGEN: 



l^i -> l".i ■ 



This is accomplished by subroutine SDRIB, the driver for MERGE. See section 3.5.8 for 
details. 



If s's are also present: 



n => "f ■ '^' 



Otherwise, 



q 



> => %\- "' 



which is then copied or appended onto QG. (Subroutine SDRIB and SDRl A). 

3. If o's are present, the dependent degrees of freedom of the "omitted" coordinates 
{u } are computed. For statics problems: 

)"o[ = [^o] l"af ^ K} • (4) 

For Dynamic problems: 

This is accomplished by calling SSG2B (see section 3.5.13). The Independent degrees of 
freedom {u,} or {u .} are merged with the dependent coordinates {u„} , using subroutine 
SDRIB: 



(6) 



4. If s's are present, the coordinates fixed by single-point constraints, 5u |, 



4.45-3 



MODULE FUNCTIONAL DESCRIPTIONS 



may have constrained displacements, {Y }, in a statics problem. These are merged with 



the {u,} vector using subroutine SDRIB: 



^ 



j;\ => t"n> (^) 



The forces of single-point constraint {q } are calculated using SSG2B from the equation: 

Subroutine SDRIB is used to merge {q^} with {q^} to form {q } . {q^} is {q^} expanded to 
the f-set: 



^ => u, • 



{q } is copied or appended onto data block QG (Subroutine SDRIA). If YS is not present. 



^ => {u„}. (10) 



The forces of single-point constraint are computed as in Equation 7 except the (Y^} term 
is omitted. 

If e-points (extra points) are present in a dynamics problem, i^f^l must oe converted to 
[Kx.] by subroutine SDRIC. If the problem is a transient problem, {u^} must be reduced to 
displacement vectors only, since {u-} contains triples - displacement, velocity and 
acceleration in transient problems. This reduction is accomplished in SDRlD. 

5. If m's are present, the dependent coordinates, {u^^^}, of the multipoint constraint 
equations are calculated using: 

{u^} = [GJ {u^} . (11) 

In dynamics problems [G^l = [G^]. The two vectors {u^} and {u^} are merged 



4.45-4 



FUNCTIONAL MODULE SDRl (STRESS DATA RECOVERY - PHASE 1) 

{-u;-| => cug) . (12) 

6, {u } (or {Up} for dynamics problems) is copied or appended onto UGV. 
4,45.8 Subroutines 

SSG2B and SDRIB are used as utility routines. See section 3.5.13 and 3.5.8 for details. 

4.45.8.1 Subroutine Name: SDRIA 

1. Entry Point: SDRIA 

2. Purpose: To copy or append vectors. 

3. Calling Sequence: CALL SDRIA (IN,I0UT) 

IM - GIN0 file number of input file - integer - input. 

W[ - GIN0 file number of output file - integer - input. 

C0MM0N//IAPEND- Append flag. If lAPEND ?* 1, I0UT will be positioned after the last 

record and IN copied onto I0UT at this point. Otherwise IN is copied 

onto I0UT, 

4.45.8.2 Subroutine Name: SDRIC 

1. Entry Point: SDRIC 

2. Purpose: To expand a file (KFS) from the f set to the fe set for dynamics. 

3. Calling Sequence: CALL SDRIC (IPVECT.KFS.KDFS) 

IPVECT - GIN0 file number of the partitioning vector previously generated - 

integer - input. 
KFS - GIN0 file number of [K^^] - integer - input. 
KDFS - GIN0 file number of [K^^] - integer - input. 

4. Design Requirement: SDRIC depends on a previous call to SDRIB to initialize set 
parameters. 

4.45.8.3 Subroutine Name: SDRID 
1, Entry Point: SDRID 



4.45-5 



MODULE FUNCTIONAL DESCRIPTIONS 

2. Purpose: To strip velocity and acceleration vectors from {u^}. 

3. Calling Sequence: CALL SDRID (PS.IUF.IUFl .ITRAN) 

PS - GINJ) file number of PS - Integer - Input. 
lUF - GIN0 file number of {u^} - integer - input. 
lUFl - GINO file number of {u^} stripped - integer - input. 
ITRAN - Flag which shows whether problem Is a transient analysis or not - integer 
input. Its values are: 

1 =^ not transient 

=^ transient. 



4.45.9 Design Requirements 

Six scratch files are required. 



4.45-6 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

4.46 FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

4.46.1 Entry Point : SDR2 

4.46.2 Purpose 

The SDR2 module processes the output requests for forces of single-point constraint, 
loads, point displacements, point velocities, point accelerations, element stresses, and element 
forces, formatting the output data blocks with these final output results for: a) direct output- 
ing by the Output File Processor (0FP) module or b) input to the S0RT2 processor (SDR3) module and 
then the XY-output modules (XYTRAN and XYPL0T). 

4.46.3 DMAP Calling Sequence 



^^«2 tegs}'^^™.^".^^^.|si'{sitD|'^^^^'^°^' 



PGG W QG \ I SgJi 

y. PGVl / \ QBG / \ JJ!;' , , . 

BGPDT, PPF , BQG U yPVC J^^T I.XYCDB / 

'PPT QGl UBGV |ESTL '^ ' 

LAMA W QPC \ / SJJ ' ' ' 

CLAMA / \ QP / CPHIP 



/ oinn \ I 0UGV1 
aPGI ) En \ "UPVl /(0ES1 ) (0EF1 ) (PUPV ) 
0PPC1 i Sf "^PVCl ) 0ESC1 ( } 0EFC1 ( )PUGV1 ( . 

K r Sn ' "^UBGVl •)0ESB1 M 0EFB1 MpPHIG ( ' 
^ * / SSof^ / 0PHIG \ (0BES1 ) ( 0BEF1 ) (pUBGVl) 



0QP1 



0CPHIP 



STATICS 
RE I GEN 
DSO 
DSl 

^•'^' '! TRANSNT ^ /V.N.N0S0RT2 $ 
BLKO 
BLKl 
CEIGEN 
.PLA 



4.46-1 



MODULE FUNCTIONAL DESCRIPTIONS 



4.46.4 Input Data Blocks 

CASECC - Case Control Data Table. 

CASEXX - Case Control Data Table for Dynamics problems. 

CSTM - Coordinate System Transformation Matrices. 

MPT - Material Property Table. 

DIT - Direct Input Tables. 

EQEXIN - Equivalence between external grid or scalar numbers and internal numbers. 

EQDYN - Equivalence between external points and scalar index values. 

SIL - Scalar Index List. 

SILD - Scalar Index List for Dynamics. 

GPTT - Grid Point Temperature Table. 

EDT - Element Deformation Table. 

BGPDT - Basic Grid Point Definition Table. 

PGG - Static load vector appended to Include all boundary conditions. 

PGVl - Matrix of successive sums of incremental load vectors. 

PPF - Dynamic loads for frequency response. 

PPT - Linear dynamic loads for transient analysis. 

LAMA - Real Eigenvalue Table. 

CLAMA - Complex Eigenvalue Table. 

QG - Single-point constraint forces and determinant support forces matrix. 

QBG - Single-point forces of constraint matrix for Differential Stiffness - g set. 

BQG - Single-point forces of constraint matrix for a Buckling Analysis problem - g set. 

QGl - Matrix of successive sums of Incremental vectors of single-point constraint 

forces. 

QPC - Complex single-point forces of constraint - p set. 

QP - Transient single-point forces of constraint - p set. 

UGV - Displacement vector matrix giving displacements in the g set. 

UGVl - Matrix of successive sums of incremental displacement vectors. 

UPV - Transient solution vectors - p set. 



4.46-2 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 



UPVC 
UBGV 



- Frequency response solution vectors - p set. 

- Displacement vector matrix for differential stiffness giving displacements 
in the g set. 

PHIG - Eigenvector matrix giving eigenvectors. 

CPHIP - Complex eigenvectors in the p set. 

EST - Element Summary Table. 

ESTL - Element Summary Table for Linear Elements. 

XYCDB - XY Case Control Data Block. 



Notes; 



1. If the first input data block is purged, it is a fatal error. This data 
block is called "Case Control" in this Module Functional Description. 

2. The CSTM may be purged if no coordinate systems are referenced, or if stresses 
and/or forces are not requested. 

3. The MPT may be purged if no stress or force requests are present. 

4. The DIT may be purged if no stress or force requests are present, or if no 
temperature dependent materials are referenced. 

5. The second record of EQEXIN or EQDYN must exist if a request exists for any of: 
loads, forces of single-point constraint, displacements, velocities, accelerations, 
or plots, 

6. SIL or SILD may be purged if no stress or force requests exist, or there are 
no extra-points and no thermal loads. (The second record is used by SDR2). 

7. The GPTT may be purged if no thermal loading exists, or there are no requests for 
stresses or forces. 

8. The EDT may be purged if there are no element requests for forces or stresses, 
or if there are no enforced element deformations in the problem. 

9. The BGPDT may be purged if the problem is in basic coordinates and no element 
requests for stresses or forces exist. 

10. LAMA or CLAMA may not be purged if an eigenvalue or frequency response problem. 



4.46-3 



MODULE FUNCTIONAL DESCRIPTIONS 

11. If input data block 11 (QG or QBG etc.) is purged, forces of single-point constraint 

requests are ignored. 

12. If input data block 12 (UGV or UGVl etc.) is purged. SDR2 will process only loads and 
forces of single-point constraint requests. 

13. If the EST or ESTL is purged, element stresses and force requests are ignored. 

14. The XYCDB may be purged. 
4.46.5 Output Data Blocks 

0PG1 - ) 

0PPC1 -> Output load vector requests. 

0PP1 - ) 

0QG1 - \ 

0BqGl -(output forces of single-point constraint requests. 

0QPC1 - ( 

0QP1 - ; 

0UGV1 - ) ^ ^ 

0UPVC1 -> Output displacement vector requests. 

0UBGV1 - ) 



^^^UTP '} Output eigenvector requests. 



0CPHIP 

0ES1 

0ESC1 -J. Output element stress requests. 

0BES1 

0EF1 - -J 

0EFC1 - I Output element force requests. 
0EFB1 - I 
0BEF1 - ' 

PUPV , .J. * 

PUGVl - [Translation components of the displacement vector rotated to basic coordinates. 

PUBGVl 
Notes : 

Output data blocks purged will result in output requests to those data blocks 
not being processed. 



4.46-4 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 



4.46.6 Parameters 



STATICS - BCD constant indicating a Statics solution. 

REIGEN - BCD constant indicating a Real Eigenvalue solution. 

DSC - BCD constant indicating the Statics phase of a Differential Stiffness solution. 

DSl - BCD constant indicating final phase of a Differential Stiffness solution. 

FREQ - BCD constant indicating a Frequency Response solution. 

TRANSNT - BCD constant indicating a Transient Response solution. 

BKLO - BCD constant indicating the Statics phase of a Buckling solution. 

BKL1 - BCD constant indicating the final phase of a Buckling solution. 

CEIGEN - BCD constant indicating a Complex Eigenvalue solution. 

PLA - BCD constant indicating a Piecewise Linear Analysis solution. 

N0S0RT2 - Integer-Output-Set to if there are no S0RT2 requests or requirements, 
and set to 1 otherwise. 



4.46-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.46.7 Method 

The SDR2 functional module is constructed in a modular form consisting of five stages. 
A small executive control program (subroutine SDR2) containing the main entry point for the 
module serially calls the five stages for execution. 

1. Stage I, performed by subroutine SDR2AA, prepares, if necessary, a modified Case 
Control data block, internal to SDR2, to insure that any XY-output requests present 
and not included in the 0FP output requests of Case Control are included in the output 
of SDR2 for later processing by functional modules XYTRAN and XYPL0T. 

2. Stage II, performed by subroutine SDR2A, analyzes the overall output requests within 
the subcases of Case Control and sets flags for use by stages III, IV, and V. 

3. Stage III, performed by subroutine SDR2B. is executed only if stage II has determined 
that some element force or stress output requests are present within Case Control. If 
executed, element stress matrices are computed once and stored along with certain other 
element properties appearing in the EST for each element appearing in a master set of 
element requests. (The master set is a set which is the union of all elements for which 
output requests are present in any subcase of Case Control). These stored data are used 
in stage V repeatedly as necessary to satisfy the various output request combinations 
and multiple displacement vectors that may be present. 

4. Stage IV, performed by subroutine SDR2C, is executed only if in stage II it has been 
determined that some output requests are present for any of: forces of single-point 
constraint, loads, displacement, velocities, accelerations, or deformed structure plots. 
If they are present, these requests (except for structure plots) are fully processed 
within this stage. 

5. Stage V. performed by subroutine SDR2D, is executed only if stage III was executed. 
Stage V performs final element stress and force computations. For each subcase of Case 
Control containing element output requests, the appropriate displacement vector is applied 
to the stress matrices, computed in Stage III. of the elements requested for output to 
arrive at the final stress and/or force outputs. 



4.46-6 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

For several of the five stages the main subroutine listed utilizes additional subroutines 
to accomplish its particular task. The methods employed within each stage are further 
described in the subroutine descriptions in the next section. 

4.46.8 Subroutines 

The utility routines PRETRS and PREfW are called within the SDR2 module for initialization 
purposes so that the structural element subroutines can call the entry point TRANSS of PRETRS 
and mi of PREMAT to fetch Coordinate System Transforation Matrices (CSTM) data and material 
properties (MPT and DIT) data respectively. GMMATS is used by element routines as a general 
matrix multiply routine and INVERS is used for inversion of small in-core (order usually < 12) 
matrices. It should be noted that all matrices referenced in the structural element subroutines 
are stored by rows and are single precision. See the subroutine descriptions for these 
routines in section 3. 

The axisymmetric shell element routines STRIRl. STRAP 1 . ST0RD1 . STRIR2. STRAP2. ST0RD2 
utilize the following functions and subroutines whose double precision versions are described 
in the Module Functional Description for SMAl (section 4.27.8). 



SDR2 (Single precision ) 

AI 

AK 

AM 

BINT 

AJ 

C0EF 

F89 

FFIOO 

IFAC 

FJAB 

F6219 

F6211 

R0MBER 

F4 

F5 

F6 

AMATRX 



SMAl (Double precision ^ 



DKI 

DKK 

DKf'l 

DKINT 

DKJ 

DKEF 

DK89 

OKI 00 

KFAC 

DKJAB 

DK219 

DK211 

R0MBDK 

D4K 

D5K 

D6K 

DMATRX 



4.46-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4.46.8.1 Subroutine Name: SDR2AA 

1. Entry Point: SDR2AA 

2. Purpose: To perform stage I as defined above, under "Method". 

3. Calling Sequence: CALL SDR2AA 

4 Method: SDR2AA attempts to open the XYCDB data block. If it is purged, a return is 
given to SDR2. Otherwise, the header record and first data record of XYCDB are skipped 
and data applying to all subcases are read from the second data record. If no such data 
exist a dummy master is created. Otherwise, the master data are reduced to a list of 
unique pairs. If only master data exist, flags are set appropriately. 

For each record in the Case Control data block the following processing occurs. 

a. The record is read into core. If no XYCDB subcase corresponds to the Case 
control subcase, pointers are set to the master data. Otherwise, the master data 
and appropriate XYCDB subcase data are merged and reduced to unique pairs. 

b. For each request for solution set output in XYCDB. the corresponding request 
in case Control is examined. If no request is present in Case Control, the XYCDB 
request is reduced to a set in Case Control format, and a request for the set is 
turned on in Case Control. If the Case Control set is "ALL", no further action 

is taken. If the Case Control request is a set. the set is "merged" with the XYCDB 
set. and the request is altered to reflect the new set (unless all points in the 
XYCDB set were already in the Case Control set). A flag is set if any new requests 
are formed. 

c. When all requests for the current Case Control record have been analyzed, the 
record (as modified) is written on a scratch file. 

d. When all Case Control records have been read, the GIN0 file name for the Case 
control data block is switched to the scratch file (unless no modifications were 
made to Case Control). 

4.46.8.2 Subroutine Name: SDR2A 

1. Entry Point: SDR2A 



4.46-8 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

2. Purpose: To perform stage II as defined above, under "Method". 

3. Calling Sequence: CALL SDR2A 

4. Method: SDR2A analyzes Case Control to determine the overall output requests. Flags 
are set to zero for all request possibilities, and, as each record of Case Control is 
analyzed, flags are set to 1 for those requests present. Simultaneously, a master set 

of all structural elements requested for output is created. The master set is then a 
union of all element requests present with duplicates removed. 

4,46.8.3 Subroutine Name: SDR2B 

1. Entry Point: SDR2B 

2, Purpose: To perform stage III as defined above, under "Method". 

3. Calling Sequence: CALL SDR2B 

4, Method: SDR2B performs the "phase I" stress and force recovery computations. 

The CSTM is first read into core, if present, and then the material property data are 
read into core via the routine PREMAT. At this point, the EST is opened and processed 
with one pass. 

SDR2A determined a master set list of all elements requested by the user to be 
output. This master set list, residing in core, is now used as the EST is processed. 

For each record of the EST a particular element type is represented. Thus the first 
word of an EST record (giving the element type) is read, and the element dependent 
variables are set. The element summary for each element of this type is read, and, if 
the element is included in the master set, the phase I stress recovery routine is called 
to compute the element stress matrices which are functions of element geometry and 
material properties only. The results of this computation are output to a scratch data 
block for use by SDR2D (stage V). When the end-of-record is encountered on the EST for 
this element type, the next element type record is processed, until all records of the 
EST have been passed. 



4.46-9 



MODULE FUNCTIONAL DESCRIPTIONS 

4.46.8.4 Subroutine Name: SR0D1 

1. Entry Point: SR0D1 

2. Purpose: To generate element stress matrices for the R0D element. 

3. Calling Sequence: CALL SR0D1 

4.46.8.5 Subroutine Name: SBEAMl 

1. Entry Point: SBEAMl 

2. Purpose: To generate element stress matrices for the BEAM element. 

3. Calling Sequence: CALL SBEAMl 

4.46.8.6 Subroutine Name: STUBEl 

1. Entry Point: STUBEl 

2. Purpose: To generate element stress matrices for the TUBE element. 

3. Calling Sequence: CALL STUBEl 

4.46.8.7 Subroutine Name: SPANLl 

1. Entry Point: SPANLl 

2. Purpose: To generate element stress matrices for the SHEAR and TWIST elements. 

3. Calling Sequence: CALL SPANLl (lARG) 
V 4 implies SHEAR panel element stress matrices will be generated. 



IRAG 

5 implies TWIST panel element stress matrices will be generated. 

4.46.8.8 Subroutine Name: STRBSl 

1. Entry Point: STRBSl 

2. Purpose: To generate element stress matrices for the TRBSC element and perform 
sub-computations for the SQPDLl and STRPLl routines. 



4.46-10 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

3. Calling Sequence: CALL STRBSl (lARG) 

(o = TRBSC element 
IARG< 1 = Sub-computations for SQDPLl . 

I 2 = Sub-computations forSTRPLl. 

4.46.8.9 Subroutine Name: STRPLl 

1. Entry Point: STRPLl 

2. Purpose: To generate element stress matrices for the TRPLT element. 

3. Calling Sequence: CALL STRPLl 

4.46.8.10 Subroutine Name: SQDPLl 

1. Entry Point: SQDPLl 

2. Purpose: To generate element stress matrices for the QDPLT element. 

3. Calling Sequence: CALL SQDPLl 

4.46.8.11 Subroutine Name: STRMEl 

1. Entry Point: STRMEl 

2. Purpose: To generate element stress matrices for the TRMEM element and perform 
sub-computations for the SQDMEl routine. 

3. Calling Sequence: CALL STRMEl (lARG) 

/ = TRMEM 

iarg| 

1 = Sub-computations for SQDMEl subroutine. 
4.46.8.12 Subroutine Name: SQDMEl 

1. Entry Point: SQDMEl 

2. Purpose: To generate element stress matrices for the QDMEM element. 

3. Calling Sequence: SQDMEl 



4,46-11 



MODULE FUNCTIONAL DESCRIPTIONS 

4.46.8.13 Subroutine Name: SELASl 

1. Entry Point: SELASl 

2. Purpose: To generate element stress matrices for the elements listed under the 
Calling Sequence. 

3. Calling Sequence: CALL SELASl (lARG) 

(1 = ELASl 

2 = ELAS2 

3 = ELAS3 

4 = ELAS4 

4.46.8.14 Subroutine Name: STRQDl 

1. Entry Point: STRQDl 

2. Purpose: To generate element stress matrices for the elements listed under the 
Calling Sequence. 

3. Calling Sequence: CALL STRQDl (lARG) 



'1 


= 


TRIAl 


2 


= 


TRIA2 


1.RG < 3 


= 


QUADl 


4 


= 


qUAD2 



4.46.8.15 Subroutine Name: SBARl 

1. Entry Point: SBARl 

2. Purpose: To generate element stress matrices for the BAR element. 

3. Calling Sequence: CALL SBARl 

4.46.8.16 Subroutine Name: SC0NE1 

1. Entry Point: SC0NE1 

2. Purpose: To generate element stress matrices for the C0NE element. 

3. Calling Sequence: CALL SC0NE1 



4.46-12 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

4.46.8.17 Subroutine Name: STRIRl 

1. Entry Point: STRIRl 

2. Purpose: To generate element stress matrices for the TRIRG element. 

3. Calling Sequence: CALL STRIRl 

4.46.8.18 Subroutine Name: STRAPl 

1. Entry Point: STRAPl 

2. Purpose: To generate element stress matrices for the TRAPRG element. 

3. Calling Sequence: CALL STRAPl 

4.46.8.19 Subroutine Name: ST0RD1 

1. Entry Point: ST0RD1 

2. Purpose: To generate stress matrices for the T0RDRG element. 

3. Calling Sequence: CALL ST0RD1 

4.46.8.20 Subroutine Name: SDR2C 

1. Entry Point: SDR2C 

2. Purpose: To perform stage IV as defined above, under "Method". 

3. Calling Sequence: CALL SDR2C 

4. Method: SDR2C operations are dependent on the Rigid Format being executed. In all 
cases the second record of EQEXIN or EQDYN is first read into core. An over-all loop 

of 3 passes is then executed to process the following: pass 1: displacements, velocities, 
accelerations; pass 2: single-point constraint forces; and pass 3: loads. 

For each pass the Case Control data block is opened for input, and the following 
operations are performed depending on Rigid Format: 

a. For eigenvalue problems, a list of eigenvalues and mode numbers is read into core 
from LAMA or CLAMA. 

b. For Differential Stiffness or Buckling phase 1 problems, the first record of 



4.46-13 



MODULE FUNCTIONAL DESCRIPTIONS 

Case Control, which is used in phase of Buckling or Differential Stiffness, is 

skipped. 

c. For frequency or transient response problems, a list of frequencies or times is 

read into core from PPF or PPT. 

At this point a record in Case Control is read, and it is determined if a symmetry 
sequence of length LSYM is to be output. If it is, the previous LSYM vectors of the 
UGV data block are unpacked and a linear combination is formed in core. Otherwise, UGV is 
opened, if not yet opened, and the next vector present is unpacked into core. 

Data items are now assembled for the identification record, and this identification 
record is output to the output data block. Output line entries for the point-ID's requested 
are then written on the output data block forming a data record. At this time, if the user 
requested magnitude/phase for complex outputs, the magnitude/phase computations are performed 
on the real/imaginary pairs. 

When all requests have been processed for this vector, the next Case Control record 
is read. If no more Case Control records exist and there are more vectors present, 
those vectors are processed using the last Case Control record's specifications. 

When all vectors have been processed for the current loop pass, the next pass may 
be made for forces of single-point constraint or loads. 

If deformed structure plots are requested, an output plot data block is formed 
during the first loop pass, described above, containing translation components of the 
displacement vector rotated to basic coordinates. 

4,46.8.21 Subroutine Name: SDR2D 

1. Entry Point: SDR2D 

2. Purpose: To perform stage V as defined above, under "Method". 

3. Calling Sequence: CALL SDR2D 



4.46-14 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

4. Method: SDR2D performs the phase 2 stress and force recovery computations. In this 
phase actual stresses and forces are computed for the user-requested elements. These 
stresses and forces are a function of the stress matrices computed in Stage III and the 
displacements at the grid points of the elements. 

The operations of SDR2D are dependent upon the Rigid Format being executed. In 
all cases the Case Control data block is opened first. For eigenvalue problems a list 
of eigenvalues and mode numbers is read into core from LAMA or CLAMA. For Differential 
Stiffness or Buckling phase 1 problems, the first record of Case Control, which is used 
in phase of Buckling or Differential Stiffness, is skipped. For frequency or 
transient response problems, a list of frequencies or times is read into core from PPF 
or PPT. 

Core and 6IN0 buffers are then allocated as required for a) the Case Control data block, 
b) the Element Deformation Table, c) the Grid Point Temperature Table, and d) the elerent 
stress matrices. If there is insufficient space in core for the element stress matrices, 
they are maintained on the scratch data block generated in stage III. 

The displacement data block (UGV) is now opened, and the displacement vectors present 
are processed serially with Case Control as in stage IV. Each element requested for 
output has its respective phase 2 element stress and force recovery routine called. 
The element routine outputs form the entries for the output data record of this 
element type. In the case of a complex displacement vector, the element routine 
is called first with a pointer to the real displacement vector and then with a pointer 
to the imaginary displacement vector. The results of these two calls are merged to 
form the complex output stresses and forces. 

4.46.8.22 Subroutine Name: SDR2E 

1. Entry Point: SDR2E 

2. Purpose: To pass through the element stress matrices once, executing the final 
element stress and force computations for the requests in the current subcase of Case 
Control. 

3. Calling Sequence: SDR2E ($n) 

n = F0RTRAN statement number defining the return taken in the event of an error in SDR2E, 

4.46-15 



MODULE FUNCTIONAL DESCRIPTIONS 

4.46.8.23 Subroutine Name: SR0D2 

1. Entry Point: SR0D2 

2. Purpose: To perform final stress and force computations for the R0D element. 

3. Calling Sequence: CALL SR0D2 

4.46.8.24 Subroutine Name: SBEAM2 

1. Entry Point: SBEAM2 

2. Purpose: To perform final stress and force computations for the BEAM element. 

3. Calling Sequence: CALL SBEAM2 

4.46.8.25 Subroutine Name: SPANL2 

1. Entry Point: SPANL2 

2. Purpose: To perform final stress and force computations for the SHEAR and TWIST 
elements. 

3. Calling Sequence: CALL SPANL2 (lARG) 

1 4 = SHEAR element. 
lARG"^ 

5 = TWIST element. 

4.46.8.26 Subroutine Name: SELAS2 

1. Entry Point: SELAS2 

2. Purpose: To perform final stress and force computations for the ELASl , ELAS2, 
ELAS3, and ELAS4 elements. 

3. Calling Sequence: CALL SELAS2 

4.46.8.27 Subroutine Name: SBSPL2 

1. Entry Point: SBSPL2 

2. Purpose: To perform final stress and force computations for the TRBSC, TRPLT, 
and QDPLT elements. 



4.46-16 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

3. Calling Sequence: CALL SBSPL2 (lARG) 

= TRBSC element. 

lARG { 3 = TRPLT element. 

4 = QDPLT element. 

4.46.8.28 Subroutine Name: STQME2 

1. Entry Point: STQME2 

2. Purpose: To perform final stress computations for the TRMEM and QDMEM elements. 

3. Calling Sequence: CALL STQME2 (lARG) 

I 1 = TRMEM element. 
lARG^ 

2 = QDMEM element. 

4.46.8.29 Subroutine Name: STRQD2 

1. Entry Point: STRQD2 

2. Purpose: To perform final stress and force computations for the TRIAl , TRIA2, QUADl, 
and QUAD2 elements. 

3. Calling Sequence: CALL STRQD2 (lARG) 

/ 3 = TRIAl or TRIA2 element. 
lARGJ 

4 = QUADl or QUAD2 element. 

4.46.8.30 Subroutine Name: SC0NE2 

1. Entry Point: SC(3NE2 

2. Purpose: To perform final harmonic stress and force computations for the C0NE element. 

3. Calling Sequence: CALL SC(3NE2 



4.46-17 



MODULE FUNCTIONAL DESCRIPTIONS 

4.46.8.31 Subroutine Name: SC0NE3 

1. Entry Point: SC0NE3 

2. Purpose: To compute the final stresses and forces for one of the 14 possible 
points in a C0NE element. 

3. Calling Sequence: CALL SCiaNE3 (LARG) 

LARG = Logical argument set .FALSE, initially and then set .TRUE, by SC|i)NE3 after 
the last point defined for a particular element has had its final stresses 
and forces computed. 

4.46.8.32 Subroutine Name: SBAR2 

1. Entry Point: SBAR2 

2. Purpose: To perform final stress and force computations for the BAR element. 

3. Calling Sequence: CALL SBAR2 

4.46.8.33 Subroutine Name: STRIR2 

1. Entry Point: STRIR2 

2. Purpose: To perform final stress and force computations for the TRIRG element. 

3. Calling Sequence: CALL STRIR2 (TGRID) 

TGRID = 3 word real array giving grid point temperatures at the 3 connection grid points. 

4.46.8.34 Subroutine Name: STRAP2 

1. Entry Point: STRAP2 

2. Purpose: To perform final stress and force computations for the TRAPRG element. 

3. Calling Sequence: CALL STRAP2 (TGRID) 

TGRID = 4 word real array giving grid point temperatures at the 4 connection grid points. 



4.46-18 



FUNCTIONAL MODULE SDR2 (STRESS DATA RECOVERY - PHASE 2) 

4.46.8.35 Subroutine Name: ST0RD2 

1. Entry Point: ST0RD2 

2. Purpose: To perform final stress and force computations for the T0RDRG element. 

3. Calling Sequence: CALL ST0RD2 (TGRID) 

TGRID = Two-word real array giving grid point temperatures at the two connection grid points. 

4.46.8.36 Subroutine Name: MAGPHA 

1. Entry Point: MAGPHA 

2. Purpose: To compute the magnitude and phase of a complex number, c. 

3. Calling Sequence: CALL MAGPHA (A,B) 

A - Real part of c on input, magnitude of c on return. 
B - Irraginary part of c on input, phase of c on return. 

4 . 46 . 9 Design Requirements 

1. Since the five stages of the SDR2 module must be able to operate under all Rigid Formats, 
a branch design has been used within each stage whereby operations that are variant under 
different Rigid Formats are grouped into substructures within that stage. At these locations, 
a branch is always made to the substructure appropriate to the Rigid Format being executed. 

2. The following common blocks appear only within the subroutines of the SDR2 module. 

a. C0MM0N/SDR2X1/ 

This common block contains seventeen flag words which are set on the basis of requests 
in the Case Control data block by SDR2A. 

b. C0MM0N/SDR2X2/ 

This common block contains twenty-nine pointers defining the locations of the various 
requests and set definitions within the Case Control data block. 

c. C0MM0N/SDR2X3/ 

This common block contains data constants unique to the structural elements. 

d. C0MM0N/SDR2X4/ 

This common block contains local variables and flags set by the subroutines of the 

4.46-19 



MODULE FUNCTIONAL DESCRIPTIONS 

SDR2 module for communication between these subroutines. 

e. C(3MM0N/SDR2X5/ 

This comnon block is used by SDR2B to send EST data to the phase 1 element routines 
and to receive outputs from the phase 1 element routines. 

f. C(3MM!ilN/SDR2X6/ 

This comnon block consists of a three hundred word scratch area for use by the element 
routines while performing phase 1 computations. 

g. C(3MM(8N/SDR2X7/ 

This common block is used by SDR2D for sending and receiving data to the element 
routines performing phase 2 computations. 

h. C0MM0N/SDR2X8/ 

This common block consists of a three hundred word scratch area in core for use by the 

element routines while performing phase 2 computations. 

4.46.10 Diagnostic Messages 

SDR2 being one of the last modules to execute in a problem solution, makes every attempt 
at execution in any event. Should an error be detected by SDR2, a message is queued for output 
and, if possible, SDR2 continues to execute portions of the solution not affected by the error. 
The following NASTRAN messages may be output by SDR2: 2075, 2076, 2077, 2078, 2079. 2080, 3001, 
3002, 3003, and 3008. 



4.46-20 



FUNCTIONAL MODULE DPD (DYNAMICS POOL DISTRIBUTOR) 

4.47 FUNCTIONAL MODULE DPD (DYNAMICS POOL DISTRIBUTOR) 

4.47.1 Entry Point : DPD 

4.47.2 Purpose 

DPD is the principal data processing module for dynamics problems. New tables are 
assembled to account for any extra points in the model and the additional displacement sets 
used in dynamics. Bulk data cards which control the solution of a dynamics problem are 
processed and assembled into various data blocks for convenience and efficiency in solution 
of the dynamics problem. 

4.47.3 DMAP Calling Sequence 

DPD DYNAMICS, GPL, SIL,USET/GPLD,SILD,USETD,TFP00L,DLT,PSDL,FRL,NLFT,TRL,EED,EQDYN/ 

V.N,LUSET/V,N,LUSETD/V,N,N0TFL/V,N,N0DLT/V,N,N!aPSDL/V,N.N!3FRL/V,N,N0NLFT/ 
V,N,N!3TRL/V,N,N0EED/C,N,O/V,N,N0UE $ 

4.47.4 Input Data Blocks 

DYNAMICS - Collection of bulk data cards for dynamics problem. 

GPL - Grid Point List. 

SIL - Scalar Index List. 

USET - Displacement set definitions table. 

Note : DYNAMICS may be purged. Other input data blocks may not be purged. 

4.47.5 Output Data Blocks 

GPLD - Grid Point List Dynamics. 

SILD - Scalar Index List Dynamics. 

USETD - Displacement set definition table dynamics. 

TFP00L - Transfer Function Pool. 

DLT - Dynamic Loads Table. 

PSDL - Power Spectral Density List. 



4,47-1 



MODULE FUNCTIONAL DESCRIPTIONS 

FRL - Frequency Response List. 

NLFT - Non-Linear Forcing Table. 

TRL - Transient Response List. 

EED - Eigenvalue Extraction Data. 

EQDYN - Equivalence between external and internal numbers - dynamics. 

Note: GPLD, SILD, USETD and EQDYN may not be purged. All other data blocks may be 
purged. 

4.47.6 Parameters 

LUSET - Input-integer-no default. Degrees of freedom in the g - displacement set. 

LUSETD - Output-integer-no default. Degrees of freedom in the p - displacement set. 

N0TFL - Output-integer-no default. Number of transfer function sets in the bulk data, 
-1 if no sets are defined. 

N0DLT - Output-integer-no default. +1 if dynamics load data are present in the bulk data 
(i.e., DLT is created), -1 otherwise. 

NfJPSDL - Output-integer-no default. +1 if the PSDL is created, -1 otherwise. 

N0FRL - Output- integer-no default. +1 if the FRL is created, -1 otherwise. 

N0NLFT - Output- integer-no default. +1 if the NLFT is created, -1 otherwise. 

N0TRL - Output- integer-no default. +1 if the TRL is created, -1 otherwise. 

N0EED - Output-integer-no default. +1 1f the EED is created, -1 otherwise. 

N0UE - Output-integer-no default. Number of extra points in the model, 
-1 if there are no extra points, 

4.47.7 Method 

4.47.7.1 General 

Subroutine DPD is the main control program for the module. It initializes each of the 
DMAP parameters, allocates buffers in open core (/DPDC0R/), and calls each of the principal 
routines of the module as follows. 



4.47-2 



FUNCTIONAL MODULE DPD (DYNAMICS POOL DISTRIBUTOR) 

1. DPDl to assemble GPLD. USETD, SILD and EQDYN. 

2. DPD2 to assemble DLT. 

3. DPD3 to assemble FRL and PSDL. 

4. DPD4 to assemble NLFT and TRL. 

5. DPD5 to assemble EED and TFL. 

4.47,7.2 Assembly of GPLD, USETD, SILD and EQDYN 

The second logical record of GPL, which contains pairs of external point identification 
and sequence numbers, is read into core. Three words are used for each entry in the GPL. In 
the third word of each entry the internal index is stored. The list of extra points is 
read from the EP0INT record in DYNAMICS. For each extra point, a three-word entry is 
added to the list now in core. The first word contains the extra point identification, the 
second contains the initial sequence number equal to 1000 times the point ID, and the third 
word is zero. The SEQEP record in DYNAMICS Is read. For each referenced point, the sequence 
number is replaced by the new sequence number. The list in core is now sorted on sequence 
number by subroutine S0RT. The sequence number in each entry is replaced by an internal 
index according to the position of the entry following the sort. The GPLD is now written. 
It consists of one logical record of one word entries, each entry containing the external 
point identification. The internal index is implied by the position of the entry in the 
record. 

The SIL is read into core following the table of three-word entries currently in core. 
Bit masks are initialized for the various displacement sets in statics and dynamics. Files 
containing the USETD and SILD data blocks are opened to write. The file containing the USET 
data block is opened to read. Each of the three-word entries in core is processed as follows. 

1, If the entry corresponds to a grid point, six words are read from USET, bits for 
displacement sets in dynamics are turned on according to the statics sets to which the 
point belongs, six words are written on USETD, one word is written on SILD, the second 
word of the three-word entry is replaced with the scalar index value in the p-set, the 
third word is replaced with the scalar index value in the g-set, and the scalar index 
counter for the p-set is incremented by six. 



4.47-3 



MODULE FUNCTIONAL DESCRIPTIONS 

2. If the entry corresponds to a scalar point, one word is read from USET, and the 
process proceeds as above except that one word is written on USETD and the scalar 
index counter is incremented by one. 

3. If the entry corresponds to an extra point, one word is written on USETD, the extra 
point counter is incremented, and the process proceeds as with a scalar point. 

When all entries have been processed, USETD Is complete and the first logical record 
of SILD is complete. The second logical record of SILD is now written. It comprises two-word 
entries, each pair containing a scalar index value in the g-set and the corresponding 
scalar index value in the p-set. 

The third word of each of the three word entries in core is now replaced with a code 
word which is ten times the scalar index value in the p-set plus the type of point (1 = grid, 
2 = scalar, 3 = extra). The table is sorted on external point identification. EQDYN is written 
as two logical records. The first record contains pairs, each consisting of an external point ID 
and a scalar index value in the p-set. The second record contains pairs, each consisting of an 
external point ID and a code word. 

4.47.7.3 Assembly of the DLT 

The DAREA, DELAY and DPHASE tables are read from DYNAMICS, one table at a time. Grid 
point and component codes are converted to a scalar index value in the p-set by subroutine 
DPDAA. When all entries of a table have been read, the table is sorted on scalar index value 
and written as a logical record on a scratch file (three scratch files are used, one for each 
of the three types of tables). The table identification is saved in core. 

The RL0AD1, RL0AD2, TL0AD1 and TL0AD2 cards are read from DYNAMICS and stored in core. 
Eleven words are used for each entry. In the first word of each entry, a code for the card 
type is stored. When all cards have been read and stored in core, the data are sorted on 
load set identification. 

DLflAD cards are read from DYNAMICS and stored in core, and the data within each DL0AD card 
are sorted on referenced set identification. The file containing the DLT data block is opened 
to write. The header record is written. It contains the data block name, a list of set 



4.47-4 



FUNCTIONAL MODULE DPD (DYNAMICS POOL DISTRIBUTOR) 

identifications defined on DL0AD cards and a list of set identifications defined on RL0AD1 , 
RL0AD2, TL0AD1 and TL0AD2 cards. The DL0AD data are then written as the first logical record 
of the DLT. The remainder of the DLT comprises one logical record per load set. For each 
entry in the 11 -word per entry table in core the following processing occurs. 

1. The scratch file containing the tables referenced in the entry is positioned 
to read the referenced table. 

2. Entries are read from each of the referenced tables. A four-word entry is written 
on the DLT consisting of the scalar index value. A, t, and .0. 

3. When all entries from the tables have been read, the DLT record is closed, and 
the process repeats for the next load set. 

4,47.7.4 Assembly of the FRL and the PSDL 

FREQl, FREq2 and FREQ cards are read from DYNAMICS and stored in core. Frequencies on 
FREQ cards are converted to radians. When all the data have been read, a list containing three 
words per entry is accumulated In core. The first word contains the frequency set identifica- 
tion, the second word contains a pointer to the first word where data belonging to the set 
are stored, and the third word defines the type (0 = FREQl, -1 = FREQ2, N = FREQ, where N is 
the number of words in the frequency set). The list is sorted on set identification. The file 
containing the FRL data block is opened to write. The header record is written. It contains 
the data block name and a list of all frequency set identifications. The remainder of the 
FRL is comprised of one logical record per frequency set. 

For each entry in the three-word per entry list in core the following processing occurs. 

1. If the entry corresponds to a FREQl set, then N+1 frequencies are written as a 
logical record on the FRL by the following equation: 

^1 ' ■''o * ^^'"'•^ ^^' ^ " ■'•2 N + 1. (1) 

2, If the entry corresponds to a FREQ2 set, then N+1 frequencies are written as one logical 
record on the FRL by the following equation: 



4.47-5 



where 



MODULE FUNCTIONAL DESCRIPTIONS 



f^ ' f^ 10^^"''^ 6 i = 1,2 N + 1 (2) 



6 = ^log^o (t^). (3) 



3. If the entry corresponds to a FREQ set, the frequencies in the set are sorted, and 
any duplicate frequencies are discarded. The sorted list is written as one logical 
record on the FRL. 

The RANDPS cards are read into core (if no RANDPS data are present, the PSDL is not 
assembled). The RANDTl and RANDT2 cards are read into core, and a list similar to that in 
the frequency processing is formed. This list is sorted on set identification number. The 
file containing the PSDL is opened to write, and the set identifications are written in the 
header record. The RANDPS data are written as the first logical record of the PSDL. The 
remainder of the PSDL contains one logical record per set. For RANDT2 sets, the data are 
sorted on time lag, and duplicates are discarded prior to writing the record. For RANDTl 
sets, N + 1 time lags, t^ , are written where 



T^ = Tjj + {i-l)AT i = 1,2,..., N + 1 (4) 



4.47.7.5 Assembly of the NLFT and TRL 

The N0LINi (i = 1,2,3,4) cards are read Into core. Each referenced grid point and 
component code is converted to a scalar index value in the u -set. The data are sorted 
on set identification number. USETD is read into core. The file containing the NLFT data 
block is opened to write, and the set identifications are written in the header record. The 
remainder of the NLFT contains one logical record per set. Scalar index values within each 
set are converted to scalar index values in the u^ and u^ sets. The data within each set are 
sorted on the scalar index value to which the forcing function is applied. 



The TIC cards are read, referenced grid points and component codes are converted to 

scalar index values in the u -set, and the data are written on SCRl, one logical record per s 

P 

A list of the TIC set identifications is accumulated in core. USETD is read into core. The 



4.47-6 



FUNCTIONAL MODULE DPD (DYNAMICS POOL DISTRIBUTOR) 

file containing the TRL data block is opened to write. The set identifications are written 

in the header record. The last word of the header contains the degrees of freedom in the u^-set 

d 

Data are read from SCRl . Scalar index values are converted to scalar index values in the u -set 

d 

Each TIC set is written as one logical record on the TRL. When all the TIC data have been 
processed, the TSTEP data are copied from DYNAMICS to the TRL, one logical record per TSTEP set, 

4.47.7.6 Assembly of the EEC and TFL 

Processing of EIGB, EIGC, EIGP and EIGR cards is minimal. For each card type present, 
a corresponding logical record is written on EED. For each of the cards which specify P0INT, 
the referenced grid point and component code is converted to a scalar index value (u set 

d 

for EIGB and EIGR cards, u. set for EIGC cards). 

Transfer function data are read from the TF record on DYNAMICS one set at a time. For 
each transfer function set, the point and component codes are converted to scalar index values 
in the Up set, which in turn form row and column numbers of the transfer function matrices. 
The data are written on the TFL, one transfer function set per logical record. The set 
identification number is the first word of each logical record. Four word entries follow. 
The first word is 65536*column number plus row number; the next three words are the terms of 
the matrices. 

4.47.8 Subroutines 

Auxiliary subroutines DPDl , DPD2, DPD3, DP4 are described above. 
4.47.8.1 Subroutine Name: DPDAA 

1. Entry Point: DPDAA 

2. Purpose: To convert a grid point and component code to a scalar index value in 
the u set. 

3. Calling Sequence: CALL DPDAA 

4. Method: A flag called INEQ is maintained in /DPDC0M/. If the flag is zero, 
EQDYN is read into core and INEQ is set to one. The grid point and component to be 
converted is stored in BUF(L) and BUF(L+1) where BUF and L are in /DPDC(3M/. A binary 
search is performed in EQDYN. If the point is found, the corresponding scalar index 
value is stored in BUF(L). Otherwise, an error message is queued, and an internal 



4.47-7 



MODULE FUNCTIONAL DESCRIPTIONS 

N0G!i) flag is turned on. 
4.47.9 Design Requirements 

4.47.9.1 Allocation of Core Storage 

In general, core storage requirements in DPD are the EQDYN table plus one set of data 
being processed plus two or three GIN0 buffers. In DPD3 where EQDYN is not required, it is 
assumed that all data required to assemble the FRL or PSDL can be held in core at one time. 

4.47.9.2 Environment 

The Block Data program DPDCBD initializes /DPDC0M/ with GIN0 file names, L0CATE codes for 
the various card types processed by DPD, and miscellaneous data. It must be resident in 
core when DPD is executed. 

DPD is designed to operate in a single overlay segment. Communication in the module 
occurs through /DPDC0M/ and open core /DPDC0R/. If an alternate overlay is desired, DPDCDB, 
DPD and DPDAA could form a local primary segment and each of DPDl , DPD2, DPD3, DPD4 and DPD5 
could form separate secondary segments. In this case, /DPDC0R/ must be inserted after the 
longest of the secondary segments. Four scratch files are used by DPD. 

4.47.10 Diagnostic Messages 

The following messages may be issued by DPD: 
2064, 2066, 2068, 2069, 2071, 2107, 2135, 2136. 



4.47-8 (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

4.48 FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

4.48.1 Entry Point : REI6 

4.48.2 Purpose : 

To solve the equation 

([K] - \ CM] j{u} = (1) 

for eigenvalues X and their associated eigenvectors. 

4.48.3 DMAP Calling Sequence 

READ KAA,MAA,MR,DM.EED,USET,CASECC/LAMA.PHIA,MI.(aEIGS/V,N.Fi3RMAT/V,N,NEIGVS/V,N.NSKIP $ 

4.48.4 Input Data Blocks 

KAA - Partition of stiffness matrix - a set. 

MAA - Partition of mass matrix - a set. 

MR - Rigid body mass matrix - r set. 

DM - Rigid body transformation matrix. 

EED - Eigenvalue Extraction Data. 

USET - Displacement set definitions table. 

CASECC - Case Control Data Table. 

Notes : 

1. KAA must be present. 

2. MR may or may not be present. 

3. DM and USET must be present if MR is present. 

4. EED and CASECC must be present. 

4.48.5 Output Data Blocks 

LAMA - Real Eigenvalue Table. 

4.48-1 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

PHIA - Eigenvectors matrix giving the eigenvectors in the a set. 

MI - Modal Mass Matrix. 

0EIGS - Real Eigenvalue Summary Table. 

4.48.6 Parameters 

FORMAT - Input-BCD-no default. If F0RMAT j* MODES, READ will solve a buckling problem 

2 

(i.e., [X M - K] {u} = 0) using EIGB data cards where M is the differential 

stiffness matrix. 
NEIGVS - Output-integer-no default. NEIGVS is the number of eigenvalues found. If none 

were found, NEIGVS = -1. 
NSKIP - Input- integer-no detault. The method used by READ is taken from the NSKlP+1 record 

of CASECC. 

4.48.7 Method 

REIG is the main controlling program for the READ module. Its responsibility is to decide 
which method was asked for (Inverse Power, Determinant or Givens) and to pass control to the 
appropriate routine. Once eigenvalues have been extracted, REIG directs the sorting and normaliz- 
ing of the vectors for final output. The flow of the module can be seen in the flow charts shown 
in Figure 1. 

4.48.8 Subroutines 

The subroutines used by READ are divided into five classes: 1) subroutines used by REIG, 
2) subroutines used for the Inverse Power Method, 3) subroutines used for the Determinant Method, 
4) subroutines used for the Givens Method, and 5) general subroutines. The descriptions for the 
general subroutines can be found in section 3. 



4.48-2 (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 



REIG 


INVERSE POWER 


DETERMINANT 


READ! 


INVPWR 


DETM SUMM 


READ2 


INVPl 


DETMl SQRTM 


READ3 


INVP2 


DETM2 DETFBS 


READ4 


INVP3 


DETM3 


READ5 


NI3RM1 


DETM4 


READ6 


MTIMSU 


DETM5 


0RTCK 


XTRNSY 


DETM6 


INVERT 


SUB 


FDVECT 


INVTR 


INVFBS 


EADD 

DETDET 

ARRM 



GIVENS 

VALVEC 

SMLEIG 

TRIDI 

SIC0X 

SINCAS 

R0TAX 

R0TATE 

EMPC0R 

FILC0R 

QRITER 

WILVEC 



GENERAL 

DEC0MP 

ADD 

PREL0C 

SSG2B 

SDR1B 

SDC0MP 

FACT0R 

TRANPl 

TRNSP 

MERGE 

MPYAD 



4.48-3 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



4.48.8.1 Subroutine Name: READl 

1. Entry Point: READl 

2. Purpose: To compute the eigenvectors for the rigid body modes. 

3. Calling Sequence: CALL READl (DM.MR,SCR1.SCR2.SCR3,PHIAT.USET.NR.LAMAT.SCR4) 
DM.MR.USET are the GIN(J file numbers of their respective data blocks - integer - input. 
SCRi SCR4 are the GIN«I file numbers of 4 scratch files - Integer - input. 

PHIAT - GIN0 file number of a temporary storage file for the eigenvectors - integer - input. 
LAMAT - GIN0 file number of a temporary storage file for the eigenvalues - integer - input. 
NR - Number of rigid boc|y modes - Integer - output. 

CUMMiJN /READ1A/Z(1) 

Z(l) - Array of open core for READl 

4. Method: Let r be the number of rigid body modes and let 



(2) 



(3) 



etc. 



Set {V,} = {I^} and perform the following three steps for 1 » 1, 2,...,r. 
d. Normalize {v^} by the following equations: 

S^ - {v^}^ [m^] {v^}. 



{*.} 



{Vj}. 



1^ ?=^^M 



(5) 



S, must be greater than zero for a consistent rigid body system. 



4.48-4 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

b. Calculate using j = 1,2 1: 

c. The next vector 1s then: 



(6) 



1 
^^1+1> = ^Ii+1> - .\ '^i {'fj> • (7) 

(Return to step b). 

This procedure Is a modification of the Schmidt orthogonal izatlon procedure using 
the {1} vectors as a starting point. Since the [m^] matrix is non-singular, the {1} 
vectors are independent with respect to the matrix. Each new vector {I.^ } is made 
orthogonal with respect to the previous vectors by subtracting its scalar matrix 
products (a) with the other vectors. The matrix of resulting vectors [$ ] should 
form a diagonal, unit matrix [m^ ] with the equation: 

[^0^ = t<t,,]^ [m,] [$^^] . (8) 

The remaining displacements of the rigid body eigenvectors are formed from the 
equation 

[\o^ = tD] [$,„]. (9) 

where [D] corresponds to the data block DM. 

Each column of [$^^] Is merged with [*j^^] using USET (UA.UL.UR). 

4.48.8.2 Subroutine Name: READ2 

1. Entry Point: READ2 

2. Purpose: To compute the modal mass matrix [MI], to normalize the extracted eigenvalues, 
and to prepare the output files LAMA and 0EIGS. 

3. Calling Sequence: CALL READ2 (MAA.PHIA,SCR1.N0RM.IA,USET.MI.LAMA,0EIGS,SCR2.EPSI,SCR3) 



4.48-5 



MODULE FUNCTIONAL DESCRIPTIONS 

MAA,PHIA,USET.MI,LAMA,0EIGS are the GIN0 file numbers of their respective data 

blocks - integer - input. 

SCR1,...,SCR3 are GIN0 file number of 3 scratch files - integer - input. 

N0RM - Normalization method requested. 
MAX - Implies maximum component. 
P0INT - Implies specified component. ^ Input - BCD 
MASS - Implies unit modal mass matrix. 
lA - If NORM = P0INT, lA is the component number which is set to 1.0 - 

integer - input. 
EPSI - If EPSI f 0.0, the off-diagonal terms of the modal mass matrix [MI] are checked 
for the number which exceed EPSI. 

C0MM0N /READ2A/Z(1) 

Z(l) - Array of open core for READ2. 

4.48.8.3 Subroutine Name: READ3 

1. Entry Point: READ3 

2. Purpose: To sort the eigenvalues in ascending order and to output the eigenvalues 
and eigenvectors in order. Also, to pack the eigenvectors in standard matrix format. 

3. Calling Sequence: CALL READ3 (N0VECT,NC0L.SCR1 ,SCR2, PHI, LAMBDA) 
N0VECT - Number of eigenvectors extracted - integer - input. 

NC0L - Length of the vectors - integer - input. 

SCRl - GIN0 file containing the unsorted eigenvalues - integer - input. 

SCR2 - GIN0 file containing the unsorted eigenvectors - integer - input. 

PHI - 6IN0 file for the output sorted vectors - integers - input. 

LAMBDA - GIN0 file for the output sorted eigenvalues - integer - input. 

C0MM0N /READ2A/Z(1) 

Z(l) - Area of open core available to READ3. 



4.48-6 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 
4.48.8.4 Subroutine Name: READ4 

1. Entry Point: READ4 

2. Purpose: To test for close and equal roots found by the Determinant Method and make 
sure the corresponding vectors are orthogonal. 

3. Calling Sequence: CALL READ4 (LAMAT.MPHIA.SCRl .EPSI.MAA) 

LAMAT - GIN0 file number of temporary storage file for the eigenvalues found - 

integer - input. 

MPHIA - Matrix control block for PHIA - integer - input, 

SCRl - GIN0 file number of a scratch file - integer - input. 

EPSI - Close root test criteria - real - input. 

MAA - 6IN0 file number of MAA - integer - input, 

C0MM0N /READ2A/Z(1) - See READ2A 

Z(l) - Array of open core for READ4. 

4,48,8,5 Subroutine Name: 0RTCK 

1, Entry Point: 0RTCK 

2, Purpose: 0RTCK will generate the generalized mass matrix for the close roots and 
make the epsilon test to determine if the vectors should be orthogonal! zed, 

3, Calling Sequence: CALL 0RTCK (X.MAA,BUFFER(1).NUM.NDIM.6M.ACCUM.EPSI) 
X - Unorthogonalized eigenvectors - real - input/output, 

MAA and EPSI are as described in READ4. 

BUFFER - GIN0 buffer. 

NUM - Number of close roots - integer - input. 

NDIM - Order of the problem - integer - input. 

GM - Generalized mass for the close roots - real array - output, 

ACCUM - Running sum of [M^^] [$^] - real - input/output. 



4.48-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4.48,8.6 Subroutine Name: INVPWR 

1. Entry Point: INVPWR 

2. Purpose: INVPWR is the main driver for the Inverse Power Method of eigenvalue 
extraction, 

3. Calling Sequence: CALL INVPWR 
C0MM«)N/INVPWX/K(7).M(7).LAM(7).PHI(7).SCRFIL(8).EIGSUM.LMIN.LMAX.N0EST.NDPLUS.NDMNUS. 

EPS,N0RTH(3 

K.M - Matrix control blocks for the input stiffness and mass matrices. [K] and [M]. 

LAM.PHI - Matrix control blocks for the output eigenvalue and eigenvector files. 

SCRFIL(8) - GIN0 file numbers for eight scratch files. 

EIGSUM - GIN0 file number for the eigenvalue summary file - integer. 

LMIN-LMAX - Desired range for eigenvalues - real. 

N0EST - Number of estimated eigenvalues in the range - integer. 

NDPLUS - Number of desired positive eigenvalues - integer. 

NDMNUS - Number of desired negative eigenvalues - Integer, 

EPS - Convergence criteria - real, 

N0RTH0 - Number of roots extracted - integer. 

C(i)MM0N /INVPX/Z(1) 

2(1) - Area of open core available to INVPWR. 

4. Method: Reference can be made to the flow charts in Figure 1 for the program 
logic. Theoretical implications are handled in section 4.48.11 and in the 
Theoretical Manual, 

4,48,8,7 Subroutine Name: INVPl 

1. Entry Point: INVPl 

2. Purpose: To set up a call to ADD to form 



[A] = [K] - X^ [M] 



(10) 



4,48-8 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

3. Calling Sequence: CALL INVPl 

C0MM0N /INVPWX/K(7).M(7),A 

C0MM0N /INVPXX/LAM0 

C0MM0N /INVP1X/Z(1) 

K.M - Matrix control blocks for the input matrices. 

A - GIN0 file number for the output matrix. 

LAM0 - Double precision scalar multiplier. 

Z(l) - Area of open core available to ADD. 

4.48.8.8 Subroutine Name: INVP2 

1. Entry Point: INVP2 

2. Purpose: To initialize and call DEC0MP for subroutine INVPWR. 

3. Calling Sequence: CALL INVP2 

C0MM0N /INVPWX/DUM(14) .A(7) .L(7) .XX(2) .U.SCRl .SCR2.SCR3.LL.UU 
C0MM0N /INVPXX/DUMM(12), SWITCH 
C0f-1M0N /INVP2X/Z(1) 

A - GIN0 file number of the input matrix - Integer - input. 

L.U - GIN0 file number for the lower and upper triangular matrices output from DEC0MP 
Integer - input. 

, I - Three scratch files used by Dec0MP - integer - input. 

LL.UU - GIN0 file numbers for alternate storage of L and U - integer - input. 

SWITCH - - Store output matrices in L and U. 1 - store output matrices in LL and UU - 
Integer - input. 

Z(l) - Area of open core available for DEC0MP. 
4.48.8.9 Subroutine Name: INVP3 

1. Entry Point: INVP3 

2. Purpose: To solve for an eigenvalue and eigenvector using the Inverse Power Method. 

3. Calling Sequence: CALL INVP3 

C0MM0N/INVPWX/K(7).M(7).LAM(7),PHI(7).SCRFIL(8).EIGSUM.LMIN.LMAX.N0EST.NDPLUS.NDMNUS.EPS 
C0MM0N /INVP3X/Z(1) 

4.48-9 



SCRl, 

SCR2 

SCR3 



MODULE FUNCTIONAL DESCRIPTIONS 

See INVPWR for a description of /INVPWX/ (section 4.48.8.6). 

Z(1) - Open core for INVP3. 

4 Method: The logic flow of INVP3 is given in Figure 1 with the mathematical 

equations supplied in 4.48.11. Theoretical considerations are given in the Theoretical 

Manual. 

INVP3 was designed with two aspects in mind: first to assure that all roots within 
a given region are found, and second to avoid any possibility of looping uncontrollably. 
To accomplish these ends, considerable testing was inserted around the mathematical 
equations. 

5. Design Requirements: INVP3 needs sufficient storage to hold seven double precision 
a set vectors and three GINjJ buffers in core. 

4.48.8.10 Subroutine Name: N0RM1 

1. Entry Point: N0RM1 

2. Purpose: To normalize a vector {x} such that its maximum component is one. 

3. Calling Sequence: CALL N0RM1 (X.DIV) 
Cj)MM0N /INVPWX/XX.N 

N - Length of the double precision vector {x}. 

X - Double precision vector {x}. 

DIV - Double precision value of the divisor used to normalize {x}- output. 

4.48.8.11 Subroutine Name: MTIMSU 

1. Entry Point: MTIMSU 

2. Purpose: To pre-multiply a vector by a matrix i.e.,: 

{X} = [M] {y}. ^^^^ 

3. Calling Sequence: CALL MTIMSU (Y.X.BUF) 

C0MM0N /INVPWX/DUM(7),M(7) 
C0MM0N /INVPXX/DUMM(13),NZER0 

4.48-10 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

M - Matrix control block for matrix [M]. 

X.Y - Double precision left and right hand side vectors. 

BUF - GINI9 buffer. 

NZER0 - Number of zero columns of matrix [M]. 

4.48.8.12 Subroutine Name: XTRNSY 

1. Entry Point: XTRNSY 

2. Purpose: To form the dot product of two vectors 

a =■ {x}' {y}. (12) 

3. Calling Sequence: CALL XTRNSY (X.Y.A) 

C0MM0N /INVPWX/XX.N 

N - Length of vectors {x} and {y}. 

X,Y - Double precision vectors. 
A - Double precision value of the dot product. 
4.48.8.13 Subroutine Name: SUB 

1. Entry Point: SUB 

2. Purpose: To evaluate the vector equation 

{z} = a{x} - b{y}. (13) 

3. Calling Sequence: CALL SUB (X.Y.A.B) 
C9mm /INVPWX/XX.N 

N - Length of the vectors {x} and {y}. 

X.Y - Double precision vectors in the above equation. Y, upon return from SUB, 
contains the difference vector {z}. 

A,B - Double precision scalar multipliers. 



4.48-11 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

4.48,8.14 Subroutine Name: IMVFBS 

1. Entry Point: INVFBS 

2. Purpose: INVFBS will perform the forward-backward substitution necessary to 
solve one iteration of the Inverse Power Method given by 

([K] - Xq [M]){W^} = [M] {u^.^}. (14) 

3. Calling Sequence: CALL INVFBS (X.Y.BUF) 
C0MM0N /INFBSX/L(7),U(7) 

L,U - Matrix control blocks for the lower and upper triangular matrices generated 

by decomposition of ([K] - X^ [M]). 
X - Double precision right hand vector, [M] (u^_-|}. 
Y - Double precision solution vector, {W^}. 
BUF - GIN0 buffer. 

4. Method: INVFBS is a stripped down version of GFBS. Both vectors are stored in 
core, and only real double precision arithmetic is performed. 



4.48-12 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 
4.48.8.15 Subroutine Name: DETM 

1. Entry Point: DETM 

2. Purpose: To supervise the operations of the Determinant Method.' 

3. Calling Sequence: CALL DETM 

All determinant routines use common blocks /REGEAN/ and /DETMX/. 

C0MM0N /REGEAN/IM(7).IK(7),IEV(7),SCR1,SCR2.SCR3.SCR4,SCR5,LC0RE,RMAX.RMIN,MZ,NEV,EPSI, 
RMINR.NE, NIT, NEVM.SCR6,SCR7,NF0UND, LAMA. IBUCK.NSYM 

IM(7) - Matrix control block for MAA. 
IK(7) - Matrix control block for KAA. 
IEV(7) - Matrix control block for the eigenvectors. 

SCRl 

SCR7 ■ ^^^0 ^■'^^ number of 7 scratch files - integer - input. 

SCRl - Contains [KAA] - A[MAA]. 
SCR2 - Contains [LLL]. 
SCR3 - Contains [ULL]. 

- Amount of open core reserved for starting points, determinants, scale factors 
and accepted eigenvalues - integer - input. 

- Maximum eigenvalue of interest - real - input/output. 

- Minimum eigenvalue of Interest - real - Input. 

- Number of zero eigenvalues - integer - input. 

- Number of estimated eigenvalues in the range of interest - integer - input. 
EPSI - Convergence criteria - real - input/output. EPSI = 1.0x10"^^ currently. 
RMINR - Lower boundary to search region. (RMINR = -.01*RMIN) 

For buckling problems a pole of geometrically Increasing order is placed at 
RMINR each time the search procedure points below RMIN - real - input. 

- Number of changes in the convergence criteria - integer - input. NE is currently 
set at 4. 



4.48-13 



LC0RE 

RMAX 
RMIN 
MZ 
NEV 



NE 



MODULE FUNCTIONAL DESCRIPTIONS 

NIT - Number of iterations allowed to converge to an eigenvalue. NIT is 

currently set to 20 - integer - input. 
NEVM - Number of eigenvalues desired - integer - input. 
NF0UND - Number of eigenvalues found - integer - output. 
LAMA - GIN0 file number of eigenvalue storage file - Integer - input. 
IBUCK - Buckling flag. If IBUCK = 3, the current problem is a Buckling Analysis 

problem - integer - input. 
NSYM - Symmetric determinant flag. If NSYM = 1. symmetric decomposition is used 

to compute the determinant of A - Integer - input. 
C!JMM!8N/DETMX/P(4).DETX(4).PS1(4).DET1(4).N2EV.IPSAV.IPS.IDET.IPDETA.PREC.NSTART.NDCMP.IC.NSM0VE 
ITERM.IS.ND.IADD.SML1.IPDETX(4).IPDET1(4),IFAIL.K.FACT1.IFFND.NFAIL.NP0LE.ISNG 

P - The 3 trial values of the eigenvalue - double precision - input/output. 

DETX - The determinants of the 3 P's above - double precision - input/output. 

PSl - The 3 current starting points - double precision - input/output. 

DETl - The determinants of the 3 starting points - double precision - input/output. 

N2EV - The number of starting points - integer - input. 

IPSAV - Pointer to the accepted eigenvalues - integer - input. 

IPS - Pointer to the starting points - integer - input. 

IDET - Pointer to the determinants of the starting points - integer - input. 

IPDETA - Pointer to the scale factors of the determinants - integer - input. 

PREC - Precision of the calculations - integer - input. 

NSTART - Number of passes through the starting points - integer - output. 

NDCMP - Total number of decompositions - integer - output. 

IC - Total number of convergence criteria changes - integer - output. 



4.48-14 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

NSM0VE - Number of starting point moves - integer - output. 

ITERM - Reason for termination - integer - output. 

IS - Start set counter - integer - input/output. 

ND - Number of new starting points to evaluate - integer - input. 

lADD - Pointer to next starting point to evaluate - integer - input/output. 

SMLl - Magnitude of smallest diagonal element of [ULL] - real - output. 

IPDETX - Scale factors for the determinants in DETX - integer - input/output. 

IPDETl - Scale factors for the determinants in DETl - integer - input/output. 

IFAIL - If this set of starting points produced a failure to iterate to a root, 
IFAIL = 1 - integer - input/output. 

K - Current iteration counter - integer - input. 

FACTl - Constant = EPSI*SQRT(RMAX) - real - input/output. 

IFFND - If an eigenvalue is accepted on a given pass through the starting points, 
IFFND = 1 - integer - input/output. 

NFAIL - Number of failures to iterate to a root - integer - output. 

NP0LE - Order of the current pole at RMINR - integer - input/output. 

ISNG - Number of singular matrices detected during decomposition - integer - input/output. 

C0MM(2IN/DETDX/DZ(1) 

DZ(1) - Array of open core for DETM, 

4. Method: The general method used for the Determinant Method is described in 
section 4.88. 

5, Design Requirements: DETM needs sufficient open core to hold two double precision a set 
vectors and one GIN0 buffer. Open core at /DETDX/ is used for storage of starting points, 
determinants, powers and accepted eigenvalues, 

4.48,8.16 Subroutine Name: DETMl 

1. Entry Point: DETMl 

2. Purpose: To compute the locations of the starting points. 

3. Calling Sequence: CALL DETMl ($n) 

4.48-15 



MODULE FUNCTIONAL DESCRIPTIONS 

n - The statement number to which DETMl will return if the first three starting points 
yield a singular matrix, 

4.48.8.17 Subroutine Name: DETM2 

1. Entry Point: DETM2 

2. Purpose: To evaluate the determinant of ND starting points. 

3. Calling Sequence: CALL DETM2 

4.48.8.18 Subroutine Name: DETM3 

1. Entry Point: DETM3 

2. Purpose: To iterate for an eigenvalue. 

3. Calling Sequence: CALL DETM3 ($n^ .Sng.Snj) 
n, - Return for a new starting point. 

n„ - Return for a new pass through the starting points, 
n-j - Return for problem time expired. 

4.48.8.19 Subroutine Name: DETM4 

1. Entry Point: DETM4 

2. Purpose: To move any starting points necessary. 

3. Calling Sequence: CALL DETM4 

4.48.8.20 Subroutine Name: DETM5 

1. Entry Point: DETM5 

2. Purpose: To write out the eigenvalue analysis summary for the determinant method. 

3. Calling Sequence: CALL DETM5. 

4.48.8.21 Subroutine Name: DETM6 
1. Entry Point: DETM6 



4.48-16 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

2. Purpose: To rescale any number by powers of 10. 

3. Calling Sequence: CALL DETM6 (D,P0WER) 

The arguments are both input and output to the routine and are defined by the 
following equation. 

°out ^ 10'^"''o^t = D.^ X loP^^'ER.^^ (^5j 

•1 1 ll^outl 110. (16) 

D is double precision and P0WER is integer. 

4.48.8.22 Subroutine Name: FDVECT 

1. Entry Point: FDVECT 

2. Purpose: To build the load vector to solve for an eigenvector. 

3. Calling Sequence: CALL FDVECT (SMLl.PK) 

SMLl - Smallest diagonal term of [ULL] - real - input. 
PK - Accepted eigenvalue - double precision - input. 

4.48.8.23 Subroutine Name: EADD 

1. Entry Point: EADD 

2. Purpose: To compute [A] = [KAA] - p[MAA]. 

3. Calling Sequence: CALL EADD (P.PREC) 

P - Trial value for one eigenvalue - double precision - input. 
PREC - "2" - integer - input. 

4.48.8.24 Subroutine Name: DETDET 

1. Entry Point: DETDET 

2. Purpose: To compute the swept determinant of [A]. 

3. Calling Sequence: CALL DETDET (DETA,IP0WR,P,SML1 ,0LDD,IPR!3LO) 



4.48-17 



MODULE FUNCTIONAL DESCRIPTIONS 

DETA - Swept determinant of [A] - double precision - output. 

IP(3WR - Scale factor of DETA - integer - output. 

P - Value of p used in computing [A] - double precision - input. 

SMLl - Value of smallest diagonal term of [ULL] - real - output. 

0LDD - Swept determinant of previous value of p - double precision - input. 

IPR0LD - Scale factor of 0LDD - integer - input. 

4.48.8.25 Subroutine Name: ARRM 

1. Entry Point: ARRM 

2. Purpose: To arrange three starting points in order by the magnitude of their 
scaled determinants. 

3. Calling Sequence: CALL ARRM (P.D.ND) 

P - Array of 3 starting points - double precision - input/output. 
D - Array of 3 determinants at P - double precision - input/output. 
ND - Array of 3 scale factors of D - integer - input/output. 

4.48.8.26 Subroutine Name: SUMM 

1. Entry Point: SUMM 

2. Purpose: To add two scaled numbers together. 

3. Calling Sequence: CALL SUMM (SUM.ISUM.Tl ,IT1 ,T2,IT2.N) 

The arguments are defined by the following equation: 

SUM X 10^^"" - Tl X 10^"^^ + T2 x lo"^ . (17) 

If N = 1, the minus sign is used, otherwise the positive sign is used. 
SUM, Tl, T2 are double precision. 
N, ITl, ISUM, IT2 are integers. 



4.48-18 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

4.48.8.27 Subroutine Name: SQRTM 

1. Entry Point: SQRTM 

2. Purpose: To compute the square root of a scaled number. 

3. Callincj Sequence: CALL SQRTM (A,IA,B,IB) 

The arguments are defined by the following equation: 



vIA _ ^p..i„IB 



A X 10'" = -VBxlO' 



A and B are double precision. 
lA and IB are integers. 

4.48.8.28 Subroutine Name: DETFBS 

1. Entry Point: DETFBS 

2. Purpose: To solve for the eigenvector. 

3. Calling Sequence: CALL DETFBS (F,X, BUFFER, FU,NR0W) 

F - Array containing the load vector {F} - double precision - input. 

X - Array containing the eigenvector - double precision - output. 

BUFFER - GIN0 buffer. 

FU - Matrix control block for [ULL] - integer - input. 

NR0W - Order of the problem (length of F and X) - integer - input. 

4.48.8.29 Subroutine Name: VALVEC 

1. Entry Point: VALVEC 

2. Purpose: To extract the eigenvalues and eigenvectors of a symmetric matrix, 

3. Calling Sequence: CALL VALVEC 

C0MM0N /GIVN/X1,M0,MD,MR1,M1,M2,M3,M4,X9(3),RSTRT,X18(82).N,LFREQ,0RDER,Y4,HFREQ,LAMA,NV, 
X8(2),NF0UND,0EIGS,PHIA,NVER,NEVER,MAX,ITERM 

C0MM0N /XXVLVC/Z(1) 

/GIVN/ is used by all Givens routines. 

4.48-19 (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

M0 GIN0 file number of the input matrix - integer - input. 

MD, MR! , Ml, M2, M3, M4 - GIN0 file numbers of scratch files - integer - input. 

RSTRT - '0' indicates no restart is being made - integer - input. 

N - Order of the problem - integer - output. 

LFREQ, HFREQ - Frequency range for computation of eigenvectors - real - input. 

0RDER - Eigenvalue sort order flag - integer - input. 

LAMA, 0EIGS, PHIA - GIN0 file name of the associated data blocks - integer - input. 

NV - Number of eigenvectors to compute - integer - input. 

NF0UND - Number of rigid body modes previously found - integer - input. 

NVER - Number of fails to converge on eigenvectors - integer - output. 

NEVER - Number of fails to converge on eigenvalues - integer - output. 

t>1AX - Maximum number of QR iterations allowed - integer - input. 

ITER - Reason for termination - integer - input. 

Z - Open core for VALVEC. 

XI, X9, X18, YY, X8 are dummy variables and are not currently used, 

4.48.8.30 Subroutine Name: SMLEI6 

1. Entry Point: SMLEIG 

2. Purpose: To compute the eigenvalues for a 1 by 1 and 2 by 2 matrix and the eigenvector 
for a 1 by 1 matrix. 

3. Calling Sequence: CALL SMLEIG (D.0,VAL) 

D - Array of diagonal values - double precision - output. 

- Array of off-diagonal values - double precision - output. 

VAL - Array of eigenvalues - double precision - output. 

4.48.8.31 Subroutine TRIDI 
1. Entry Point: TRIDI 



4.48-19a (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

2. Purpose: To tridiagonalize a symmetric matrix. 

3. Calling Sequence: CALL TRIDI (D,0,C,A,B,AA) 

D - Diagonal terms of the tridiagonal matrix - double precision - output. 

- Off diagonal terms of the triadiagonal matrix - double precision - output. 

C - Scratch array which contains another copy of the diagonal terms at the conclusion 
of TRIDI - double precision - output. 

A - Remainder of core - double precision - scratch. 

B - Scratch array which contains the square of the off-diagonal terms - double precision 
- output. 

AA - Remainder of core - single precision - scratch. 

4.48.8.32 Subroutine Name: SIC0X 

1. Entry Point: SIC0X 

2. Purpose: To initialize the arrays in SICAS. See section 4.48.8,33. 

3. Calling Sequence: CALL SIC0X (D,0,C0S) 

D - Array of diagonal values - double precision - input/output. 

- Array of off-diagonal values - double precision - input. 

C0S - Array of cosine rotation factors - double precision - irput/output. 

4.48.8.33 Subroutine Name: SIC0X (D,0,C0S) 

1. Entry Point: SINCAS 

2. Purpose: To compute the rotation factors for a given row. 

3. Calling Sequence: CALL SINCAS (R0W,FLAG) 

R0W - The number of the current row to rotate - integer - input. 

FLAG - If no rotations are required for this row, FLAG = 0. Otherwise, FLAG = 1 - integer 
- input. 



4.48-19b (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

4.48.8.34 Subroutine Name: R0TAX 

1. Entry Point: R0TAX 

2. Purpose: To initialize the arrays in R0TATE. See section 4.48.8.35. 

3. Calling Sequence: CALL R0TAX {0,SIN,C(3S) 

- Array of off-diagonal values - double precision - input/output, 

SIN - Array of sine rotation factors - double precision - input. 

C0S - Array of cosine rotation factors - input. 

4.48.8.35 Subroutine Name: R0TAX 

1. Entry Point: R0TATE 

2. Purpose: To rotate as much of the matrix as fits into core. 

3. Calling Sequence: CALL R0TATE (A,R0W,R0W1 ,R0W2) 

A - Partition of the matrix held in core - double precision - input. 

R0W -- The row number of current rotation row - integer - input. 

R0W1 - The row number of the first row of the matrix partition in core - integer - input. 

R0W2 - The row number of the last row of the matrix partition in core - integer - input. 

4.48.8.36 Subroutine Name: EMPC0R 

1. Entry Point: EMPC0R 

2. Purpose: To empty core of a triangular matrix partition. 

3. Calling Sequence: CALL EMPC0R (MTl ,MT2,PT,PC,FRSR0W,MIDR0W.LASR0W,NX,A,Z) 
MTl - GIN0 file name of the first output file - integer - input. 

MT2 - GIN0 file name of the second output file - integer - input. 

PT - Precision (1 = single precision, 2 = double precision) of the input matrix - 

integer - input. 
PC - Precision (1 = single precision, 2 = double precision) of the output matrix - 

integer - input. 

FRSR0W - The row number of the first row in core - integer - input. 

MIDR0W - When the current row is greater than MIDR0W, write the remainder of the matrix 

4.48-19C (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

onto MT2 - integer - input. 
LASR0W - TKe row number of the last row in core - integer - input. 
NX - Order of the matrix - integer - input. 

A - Storage containing the triangular matrix - double precision - input. 
Z - GIN0 buffer - input. 

4.48.8.37 Integer Function Name: FILC0R 

1. Entry Point: FILC0R 

2. Purpose: To fill core with a triangular matrix. 

3. Calling Sequence: R0W = FILC0R (MTl ,MT2,PC,FRSR0W,MIDR0W,NX,A,NZA,Z) 

MTl - GIN0 file name of the first part of the matrix (up to MIDR0W) - integer - input. 

MT2 - GIN0 file name of the rest of the matrix - integer - input. 

PC - Precision (1 = single precision, 2 = double precision) of the matrix in core - 
integer - input. 

FRSR0W - The row number of the first row of the matrix to be read - integer - input. 

MIDR0W - Breakpoint of the matrix - integer - input. 

NX - Order of the matrix - integer - input. 

A - Core storage to hold the matrix - integer - input. 

NZA - Number of single precision words at A - integer - input. 

Z - GIN0 buffer - input. 

R0W - The row number of the last row read into A - integer - output. 

4.48.8.38 Subroutine Name: QRITER 

1. Entry Point: QRITER 

2. Purpose: To obtain the eigenvalues of a tridiagonal matrix by the Ortega - Kaiser QR 
iteration technique. 

3. Calling Sequence: CALL QRITER (VAL.0,L0C,QR) 

4.48-19d (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

VAL - Diagonal terms of the tridiagonal matrix on input, reordered eigenvalues on return - 
double precision - input/output. 

9 — Squares of the off-diagonal terms of the tridiagonal matrix. These are iteratively 
reduced to zero - double precision - input/output. 

L0C - Array giving the order in which each eigenvalue is found - integer - output. 

QR ~ QR ;* implies that the eigenvalues already exit at VAL and this is an ordering call 
only - integer - input. 

4.48.8.39 Subroutine Name: UILVEC 

1. Entry Point: UILVEC 

2. Purpose: To compute eigenvectors by the Wilkinson method. 

3. Calling Sequence: CALL WILVEC (D,0,VAL.VL0C,V.F,P,Q,R,VEC,NX,SVEC) 
D - Array of diagonal values - double precision - input. 

- Array of off-diagonal values - double precision - input. 

VAL - Array of eigenvalues - double precision - input. 

VL0C - Array of original ordering of eigenvalues - integer - input. 

V,F,P,Q,R - Scratch arrays of length equal tc the order of the problem - double precision 
input/output. 

VEC - Array of core to store vectors - double precision - scratch. 

NX - Not used 

SVEC - Array of core to store vectors - single precision - scratch. 

4.48.8.40 Subroutine Name: INVERT 

1. Entry Point: INVERT 

2. Purpose: To drive INVTR (see section 4.48.8.41) to compute the inverse of an upper or 
lower triangular matrix. 

3. Calling Sequence: CALL INVERT (lA.IB.SCRl) 
C0MM0N /INVTRX/Z(1) 

4.48-19e (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

lA - GIN0 file name of an upper or lower triangular matrix - integer - input. 

IB - GIN0 file name of tne inverse of the matrix on lA - integer - input. 

SCRl - GIN0 file name of a scratch file - integer - input. 

Z - Open core for INVERT. 

4.48.8.41 Subroutine Name: INVTR 

1. Entry Point: INVTR 

2. Purpose: To invert a triangular matrix. 

3. Calling Sequence: CALL INVTR (X,DX) 
C0MM0N /INVTRX/FA(7),FB(7),SCRFIL,NX,PREC 

X - Open core for INVTR - single precision - scratch. 

DX - Open core for INVTR (same address as X) - double precision - scratch. 

FA - Matrix control block for the input matrix - integer - input. 

FB - Matrix control block for the output matrix - integer - input. 

SCRFIL - GIN0 file name of a scratch file - integer - input. 

NX - Length in words of X - integer - input. 

PREC - Precision (1 = single precision, 2 = double precision) of the computation 
integer - input. 

4.48.8.42 Subroutine Name: READ6 

1. Entry Point: READ6 

2. Purpose: To merge the rigid body eigenvectors with vectors computed by GIVENS. 

3. Calling Sequence: CALL READ6 (IRBM.IMGIV.NR.IPHIA) 
C0MM(3N /READ6X/Z(1) 

IRBM - GIN0 file name for eigenvectors computed by READ! - integer - input. 
IMGIV - GIN0 file name for eigenvectors computed by GIVENS - integer - input. 
NR - Number of eigenvectors computed by READl - integer - input. 

4.48-19f (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

IPHIA - GINJ} file name for merged eigenvectors - integer - input. 
Z - Open core for READ6. 

4.48.9 Design Requirements 

Design requirements are peculiar to the method chosen. The appropriate subroutines should 
be consulted. 

4.48.10 Diagnostic Messages 

Messages output from READ are peculiar to the individual subroutine. 



4.48-19g (12-1-69) 



MODULE FUi^CTIONAL DESCRIPTIONS 

4.48. n Mathematical Considerations for the Inverse Power Method 

The algorithm for finding the eigenvalues and eigenvectors of 

([K] - xm) M = 0. (19) 

1s given as follows. 

1. The iteration algorithm is given by the following equations. 

{[K] - Xq [M]) {W^} = [M] {u^_^} . (20) 



[u^] = {u^} - L ({$.}'•' [M] {u^}) {<J>^} . 



where C is the absolute value of the maximum component of (W }. The sum over 1 
extends over all previously extracted eigenvectors. 

2. Form 



3. Compute 



4. Compute 



5. Compute 



6. Compute the approximate eigenvalue 



(22) 



{F^} = CM] {u^}. (23) 



'^n = (^%>' ^^J)'^' • (24) 



«%> = iV iVji (25) 

% "n-1 ■ 



{6F^} = [M] {6u^} , (26) 



^1 = C7 ^ ■ (27) 

n n 



4.48-20 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 

7. For the rapid convergence test, compute 

n = ({5u^}^ {6Fn})^/^ (28) 

8. For normal convergence, compute 



X, " 2 

I n 



and 



9, For the shift decision test, compute 



and 






10. For the X^ reliability test, compute 



(29) 



6^ = ({«u^}^ {5F^}) /(I - -^) ^ . (30) 



^l,n = '^'V '''""' ' ^''^ 



k = ^°^ "^ ^ . (32) 

log^Q (Xg/^i) 



2,n o 133) 





The abov(i equations, along with the proper logic given in Figure 1 form the basis for the 
Inverse Power Method. 



4.48-21 



MODULE FUNCTIONAL DESCRIPTIONS 



REIQ 




Extract rigid body 
modes (READ1) 



Extract roots by Givens 
Trid1 agonal Izati on method 



Givens 





Inverse 
Power . 



Extract foots by Inverse 
Power method (INVPWR) 



Determinant 



Extract roots by Determinant 
method (DETM) 



Write eigenvalue summary 
record (READ5) 





Sort eigenvalues & vectors 
into ascending order {READ3) 




Det. or 
Givens 



Orthogonal ize vectors for 
close roots (Ri;AD4) 



Normalize vectors, compute 

modal mass, and write 
eigenvalue summary CREADZ) 



c 



RETURN 



3 



Figure l.(a) Flowchart for module READ. 



4.48-22 (12-1-69) 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 



INVPWR 



( 


ENTER 


) 


' ' 




Initialize 
parameters 






, ^ 






Pick Xq in center of 
search region 






' ' 




Form ([K] - X^ [M]) (INVP1) 




, , 




Decompose ([K] - X^ [M]) 
(INVP2) 




1 


' 




Evaluate eigenvalues in 
the region (INVP3) 




<r 


More regions 


.^.jte 



No 



Output eigenvalue 
summary 



C RETURN J 



Figure l.(b) Flowchart for module READ 



4.48-23 



MODULE FUNCTIONAL DESCRIPTIONS 



INVP3 



c 



ENTER 



J 



i 




Initialize 
parameters 








<d 







Use last 
iteraterated vector 




No 



Use previously stored 
vector for starting 



Orthogonal ize 
vector 




Solve for {y } 
(INVFBS) 



Normalize vector 
{N0RM1) 



Orthogonal ize 
vector 



Generate a 
starting vector 




Figure l.(c) Flowchart for module READ 
4.48-24 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 




Compute 
(Fn) = [M] {y^} 



Compute 



a = ({y }'''{F })^^^ 
n ^ ^n n ' 



t^PnJ 



Compute 



n n-1 



Compute 




2A 

'a 



Set rapid 
convergence flag 




{6m„}'{6F„.i} 




2C 



Figure l.(d) Flowchart for module READ 



4.48-25 



MODULE FUNCTIONAL DESCRIPTIONS 




Yes 



Set 62 flag 
X = X 
2,n 2,n-l 



MM 



^-^ 





Yes 



Convergence achieved 
Save X and * 





Move shift point 




c 



RETURN 



3 




3B 



Figure l.(e) Flowchart for module READ. 



4.48-26 



FUNCTIONAL MODULE READ (REAL EIGENVALUE ANALYSIS - DISPLACEMENT) 




Save current vector 


\ 


f 


Move X close to 



eigenvalue 


1 


t 


C RETURN ^ 



Figure l.(f) Flowchart for module READ 
4.48-27 



FUNCTIONAL MODULE DSMGl (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 1) 

4.49 FUNCTIONAL MODULE DSMGl (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 1) 

4.49.1 Entry Point : DSMGl 

4.49.2 Purpose 

To generate the differential stiffness matrix, [K^ 1, which is used in two Rigid Formats; 
Static Analysis with Differential Stiffness and Buckling Analysis. 

4.49.3 DMAP Calling Sequence 

DSMGl CASECC,GPTT,SIL.EDT,UGV,CSTM,MPT,ECPT,GPCT,DIT/KDGG/V,N,DSC0SET $ 

4.49.4 Input Data Blocks 

CASECC - Case Control Data Table. 

GPTT - Grid Point Temperature Table. 

SIL - Scalar Index List. 

EDT - Element Deformation Table. 

UGV - Initial Approximation to the Displacement Vector - g set. 

CSTM - Coordinate System Transformation Matrices. 

MPT - Material Properties Table. 

ECPT - Element Connection and Properties Table. 

GPCT - Grid Point Connection Table. 

DIT - Direct Input Tables. 

Notes : 

1. A fatal error exists if CASECC is purged. 

2. A fatal error exists if there is a temperature load and the GPTT is purged. 

3. A fatal error exists if there is a temperature load and the SIL is purged. 

4. A fatal error exists if an element deformation set is requested by the user in 
case control and EDT is purged. 

5. A fatal error exists if UGV is purged. 

6. CSTM can be purged. However, 1f some grid point of the model is not in basic 
coordinates and the CSTM is purged, a fatal error occurs. 

4.49-1 



MODULE FUNCTIONAL DESCRIPTIONS 

7. If the MPT is purged and some element references a material property, a fatal 
error occurs. 

8. A fatal error occurs if the ECPT is purged. 

9. A fatal error occurs if the GPCT is purged. 

10. If some material property is temperature dependent, DIT cannot be purged. 

4.49.5 Output Data Blocks 

KDGG - Partition of differential stiffness matrix - g set. 
Note: KDGG cannot be pre-purged. A fatal error occurs if it is. 

4.49.6 Parameters 

DSC0SET - Output-integer-no default value. The set identification number of a DSFACT bulk 
data card chosen by the user in his Case Control Deck. If no such set was. 
specified by the user, DSC0SET is set to -1. 

4.49.7 Method 

The module driver, DSMGl , is a very short routine whose only function is to call the two 
principal subroutines of the module, DSl and DSIA, which accomplish the two phases of the module. 
The first phase of the module is incorporated in subroutine DSl. This routine creates the scratch 
file ECPTDS (GIN(3 file number 301) by appending to each element in the ECPT data block for which 
differential stiffness is defined an element deformation, an average element loading temperature 
for all elements except the conical shell element (a loading temperature at each grid point is 
appended for the conical shell element) and the proper components of the displacement vector, UGV. 
It should be noted that although element deformations are defined only for rods, tubes, beams, and 
bars, an element deformation is attached to each element written on the ECPTDS scratch data block. 
The elements admissible to the ECPTDS scratch data block are: rods, beams, tubes, shear (but 
not twist) panels, triangular and quadrilateral elements (TRMEM's and QDMEM's), the combination 
membrane and plate triangular and quadrilateral elements (TRIAl , TRIA2, QUADl , QUAD2) and the 
conical shell element. 

The flow of DSl is given in the following steps: 

1. The length of variable core is determined, buffers are defined at the bottom of open 

4.49-2 (12-1-69) 



FUNCTIONAL MiDDULE DSMGl (DIFFERENTIAL STIFFNESS MATRIX GENERATOR PHASE 1) 

core, and zero pointers to, and lengths of, subarrays in open core are initialized. 

2. The Case Control data block. CASECC. is read to determine the element deformation set 
number, the loading temperature set number, and the differential stiffness coefficient 
set number. 

3. If there is no temperature load, go to step 4. If there is a temperature load, the 
Grid Point Temperature Table data block, GPTT, is read such that the proper temperature 
set is read into open core. The Scalar Index List data block, SIL, is read into open 
core, and the internal grid point numbers in the GPTT are replaced with the corresponding 
SIL numbers. 

4. If a non-zero elemrimt deformation set number was read from CASECC, the element deforma- 
tion set is read into open core. 

5. The first (and only) record of the displacement vector file, UGV, is read into open 
core, and then the ECPTDS and ECPT files are opened and positioned correctly. 

6. The ECPT data block is read record by record, and the ECPTDS scratch data block is 
generated for use by subroutine DSIA. The procedure for each record is as follows. The 
pivot point is read. For each element in the current ECPT record, it is determined if 
the element type is admissil)le to the ECPTDS data block. If is not admissible, the next 
element entry is read; if it is admissible, a test is made to determine if the element type 
is a TRIAl, QUADl or conical shell element. If it is a TRIAl , QUADl or a conical shell 
element and if this element has zero membrane thickness (which implies the element has bend- 
ing properties only) and s^.nce differential stiffness is not defined for plate elements, then 
the next element entry is read from the current ECPT record. When the first element of the 
ECPT record which belongs l;o the differential stiffness set is encountered, the pivot point 
is written on the ECPTDS daita block. Note that if the element is a BAR, the ECPT entry is 
rearranged to conform with the .ECPT entry for the BEAM so that the DBEAM subroutine may be 
called in subroutine DSIA. The element type is written on the ECPTDS record. Then an 
element deformation number, an average element loading temperature (two loading temperatures 
for a conical shell element), and the displacement vector components are appended in core 

to the ECPT entry for the element. Finally this appended ECPT entry is written on ECPTDS. 
It should be noted that the 2nd through the (n+1)^^ words (n being the number of grid points 
of the element) of every ECPT entr>', since they are scalar index numbers, are direct pointers 

4.49-3 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

into the displacement vector, UGV. Note further that for elements ^^or which differential 
stiffness is defined (save for the BAR. the BEAM and the conical shell element) only the 
three translational components of the displacement vector at each grid point are appended. 
For the BAR and BEAM all six displacement components at each grid point are appended. For 
the special case of the conical shell element, only the six displacement components at each 
grid point associated with the zeroth harmonic are appended. 

When an end-of -record is sensed for an ECPT record, an indiccitor is interrogated to 
determine whether or not any of the elements in the record were written on the ECPTDS data 
block. If there weren't any, a -1 is written on ECPTDS with an end-of-record mark; if there 
was at least one element, an end-of-record is written on ECPTDS. In either case, after this 
step has been done, the next ECPT record is processed identically. When an end-of-file is 
sensed on the ECPT. the files for ECPT and ECPTDS are closed, ar.d the routine returns to 
DSMGl . 

The module driver, DSMGl. tests the argument of DSl . If it is equal to zero, this implies 
that no element of the ECPT was a member of the set of elements for which differential stiffness 
is defined, and hence a fatal error exit occurs. If the argument is greater than zero, subroutine 
DSIA is called. 

In the second phase of the module, subroutine DSIA processes the scratch file ECPTDS to 
produce the differential stiffness matrix, [K^g]. The logic of th^'s processing is very similar 
to that used in subroutine SMAIA ( of module SMAl , the stiffness metrix generation routine). 
See the Module Functional Description for SMAl (section 4.27) for details. 



4.49-4 (12-1-69) 



FUNCTIONAL MODULE DSMGl (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 1) 



4,49.8 Subroutines 



All subroutines defined below except DSl are necessary to accomplish the second phase 

of the module, which is the processing of the ECPTDS scratch file in order to generate Tk'' 1 

^ gg-" 
The auxiliary routines PRETRD, PREMAT, GMMATD and INVERD are used similarly to module SMAl . 

The data (an ECPTDS entry) input to an element differential stiffness matrix generation 
routine (e.g., DR0D) are communicated to the routine via /DSIAET/, which fact is not expressly 
stated in the subroutine descriptions given below. 

4.49.8.1 Subroutine Name: DSl 

1. Entry Point: DSl 

2. Purpose: See discussion above. 

3. Calling Sequence: CALL DSl (lARG) 

lARG - Initially set to zero in subroutine DSl. This variable is set to 1 in DSl every 
time an element in the ECPT is encountered which is in the set of elements for 
which differential stiffness is defined. If lARG is still zero upon DSl's 
return to DSMGl, DSMGl will terminate the job by calling MESAGE and PEXIT. 

4.49.8.2 Subroutine Name: DSIA 

1. Entry Point: DSIA 

2. Purpose: See discussion above. 

3. Calling Sequence: CALL DSIA 

4.49.8.3 Subroutine Name: DSIB 

1. Entry Point: DSIB 

2. Purpose: This routine, called by the module's element matrix generation routines 
such as DR0D, DBEAM, etc., adds a double precision 6 by 6 element differential stiffness 
matrix to the "submatrix" corresponding to the current pi"nt ooint. This same function 
is performed in module SMAl by subroutine SMAIB, in SMA2 by SMA2B and in PLA4 by PLA4B. 



4.49-5 



MODULE FUNCTIONAL DESCRIPTIONS 

3. Calling Sequence: CALL DSIB (KE.J) 

KE - Row-stored double precision 6 by 6 matrix to be added to the "submatrix" corresponding 
to the current pivot point. Double precision; input. 



J - The column index of the [K ] matrix which corresponds to the first column of the KE 



matrix. Integer; input. 

4.49.8.4 Block Data Subprogram Name: DSIABD 

1. Entry Point: DSIABD 

2. Purpose: This block data program sets 1) GIN0 file numbers; 2) GIN0 j)PEN, WRITE 

and CL0SE option parameters; 3) differential stiffness element routine (e.g., DR0D,DBEAM) 
overlay parameters; and 4) an array which defines the number of words to be read for 
each element from the ECPTDS scratch file. The common block /DSIAAA/ is used for the 
second phase of the module. 

4.49.8.5 Subroutine Name: DR0D 

1. Entry Point: DR0D 

2. Purpose: To generate the element differential stiffness matrix for a R0D, C0NR0D 
or TUBE element. 

3. Calling Sequence: CALL DR0D 

4.49.8.6 Subroutine Name: DBEAM 

1. Entry Point: DBEAM 

2. Purpose: To generate the element differential stiffness matrix for a BAR or BEAM 
element. 

3. Calling Sequence: CALL DBEAM 

4.49.8.7 Subroutine Name: DSHEAR 

1. Entry Point: DSHEAR 

2. Purpose: To generate the element differential stiffness matrix for a SHEAR (panel) 
element. 



4.49-6 



FUNCTIONAL MODULE OSMGl (DIFFERENTIAL STIFFNESS MATRIX GENERATOR PHASE 1) 

3. Calling Sequence: CALL DSHEAR 
4.49.8.8 Subroutine Name: DTRMEM 

1. Entry Point: DTRMEM 

2. Purpose: To generate the element differential stiffness matrix for a TRIAl, TRIA2 and 
TRMEM element. 

3. Calling Sequence: CALL DTRMEM (lARG) 
= Called from DSGMl 



lARG = 

1 = Called from DQDMEM 

Note that the ECPTDS entry for the TRIAl element is rearranged in subroutine DSIA to confonn 
with the ECPTDS entry for the TRMEM element before DTRMEM is called. 

4.49.8.9 Subroutine Name: DQDMEM 

1. Entry Point: DQDMEM 

2. Purpose: To generate the element differential stiffness matrix for a QUAD!, QUAD2 and 
QDMEM element. 

3. Calling Sequence: CALL DQDMEM 

Note that the ECPTDS entry for the QUAD! element is rearranged in subroutine DSIA to conform 
with the ECPTDS entry for the QDMEM element before DQDMEM is called. 

4.49.8.10 Subroutine Name: DC0NE 

1. Entry Point: DC0NE 

2. Purpose: To generate the element differential stiffness matrix for a conical shell 
element. 

3. Calling Sequence: CALL DC0NE 
4.49.9 Design Requirements 
4.49.9.1 Open Core Design 

During phase one of the module's operation, the maximum core storage requirements are given 
in the following diagram, in which open core, the Z array, is defined at /DSIX/, 

4.49-7 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Z{IGPTT) 



Z(IEDT) 
Z(IDISP) 



C0MM0N /DSIX/ 



GPTT data with internal grid point 
numbers replaced by scalar index 
numbers from the SIL 



EDT data 



Single precision displacement 
vector in unpacked form from the 
UGV data block 



Z(BUFFRI) 
Z(BUFFR2) 



GIN0 buffer 



GIW buffer 



During phase two of the module's operation, the open core design is the same as that 
for module SMAl , except that only 3 GIN0 buffers are needed instead of 5, one for ECPTDS, 
one for GPCT and one for KDGG. Open core for phase two is defined at /DSIAXX/. 

4.49.9.2 Common Storage Requirements 

During phase one, there are no special common storage requirements. 

During phase two, /DSIAAA/ takes the place of /SMAl 10/, /SMAIBK/ and /SHAICL/; /DSIAET/ 
corresponds to /SMAIET/; and /DSIADP/ corresponds to /SMAIDP/. See the common storage re- 
quirements section of the SMAl Module Functional Description for details on /SMA1I0/, /SMAIBK/, 
/SMAICL/, /SMAIET/ and /SiWDP/ (section 4.27.9.3). 



4.49-8 



FUNCTIONAL MODULE DSMGl (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 1) 
4.49.9.3 Arithmetic Considerations 

All floating point arithmetic operations are carried out in double precision. [K° ] is 
a real double precision symmetric matrix. 

4.49.10 Diagnostic Messages 

During phase one the fatal messages 2029 and 2030 can be called if the GPTT is not in the 
proper format. If a BAR element is encountered whose coupled bending interia property, 
1^2. is non-zero, then it is set to zero and the user is warned of this fact with message 
2111. User messages 2081 and 2083 are fatal messages indicating a null differential stiffness 
matrix and a null displacement vector respectively. 

For phase two diagnostics, the reader is referred to the diagnostic message section of 
the Module Functional Description for SMAl . 



4.49-9 



FUNCTIONAL MODULE SMP2 (STRUCTURAL tWRIX PARTITIONER - PHASE 2) 



4.50 FUNCTIONAL MODULE SMP2 (STRUCTURAL MATRIX PARTITIONER - PHASE 2) 



4.50.1 Entry Point : SMP2 



4.50.2 Purpose 



To perform the following matrix operations: 



[K?,] 



=> 



Sa 



^<f\ 



ao 



00 



(1) 



^O - ^'O ' <^ [<^oJ ' ^<^ t«o^)' ' ^%^' fC^ ^'^o^- 



4.50.3 DHAP Calling Sequence 



SMP2 USET,G0,KDFF/KDAA/ $ 



4.50.4 Input Data Blocks 



USET 
KDFF 



- Displacement set definitions table. 

- Structural matrix partitioning transformation matrix. 

- Partition of differential stiffness matrix - f set. 



4.50.5 Output Data Blocks 



KDAA 



4.50.6 Parameters 



None 



4.50.7 Method 



Partition of differential stiffness matrix - a set. 



(2) 



The matrix [K^^] is partitioned as in Equation 1 using USET (UF,UA,U0), and matrix 
subroutine ELIM (see section 3.5.22 for details) is called to perform the operations in 
Equation 2. 



4.50-1 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 



4.50.8 Subroutines 

SMP2 has no auxiliary subroutine. 



4,50.9 Design Requirements 

See design requirements for subroutine UPART and its entry point MPART which perform 
the symmetric partition of Equation 1; also see design requirements for subroutine ELIM. 
These are in sections 3.5.9 and 3.5.22 respectively. 



4.50-2 



FUNCTIONAL MODULE DSMG2 (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 2) 

4.51 FUNCTIONAL MODULE DSMG2 (DIFFERENTIAL STIFFNESS MATRIX GENERATOR - PHASE 2). 

4.51.1 Entry Point : DSMG2 

4.51.2 Purpose 

This module performs the following matrix operations: 

<^ - t^aa^^^tK^,] . (1) 

C^] = [K,3].e<]. (2) 

r^ss^ = [Ksj] + BL^] . (3) 

{pS> = BfP,i> . (4) 

{Pj} = BiPg} . (5) 

{Y^} = 3{Y^} , (6) 

(uf } = B(u°} . (7) 

The value of 3 is on a DSFACT bulk data card whose set identification number is specified by the 
input parameter DSC0SET. The particular value on that card to be used for on any pass through 
the DMAP loop in the Static Analysis with Differential Stiffness Rigid Format is controlled by the 
parameter NDSKIP (see below). 

4.51.3 DMAP Calling Sequence 

DSMG2 MPT,KAA,KDAA,KFS,KDFS,KSS,KDSS,PL,PS,YS,U(30V/KBLL,KBFS,KBSS,PBL,PBS,YBS,UB00V/ 
V,N,NDSKIP/V,N,REPEATD/V,N,DSC0SET $ 

4.51.4 Input Data Blocks 

MPT - Material Property Table. 

KAA - Partition of stiffness matrix - a set. 

KDAA - Partition of differential stiffness matrix - a set. 

4.51-1 



MODULE FUNCTIOMAL DESCRIPTIONS 

KFS - Partition of stiffness matrix after single-point constraints have been removed. 
KDFS - Partition of differential stiffness matrix after single-point constraints have 

been removed. 
KSS - Partition of stiffness matrix after single-point constraints have been removed 

s set. 
KDSS - Partition of differential stiffness matrix after single-point constraints have 

been removed - s set. 
PL - Partition of the load vector matrix giving static loads on I set. 
PS - Partition of the load vector matrix giving loads in s set. 
YS - Constrained displacement vector - s set. 

U00V - Partition of the displacement vector matrix giving displacements in the o set. 
Notes : 

1. A fatal error occurs if MPT is purged. 

2. KAA and KDAA cannot be purged. 

3. KFS and KDFS must be both purged or both non-purged. 

4. KSS and KDSS must be both purged or both non-purged. 

5. A fatal error occurs if PL is purged. 

6. PS, YS and U00V can be purged. 

4.51.5 Output Data Blocks 

KBLL - Partition of the stiffness matrix of the first order approximation to large 

displacements - I set. 
KBFS - Partition of the stiffness matrix of the first order approximation to large 

displacements. 
KBSS - Partition of the stiffness matrix of the first order approximation to large 

displacements - s set. 
PBL - Partition of the load vector of the first order approximation to the large 

displacements - I set. 



4.51-2 



FUNCTIONAL MODULE DSrlG2 (DIFFEREUTIAL STIFFNESS i-ttTRIX GENERATOR - PHASE 2) 

PBS - Partition of the load vector of the first order approximation to the large 
displacements - i set. 

YBS - Partition of the constrained displacement vector of the first order approximation 
to the large displacement vector - s set. 

UB00V - Partition of the displacement vector of the first order approximation to the 
large displacement problem - o set. 
Notes : 

1. KBLL must not be purged or a fatal error exists. 

2. KEFS can be purged if and only if both KFS and KDFS are purged. 

3. KBSS can be purged if and only if both KSS and KDSS are purged. 

4. PL must not be purged or a fatal error exists. 

5. PBS, YBS and UB(il0V can be purged if and only if PS, YS and UB00V respectively 
are purged, 

4.51.6 Parameters 

NDSKIP - Input and output-integer - must be set to zero before the DMAP loop for Static 
Analysis with Differential Stiffness is initiated. This parameter is used as a 
loop counter for the DMAP loop in the Static Analysis with Differential Stiffness 
Rigid Format. It enables this module to skip the proper number of words on the 
proper DSFACT card (see definition of the parameter DSC0SET below) to fetch the 
value of S for the scalar multiplications defined above. 

REPEATD - Output-integer-no default value. This parameter is set to +1 if another pass is 
to be made through the Static Analysis with Differential Stiffness DMAP loop (and 
hence through the DSMG2 module). It is set to -1 if the module determines that 
the current pass through the module will be the final one. This latter condition 
is met if (1) no differential stiffness coefficient set number was specified by 
the user in his Case Control Deck (if this condition is true, module DSMGl sets 
the parameter DSC0SET (see below) equal to -1 and a value of 1.0 is used for B); 
or if (2) the current S is the last one on the user specified DSFACT card. 

DSC0SET - Input-integer-no default value. DSC0SET is the differential stiffness coefficient 



4.51-3 



MODULE FUNCTIONAL DESCRIPTIONS 

set number of a DSFACT bulk data card chosen by the user in his Case Control Deck. 
If no such set was specified by the user, DSCj^SET = -1 and this module will set 
3 = 1 .0 and set the REPEATD parameter to -1. If DSFACT > 0, DSFACT is used to 
search the MPT for the DSFACT bulk data card chosen by the user. 



4.51.7 Method 



REPEATD is set to one and NDSKIP is incremented by one. If DSC0SET = -1, REPEATD is set to 
-1 and the three matrix additions in Equations 1, 2 and 3 are carried out using the matrix sub- 
routine SSG2C. It should be noted that if DSC0SET = -1 , it is assumed that DMAP equivalences have 
been made between PL and PBL, PS and PBS, YS and YBS, and U00V and UB00V and hence Equations 4 
through 7 are not calculated. 

If DSC0SET f -1, the MPT is searched until a match is found between DSC0SET and a DSFACT 
bulk data card image on the MPT. If a match is found, the parameter NDSKIP is used to find the 
correct value of B for this pass through the DMAP loop. If a match is not found, a fatal error 
occurs. A match having been found, the following operations are performed. 

1. REPEATD is set to -1 if it is determined that this B is the last one on the DSFACT card. 

2. The four scalar multiplications in Equations 4 through 7 are performed using matrix 
subroutine SSG2C. 

3. The three matrix additions in Equations 1 through 3 are performed using matrix sub- 
routine SSG2C. 

4.51.8 Subroutines 

DSMG2 has no auxiliary subroutines. A description of SSG2C can be found in section 3.5.11. 

4.51.9 Design Requirements 

If DSC0SET = -1, it is assumed that DMAP equivalences have been made between the data blocks 
corresponding to the matrices in Equations 4 through 7. 

Two GINI3 buffers are needed and open core is defined at /DSMG2X/. 

4.51.10 Diagnostic Messages 

Fatal error message 2084 may occur. 



4.51-4 



FUNCTIONAL MODULE PLAl (PIECEWISE LINEAR ANALYSIS - PHASE 1) 

4.52 FUNCTIONAL MODULE PLAT (PIECEWISE LINEAR ANALYSIS - PHASE 1) 

4.52.1 Entry Point : PLAl 

4.52.2 Purpose 

PLAl is a pre-processor for the modules unique to the Piecewise Linear Analysis Rigid 
Format. PLAl extracts the linear elements from the ECPT data block (an element is defined 
to be linear if its modulus of elasticity - E on a MATl bulk data card - is not defined to 
be the first derivative of a stress-strain tabular function defined on a TABLESl bulk data 
card) to form [K ] , extracts the nonlinear element entries from the ECPT data block to 
form ECPTNL, and separates the linear and nonlinear element entries in the EST to form ESTL 
and ESTNL. 

4.52.3 DMAP Calling Sequence 

PLAl CSTM,MPT,ECPT,GPCT,DIT,CASECC.EST/KGGXL, ECPTNL, ESTL, ESTNL/V.N.KGGLPG/V.N.NPLALIM/ 
V ,N ,ECPTNLPG/V ,N ,PLSETN0/V ,N ,N0NLSTR/V ,N .PLFACT $ 

4.52.4 Input Data Blocks 

CSTM - Coordinate System Transformation Matrices. 

MPT - Material Properties Table. 

ECPT - Element Connection and Properties Table. 

GPCT - Grid Point Connection Table. 

DIT - Direct Input Tables. 

CASECC - Case Control Data Table. 

EST - Element Summary Table. 

Notes : 1. The CSTM may be purged. However, if it is, and some grid point is not in 
basic coordinates, then a fatal error exists. 

2. If an element references a material property and the MPT is purged, a fatal 
error exists. 

3. If any of the data blocks ECPT, GPCT, DIT, CASECC or EST is purged a fatal 
error exists. 



4.52-1 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

Rigid Format DMAP loop counter. It is used in this routine to find the proper 
loading factors on the PLFACT bulk data card specified by the user (see 
PLSETN0 below). 

PLTSETN0 - Input-integer-no default value. PLSETN0 is the set identification number of 
some PLFACT bulk data card chosen by the user in his Case Control Deck. It is 
used to find this PLFACT card in the MPT data block. 

4.54.7 Method 

The module driver, PLA3, is a short routine whose only function is to call subroutines 
PLA31 and PLA32 which accomplish phase 1 and phase 2 of the task of the module respectively. 
Subroutine PLA31 reads the incremental displacement vector into core and appends to each element 
entry of the ESTNL data block the components of the incremental displacement vector corresponding 
to the grid points of each element. This merged information is written on the scratch data 
block ESTNLS, GIN0 file number 301. In PLA32, the ESTNLS data block is read, and the proper 
element routine is called to compute element stresses which are prepared in 0FP (Output File 
Processor) format. Each element routine also updates incremental stress data. The ESTNL data 
for each element with the updated stress information (but without the components of the displace- 
ment vector) are written on ESTNLl. 

Ir PLA31, for TRMEM and QDMEM elements, only the three translational components of the dis- 
placement vector at each grid point of the element are appended to the ESTNL entry. Other elements 
for which Piecewise Linear Analysis is defined use all six components at each grid point. 

In PLA32, the difference quotients y* anci y, which are the previous and current (with respect 
to the DMAP loop in the PLA Rigid Format) load increment ratios, are computed as follows. Let 
P P P be the loading factors on a PLFACT bulk data card. Define P^ = 0. Define 

^i = Pi - P,.i . (1) 

for i >^ 1. Then, define y-r = 0, and 

* "i 
Y- = — ^ . (2 

^i-1 



4.52-2 (12-1-69) 



FUNCTIONAL MODULE PLAl (PIECEWISE LINEAR ANALYSIS - PHASE 1) 

element stress output for a set of elements all of whose members are 
linear, then N0NLSTR is set to -1. If there is a stress output request 
for some nonlinear element, then N0NLSTR is set = +1 and PLA3 will be 
called each time through the PLA DMAP loop. 

PLFACT - Output-complex-no default value. The first load increment factor to be 
used the first time through the PLA DMAP loop, 

4.52.7 Method 

The routine is divided into two phases. Phase 1 processes the ECPT data block in a 
fashion similar to module SMAl (see section 4.27). For each pivot point, every element is 
examined to determine whether it is linear or non linear. This is accomplished by 
calling subroutine MAT (see section 3.4.36) with the second word, INFLA6, of the common block 
/MATIN/ equal to 5. If the element is linear, the proper element stiffness matrix generator 
routine such as KR0D. KBAR, etc. is called. The element routine will, in turn, call subroutine 
SMAIB to add its contribution to the 6 (or fewer, if the pivot point is a scalar point or there is 
not enough core storage available-see Module Functional Description for SMAl, section 4.27-) 
rows of the KGGXL matrix currently being generated. If the MAT routine determines that the 
element is nonlinear, then the ECPT entry for that elerent, along with words needed subsequently 
in module PLA4, is appended (see data block description for ECPTNL in section 2.3.34.4 for details) 
The number of words appended depends upon element type. This appended ECPT entry is written 
onto the ECPTNL data block. 

Phase 2 of this routine reads the first record of CASECC into core, and the MPT data block 
is searched to find the set number on a PLFACT bulk data card requested by the user in CASECC. 
Parameters PLFACT and PLASETN0 are set. The EST data block is then processed. The logic here 
is similar to Phase 1. For each element, it is determined if the element is linear or nonlinear. 
If the element is linear, its EST entry is copied onto the ESTL data block. If the element is 
non-linear and stress output is requested, the EST entry along with words needed subsequently 
in module PLA3 are appended. The number of words appended depends upon element type and is 
not the same number of words appended to the ECPT entry to create the ECPTNL. If the element 
is nonlinear and stress output is not requested, the EST entry for the element is written onto 
the ESTL data block. 



4.52-3 



MODULE FUNCTIONAL DESCRIPTIONS 



4.52.8 Subroutines 

PLAT has no auxiliary subroutines as such. However, it uses all the structural element 
routines of module SMAl to generate [k^^ ] , which in turn use the common blocks of SMAl as well 
as the "insertion" routine, SMAIB. See Module Functional Description for SMAl, section 4.27. 

4.52.9 Design Requirements 

For phase 1 of PLAl , the design requirements are the same as those for SMAl. For phase 
2, the first record of CASECC must be able to be held in open core. 

4.52.10 Diagnostic Messages 

For phase 1, see diagnostic messages for module SMAl, section 4.27.10. For phase 2, a user 
fatal message, 2032, occurs if the PLFACT bulk data card which was chosen by the user in his 
Case Control Deck could not be found in the MPT. 



4.52-4 



FUNCTIOMAL MODULE PLA2 (PIECEWISE LINEAR ANALYSIS - PHASE 2) 

4.53 FUNCTIONAL MODULE PLA2 (PIECEWISE LINEAR ANALYSIS - PHASE 2) 

4.53.1 Entry Point : PLA2 

4.53.2 Purpose 

To add the incremental displacement vector, the incremental load vector, and the incremental 
vector of single-point forces of constraint for the current pass through the Piecewise Linear 
Analysis Rigid Format DMAP loop to the current running sum of these vectors: 

{U } = {U }+{AU } , (1) 

{P. } = {P. } + {AP } . (2) 

9i+l 9i 9^ 

{q_ } = {q^ } + {Aq } . (3) 

9i+l °i 9] 

4.53.3 DMAP Calling Sequence 

PLA2 DELTAUGV,DELTAPG,DELTAqG/UGVl,PGVl,QGL/V,N,PLAC0UNT $ 

4.53.4 Input Data Blocks 

DELTAUGV - Incremental displacement vector in Piecewise Linear Analysis - g set. 

DELTAPG - Incremental load vector in Piecewise Linear Analysis - g set. 

DELTAQG - Incremental vector of single-point forces of constraint in Piecewise 
Linear Analysis - g set. 

Note : 

1 . DELTAUGV and DELTAPG cannot be pre-purged. 

2. DELTAQG may be pre-purged. 

4.53.5 Output Data Blocks 

UGVl - Matrix of successive sums of incremental displacement vectors - g set. 

PGVl - Matrix of successive sums of incremental load vectors - g set. 

QGl - Matrix of successive sums of incremental vectors of single-point forces of 

constraint - g set. 

4.53-1 



MODULE FUNCTIONAL DESCRIPTIONS 



Notes: 



1. UGVl and PGVl cannot be purged. 

2. QG1 may be purged if DELTAQG is purged. 



4.53.6 Parameters 



PLAC0UNT - Input and output-integer - this parameter must be set to 1 outside the 
Piecewise Linear Analysis Rigid Format DMAP Toon. This is done usinq 
the PARAM module rather than through the Module Properties List (MPL). 

4.53.7 Method 

If PLACjIUNT = 1, that is, this is the first time PLA2 has been called in the Piecewise 
Linear Analysis Rigid Format DMAP loop, then the DELTAUGV data block is copied onto the UGVl 
data block. If PLAC0UNT > 1, then PLAC0UNT is used as a counter to determine how many records 
{running sum displacement vectors) to skip on the file containing UGVl so that the most recently 
computed running sum displacement vector can be read into open core for the vector addition. 
Once this vector is read into open core, the incremental displacement vector is read and 
interpreted using subroutines INTPK and ZNTPKI , and the vector addition given in Equation 1 is 
carried out element-by-element. 

Equations 2 and 3 are computed using the method described in the above oaraqraoh. 

4.53.8 Subroutines 

PLA2 has no auxiliary subroutines. 

4.53.9 Design Requirements 

Open core is defined at /PLA2X/. 

4.53.10 Diagnostic Messages 

User message 2127 or 2128 is output if either DELTAUGV (DELTAPG) or UGVl (PGVl) is purged. 



4.53-2 



FUNCTIONAL MODULE PLA3 (PIECEWISE LINEAR ANALYSIS - PHASE 3) 

4.54 FUNCTIONAL MODULE PLA3 (PIECEWISE LINEAR ANALYSIS - PHASE 3) 

4.54.1 Entry Point : PLA3 

4.54.2 Purpose 

To compute element stresses for nonlinear elements (see definition of linear elements in 
section 4.52.2) for which the user has requested stress output. It also updates the ESTNL data 
block so that the output data block, ESTNLl, contains up-to-date element stress information. 

4 . 54 . 3 DMAP Calling Sequence 

PLA3 CSTM, MPT, DIT.DELTAUGV, ESTNL, CASECC/(3NLES,ESTNL1/V,N,PLAC0UNT/V,N,PLSETN0 $ 

4.54.4 Input Data Blocks 

CSTM - Coordinate System Transformation Matrices. 

MPT - Material Properties Table. 

DIT - Direct Input Tables. 

DELTAUGV - Current incremental displacement vector. 

ESTNL - Element Summary Table for Nonlinear Elements. 

CASECC - Case Control Data Table. 

Notes : 

1. CSTM can be purged. However, if some grid point of the model is not in basic 
coordinates and the CSTM is purged, a fatal error occurs. 

2. A fatal error occurs if either MPT, DIT, DELTAUGV, ESTNL or CASECC is Durged. 

4.54.5 Output Data Blocks 

0NLES - Nonlinear element stresses (to be processed by the Output File Processor). 
ESTNLl - Element Summary Table for Nonlinear Elements - Updated. 

Note : Neither output data block may be purged. 

4.54.6 Parameters 

PLAC0UNT - Input-integer-no default value. This is the Piecewise Linear Analysis (PLA) 



4.54-1 



MODULE FUNCTIONAL DESCRIPTIONS 

Rigid Format DMAP loop counter. It is used in this routine to find the proper 
loading factors on the PLFACT bulk data card specified by the user (see 
PLSETN0 below). 

PLSETN0 - Input-integer-no default value. PLSETN0 is the set identification number of 
some PLFACT bulk data card chosen by the user in his Case Control Deck. It is 
used to find this PLFACT card in the MPT data block. 

4.54.7 Method 



The module driver, PLA3, is a short routine whose only function is to call subroutines 
PLA31 and PLA32 which accomplish phase 1 and phase 2 of the task of the module respectively. 
Subroutine PLA31 reads the incremental displacement vector into core and appends to each element 
entry of the ESTNL data block the components of the incremental displacement vector corresponding 
to the grid points of each element. This merged information is written on the scratch data 
block ESTNLS, GIN0 file number 301. In PLA32, the ESTNLS data block is read, and the proper 
element routine is called to compute element stresses which are prepared in 0FP (Outnut File 
Processor) format. Each element routine also updates incremental stress data. The ESTNL data 
for each element with the updated stress information (but without the components of the dis- 
placement vector) are written on ESTNLl . 

In PLA31, for R0D, TUBE and BAR elements all six compon-. .j of the displacement vector at 
each grid point of the element are appended to the ESTNL entry. Other elements for which 
Piecewise Linear Analysis is defined use only the three translational components at each grid 
point. 

In PLA32, the difference quotients y* and y. which are the previous and current (with 
respect to the DMAP loop in the PLA Rigid Format) load increment ratios, are computed as follows. 
Let P, , Py, P3 be the loading factors on a PLFACT bulk data card. Define P = 0. Define 



a. = P. - P-.T . (1) 



for i ^ 1. Then, define y-i = 0> 3 



nd 



* 



a. 



yI = :r^ , (2) 



"i-1 



4.54-2 



FUNCTIOriAL MODULE PLA3 (PIECEWISE LINEAR ANALYSIS - PHASE 3 
for i > 1 , and define 



^i + 1 



Yi = -77- • (3) 



a. 
1 



for i ^ 1. These difference quotients are stored in /PLA32C/ for communication to the module's 
element routines so that they can compute the estimated next strain. The details of the element 
calculation are given in section 4.87. The input parameter PLAC0UNT, being the counter for the 
PLA Rigid Format DMAP loop, controls the computation of y* and ,. However, the module's design 
assumes (1) PLAC0UNT is set to one outside the PLA DIW loop and (2) module PLA2, whicii incre- 
ments PLACiaUNT by one, will be executed prior to every omP call to PLA3. Hence, the proper 
choice for the subscript i in Equations 1 , 2 and 3 is one less than the value of PLAC0UNT. 
The difference PLAC0UNT-1 is stored in /PLA32C/ as IPASS. 

4.54.8 Subroutine s 

PLA3 uses, for element routine calculations, the utility routines PRETRS, PREMAT, GMMATS and 
element drivers. Communication of an appended ESTNL element entry to an element routine during 
phase 2 of PLA3 is accomplished via /PLA32E/, which is 100 words in length. This fact is not 
explicitly stated below. 

The element drivers PSTRM, PSQDM, PSTRIl, PSTRI2, PSQADl, and PSQAD2, use a) /PLA3ES/, which 
is 300 words in length, as a communication link for the element subroutines which they cell; and 
b) /PLA3UV/, which is 25 words in length, as a communication link for displacement vectors between 
the driver and their subroutines. PLA32 will call the element drivers listed above (plus PSRSJD 
and PSBAR); the other subroutines described below (in sections 4.54.8.11 through 4.54.8.18) are 
only used (directly or indirectly) by the element drivers. 

4.54.8.1 Subroutine Name: PLA31 

1. Entry Point: PLA31 

2. Purpose: To perform phase 1 of the module's operations as described above. 

3. Calling Sequence: CALL PLA31 



4.54-3 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



4.54.8.2 Subroutine Name: PLA32 

1. Entry Point: PL.A32 

2. Purpose: To perform phase 2 of the module's operation as described above. 

3. Calling Sequence: CALL PLA32 

4.54.8.3 Subroutine Name: PSR(3D 

1. Entry Point: PSROD 

2. Purpose: To compute element stresses and to update the ESTNL entry for a RCID, C0NR0D or 
TUBE element. Note that for a TUBE element, the ESTNL entry is rearranged and elementary 
transformations are performed in PLA32 so that the PSR0D routine may compute element stresses 
for a TUBE. 

3. Calling Sequence: CALL PSR0D 

4.54.8.4 Subroutine Name: PSBAR 

1. Entry Point: PSBAR 

2. Purpose: To compute element stresses and to update the ESTNL entry for a BAR element. 

3. Calling Sequence: CALL PSBAR 

4.54.8.5 Subroutine Name: PSTRM 

1. Entry Point: PSTRM 

2. Purpose: To calculate the material properties matrix, arrange the flow of element 
stress calculations and update the ESTNL entry for the TRMEM element. 

3. Calling Sequence: CALL PSTRM 

4.54.8.6 Subroutine Name: PSQDM 

1. Entry Point: PSQDM 

2. Purpose: To calculate the material properties matrix, arrange the flow of element stress 
calculations and update the ESTNL entry for the QDMEM element. 

3. Calling Sequence: CALL PSQDM 

4.54-4 (12-1-69) 



FUNCTIONAL MODULE PLA3 (PIECEWISE LINEAR ANALYSIS - PHASE 3) 

4.54.8.7 Subroutine Name: PSTRIl 

1. Entry Point: PSTRIl 

2. Purpose: To calculate the material properties matrix, arrange the flow of element stress 
calculations and update the ESTNL entry for the TRIAl element. 

3. Calling Sequence: CALL PSTRIl 

4.54.8.8 Subroutine Name: PSTRI2 

1. Entry Point: PSTRI2 

2. Purpose: To calculate the material properties matrix, arrange the flow of element stress 
calculations and update the ESTNL entry for the TRIA2 element. 

3. Calling Sequence: CALL PSTRI2 

4.54.8.9 Subroutine Name: PSQADl 

1. Entry Point: PSQADl 

2. Purpose: To calculate the material properties matrix, arrange the flow of element stress 
calculations and update the ESTNL entry for the QUADl element. 

3. Calling Sequence: CALL PSQADl 

4.54.8.10 Subroutine Name: PSQAD2 

1. Entry Point: PSAQD2 

2. Purpose: To calculate the material properties matrix, arrange the flow of element stress 
calculations and update the ESTNL entry for the QUAD2 element. 

3. Calling Sequence: CALL PSQAD2 

4.54.8.11 Subroutine Name: PSTRMl 

1. Entry Point: PSTRMl 

2. Purpose: To generate element stress matrices for the TRMEM element, and the membrane 
portion of TRIAl and TRIA2 elements, and perform subcomputations for the PSQDMl routine. 

3. Calling Sequence: CALL PSTRMl (NTYPE) 

4.54-5 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



[0 = TRMEM, TRIAl , or TRIA2 
NTYPE 

Subcomputations for the PSQDMl subroutine 



i: 



4.54.8.12 Subroutine Name: PSQDMl 

1. Entry Point: PSQDMl 

2. Purpose: To generate element stress matrices for the QDMEM element and the membrane 
portions of QUADl and QUAD2 elements. 

3. Calling Sequence: CALL PSQDMl 

4.54.8.13 Subroutine Name: PSTQl 

1. Entry Point: PSTQl 

2. Purpose: To generate element stress matrices for the TRIAl, TRIA2, QUADl, and QUAD2 
elements. 

3. Calling Sequence: CALL PSTQl (NTYPE) 

1 = TRIAl 

12 = TRIA2 
NTYPE 

1 3 = QUADl 

4 = QUAD2 

4.54.8.14 Subroutine Name: PSTRBl 

1. Entry Point: PSTRBl 

2. Purpose: To generate element stress matrices for subcalculations of basic bending 
triangles for the plate portion of TRIAl, TRIA2, QUADl and QUAD2 elements. 

3. Calling Sequence: CALL PSTRBl {I0PT) 
|1 = Subcalculations for PSQPLl 



liJPT 

l2 = Subcalculations for PSTPLl 



4.54.8.15 Subroutine Name: PSTPLl 



1. Entry Point: PSTPLl 

2. Purpose: To generate the element stress matrices for the plate portion of TRIAl and 

4.54-6 (12-1-69) 



FUNCTIONAL MODULE PLA3 (PIECEWISE LINEAR ANALYSIS - PHASE 3) 

TRIA2 elements, 

3. Calling Sequence: CALL PSTPLl 

4.54.8.16 Subroutine Name: PSQPLl 

1. Entry Point: PSQPLl 

2. Purpose: To generate element stress matrices for the QUADl and QUAD2 elements. 

3. Calling Sequence: PSQPLl 

4.54.8.17 Subroutine Name: PSTRQ2 

1. Entry Point; PSTRQ2 

2. Purpose: To perform final stress computations for TRMEM and QDMEM elements. 

3. Calling Sequence: CALL PSTRQ2 (NTYPE) 
n = TRMEM element 



NTYPE 

(2 = QDMEM element 

4.54,8.18 Subroutine Name: PSTQ2 

1. Entry Point: PSTQ2 

2. Purpose: To perform final stress computations for the TRIAl , TRIA2, QUADl, and QUAD2 
elements. 

3. Calling Sequence: CALL PSTQ2 (NPTS) 

(3 = TRIAl and TRIA2 elements 
NPTS I 

U = QUADl and QUAD2 elements 



4.54.9 Design Requirements 

1. The module was designed so that phase 1 and phase 2 can be executed in separate overlay 
segments. 

2. Open core for phase 1 is defined at /PLA31X/ and for phase 2 at /PLA32X/. Open core 
requirements for both phases are minimal. In phase 1, the single precision incremental 
displacement vector in unpacked form must be able to be contained in open core. In phase 2, 
the CSTM and MPT data blocks, tables in the DIT referenced on MATSl bulk data cards, and 

4.54-7 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

the first record (and only record since a PLA problem allows only one CASECC record) of 
CASECC must be able to be contained in open core. 

3. In addition to the common blocks mentioned above, PLA32 uses /PLA32S/, which is 325 
words in length, as scratch storage for the module's element routines, and /S0UT/, which 
is 30 words in length, as a storage buffer for computed element stresses. 

4. One scratch file is used, and all arithmetic operations are performed in single 
precision. 

4.54.10 Diagnostic Messages 

During phase 1, the following diagnostic messages may appear. If the incremental displace- 
ment vector is null, user fatal error 3005 will be given. Two system fatal "fail-safe" error 
messages, 2091 and 2092, may be implemented if the ESTNL input data block was incorrectly con- 
structed in PLAl or was incorrectly updated during the previous execution of the PLA3 module. 

During phase 2, error messages 3001, 3002 or 3003 may occur if the proper loading factors 
P. cannot be found on the PLFACT bulk data card image in the MPT. If the ECPTDS scratch file 

J 

is not in the prescribed format, system fatal message 2091 will occur. 

If the minimal core storage requirements in either phase 1 or phase 2 are not met, the 
usual fatal error 3008 will occur. 



4.54-8 (12-1-69) 



FUNCTIONAL MODULE PLA4 (PIECEWISE LINEAR ANALYSIS - PHASE 4) 

4.55 FUNCTIONAL MODULE PLA4 (PIECEWISE LINEAR ANALYSIS - PHASE 4) 

4.55.1 Entry Point: PLA4 

4.55.2 Purpose 

To generate the stiffness matrix for nonlinear elements, [k"'^], and to update the 
Element Connection and Properties Table for Nonlinear Elements, ECPTNL, so that it contains 
up-to-date element stress information. 

4.55.3 DMAP Calling Sequence 

PLA4 CSTM,MPT, ECPTNL, GPCT,DIT,DELTAUGV/KGGNL,ECPTNL1/V,N,PLAC0UNT/V,N,PLSETN0/ 
V.N, PL FACT $ 

4.55.4 Input Data Blocks 

CSTM - Coordinate System Transformation Matrices. 

MPT - Material Properties Table. 

ECPTNL - Element Connection and Properties Table for Nonlinear Elements. 

GPCT - Grid Point Connection Table. 

DIT - Direct Input Tables. 

DELTAUGV - Current incremental displacement vector. 

Notes : 

1. CSTM may be purged. However, if some grid point of the model 1s not In basic 
coordinates and the CSTM has been purged, a fatal error will occur. 

2. A fatal error occurs if either MPT, ECPTNL, GPCT, DIT or DELTAUGV is purged. 
4.55.5 Output Data Blocks 

KGGNL - Stiffness matrix of nonlinear elements - g set. 

ECPTNLl - Element Connection and Properties Table for Nonlinear Elements - updated. 

Note : Neither KGGNL or ECPTNLl may be purged. 



4.55-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.55.6 Parameters 

PLACjJUNT - Input-integer-no default value. Loop counter for the Plecewise Linear 

Analysis (PLA) Rigid Format DMAP loop. The module uses this parameter to find 
the correct loading factors on the PLFACT bulk data card chosen by the user. 

PLSETN0 - Input-integer-no default value. Set identification number of a PLFACT 

bulk data card chosen by the user in his Case Control Deck. The module uses 
this parameter to search the MPT for this card. 

PLFACT - Output-complex-no default value. The difference of loading factors to be used 
during the next pass of the PLA Rigid Format DMAP loop. 

4.55.7 Method 

The module driver PLA4 is a short routine whose only function is to call subroutines 
PLA41 and PLA42 which accomplish phase 1 and phase 2 of the task of the module respectively. 
Subroutine PLA41 reads the incremental displacement vector into core and appends to each 
element entry of the ECPTNL data block the components of the incremental displacement vector 
corresponding to the grid points of each element. This merged information is written on the 
scratch data block ECPTS, GIN(3 file number 301. In PLA42, the ECPTS data block is processed 
in a fashion similar to the processing of the ECPT data block in module SMAl (see the Module 
Functional Description for SMAl, section 4.27). 

In PLA41, for all elements except the BAR element, only the three translational 
components of the displacement vector at each grid point of an element are appended to the 
ECPTNL element entry. For a BAR element, all six components of the displacement vector at 
each grid point are appended. 

The logic of the processing of the scratch data block, ECPTS, in PLA42 is very similar 
to that used in subroutine SMAIA (of SMAl, the stiffness matrix generation module - see 
the Module Functional Description for SMAl, section 4.27). The similarities are not enumerated 
here, but notable differences are the following. 

1. Before PREMAT is called to read into open core the MPT data block and tables from 
the DIT data block referenced on MATSl bulk data cards, the MPT is read in subroutine 



4.55-2 



FUNCTIONAL MODULE PLA4 (PIECEWISE LINEAR ANALYSIS - PHASE 4) 

PLA42 to compute y* and y as in Equations 1 , 2 and 3 in section 4.54, and the real part 
of the output DMAP parameter PLFACT is set to the value of a.^^ in Equation 3 in section 
4.54. The imaginary part of PLFACT is set to zero. The reason for PLFACT being complex is 
that it is an input parameter to the DMAP module ADD during the next pass of the PLA 
Rigid Format DMAP loop, and ADD (see section 4.78) requires its parameters to be complex. 

2. When PREMAT is called, the last argument is set negative to signal PREMAT that this 
is a PLA problem and hence that special processing will be required. 

3. Subsequent to the call of an element routine, the element type and the updated ECPT 
entry are written onto the ECPTNLl data block. 

4.55.8 Subroutines 

PLA4 uses PRETRD. PRETRS, PREMAT, INVERS, INVERD, GMMATS, and GMMATD as utility routines. The 
common block /PLA42E/ is the means of communicating a) the element entry of the ECPTS from PLA42 
to an element stiffness matrix generation routine and b) the ECPTS element entry with updated 
stress information from the element routine back to PLA42 upon completion of element matrix 
generation. This fact is not explicitly stated in the descriptions of the element routines 
(e.g., PKRCID) given below. 

The element drivers PKTRM. PKQDM, PKTRIl. PKTRI2. PKQADl, and PKQAD2 use a) /PLA4ES/, which 
is 300 words in length, and b) /PLA4UV/, which is 25 words in length, as communication links with 
the subroutines that they call. PLA42 will call the drivers listed above which will use (directly 
and indirectly) the subroutines described below in sections 4.55.8.12 through 4.55.8.22. 

4.55.8.1 Subroutine Name: PLA41 

1. Entry Point: PLA41 

2. Purpose: See discussion above. 

3. Calling Sequence: CALL PLA41 

4.55.8.2 Subroutine Name: PLA42 

1. Entry Point: PLA42 

2. Purpose: See discussion above. 



4.55-3 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

3. Calling Sequence: CALL PLA42 
4.55.8.3 Subroutine Name: PLA4B 

1. Entry Point: PLA4B 

2. Purpose: To add a double precision 6 by 6 element stiffness matrix to the "submatrix" 
corresponding to the current pivot point. This routine performs the same function as, and 
is modeled after, subroutine SMAIB of module SMAl . 

3. Calling Sequence: CALL PLA4B (KE,J) 

KE - Row-stored double precision 6 by 6 matrix to be added to the submatrix in core - input. 
J - The column index of the KGGNL matrix which corresponds to first column of the KE 
matrix - integer - input. 

4.55.8.4 Subroutine Name: PKR0D 

1. Entry Point: PKR0D 

2. Purpose: To generate the element stiffness matrix for a R0D element and to update 
the ECPTNL element entry for a R0D element. 

3. Calling Sequence: CALL PKR0D 

4.55.8.5 Subroutine Name: PKBAR 

1. Entry Point: PKBAR 

2. Purpose: To generate the element stiffness matrix for a BAR element and to update the 
ECPTNL element entry for a BAR element. 

3. Calling Sequence: CALL PKBAR 

4.55.8.6 Subroutine Name: PKTRM 

1. Entry Point: PKTRM 

2. Purpose: To calculate the material properties matrix, update the ECPTNL entry, and 
arrange the flow of element stiffness calculations for the TRMEM element. 

3. Calling Sequence: PKTRM 

4.55-4 (12-1-69) 



FUNCTIONAL MODULE PLA4 (PIECEWISE LINEAR ANALYSIS - PHASE 4) 

4.55.8.7 Subroutine Name: PKQDM 

1. EEntry Point: PKQDM 

2. Purpose: To calculate the material properties matrix, update the ECPTNL entry, and 
arrange the flow of element stiffness calculations for the QDMEM element. 

3. Calling Sequence: CALL PKQDM 

4.55.8.8 Subroutine Name: PKTRIl 

1. Entry Point: PKTRIl 

2. Purpose: To calculate the material properties matrix, update the ECPTNL entry, and 
arrange the flow of element stiffness calculations for the TRIAl element. 

3. Calling Sequence: CALL PKTRIl 

4.55.8.9 Subroutine Name: PKTRI2 

1. Entry Point: PKTRI2 

2. Purpose: To calculate the material properties matrix, update the ECPTNL entry, and 
arrange the flow of element stiffness calculations for the TRIA2 element. 

3. Calling Sequence: CALL PKTRI2 

4.55.8.10 Subroutine Name: PKQADl 

1. Entry Point: PKQADl 

2. Purpose: To calculate the material properties matrix, update the ECPTNL entry, and 
arrange the flow of element stiffness calculations for the QUADl element. 

3. Calling Sequence: CALL PKQADl 

4.55.8.11 Subroutine Name: PKQAD2 

1. Entry Point: PKQAD2 

2. Purpose: To calculate the material properties matrix, update the ECPTNL entry, and 
arrange the flow of element stiffness calculations for the QUAD2 element. 

3. Calling Sequence: CALL PKQAD2 

4.55-5 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

4.55.8.12 Subroutine fiame: PKTRMl 

1. Entry Point: PKTRMl 

2. Purpose: To generate element stress matrices for the TRMEM, TRIAI and TRIA2 elements, 
and perform subcomputations for the PKQDMl routine. 

3. Calling Sequence: CALL PKTRMl (NTYPE) 
(0 = TRMEM, TRIAI or TRIA2 



NTYPE . 

U = Subcomputations for the PKQDMl routine 

4.55.8.13 Subroutine Name: PKQDMl 

1. Entry Point: PKQDMl 

2. Purpose: To generate element stress matrices for the QDMEM, QUAD! and QUAD2 elements. 

3. Calling Sequence: CALL PKQDMl 

4.55.8.14 Subroutine Name: PKTQl 

1. Entry Point: PKTQl 

2. Purpose: To generate element stress matrices for the TRIAI. TRIA2, QUADl , and QUAD2 
elements. 

3. Calling Sequence: CALL PKTQl (NTYPE) 

TRIAI 

12 = TRIA2 
NTYPE 

1 3 = QUADl 

4 = QUAD2 
4.55.8.15 Subroutine Name: PKTRQ2 

1. Entry Point: PKTRQ2 

2. Purpose: To perform final stress computations for the TRMEM and QDMEM elements. 

3. Calling Sequence: CALL PKTRQ2 (NTYPE) 
[1 = TRMEM element 



4.55-6 (12-1-69) 



NTYPE 

l2 = QDMEM element 



FUNCTIONAL MODULE PLA4 (PIECEWISE LINEAR ANALYSIS - PHASE 4) 

4.55.8.16 Subroutine Name: PKTQ2 

1. Entry Point: PKTQ2 

2. Purpose: To perform final stress computations for the TRIAl . TRIA2. QUADl . and QUAD2 
elements. 

3. Calling Sequence: CALL PKTQ2 (NPTS) 
(3 = TRIAl or TRIA2 elements 



NPTS 

U = QUADl or QUAD2 elements 

4.55.8.17 Subroutine Name: PKTRMS 

1. Entry Point: PKTRMS 

2. Purpose: To generate the element stiffness matrix for the TRMEM element and sub- 
computations for the PKQDMS routine. 

3. Calling Sequence: CALL PKTRMS (NTYPE) 

(0 = TRMEM 
NTYPE < 

U = Sub-computations for PKQDMS 
4.55.8.18 Subroutine Name: PKQDMS 

1. Entry Point: PKQDMS 

2. Purpose: To generate the element stiffness matrix for the QOMEM element. 

3. Calling Sequence: CALL PKQDMS 

4.55.8.19 Subroutine Name: PKTRQD 

1. Entry Point: PKTRQD 

2. Purpose: To generate the element stiffness matrix for the TRIAl. TRIA2, QUADl, or 
QUAD2 elements. 

3. Calling Sequence: CALL PKTRQD (NTYPE) 



4.55-7 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



NTYPE 



1 = TRIM 
1 2 = TRIA2 
Is = QUAD! 

4 = QUAD2 



4.55.8.20 Subroutine Name: PKTRBS 

1. Entry Point: PKTRBS 

2. Purpose: To generate the element stiffness matrix subcalculations for the PKTRPL and 
PKQDPL routines. 

3. Calling Sequence: CALL PKTRBS (I0PT) 

p = Subcomputations for PKQDPL 
I0PT 



C: 



Subcomputations for PKTRPL 
4.55.8.21 Subroutine Name: PKTRPL 

1. Entry Point: PKTRPL 

2. Purpose: To generate the element stiffness matrix for the TRIAl and TRIA2 elements. 

3. Calling Sequence: CALL PKTRPL 
4.55.8.22 Subroutine Name: PKQDPL 

1. Entry Point: PKQDPL 

2. Purpose: To generate the element stiffness matrix for the QUAD! and QUAD2 elements. 

3. Calling Sequence: CALL PKQDPL 
4.55.9 Design Requirements 

The module was designed so that phase 1 and phase 2 can be executed in separate overlay 
segments. 

Open core for phase 1 is defined at /PLA4U/ and for phase 2 at /PLA42X/. In phase 1 the 
single precision incremental displacement vector in unpacked form must be able to be contained in 
core. In phase 2. the open core requirements are the same as those for module SMAl (see section 
4.27.9.1) except that only four GINU buffers are required during the principal loop of phase 2. 

4.55-8 (12-1-69) 



FUNCTIONAL MODULE PLA4 (PIECEWISE LINEAR ANALYSIS - PHASE 4) 

which processes the ECPTS and GPCT in a complementary manner. One GIN0 buffer is defined for 
each of KGGNL, ECPTNLl, ECPTS and GPCT. 

In addition to /PLA42E/, which is TOO words in length, subroutine PLA42 uses the following 
common blocks: a) /PLA42D/, which is 300 double precision words in length, and is used as a 
scratch storage for the module's element routines; b) /PLA425/, which is 325 single precision words 
in length, and is used as scratch storage for the module element routines; and c) /PLA42C/, which 
is a communication region for phase 2 of the task of the module. /PLA42C/ is defined as follows: 
C0MMiaN/PLA42C/NPVT,GAMf<1A. GAMMAS, IPASS,ICSTM,NCSTM,IGPCT,NGPCT,IP0INT,NP0INT,I6X6K.N6X6K,CSTM, MPT, 
ECPTS, GPCT, DIT, KGGNL, ECPT(3,INRW,0UTRW,E(3R,NE0R,CLSRW,JMAX,FR(3WIC,LR0WIC,NR(2WSC,NLINKS,NWj3RDS(4O), 
I0VRLY(4O),LINK(4O),N0G0 

GAMMA, GAMMAS - The load increment ratios as defined in Equations 2 and 3 in 

section 4.54. 

IPASS - Number of the current pass through the PLA DMAP loop. 

NPVT.ICSTM.NCSTM.IGPCT, ) 

NGPCT,IP0INT.NP0INT, ( - As defined in section 4.27.9. 

I6X6K,N6X6K ^ 

CSTM, MPT, ECTPS, GPCT, ) ^,„- ^., u ^ .. • 

DIT, KGGNL i ' ''^^^ ^^^^ numbers for their corresponding data blocks. 



ECPT0 - GINi3 file number for the ECTPNLl data block. 

- As defined in section 4.27.9. 



INRW,0UTRW 

I0VRLY(4O),LINK(4O),N0G{5 

The variables a) corresponding to GIN0 file numbers, b) GIN0 parameter options (e.g., INRW, 
0UTRW), and c) NLINKS, I0VRLY. and NW0RDS, and N0G0 are set in the block data subprogram PLA4BD. 

One scratch file is used, and all operations associated with stiffness matrix calculations 
are performed in double precision. 

4.55.10 Diagnostic Messages 

During phase 1, if the incremental displacement vector is null, user fatal error 2083 will 
occur. 

During phase 2, error messages 3001, 3002, or 3003 may occur if the proper loading factors 
cannot be found on the PLFACT bulk data card image in the MPT. Other diagnostic messages for 
phase 2 are the same as those for module SMAl (see section 4.27.10). 

4.55-9 (12-1-69) 



FUNCTIONAL MODULE CASE (SIMPLIFY CASE CONTROL) 



4.56 FUNCTIONAL MODULE CASE (SIMPLIFY CASE CONTROL) 



4.56.1 Entry Point : CASE 



4.56.2 Purpose 

To remove looping considerations from later dynamics modules. 

4.56.3 DMAP Calling Sequence 

CASE CASECC,PSDL/CASEXX/C.N,APPR0ACH/V,N,R£PEAT/V,N,L00P $ 

4 . 56 . 4 Input Data Blocks 

CASECC - Case Control Data Table. 
PSDL - Power Spectral Density List. 

Note: PSDL is used only if APPROACH = FREQRESP and Random Analysis is selected in CASECC, 

4.56.5 OutpU Data Blocks 

CASEXX - Case Control data table for dyne.mics problems. 
Note: CASEXX cannot be purged. 

4.56.6 Parameters 



APPROACH - Input-3CD-no default. Defines the approach to be used for looping 
criteria. 
BCD Val ue Lg0P 

NONE 

NONE 

N0NE 



STATICS 

REIGEN 

DSO 

DSl 

FREQRESP 

TRANRESP 

BLKO 

3LK1 

CEIGEiJ 



DIRECT INPUT MATRICES OR TRANSFER FUNCTIONS 

LOADS 

NONE 

NONE 

DIRECT INPUT MATRICES OR TRANSFER FUNCTIONS 



4.56-1 



MODULE FUNCTIONAL DESCRIPTIONS 



BCD Value L00P 

PLA N0NE 



REPEAT - Input and output-integer-set equal to zero outside of the DMAP loop by the PARAM 

module. -1 if no additional loops; + loop count if loops. 
L!3(3P - Output-integer-default = -1 . -1 if this is not a looping problem, if this 

is a looping problem. 

4.56.7 Method 

The method of operation depends upon the input parameter APPROACH. 

4.56.7.1 Transient Response 

If APPROACH = TRANRESP, CASECC is skipped over REPEAT records. If REPEAT = 0, REPEAT is set 
to 1. One record of CASECC is read and copied onto CASEXX. An attempt is made to read another 
record. If no more records exist. REPEAT is set to -1. Also, if this is the first entry to CASE 
(i.e., REPEAT =1), L00P is set to -1. If additional records exist, REPEAT and L00P are set to 1. 

4.56.7.2 Complex Eigenvalue Analysis 

If APPROACH = CEIGEN. REPEAT records are skipped in CASECC. If REPEAT = 0. REPEAT is set to 
1. One record of CASECC is read and copied onto CASEXX. The names of the Direct Input Matrices 
and Transfer Functions sets are saved. An attempt is made to read another record. If no 
more exist, REPEAT is set to -1. Also if this is the first entry (i.e., REPEAT = 1) L00P is set 
to -1. If additional records exist, their Direct Input Matrices and Transfer Functions sets are 
compared to those saved. If they all agree, this record is copied onto CASEXX and the process 
is repeated. If they do not agree, REPEAT is incremented by 1, L00P is set to 1, and CASE returns, 

4.56.7.3 Frequency Response 

If APPROACH = FREQRESP, the method used is the same as Complex Eigenvalue Analysis unless 
RANDPS cards are selected. If RANDPS cards are selected, the selected set is read from PSDL and 
the unique subcase 'Md's" referenced are stored. Each subcase id copied onto CASEXX 1s compared 
to this list, and the entry is marked as found. If at the completion of CASE unmarked entries 
exist, the routine terminates with message 3033. 



4.56-2 



FUNCTIONAL MODULE CASE (SIMPLIFY CASE CONTROL) 



4.56.8. Subroutines 



No auxiliary subroutines are used by CASE. 



4.56.9 Design Requirements 



Open core is defined at /CASC0R/. 
C0MM0N/CASC0R/ 



CASECC 
Record 




List 


CASEXX 


buffer 


PSDL bL 


ffer 


CASECC 


buffer 



Present only if RAND0M checks done 



3 GIN0 buffers 



4.56.10 Diagnostic F-^essages 

If a case control record cannot be held in core, CASE will issue error message 300£ 
Message 3033 may be issued by CASE as outlined above. 



4.56-3 



FUNCTIONAL MODULE MTRXIN (MATRIX INPUT) 
4.57 FUNCTIONAL MODULE MTRXIN (MATRIX INPUT) 

4.57.1 Entry Point : MTRXIN 

4.57.2 Purpose 

MTRXIN has two purposes: (1) to provide a capability for direct input matrices as may occur in 
control systems in the dynamics Rigid Formats and, (2) to provide the DMAP user a capability 
of converting matrices input on DMIG bulk data cards to NASTRAN matrix format. 

4.57.3 DMAP Calling Sequences 

1. Dynamics Rigid Formats: 

MTRXIN CASECC,MATP00L,EqDYN,SILD,TFP00L/K2PP.M2PP.B2PP/V,N,LUSETD/V,N.N!3MATl/V,N,N0MAT2/ 
V.N,N0MAT3 $ 

2. DMAP Approach: 

MTRXIN. .MATP00L,EQEXIN,SIL,/NAME1 .NAME2,NAME3/V,N,LUSET/V,N.N0MAT1/V.N.N0MAT2/V,N,N0MAT3 $ 

4.57.4 Input Data Blocks 

CASECC - Case Control, 

MATPi30L - Data block containing matrices input on DMIG bulk data cards. 

EQDYN - Equivalence between external numbers and internal numbers, dynamics. 

SILD - Scalar Index List - dynamics. 

TFP00L - Transfer Function Pool. 

EQEXIN - Equivalence between external numbers and internal numbers. 

SIL - Scalar Index List. 



Notes : 



1. If CASECC is purged, the second purpose is assumed by MTRXIN. 

2. EQDYN, EQEXIN, SIL and SILD may not be purged. 



4.57-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4 . 57 . 5 Output Data Blocks 

K2PP - Direct input stiffness matrix - p set. 

M2PP - Direct input mass matrix - p set. 

B2PP - Direct input damping matrix - p set. 

^AMrll The same names that appear on the DMIG cards, i.e., the DMIG matrix called 



NAME 2 y 
NAMES) 



NAME! win be output on data block NAMEl 



Note : Any output data block may be purged. 



4.57.6 Parameters 



LUSET - Input-integer-no default. Degrees of freedom in the g set. Used with EQEXIN 
and SIL. 

LUSETD - Input-integer-no default. Degrees of freedom in the p set. Used with EQDYN 
and SILD. 

N0MATi - Output-integer-no default. +1 if the i^^ output data block is generated, 
-1 otherwise. 

4.57.7 DMAP Example 

Assume the bulk data contain two DMIG matrices named Ml and M2 which reference grid and/or 
scalar points only. The following set of DMAP instructions will generate these two matrices in 
NASTRAN matrix format, multiply them together and print the result. 

BEGIN 

GPl GE0M1 ,GE0M2/GPL,EQEXIN,GPDT,CSTM.BGPDT.SIL/V.N,LUSET/C.N,O/C,N.O $ 

SAVE LUSET $ 

MTRXIN, .MATP!3(3L, EQEXIN, SIL, /Ml ,M2,/V,N,LUSET/V,N,N0M1/V,N,N0M2/C,N,O $ 

SAVE N0M1,N0M2 $ 

C0ND EXIT,N0M1 $ 

C0ND EXIT,N0M2 $ 

MPYAD M1,M2,/PR0DUCT/C,N,O/C,N,1/C,N,1/C,N,1 $ 

MATPRN PR0DUCT,,,,// $ 

LABEL EXIT $ 

END 



4.57-2 



FUNCTIONAL MODULE MTRXIN (MATRIX INPUT) 

4.57.8 Method 

The first logical record in the Case Control data block is read into core, and the names of 
the requested DMIG matrices are fetched. If the Case Control data block is purged, FNAME is 
called to determine the names of the DMIG matrices from the names of the output data blocks. If 
the Case Control record was read, the transfer function set selection is fetched. If transfer 
matrices are requested, the TFP00L data block is opened, and the file is positioned to the 
requested set. Each transfer function matrix for which a corresponding direct input matrix exists 
is written on a scratch file. If no direct input matrix exists corresponding to a transfer func- 
tion matrix, the transfer function matrix is written directly on the appropriate output data block. 
The transfer function matrices are written in NASTRAN matrix format by decoding the row and 
column numbers and calling BLDPK. 

Upon completion of the writing of the transfer function matrices (if any), the second record 
of EQEXIN or EQDYN is read into core. The second word of each entry is converted into a scalar 
index number by dividing by 10. The MATP0!2IL data block is opened. The following processing 
occurs: 

1. The header information for the DMIG matrix is read. If an end-of-file is encountered, 
step (5) is executed. If the matrix is not requested, the remainder of the record is 
skipped and step (1) is repeated. Otherwise, step (2) is executed. 

2. Each term in the matrix is read. The grid identification and component code are 
converted to a scalar index value by performing a binary search in EQEXIN or EQDYN in 
core. The scalar index forms a row position of the matrix. The row and column number 
(packed in one word) and the value for the term are stored in core. If core storage is 
exceeded, the terms are written on a scratch file. 

3. When all terms have been read, converted and stored, the matrix is sorted by S0RT. 
The matrix is now written in NASTRAN format by BLDPK. 

4. If a transfer function is to be added to the DMIG matrix, the ADD routine is called 
to accomplish the matrix addition. 

5. A test is made to determine if all requested matrices have been processed. If not, 

an error message is queued, and PEXIT is called. Otherwise, the module makes a normal exit. 



4.57-3 



MODULE FUNCTIONAL DESCRIPTIONS 

4.57.9 Design Requirements 

4.57.9.1 Allocation of Core Storage 

Storage is required to hold the EQDYN or EQEXIN table (2 words per point in the problem) plus 
five GIN0 buffers. Complete spill logic is provided for processing the DMIG matrices. 

4.57.9.2 Environment 

The module l^fTRXIN consists of one subroutine, MTRXIN. Calls are made to the utility routine 
S0RT and matrix operation ADD. Open core is defined by /MTRXXX/. Seven scratch files are used. 

4.57.10 Diagnostic Messages 

The following messages may be issued by MTRXIN: 
2065, 2070, 2074. 



4.57-4 



FUNCTIONAL MODULE 6KAD (GENERAL K ASSEMBLER DIRECT) 
4.58 FUNCTIONAL MODULE GKAD (GENERAL K ASSEMBLER DIRECT) 

4.58.1 Entry Point : GKAD 

4.58.2 Purpose 

To assemble the dynamic stiffness, damping and mass matrices. 

4.58.3 DMAP Calling Sequence 

GKAD USETD,6M,G0,KAA,BAA,MAA,K4AA,K2PP,M2PP,B2PP/KDD,BDD,MDD,GMD,G0D,K2DD,M2DD,B2DD/ 
V,N,TYPE/V,N,APP/V,N,F0RM/V,Y,G/V,Y,W3/V,Y,W4/V,N,Nj3K2PP/V,N,N0M2PP/V,N,N0B2PP/ 
V,N,MPCF1/V,N,SINGLE/V,N,0MIT/V.N,N0UE/V,N,N0K4GG/V,N,N0BG&/V,N,KDEKA/V,Y,M0DACC $ 

4.58.4 Input Data Blocks 

USETD - Displacement set definitions table dynamics, 

GM - Multipoint constraint transformation matrix - m set. 

G0 - Structural matrix partitioning transformation matrix. 

KAA - Partition of stiffness matrix - a set. 

BAA - Partition of damping matrix - a set. 

MAA - Partition of mass matrix - a set. 

K4AA - Partition of structural damping matrix - a set. 

K2PP - Direct input stiffness matrix - p set. 

M2PP - Direct input mass matrix - p set. 

B2PP - Direct input damping matrix - p set. 

Notes : 1. USETD cannot be purged. 

2. GM cannot be purged if MPCFl a 0. 

3. 60 cannot be purged if 0MIT a 0. 

4. KAA cannot be purged if KDEKA a 0. 

5. BAA cannot be purged if N0BGG i 0. 

6. MAA may be purged. 

7. K4AA cannot be purged if N0K4GG > 0. 

8. K2PP cannot be purged if N0K2PP = 0. 

9. M2PP cannot be purged if N0M2PP 2 0. 

4.58-1 



MODULE FUNCTIONAL DESCRIPTIONS 
10. B2PP cannot be purged if N0B2PP ? 0. 

4.58.5 Output Data Blocks 

KDD - Dynamic stiffness matrix - d set. 

BDD - Dynamic damping matrix - d set. 

MDD - Dynamic mass matrix - d set. 

GMD - Multipoint constraint transformation matrix - dynamics. 

G0D - Omitted coordinate transformation matrix - dynamics. 

K2DD - Direct input stiffness matrix - d set, 

M2DD - Direct input mass matrix - d set. 

B2DD - Direct input damping matrix - d set. 

Notes: 1. GMD cannot be purged if MPCFl >_ 0. 

2. G0D cannot be purged if 0MIT >_ 0. 

3. K2DD cannot be purged if NI3K2PP > 0. 

4. M2DD cannot be purged if N0M2PP > 0. 

5. B2DD cannot be purged if N0B2PP > 0. 

4.58.6 Parameters 



TYPE - Input-BCD-no default. If TYPE = TRANSIENT the transient equations are used; 
otherwise the frequency response equations are useo. 

APP - Input-BCD-no default. If APP = F0RCE the p set = d set; otherwise p's are 
reduced to d's by removing m's, s's. and o's. 

F0RM - Input-BCD-no default. If F0RM = Mi3DAL, KDD and BDD are not computed. MDD is 
not computed unless M0DACC a 0. 

G - Input-real-default = 0.0. G is the coefficient of K4uD if TYPt / TRANSIENT. G/W3 
is coefficient of KIDD if TYPE = TRANSIENT. 



W3 



W4 



Input-real-default = 0,0. If TYPE = TRANSIENT G/W3 is the coefficient of KIDD. 
If W3 = 0.0 KIDD is not used. 

Input-real-default = 0.0, 1.0/W4 is the coefficient of K4DD if TYPE = TRANSIENT. 
If W4 = 0.0 K4DD is not used. 



4.58-2 



FUNCTIONAL MODULE GKAD (GENERAL K ASSEMBLER DIRECT) 

N0K2PP - Input-integer-no default. N0K2PP ^0 indicates presence of K2PP. 

N0M2PP - Input-integer-no default. N0M2PP i indicates presence of M2PP. 

N0B2PP - Input-integer-no default. N0B2PP > indicates presence of B2PP. 

KPCFl - Input-integer-no default. MPCFl i indicates presence of GM. 

SIN'GLE - Input-integer-no default. SINGLE a indicates presence of single-point 
constraints. 

0MIT - Input-integer-no default. 0MIT 2 indicates presence of G0. 

N0UE - Input-integer-no default. N0UE 2 indicates presence of extra points. 

N0K4GG - Input-integer-no default. N0K4GG » indicates presence of K4AA. 

N0BGG - Input-integer-no default. N0B6G ^ o indicates presence of BAA. 

KDEKA - Input-integer-no default. KDEKA s. indicates presence of MAA and KAA. 

M0DACC - Input-integer-default = -1. M0DACC » requests computation of HDD (meaningful 
only if F0RM = M0DAL) 

4.58.7 Method 

If extra points are present (M0UE>O) and multipoint constraints or omitted coordinates 
are present (MPCF1>0 or 0MIT>O), then 

GM => GMD, (1) 

and 

G0 => G0D. (2) 

Subroutine GKADIA performs these tasks. 

If direct input matrices are present and m's, s's or o's are present, the direct input 
matrices are reduced from the p set to the d set. Let [D^ ] be a direct input matrix, 

Kp^ - tK^pp]. [Mpp] or [B^p] 
1 . If m's are present. 



4.58-3 



MODULE FUNCTIONAL DESCRIPTIONS 



to p] H> 



nn ' nm 
1- mn 1 mm 



(3) 



(The e coordinates are included with the n coordinates). Then compute: 



[dL] = [dL] - [bLi [gS ^ [G^f [dL] - [<]' [D^] c<] 



2. If s's are present, 



tOff^ => 



'ff 



SS J 



(5) 



where only [dL] is saved. The e coordinates are included with the f coordinates. 
3. If o's are present, first partition [D^^] 

-°dd 



[D^,] =) 



.^d 



'do 

00- 



(6) 



then: 



tt'd'd] 



[Ddd^^^4^tGj]^[Gjf [D^^].[Gj3T[D2^]tGj3, 



(7) 



Steps 1 through 3 are done for K2PP, M2PP and B2PP, using subroutines GKADIC and GKADID. 



4.58-4 



FUNCTIONAL MODULE GKAD (GENERAL K ASSEMBLER DIRECT) 



If F0RM = M0DAL and M0DACC < 0, GKAD is done. If not, the a set matrices are expanded to 

the d set by adding zeros at extra points. Let [D,,] be an a set matrix. Then, 

aa 



aa 






<^ 



(8) 



The above step is done for KAA, BAA, MAA, and K4AA and is performed in subroutine GKAD1B. 

Compute KDD, BDD and MDD. 

1. For Frequency Response or Complex Eigenvalue Analysis (TYPE f TRAN), 



t^dd^ = 



:HiG) [kJ,] . [k2^] . i [kJJ] , 



(9) 



[Bjd^ = [b;^] + [B^^] , 



t^dd^ = tMj,] . [m2^] . 



(10) 
(11) 



2. For Transient Analysis (TYPE = TRAN), 



[KjdJ = tK;^] + [k2^] . 



(12) 



[B,J = [b1,] + [b2^] . ^ Ik],1 . J5O [K^J] . 



'dd^ 



'dd- 



(13) 



[M,,] = [M;,].[m2^] 



(14) 



If W3 or W4 is zero, the corresponding matrices are ignored. 



4.58-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.58.8 Subroutines 

GKAD uses matrix utility routines SSG2C, CALCV, MERGE, UPART, MPART and ELIM. Descriptions 
for these routines can be found in section 3. 

4.58.8.1 Subroutine Name: GKADIA 

1. Entry Point: GKADIA 

2. Purpose: To expand GM or G0 to d size matrices: 

[G„ : 0] => [gJ] (15) 



3. Calling Sequence: CALL GKADIA (USETD,G0,G|2ID,SCR1 .UE.UA.UNE) 

USETD - GIN0 file number of USETD - integer - input. 

G0 - GIN0 file number of Qt<f - integer - input. 

G0D - 6IN0 file number of G(3D - integer - input. 

SCRl - GIN0 file number of scratch file - integer - input. 

UE - Pointer to UE bit in USETD word - integer - input. 

UA - Pointer to UA bit in USETD word - integer - input. 

UNE - Pointer to UNE bit in USETD word - integer - input. 

4.58.8.2 Subroutine Name: GKADIB 

1. Entry Point: GKADIB 

2. Purpose: To expand a set matrices to d set size. 

3. Calling Sequence: CALL GKADIB (USETD, KAA.MAA. BAA, K4AA,K1DD,M1DD,B1DD,K41DD,UA, 

UE,UD,SCR1) 

USETD - GIN0 file number of USETD - integer - input. 

KAA - GINjI file number of KAA - integer - input. 

MAA - GIN0 file number of MAA - integer - input. 

BAA - GIN0 file number of BAA - integer - input. 

K4AA - GIN0 file number of K4AA - integer - input. 



4.58-6 



FUNCTIONAL MODULE GKAD (GENERAL K ASSEMBLER DIRECT) 

KIDD - GIN0 file number of KIDD - integer - input. 

MIDD - GIN0 file number of MIDD - integer - input. 

BIDD - GIN0 file number of BIDD - integer - input. 

K41DD - GIN0 file number of K41DD - integer - input. 

SCRl - GIN0 file number of scratch file - integer - input. 

UA - Pointer to UA bit in USETD word - integer - input. 

UE - Pointer to UE bit in USETD word - integer - input. 

UD - Pointer to UD bit in USETD word - integer - input. 

4.58.8.3 Subroutine Name: GKADIC 

1. Entry Point: GKADIC 

2. Purpose: To initialize GKADID. 

3. Calling Sequence: CALL GKADIC (GMD, G0D, SCRl ,SCR2,SCR3,SCR4, SCR5,SCR6, USETD) 
GK!D,G0D, USETD are GIN0 file numbers of their respective data blocks - integer - input. 
SCRl,... ,SCR6 are 6IN0 file numbers of six scratch files - integer - input. 

4.58.8.4 Subroutine Name: GKADID 

1. Entry Point: GKADID 

2. Purpose: To reduce "2PP" matrices to "2DD" matrices. 

3. Calling Sequence: CALL GKADID (K2PP,K2DD) 

K2PP - GIN0 file number of input matrix - integer - input. 
K2DD - GIN0 file number of reduced matrix - integer - input. 

4.58.9 Design Requirements 

Six scratch files are necessary. Open core for GKADIA and GKADIB is defined at /GKADAl/. 
Open core for GKADIC and GKADID is defined at /GKADCl/. 

4.58.10 Diagnostic Messages 
None 



4.58-7 



FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 

4.59 FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 

4.59.1 Entry Point : CEAD 

4.59.2 Purpose 

To solve the equation 

([M]p' + [B]p + [K]) {u} = {0} (1) 

for the eigenvalues p and the associated eigenvectors {u} where [M], [B] and [K] are mass, 
damping and stiffness matrices respectively. 

4.59.3 DHAP Calling Sequence 

CEAD KDD,BDD,MDD,EED,CASECC/PHID,CLAHA.0CEIGS/V,N,NF0UND $ 

4.59.4 Input Data Blocks 

KDD - Dynamic stiffness matrix - d set. 

BDD - Dynamic damping matrix - d set. 

HDD - Dynamic mass matrix - d set. 

EED - Eigenvalue Extraction Data. 

CASECC - Case Control Data Table. 
Notes : 

1. EED must be present. 

2. CASECC must be present. 

3. At least one of KDD, BDD and MDD must be present. 

4.59.5 Output Data Blocks 

PHID - Complex eigenvectors in the d set. 

CLAMA - Complex eigenvalue table. 

0CEIGS - Complex eigenvalue summary table. 

Note: No output data block can be purged. 

4.59-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.59.6 Parameters 

NF0UND - Output-integer-no default. NF0UND indicates the number of eigenvalues 
found. If none were found, NF0UND 1s set to -1. 

4.59.7 Method 

The Complex Eigenvalue Analysis Module calculates the eigenvalues and eigenvectors for 
a general system which may have complex terms 1n the mass, damping, and stiffness matrices. 
The eigenvectors are scaled according to the user-requested normalization scheme. Modal masses 
are not calculated since they will. In general, be complex, and their value Is rather dubious. 
The form of the problem solved by the Complex Eigenvalue Analysis Module is given In Equation 1. 

The eigenvalues p and the eigenvectors {u} are always treated as complex. These data 
are related to the u^ displacements If a direct formulation is used or are related to the 
u^ displacements if a modal formulation is used. The method to be used and the necessary data 
are selected by calling for one ID number in the EED data block. A set of EED data wmcn 
defines either the Determinant Method or the Inverse Power Method must be used. Subroutine 
CINVPR or CDETM is called to solve the eigenvalue problem (see subroutine descriptions below 
for method details). The eigenvalues and associated vectors are sorted by the magnitude of the 
imaginary part of the eigenvalue with all positives listed ahead of all negatives. (Subroutine 
CEADIA). 

4.59.8 Subroutines 

The subroutines used by CEAD can be divided into four groups: 1) those used by CEAD; 
2) those used for the Inverse Power Method; 3) those used by the Determinant Method; and, 4) 
general utility routines. The descriptions of the utility routines can be found In section 3. 

CEAD Inverse Power Determinant General 

CEADIA CINVPR CINFBS CDETM CDCiSMP 

ADD 
PREL0C 



Inverse 


Power 


Determinant 


CINVPR 


CINFBS 


CDETM 


CINVPl 


CMTIMU 


CDETM2 


CINVP2 


CXTRNY 


CSUMM 


CINVP3 


CSUB 


CSQRT 


CNfSRM 


0RTH0 


CDTFBS 


CNI3RM1 


CDIFBS 
CSQRTX 


CDETM3 



4.59-2 



FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 

4.59,8.1 Subroutine Name: CEADlA 

1. Entry Point: CEADlA 

2. Purpose: To sort the eigenvectors and eigenvalues. 

3. Calling Sequence: CALL CEADlA (LAMAI,PHII,LAMA0,PHI0,NF0UND) 
LAMAI - GIN0 file number of unsorted eigenvalues - integer - input. 
PHII - GIN0 file number of unsorted eigenvectors - integer - input. 
LAMA0 - GIN0 file number of data block CLAMA - integer - input. 
PHI0 - GIN0 file number of data block PHID - integer - output. 
NF0UND - Number of eigenvalues found - integer - input. 

4.59.8.2: Subroutine Name: CINVPR 

1. Entry Point: CINVPR 

2. Purpose: CINVPR is the main driver for the Complex Inverse Power Method of 
eigenvalue extraction. 

3. Calling Sequence: CALL CINVPR (EED.METH0D,NF0UND) 

C0MM0N /CINVPX/K(7),M{7),B(7),LAM(7),PHI{7).EIGSUM,SCRFIL(11).N0REG,EPS,REG(7,1O) 
C0MM0N /CINVX/Z{1) 

K.M.B - Input matrix control blocks for the stiffness, mass, and damping 
matrices [K], [M], and [B]. 

LAM, PHI - Matrix control blocks for the output eigenvalue and eigenvector files. 

EIGSUM - The output eigenvalue summary file. 

SCRFIL(ll) - Eleven scratch files available to Inverse Power. 

N0REG - Number of regions input to CINVPR. 

EPS - Convergence criterion. 

REG(7,10) - Storage space for up to 10 region parameters. 

Z(l) - Open core for CINVPR. 



4.59-3 



NWDULE FUNCTIONAL DESCRIPTIONS 

EED - GIN0 file number for this input data block. 

METH0D - ID of an EIGC card for the Inverse Power Method. 

NF0UND - Number of eigenvalues found. 

4. Method: Complex Inverse Power was, in general, designed identically to Real Inverse 

Power. The notable exceptions are in the iteration equation and the orthogonal ization 

with respect to previously extracted eigenvectors. With these points in mind, the 

basic flow can be taken from READ in section 4.48. Theoretical development is given in 
the Theoretical Manual. 

4.59.8.3 Subroutine Name: CINVPl 

1. Entry Point: CINVPl 

2. Purpose: To generate calling sequences to ADD to form 

[A] = [K] + X[B] + X^[M]. (2) 

3. Calling Sequence: CALL CINVPl 

C0MM13N /CINVPX/ K(7) ,M(7),B(7) ,DUM(15) ,A 
C|iJMM0N /CINV1X/Z(1) 
C0MM1!IN /CINVXX/ LAMBDA 

K,M,B - Matrix control blocks for the input matrices. 

A - GIN{I file number for the output matrix. 

Z(l) - Area of open core available to ADD. 

LAMBDA - Complex double precision scalar multiplier. 

4.59.8.4 Subroutine Name: CINVP2 

1. Entry Point: CINVP2 

2. Purpose: To initialize and call CDC0MP for subroutine CINVPR. 



4.59-4 



FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 

3. Calling Sequence: CALL CINVP2 

C0MM0N /CINVPX/ DUM{36),A,XX,L,U,SCR1,SCR2,SCR3,LL,UU 
C0Mr'10N /CINVXX/DUMM(4) .SWITCH 
C0MM0N /CINV2X/Z(1) 

A - GIN0 file number for the input matrix. 

L,U - GIN0 file number for the lower and upper triangular factors output 

from CDC0MP. 

SCR1,SCR2,SCR3 - Three scratch files used by CDC0MP. 

LL.UU - 6IN0 file numbers for alternate storage of L and U. 

!0, store factors on L and U. 
1, store factors on LL and UU. 

Z(l) - Area of open core used by CDC0MP. 



4.59-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.59.8.5 Subroutine Name: CINVP3 

1. Entry Point: CINVP3 

2. Purpose: To solve for a complex eigenvalue and eigenvector using the Inverse 
Power Method. 

3. Calling Sequence: CALL CINVP3 

C0MM0N /CINVPX/K(7),M(7),B(7),L/>I(7),PHI(7).XXX,SCRFIL(11) 
CiJMMiJN /CINV3X/Z(1) 

See section 4.59.8.2 above for details on /CINVPX/. 
Z(l) - Area of open core available in CINVP3. 

4. Method: The logic flow and the mathematical equations are essentially identical 
to INVP3, with the following exceptions. The eigenvalues and eigenvectors are found 
corresponding to the matrix equation 

(X^CM] + X[B] + [K]) [4] = [0] (3) 

where the iteration equation is given by 

(A^[M] + X^[B] + [K]) {W^} = -([B] + X^[M]) {u^,^} -CM] {v^_^} (4) 

with 

(%} - ^ {W^} . (5) 



^%> = V"n>^ 37 Vl> • (6) 



{u^} = {u^} - 2 a^{*^}. (7) 

{v^} =. {\} - I a. X.{$.}. (8) 

and 



i^^}"^ [X^[M]{u^} + [M] {7^} + [B] {u^}j 
^ ii^}^ (2X^ [M] + [B]) {*^} 



(9) 



4.59-6 



FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 

where 

*^ = Previously extracted right-hand vector, 

#^ = Previously extracted left-hand vector, 

C^ = Largest element (in magnitude) of {W } , and 

X^ = Previously extracted eigenvalue. 

The above equations replace Equations 19 through 22 in section 4.48. The calculation of the 
remaining equations remains the same except for the use of complex arithmetic. The left 
eigenvector is obtained by decomposing Equation 3 with X^^ - X. and using CDIFBS to make the 
appropriate substitution using the factors from CDC0MP. 

5. Design Requirements: CINVPS requires fourteen complex double precision vectors in 
core plus four GIN0 buffers. 

4.59.8.6 Subroutine Name: CN0RM 

1. Entry Point: CN0RM 

2. Purpose: To normalize successive iterated vectors such that the maximum element is 
equal to unity, and to return the normalizing divisor. 

3. Calling Sequence: CALL CN0RM (X.DIV) 

X - Input vector to be normalized. 

DIV - Divisor which was used to normalize the vector corresponding to the 
argument X. 

4.59.8.7 Subroutine Name: CN0RM1 

1. Entry Point: CN0RM1 

2. Purpose: To normalize a complex vector such that the largest magnitude of an element is 
equal to one. 

3. Calling Sequence: CALL CN0RM (X.N) 
X - Vector to be normalized. 

N - Length of the vector (complex terms). 



4.59-7 



MODULE FUNCTIONAL DESCRIPTIONS 

4.59.8.8 Subroutine Name: CINFBS 

1. Entry Point: CINFBS 

2. Purpose: To perform the forward-backward substitution necessary to solve an 
iteration of the Inverse Power Method. 

3. Calling Sequence: CALL CINFBS (X.Y.BUF) 
C0MM(»N /CINFBX/L(7),U(7) 

L.U - Matrix control blocks for the factors output from CDC0MP. 
X - Complex double precision input vector. 
Y - Complex double precision solution vector. 
BUF - GIN(3 buffer. 

4. Method: CINFBS is a stripped down version of GFBS. Both vectors reside in core, 
and only complex double precision arithmetic is used. 

4.59.8.9 Subroutine Name: CDIFBS 

1. Entry Point: CDIFBS 

2. Purpose: To perform the forward-backward substitution necessary to solve for the 
left eigenvector. 

3. Calling Sequence: CALL CDIFBS (X.BUF) 
CUMMIN /CINVPX/DUM(41) ,UPRTRI,XXX,L|SWTRI 

UPRTRI,L!8WTRI - Files containing the upper and lower triangular factors output from COC0MP. 

X - The output complex double precision left eigenvector, 
BUF- GIN0 buffer used by CDIFBS. 

4. Method: CDIFBS actually solves the system of equations 

[A]"^ {X} - {y}. (10) 

where [A] has been decomposed into [A] = [L] [U]. To solve the transpose problem we have 
that 



4.59-8 



FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 

[A]^ = ([L] [U])^ = [U]"^ [Lf (11) 



SO that 



[uf [L]"^ {X} = {y}. (12) 

CDIFBS 1s a modified form of GFBS which does the forward pass on [U] and the backward 
pass on [L]. All arithmetic operations are complex double precision. 

4.59.8.10 Subroutine Name: CMTIMU 

1. Entry Point: CMTIMU 

2. Purpose: To pre-multiply a vector {y} by a matrix to obtain a vector {x}. 

3. Calling Sequence: CALL CMTIMU (Y.X.FILE.BUF) 

C0MM0N /CINVPX/DUM(7),M(7) 

FILE - If FILE = 0, form {x} = [M]{y}. 

FILE ^ 0, form {x} = [AJ {y}, where [A] is the matrix on FILE. 

X,Y - Complex double precision vectors. 

BUF - GIN0 buffer. 

4.59.8.11 Subroutine Name: CXTRNY 

1. Entry Point: CXTRNY 

2. Purpose: To form the inner product of two complex vectors, {x} and {y} 

a - {x}""" {y}. (13) 

where {y} denotes a vector all of whose components are the complex conjugates of {yl. 

3. Calling Sequence: CALL CXTRNY (X.Y.A) 
C0MM0N /CINVPX/XX.N 

N - Length of the vectors. 

X,Y - Complex double precision vectors. 

A - Complex double precision value of the inner product of {x} and {y}. 

4.59-9 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

4,59.8.12 Subroutine Name: CSUB 

1. Entry Point: CSUB 

2. Purpose: To evaluate the vector equation 

{z} = a{x} - b{y}, (14) 

where {x}, {y}, a and b may be complex. 

3. Calling Sequence: CALL CSUB (X.Y.Z.A.B) 
CjSMMUN /CINVPX/XXX.N 

N - Length of the vectors {x} and {y}. 

X.Y.Z - Complex double precision vectors. 

A,B - Complex double precision scalar multipliers. 

4.59.8.13 Subroutine Name: 0RTH0 

1. Entry Point: 0RTH0 

2. Purpose: To orthogonalize a vector with respect to all previously extracted vectors. 

3. Calling Sequence: CALL 0RTH0 (U,V,X1 ,X2,X3,X4,X5.NZ,BUF1 ,BUF2.BUF3,BUF4) 
C0MM0N /CINVPX/K(7),M(7),B(7).LAMBDA(7).PHI(7),XXX,SCRFIL{10) 

C0MM0N /CINVXX/DUM{19),NR00TS 

See section 4.59.8.2 for /CINVPX/ details. 

NR00TS - Number of eigenvectors already extracted. 

U,V - Input-current vectors - Output - orthogonal 1 zed vectors. 

X1,...,X5- Storage space for five complex double precision vectors. 

NZ - The number of words of core available to 0RTH0. 

^^^^' \ - Four GIN0 buffers. 
BUF4 ' 

4. Method: 0RTH0 solves the equations 

{u^} = {u^} - L a^ X^ {i^], (15) 

4.59-10 



where 



FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 



{v^} = {v^} -I a^X^ {$.}, (16) 



{*l}'^[^l[M] {u^} + [M] {v^} + [B] {u^}] 

a. = ;;;— = (17) 

{*^r[2 X^[M] + [B]] {$^} 



and 



{$^} = Previously found left eigenvectors. 
{$^} = Previously found right eigenvectors. 
X^ = Previously found eigenvalues. 



4.59-11 



MODULE FUNCTIONAL DESCRIPTIONS 

4.59.8.14 Subroutine Name: CDETM 

1. Entry Point: CDETM 

2. Purpose: To solve the complex eigenvalue problem by the Determinant Method. 

3. Calling Sequence: CALL CDETM (METH0D,EED,M,B,K,LAMA,PHID,0CEIGS,NF0UND,SCR1 ,SCR2. 

SCR3,SCR4,SCR5,SCR6,SCR7,SCR8) 

METH0D - ID of an EIGC card for the Determinant Method - integer - input. 

EED,0CEIGS, r _ ^jj^^ ^^^^ numbers of their respective data blocks - integer - input. 
M.B.K ) 

LAMA - GIN0 file number of temporary eigenvalue storage file - integer - input. 

PHID - GIN0 file number of temporary eigenvector storage file - integer - input. 

NF0UND - Number of eigenvalues found - integer - output. 



SCR1,SCR2, 
...,SCR8 



- GIN0 file numbers of 8 scratch files - integer - input. 



4. Method: The overall flow and theoretical considerations of the Determinant Method 
are explained in section 4.88. Two refinements are made in CDETM. The first is the 
handling of multiple search regions, which allows the user to control the distribution of 
starting points in the complex plane. See the EIGC bulk data card description in section 

2 of the User's Manual for further details. The second is the use of the EIGP card tc define 
poles which will be swept from the determinant as if they were previously accepted 
eigenvalues. This allows the user to prevent convergence to known or already extracted 
eigenvalues. 

5. Design Requirements: CDETM requires two complex double precision d set vectors plus 
one GIN0 buffer in core. 

4.59.8.15 Subroutine Name: CDETM2 

1. Entry Point: CDETM2 

2. Purpose: To arrange 3 starting points in order of the magnitude of the determinant. 

3. Calling Sequence: CALL CDETM2(P,D,IP,PR,PI .DR.DI.IPS) 

P - Three starting point values - input-complex double precision. 

4.59-12 



FUNCTIONAL MODULE CEAD (COMPLEX EIGENVALUE ANALYSIS - DISPLACEMENT) 

D - Scaled determinants at P - input-complex double precision. 
IP - Scale factors for D - input - integer. 

PR - Real parts of the reordered starting points - output-double precision. 

PI - Imaginary parts of the reordered starting points - output-double precision. 

DR - Real parts of the reordered determinants - output-double precision. 

DI - In-aginary parts of the reordered determinants - output-double precision. 

IPS - Scale factors of the reordered determinants - output - integer. 

4.59.8.16 Subroutine Name: CSUMM 

1. Entry Point: CSUMM 

2. Purpose: To add two scaled complex numbers together. 

3. Calling Sequence: CALL CSUMM (Dl ,D2,ID1 ,D3,D4,ID2,D5,D6,ID3) 
The arguments are defined in the following equation: 

(D1.D2) X 10^°^ + (03. D4) x 10^°^ ^ ^^^^^^^ ^ ^^m ^ 
where all Di's are double precision. 
4.59.8.17 Subroutine Name: CSQRT 

1. Entry Point: CSQRT 

2. Purpose: To compute the positive principal square root of a scaled complex number. 

3. Calling Sequence: CALL CSQRT (Dl ,D2,ID1 ,D3,D4,ID2) 
The arguments are defined in the following equation: 



(18) 



(D3.D4) X 10^°2 __ y(DT,o2)Ti^1 (19) 

where all Di's are double precision. 



4.59-13 



MODULE FUNCTIONAL DESCRIPTIONS 

4,59.8.18 Subroutine Name: CDTFBS 

1. Entry Point: CDTFBS 

2. Purpose: To solve for the eigenvector given the decomposed incedance matrix. 

3. Calling Sequence: CALL CDTFBS (F.EV,BUFFER(1) .FU,NR0W) 

F - Applied complex load vector - input-complex double precision. 

Ev - Eigenvector - output- complex double precision. 

BUFFER(l) - GIN0 buffer. 

FU - Matrix control block for [U] - integer - input. 

NR0W - Order of problem - integer - input. 

4.59.8.19 Subroutine Name: CDETM3 

1. Entry Point: CDETM3 

2. Purpose: To rescale a scaled complex number. 

3. Calling Sequence: CALL CDETM3(D1 ,D2,ID1 ) 

Let Dl, D2, ID! be the input values of Dl , D2, IDl. On return from CDETM3 

(D1,D2) x 10^"^^ = (DT.DI) X 10^^ . (20) 

and 

1.0 < |(D1,D2)| < 10.0 , (21) 

where all Di's are double precision. 
4.59.9 Design Requirements 

Open core is defined at /CEADIX/ to process EED. Open core is defined at /CEADAl/ for 
use by CEADIA. 



4.59-14 



FUNCTIONAL MODULE VDR (VECTOR DATA RECOVERY) 

4.60 FUNCTIONAL MODULE VDR (VECTOR DATA RECOVERY) 

4.60.1 Entry Point : VDR 

4.60.2 Purpose 

VDR formats data blocks for input to the Output File Processor (0FP) and XY plot 
(XYPL0T) modules to provide a capability for output of vectors in the solution set. 

4.60.3 DMAP Calling Sequence 

VDR CASECC,EQDYN,USETD,UDV,PP,XYCDB,PNL/0UDV1 ,0PNL1/ 

pRANRESP) (direct) 

C.N, < FREQRESP > /C.N, J^Jq^L [ /V.N,S0RT2/V,N,0UTPUT/V,N.SDR2/V.N,FM0DE $ 

4.60.4 Input Data Blocks 

CASECC - Case Control Data Table. 

EQDYN - Equivalence between external and internal number - Dynamics. 

USETD - Displacement set definitions table - Dynamics. 

UDV - Partition of Displacement Vector. 

PP - Dynamic Load Vector. 

XYCDB - XY Control Data Block. 

PNL - Non-Linear Load Vector. 

Notes : 

1. CASECC, EQDYN and USETD may not be purged. 

2. PP may be purged only if UDV is purged. 

3. PNL and XYCDB may be purged, 

4.60.5 Output Data Blocks 

0UDV1 - Output Displacement Requests - Solution set. 
0PNL1 - Output Non-Linear Load Requests - Solution set. 



4.60-1 



MODULE FUNCTIONAL DESCRIPTIONS 

Note : Output data blocks may be purged. 

4.60.6 Parameters 

The first parameter indicates a Rigid Format and must be one of the three names shown 
above. The second parameter indicates a direct or modal formulation and must be one of the 
two names shown above. 

S0RT2 - Output-integer-no default. +1 if any S0RT2 output is requested, -1 otherwise. 
0UTPUT - Output- integer-no default. +1 if any output in the solution set is requested, 

-1 otherwise. 
SDR2 - Output-integer-no default. +1 if any requests for output in the physical set 

are found in CASECC or XYCDB, -1 otherwise. 
FMjJDE - Input-integer-no default. If a modal formulation, FM0DE = mode number of the 
first mode. FM0DE is not used in a direct formulation. 

4.60.7 Method 

4.60.7.1 General 

VDR is the main control program for the module. VDRA is called to analyze the Case 
Control (CASECC) and XYCDB data blocks. If any requests for solution set output are found, 
VDRB is called to assemble the 0UDV1 output data block for processing by the 0FP. If the 
problem is a transient response problem, VDRB is called a second time to process any requests 
for non-linear load output. 

4.60.7.2 Analysis of the Case Control and XYCDB Data Blocks 

VDRA attempts to open the XYCDB data block. If it is purged, a return is given to VDR. 
Otherwise, the header record and first data record of XYCDB are skipped, and data applying to 
all subcases are read from the second data record. If no such data exist, a dummy master 
is created. Otherwise, the master data are reduced to a list of unique pairs. If only master 
data exist, flags are set appropriately. 

For each record in the Case Control data block the following processing occurs: 



4.60-2 



FUNCTIONAL MODULE VDR (VECTOR DATA RECOVERY) 

1. The record is read into core. If no XYCDB subcase corresponds to the Case Control 
subcase, pointers are set to the master data. Otherwise, the master data and appropriate 
XYCDB subcase data are merged and reduced to unique pairs. 

2. For each request for solution set output in XYCDB, the corresponding request in Case 
Control is examined. If no request is present in Case Control, the XYCDB request is 
reduced to a set in Case Control format, and a request for the set is turned on in Case 
Control. If the Case Control set is "ALL", no further action is taken. If the Case 
Control request is a set, the set is merged with the XYCDB set, and the request 
altered to reflect the new set (unless all points in the XYCDB set were already in the 
Case Control set). A flag is set if any new requests are formed. 

3. When all requests for the current Case Control record have been analyzed, the 
record (as modified) is written on a scratch file. 

4. When all Case Control records have been read, the GIN0 file name for the Case Control 
data block is switched to the scratch file (unless no modifications were made to Case 
Control ) . 

4.60.7.3 Preparation of Solution Set Output 

The operations of VDRB are dependent on the Rigid Format being executed. VDRB operates 
in all six of the dynamics Rigid Formats. The initial operations in VDRB proceed as follows: 

1. For a direct solution, or a modal solution with extra points, the second record of EQDYN 
is read into core. USETD is read into core. 

2. If the problem is a direct solution, each entry in EQDYN is processed. The scalar 
index value (the 2nd word of each entry) is replaced by the scalar index value in the 
solution set plus a code indicating which components of the point are in the solution 
set. 

3. If the problem is a modal solution with extra points, the scalar index of each extra 
point in EQDYN is replaced with a scalar index in the solution set. The scalar indices of 
all other points are replaced with zero. 

4. If the problem is a complex eigenvalue problem, a list of mode numbers and complex 
eigenvalues is read into core from the CLAMA data block. 



4.60-3 



MODULE FUNCTIONAL DESCRIPTIONS 

5. If the problem is a transient response problem, a list of times is read into core 
from the PP data block. 

6. If the problem is a frequency response problem, a list of frequencies is read into 
core from the PP data block. 

7. The header record on the input file is skipped, and various parameters are 
initialized for the overall processing, 

A record on the Case Control data block is read. The output request is examined. If 
the output is defined in terms of a set. pointers to the set definition are computed. The 
vector is unpacked in core (unless the vector is already in core in the case of velocities and 
accelerations for frequency problems). 

Information is assembled to write the identification record on the output data block 
as follows. 

1. For complex eigenvalues, the mode number and eigenvalue are picked up from the list 
in core. 

2. For frequency response, the frequency is picked up from the list in core. A 
comparison with the 0FREQ selection in Case Control is made. If thp current freouency 
is not marked for output, the remainder of the calculations for the current vector are 
skipped, 

3. For a transient problem, the time is picked up. 

The identification record is written. Entries are written in the data record according to 
the request. The modified EQDYN table in core is used to pick up points in the vector to be 
output. Conversion to magnitude and phase is made if requested. 

When all points in the current request have been processed, post processing occurs 
depending on the problem type as follows: 

1. For complex eigenvalues, a pointer is updated to the next mode number and eigenvalue. 

If all eigenvectors have not been processed, the steps above are repeated. Otherwise, 

terminal processing is initiated. 



4.60-4 



(2) 



n 



FUNCTIONAL MODULE VDR (VECTOR DATA RECOVERY) 

-i 

2. For frequency response, if the vector just processed was a displacement vector. 

the corresponding velocity vector is determined by differentiating with respect to time. 

iv) = iw {u}. 

Similarly, if the vector just processed was a velocity vector, the corresponding 
acceleration vector Is formed by differentiating with respect to time: 

{a} = iw {v}. 

If all vectors have not been processed, the steps above are repeated. Otherwise, 
terminal processing is initiated. 

3. For transient response, pointers are updated so that the vectors will be processed i 
the order a) displacement, b) velocity, and c) acceleration. If all vectors have not been 
processed, the steps above are repeated. Otherwise, terminal processing is initiated. 

The terminal processing consists of closing all files, writing a trailer on the 
output file and exiting. 

4.60.8 Subroutines 

4.60.8.1 Subroutine Name: VDR 

1. Entry Point: VDR 

2. Purpose: Main control program for the module. 

3. Calling Sequence: CALL VDR 

4.60.8.2 Subroutine Name: VDRA 

1. Entry Point: VDRA 

2. Purpose: To analyze the output requests in the Case Control and XYCDB data blocks. 

3. Calling Sequence: CALL VDRA 



(1) 



4.60-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.60.8.3 Subroutine Name: VDRB 

1. Entry Point: VDRB 

2. Purpose: To process requests for solution set output and assemble the output 
data block. 

3. Calling Sequence: CALL VDRB {INFIL,0UTFL.IREq) 

IKFIL - GIN0 file name of the data block containing vectors to be output in the 

solution set. 
0UTFL - GINiS file name of the data block where solution set output will be written. 
IREQ - Word position in the Case Control record where solution set output request is 

defined. 

4.60.9 Design Requirements 



4.60.9.1 Allocation of Core Storage 

The maximum storage requirements for the module are in VDRB. A general picture of core 



2 words per entry, one entry for each 
point in the problem. 



storage is as follows: 


C(3MM0N/VDRC(3R/Z(1) 


1 


EQDYN Table 


ILIST 


List of eigenvalues, 
frequencies or times 


ICC+1 


Case Control record 


IVEC 


Unpacked Vector 


BUF3 


Buffer for input file 


BUF2 


Buffer for output file 


BUFl 


Buffer for Case 
Control 



1, 2 or 3 words per entry, one entry for 
each eigenvalue, frequency or time. 



One word for each degree of freedom in the 
solution set. (two words if complex). 



4.60-6 



FUNCTIONAL MODULE VDR (VECTOR DATA RECOVERY) 

4.60.9.2 Environment 

The Block Data program VDRBD initializes /VDRC0M/ with GIN0 file names, data defining 
position of parameters in a Case Control record, data definirg rigid formats and problem 
types, and miscellaneous data. It must be in core when VDR is executed. 

The module VDR is designed to be executed as one overlay segment. Open core is defined 
by /VDRC0R/. Two scratch files are used. 



4.60-7 



FUNCTIONAL MODULE FRRD (FREQUENCY RESPONSE - DISPLACEMENT APPROACH) 



4.61 FUNCTIONAL MODULE FRRD (FREQUENCY RESPONSE - DISPLACEMENT APPROACH) 

4.61.1 Entry Point : FRRD 

4.61.2 Purpose 

To solve the matrix equation 

[-01^ [M] + 1u [B] + [K]] [X] = [P(a).)] (1) 

at a given set of frequencies m. and loads P (which may be functions of u.). 

4.61.3 DMAP Calling Sequence 

FRRD CASECC,USETD,DLT,FRL,6MD.G0D,KHH.BHH,MHH,PHIDH,DIT/UHV,PS,PD,PP/V.N,APP/V,N,F0RM/ 
V,N,LUSETD/V,N,MPCF1/V,N,SINGLE/V,N.0MIT/V,N,N0NCUP/V.N,FRQSET $ 

4.61.4 Input Data Blocks 

CASECC - Case Control Data table. 

USETD - Displacement set definitions table dynamics. 

DLT - Dynamic Loads Table. 

FRL - Frequency Response List. 

SMD - Multipoint constraint transformation matrix - dynamics. 

G0D - Omitted coordinate transformation matrix - dynamics. 

KHH - Modal stiffness matrix - h set. 

BHH - Modal damping matrix - h set. 

MHH - Modal mass matrix - h set. 

PHIDH - Transformation matrix from d set to modal coordinates. 

DIT - Direct Input Tables. 

Notes: 1. CASECC cannot be purged. 
USETD cannot be purged. 
DLT cannot be purged. 
FRL cannot be purged. 
GMD cannot be purged 1f MPCFl >^ 0. 
60D cannot be purged if 0MIT >^ 0. 



1. 
2. 
3. 

4. 
5. 
6. 



4.61-1 



MODULE FUNCTIONAL DESCRIPTIONS 

7. PHIDH cannot be purged if F0RM = M0DAL. 

8. DIT cannot be purged if a load uses tables. 

4.61.5 Output Data Blocks 

UHV - Displacement vectors. 

PS - Partition of load vector matrix giving loads in s set. 

PD - Load vectors - d set. 

PP - Load vectors - p set. 

Notes: 1. UHV, PD, and PP cannot be purged. 
2. PS cannot be purged if SINGLE > 0. 

4.61.5 Parameters 

APP ~ Input-BCD-no default. APP should be set equal to DISP. 

F0RM - Input-BCD-no default. F0RM = M0DAL implies a modal solution should be used. 

LUSETD - Input-integer-no default. LUSETD indicates length of p set. 

MPCFl - Input-integer-no default. MPCFl >_ implies multipoint constraints present. 

SINGLE - Input-integer-no default. SINGLE >_ implies single-point constraints present. 

0MIT - Input-integer-no default. 0MIT >_0 implies omitted coordinates present. 

N0NCUP - Input-integer-no default. N0NCUP= -1 implies noncoupled solution if 

F0RM = M0DAL. 
FRQSET - Output-integer-no default. FRQSET is the set id of the selected frequency 

list from CASECC. 

4.61.7 Method 

4.61.7.1 Overview of the Method 

The Frequency Response module for the displacement approach assembles a frequency-dependent 
load vector end solves for the steady-state, frequency response, displacement vectors. Various 
load sets are defined as functions of frequency. Combinations of these sets are used with the 
various specified frequencies. Load vectors for each frequency are formed and reduced to loads 
on the proper degree of freedom. The solutions for both direct formulation and coupled modal 
formulation are identical except that different matrices are used. The solution involves a 



4.61-2 



FUNCTIONAL MODULE FRRD (FREQUENCY RESPONSE - DISPLACEMENT APPROACH) 

triangular decomposition and back substitution using an unsymmetric, complex matrix and complex 
load vectors for each frequency. The solutions for the uncoupled modal formulation are analytic 
equations. 

4.61.7.2 Logical Phases 

1. The load vectors for each desired frequency are assembled from the DLT data block. 
The DL0AD section of the DLT tells which load sets to use and what scale factors to use 
in combining the load sets. The data for each load set are given in the RL0AD section 
of the DLT. This work is done in subroutine FRRDIA. 

2. The total load vectors are partitioned and manipulated to produce load vectors 
on the solution coordinates. This work is done in subroutine FRRDIB. 

3. The matrix equation for displacements is now solved for each load combination 
and each frequency. The overall dynamic matrix is formed. The matrix is decomposed, 
and the displacements are formed by back substitution using the various loads. If the 
formulation is an uncoupled modal system, the displacements are calculated directly. 
This work is done by subroutines FRRDIC and FRRDID or FRROIF. 

4. The solution vectors are then resorted into load-frequency order. This work is 
done by subroutine FRRDIE. 

4.61.7.3 Algorithms 

1. Assembly of Load Vectors: 

The frequency set id is extracted from CASECC. This frequency set is placed in 
core from the FRL and converted from radians to frequency. These frequencies are output 
into the header of PR for later output identification. The load id is read from CASECC, 
found in DLT, and a table is constructed giving a simple id and a scale factor for each 
component. The DLT data are read for each simple id, and a list of the required tables is 
extracted. Core is allocated to hold as many load vectors as possible up to the number of 
frequencies. If tables are present, they are initialized and evaluated for all frequencies 
in core. The DLT is read, and two types of loads are constructed: 
1 ) RL0AD1 



P(f) = A [C (f) + iD(f)] e i(9-2^^^), (2) 



4.61-3 



MODULE FUNCTIONAL DESCRIPTIONS 

where A, B, C, D, 0,t and <{) are user input constants or tables. 

If all frequencies cannot be evaluated at once, additional passes through the DLT are made 
until all are evaluated. If additional subcases exist in CASECC, the above steps are 
repeated for each load, 

2. Manipulation of Load Vectors: 

The vectors produced in the previous sections are related to the p set. They are 
reduced by the following steps using data blocks USETD, GMD and G0D. 



If MPCFl > 0: 






If SINGLE > Q: 



'V>=>{4ff 



{P } is output on data block PS. 



If 0MIT > 0: 



{Pj} is output on PD. 
If F0RM = M0DAL: 



(6) 



{Pj} = {Pj} + [gJ]T {P^}, (8) 



(P,) = [^dh^'^V- (9) 



3. Solution Phase: 

For a direct formulation the equation to be solved is: 

i-^^ [Mj^] + io; [B^j] + [K^j]] {Uj} = {P^(o.)} . (10) 



4.61-4 



FUNCTIONAL MODULE FRRD (FREQUENCY RESPONSE - DISPLACEMENT APPROACH) 
For a coupled modal formulation the equation to be solved is: 

l-^ i\^2 ^ i-iB^^l ^ LK^^ll {Uf,} = {P^(co)}. (11) 

The left hand matrix is generated by two calls to ADD and decomposed. The normal matrix 
decomposition checks are relaxed in these solutions. It is expected that the matrices 
will not pass the triangular decomposition at certain frequencies. The solution will 
proceed, and only a warning will be issued. The loads at the given frequency are collected 
from the load file and fed to GFBS for a forward backward substitution solution. If the 
decomposition failed, a zero vector will result. 

For one uncoupled modal formulation the equations to be solved are: 

- ( ^ ^-^ ) 

^■^ " ( -m,.^ . ib.. . k^. ^j • ^''^ 

With zero damping the uncoupled modal formulation may produce division by small 
numbers. This fact is noted and the solution proceeds. 
4. Order Phase: 

Except for the uncoupled modal approach it may be necessary to reorder the solutions 
from a frequency / load sort to a load / frequency sort. 

4.61.8 Subroutines 

Utility subroutines PRETAB.TAB.CALCV.SSG2B.SSG2A.SS62C,CDC0MP. and GFBS are used. See 
subroutine descriptions, section 3 for details. 

4.61.8.1 Subroutine Name: FRRDIA 

1. Entry Point: FRRDIA 

2. Purpose: To assemble the user selected loads. 

3. Calling Sequence: CALL FRRDIA (DLT.FRL.CASECC,DIT.PP.LUSETD,NFREQ,NL0AD,FRQSET) 
DLT.FRL,CASECC.DIT,PP are GIN0 file numbers of their respective data blocks - integer - 
input. 

LUSETD - Length of p set - integer - input. 

NFREQ - Number of frequencies in selected frequency set - integer - output. 



4.61-5 



[■lODULE FUNCTIONAL DESCRIPTIONS 

NL0AD - Number of loads (records in CASECC) selected - integer - output. 
FRQSET - Set id of selected frequency set - integer - output. 

4.61.8.2 Subroutine Name: FRRDlB 

1. Entry Point: FRRDlB 

2. Purpose: To reduce loads from the p to the d (or h) set. 

3. Calling Sequence: CALL FRRDlB (PP,USETD.GMD.G0D.MULTI,SIKGLE.0HIT,M0DAL.PHIDH. 

PD,PS,PH,SCR1,SCR2.SCR3,SCR4) 
PP,USETD,GMD,Gj3D,PHIDH,PD,PS,PH are GIN0 file numbers of their respective data 
blocks - integer - input. 

MULTI - MULTI >_ implies m's are present - integer - input. 
SINGLE - SINGLE > implies s's are present - integer - input. 
0MIT - 0MIT > implies o's are present - integer - input. 
M0DAL - M0DAL = M0DA implies a modal formulation - BCD - input. 

SCR1,...,_ Qjf^jj f^^g numbers of 4 scratch files - integer - input. 
SCR4 

4.61.8.3 Subroutine Name: FRRDIC 

1. Entry Point: FRRDIC 

2. Purpose: To form and decompose "left" hand side of the frequency equation. 

3. Calling Sequence: CALL FRRDIC (FRL.FRQSET.MDD.BDD.KDD.I.ULL.LLL.SCRl .SCR2.SCR3, 

SCR4,IG!30D) 
FRL,MDD,BDD,KDD,ULL,LLL,SCRl-4 are GIN0 file numbers of their respective data blocks 

integer - input. 

FRQSEl - Set id of selected frequency set - integer - output. 

I - Current frequency counter - integer - input. 

IG00D - IG00D = 1 implies a singular matrix - integer - output. 

4,61,8.4 Subroutine Name: FRRDID 

1. Entry Point: FRRDIO 

2, Purpose: To solve for displacements given decomposition factors and loads. 

4.61-6 



FUNCTIONAL MODULE FRRD (FREQUENCY RESPONSE - DISPLACEMENT APPROACH) 

3. Calling Sequence: CALL FRRDID (PD.ULL.LLL.SCRl ,SCR2.UDVP,I,NL0AD.IG00D,NFREQ) 

PD,ULL,LLL.UDVP,SCR1,SCR2 are GIN0 file numbers of their respective data blocks - 

integer - input. 

I - Current frequency count - integer - input. 

NL0AD - Number of loads - integer - input. 

IG00D - IG00D = 1 implies a singular matrix - integer - input. 

NFREQ - Total number of frequencies - integer - input. 

4.61.8.5 Subroutine Name: FRRDIE 

1. Entry Point: FRRDIE 

2. Purpose: To reorder displacements if necessary. 

3. Calling Sequence: CALL FRRDIE (UDVP,UDV,NL0AD,I) 

UDVP - GIN0 file number of displacements sorted by frequency/ load - integer - input. 

UDV - GIN0 file number of displacements sorted by load/frequency - integer - input. 

NL0AD - Number of loads - integer - Input. 

I - Number of frequencies solved. 

4.61.8.6 Subroutine Name: FRRDIF 

1. Entry Point: FRRDIF 

2. Purpose: To solve the uncoupled modal equations. 

3. Calling Sequence: CALL FRRDIF (MHH,BHH,KHH,FRL.FRQSET,NL0AD, NFREQ. PH.UHV) 
MHH,BHH,KHH,FRL,PH,UHV are GIN0 file numbers of their respective data blocks. - 
integer - input. 

FRQSET - Selected frequency set id-integer - input. 

MFRLQ - Number of frequencies in FRQSET - integer - input. 

NL0AD - Number of loads (Subcases in current execution) - integer - input. 

4.61.9 Design Requirements 

Eight scratch files are used by FRRD. 
Open core at /FRRDAl/ is used as follows: 



4.61-7 



MODULE FUNCTIONAL DESCRIPTIONS 



C0MM0N/FRRDA1/ 



Frequency List 



ID^ 

Scale-. 
ID2 
Scale^ 



Table ID's 



F (f) 



Buffer 



NFREQ 



ID, scale for all members of a DL0AD card 

I NTABL \ 

\ 2* LUSETD ) As many loads as will fit 

I 2* LUSETD I up to all frequencies. 



NTABL 



J 



Open core at /FRRDBl/, /FRRDCl/, /FRRDDl/ are used by the matrix routines. 
Open core at/FRRDFl/ is used as follows: 



C0MM0N/FRRDF1/ 



Frequency List 



UHV 



PH 



NFREQ 

h set size 
h set size 

h set size 



2 GIN0 Buffers 



4.61.10 Diagnostic Messages 

Module FRRD may issue the following diagnostic messages: 

3005, 3008 and 3045. 



4.61-8 



FUNCTIONAL MODULE SDR3 (STRESS DATA RECOVERY - PHASE 3 - S0RT1 TO S0RT2 PROCESSOR) 

4.62 FUNCTIONAL MODULE SDR3 (STRESS DATA RECOVERY - PHASE 3 - S|3RT1 to S0RT2 PROCESSOR) 

4.62.1 Entry Point : SDR3 

4.62.2 Purpose 

To transpose (perform S0RT2) data blocks containing data prepared for output in the form of 
ELEMENT-ID-SETS or P0INT-ID-SETS versus TIME-STEP or FREQUENCY-STEP to data prepared for output 
in the form of TIME-STEP-SETS or FREQUENCY-STEP-SETS versus ELEMENT-ID or P(2INT-ID. 

4.62.2.1 Example of S0RT1 and S0RT2 Output 

Below is a table of (2FP printed output of SDR3 input (S0RT1) and output (S0RT2) data blocks. 
SDR3 Input Data Block Printed (S0RT1) 



TIME ■ 


= 1.0 








D I S 


P 


L A 


C 


E 


MEN 


T 


S 






POINT- 


-ID 




Tl 




T2 




T3 






Rl 






R2 


R3 


1 
2 






0.0 
0.0 




4.53 
5.12 




0.0 
0.0 






0.0 
0.0 






0.0 
0.0 


0.0 
0.0 


TIME = 


= 2.0 








D I S 


P 


L A 


C 


E 


MEN 


T 


S 






POINT- 


-ID 




Tl 




T2 




T3 






Rl 






R2 


R3 


1 
2 






0.0 
0.0 




4.83 
5.53 




0.0 
0.0 






0.0 
0.0 






0.0 
0.0 


0.0 
0.0 


TIME = 


= 3.0 








D I S 


P 


L A 


C 


E 


MEN 


T 


S 






POINT- 


-ID 




Tl 




T2 




T3 






Rl 






R2 


R3 


1 
2 






0.0 
0.0 




6.84 
7.96 




0.0 
0.0 






0.0 
0.0 






0.0 
0.0 


0,0 
0.0 


SDR3 Output Data 


Bl 


ock Prii 


nted 


(S0RT2) 





















0.0 


4,53 


0.0 


0.0 


0.0 


0.0 


0.0 


4.83 


0.0 


0.0 


0.0 


0.0 


0.0 


6.84 


0.0 


0.0 


0.0 


0.0 



POINT-ID =1 DISPLACEMENTS 

TIME Tl T2 T3 Rl R2 R3 

1.0 
2.0 
3.0 

POINT-ID =2 DISPLACEMENTS 

TIME Tl T2 T3 Rl R2 R3 

1.0 
2.0 
3.0 



0.0 


5.12 


0.0 


0.0 


0.0 


0.0 


0.0 


5.53 


0.0 


0.0 


0.0 


0.0 


0.0 


7,96 


0.0 


0.0 


0.0 


0.0 



4.62-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.62.3 DMAP Calling Sequence 

SDR3 INl,IN2,IN3,IN4,IN5,IN6/0UT1,0UT2,!i!UT3,i3UT4,|3UT5,0UT6/ $ 

4.62.4 Input Data Blocks 

One to six data blocks in any order desired. Input data blocks to SDR3 which are purged 
are ignored. 

4.62.5 Output Data Blocks 

One to six data blocks in corresponding order to that of the input data blocks. If S0RT2 
is to be performed, there must be an available output data block for the corresponding input data 
block (Non-Fatal Error if this condition is not met). 

4.62.6 Parameters 



None 



4.62.7 Method 



4.62.7.1 Input and Output Data Block Record Arrangements 

Both the input and output data blocks of SDR3 have the following format: 



4.62-2 



FUNCTIONAL MODULE SDR3 (STRESS DATA RECOVERY - PHASE 3 - S|2RT1 TO S0RT2 PROCESSOR) 



Group 1 



Header 



ID 



DATA 



ID 



DATA 



ID 



DATA 



ID 



DATA 



[■ Record 
> Record 1 
j Record 2 
} Record 3 



Record 4 



I Record N -] 

( Record N (an even number) 



Group M 



ID 



DATA 



4.62-3 



MODULE FUNCTIONAL DESCRIPTIONS 

4.62.7.2 Description of a Group 

1. An input (S0RT1) data block Group and an output (S0RT2) data block Group are given in the 
following figures: 

Theoretical Input Group 
(SiJRTl ) 



One Input Group 



\ 



ID 
Data Type 1 


DATA 
Entries 1 thru 


Ki 


: 


ID 
Davd Type J 


DATA 
Entries 1 thru 


K.1 


'■ 


ID 
Data Type 1 


DATA 
Entries 1 thru 


Ki 


; 


ID 
Data Type J 


DATA 
Entries 1 thru 


K,l 



Record pair for 
Data Type 1. 



Base Set for 
Value 1. 



Record pair for 
Data Type J. 



Record pair for 
Data Type 1 . 



Record pair for 
Data Type J. 



Base Set for 
'value I. 



4.62-4 



FUNCTIONAL MODULE SDR3 (STRESS DATA RECOVERY - PHASE 3 - S0RT1 TO S0RT2 PROCESSOR) 



Theoretical Output Group 
(S0RT2) 



One Output Group 



\ 



ID 
Data 


Record 
Type 1 


DATA 
Entries 


Record 
1 thru I 


_• 


ID 
Data 


Record 
Type 1 


DATA 
Entries 


Record 
1 thru I 




ID 
Data 


Record 
Type J 


DATA 
Entries 


Record 
1 thru I 


\ 


ID Record 
Data Type J 


DATA 
Entries 


Record 
1 thru I 



Record pair for 
P0INT or ELEMENT 1 J 



S(3RT2 Collectinn 
*of Data Type I . 



Record pair for 
P0INT or ELEMENT Ki I 



Record pair for 
P0INT or ELEMENT 1 



Record pair for 
P0INT or ELEMENT K, 



S0RT2 Conection 
of Data Typo J. 



4.62-5 



MODULE FUNCTIONAL DESCRIPTIONS 

2. In the above figures each Group is independent of any other Group so far as SDR3 need 
be concerned. 

3. A Group is defined as a collection of successive records belonging to the same subcase. 

4. An ID-Record is of a fixed size equal to 146 words. 

5. A DATA-Record contains multiple Entries with each Entry being of a length in words 
specified within the immediately preceding ID-Record. 

6. I = The nuntoer of Values (FREQUENCIES or TIMES) present in the Group. 

7. A Base Set is a sub-Group of the Group containing data records for one oarticular Value. 

8. J = The number of different Data Types (DISPLACEMENTS. VELOCITIES, etc.) within a Base Set. 

9. K. = The number of Entries for Data Type j. 

10. Respective records of any two Base Sets within an input data block Group are of the 
same size. 

11. Respective Entries within respective DATA Records of all Base Sets of an input data 
block Group begin with the same ELEMENT-ID or P|i)INT-ID. 

12. Most input data blocks will contain only one Group having but one Data Type. There is 
normally more than one Base Set within any Group. 

13. A pictoral representation of a S0RT1 to S0RT2 process is given on the next page using 
the following data: 

Values = 3 time steps (1.0. 2.0, 3.0) 

(1 - Displacements (3 Entries/Value - points 5, 8 and 9) 
Data Types =<2 - Velocities (2 Entries/Value - points 3 and 4) 

(3 - Accelerations (2 Entries/Value - points 1 and 4) 



4.62-6 



FUNCTIONAL MODULE SDR3 (STRESS DATA RECOVERY - PHASE 3 - S0RT1 TO S0RT2 PROCESSOR) 



ID 
Recon 



DATA i 
iRecord 



Base 
Set 



Base 
Set 



Base 
Set 



Input Data Block 
S0RT1 Group 



DISPLACEMENTS 
t = 1.0 



Pt. 5 Entry" 



Pt. 8 Entry 



Pt. 9 Entry 



VELOCITIES 
t = 1.0 



"TT. 3 Entry 
Pt. 4 EntTy 



t = 1.0 



Tt7 



1 Entry 



4 Entr 



DISPLACEMENTS 
2.0 



Pt. 5 Entry 
Pt. 8 Entry 



Pt. 9 Entry 
VELOCITIES 

t = 2.0 



Pt. 3 Entry" 



Pt. 4 En try 
ACCELERATIONS 



t = 2.0 



Pt. 1 Entry" 



Pt. 4 En try 
bISt>LAcEMENT$ 

t = 3.0 



Pt. 5 Entry" 
Pt. 8 Entry 



Pt. 9 Entry 
VELOCITIES 



3.0 



Pt. 3 Entry" 



Pt. 4 E ntry 
ACCELERATIONS 

t = 3.0 

Pt. 1 Entry~ 
Pt. 4 Entry 



S0RT1 to S0RT2 
Process 




Output Data Block 
S0RT2 Group 



DISPLACEMENTS 
Pt. 5 



t = 1.0 Entry 



t = 2.0 Entry 



t = 3.0 Intr. 
DISPLACEMENT' 



Pt. 8 



t = 1.0 Entry 
t = 2.0 Entry 
t =3.0 Entry 



bISPLACEMENTs 
Pt. 9 



t = 1.0 Entry 
t = 2.0 Entry 
t =3-0 Entry 



VELOCITIES 
Pt. 3 



t = 1.0 En£?F 
t = 2.0 EnW" 
t = 3-0__Entry" 



VELOCITIES 
Pt. 4 



t = 1.0 Entry" 
t = 2.0 Entry 



TU~ 



Entry 

ACCELERATION'S 



Pt. 1 



t = 1.0 Entry 
t = 2.0 Entry 



t = 3.0 Entry 
ACCELERATIONS 



Pt. 4 
t = 1.0 



Entry 

t = 2.0 Entry 



t = 3.0 Entry 



ID 
( Record 

) DATA 
I Record 



4.62-7 



MODULE FUNCTIONAL DESCRIPTIONS 
4,62.7.3 Physical Data Processing (S0RT1 to S0RT2) 

An emphasis is placed on the Group, and thus in performing S0RT2 a Group pointer always 
points to the first record of the current Group being processed. 

Each Group is processed and completed successively until all Groups have been processed. 
For each Group a loop of J passes is executed. During the j*'^ pass of this loop, the 3^^ Data 
Type (note 4.62.7.2) present of the Base Sets will be collected and transposed. The transpose 
consists of determining how many Entries are present for the current Data Type and then dividing 
the available core into that many Regions. The Entries of each DATA record for the j*^ Data Type 
are distributed in Entry order, one each, to the Regions. At the time each Entry is distributed 
to a Region, the Entry's first word (P^IOT-ID or ELEMENT-ID) is replaced by the Value (FREQUENCY 
or TIME) in the ID-Record associated with the DATA-Record from which the Entry has come. At the 
conclusion of each pass of this loop, output to the data block can proceed. For each Region an 
ID-Record is written. This ID-Record is a copy of the input data block ID-Record in the first 
Base Set for the j Data Type, having had the Value (FREQUENCY or TIME) replaced with the P0INT- 
ID or ELEMENT-ID of the respective Region. The filled portion of the Region is then output as the 
DATA-Record. 



4.62.7.4 Spill Logic 

If during the Entry distribution the Regions can hold no more Entries, spill to scratch files 
is performed. A Layer of records is written, one record for each Region, each time spill is 
required. 

Scratch 1 Scratch 2 



Layer 



Region 1 



Region N+1 



Region K-1 



Region 2 



Region K 



i/vv*- 



Scratch N 



Region N 



Region K-2 



4.62-8 



FUNCTIONAL MODULE SDR3 (STRESS DATA RECOVERY - PHASE 3 - S0RT1 TO S0RT2 PROCESSOR) 

At the output stage, if spill to the scratch files has occurred, the Regions in the scratch 
files are output before the in-core Regions. 

4.62.8 Subroutines 

4.62.8.1 Subroutine Name: SDR3A 

1. Entry Point: SDR3A 

2. Purpose: To perform all S0RT2 operations when called by the driver routine SDR3. 

3. Calling Sequence: CALL SDR3A {0FPFIL) 

0FPFIL - An array of six words, one for each input data block, each of which is set 
to zero before the CALL and then reset by SDR3A with a traceback positive 
integer in the event an error for its respective data block occurred. 

4.62.9 Design Requirements 

1. The design requires that the largest DATA-Record fit in core. If a problem is outputting 
so many ELEMENT-ID or P0INT-ID Entries for a particular FREQUENCY or TIME that core is 
insufficient, then more subcases in conjunction with output request sets are recommended. 

2. C0MM0N/SDR3ZZ/Z(1) 

This common block defines open core for the SDR3 module. 

4.62.10 Diagnostic Messages 

All errors within SDR3 are considered non-fatal -User Warning type errors. Any error 
resulting in termination of the S0RT2 process results in the setting of an SDR3 traceback 
number, an appropriate message, and a call to the 0FP (Output File Processor) which in turn 
will output the data block in S0RT1 format. If 0FP is una^^le to output the data block it in 
turn will call the TABPRT routine, and the data block will be printed. 



4.62-9 



FUNCTIONAL MODULE XYTRAN (XY - OUTPUT DATA TRANSLATOR) 

4.63 FUNCTIONAL MODULE XYTRAN (XY - OUTPUT DATA TRANSLATOR) 

4.63.1 Entry Point : XYTRAN 

4.63.2 Purpose 

To read the first record of the XYCDB data block (prepared by subroutine IFPIXY of 
Executive module IFPl); to set xy-output parameters from the serial specifications of this 
record; to interpret the user curve requests; to locate in the XYTRAN input data blocks (2 
thru 6) the data sets containing the requested curve data; to prepare summary and xy-coordinate 
data for the requested curves and output them to the system output printer and punch units; and to 
prepare xy-coordinate data and output them to the XYTRAN output data block for direct plotting by 
the XYPL0T module of those curve requests specified to be plotted. 

4.63.3 DMAP Calling Sequences 

4.63.3.1 Frequency Response - Direct Formulation. (Rigid Format 8) 

1. Vector data recovery output. 

XYTRAN XYCDB.0UDVC2 .... /XYPLTFA/C.N.FREQ/C,N,DSET/V.N.PFILE/V.N,CARDN0 $ 

2. Stress data recovery output. 

XYTRAN XYCDB.0PPC2.0qPC2.0UPVC2.0ESC2.0EFC2/XYPLTF/C.N.FREQ/C.N.PSET/V.N.PFILE/V.N.CARDN0$ 

3. Random response output. 

XYTRAN XYCDB, PSDF.AUT0.../XYPLTR/C.N.RAND/C.N.PSET/V.N,PF1LE/V.N.CARDN0 $ 

4.63.3.2 Transient Response - Direct Formulation. (Rigid Format 9) 

1. Vector data recovery output. 

XYTRAN XYCDB.0UDV2.0PNL2.../XYPLTTA/C.N.TRAN/C.N.DSET/V.N.PFILE/V.N.CARDN0 $ 

2. Stress data recovery output. 

XYTRAN XYCDB.0PP2.0QP2.0UPV2.0ES2.0EF2/XYPLTT/C.N.TRAN/C.N.PSET/V.N.PFILE/V.N.CARDN0 $ 

4.63.3.3 Frequency Response - Modal Formulation. (Rigid Format 11) 
1. Vector data recovery output. 

XYTRAN XYCDB.0UHVC2,..,/XYPLTFA/C.N.FREQ/C.N.HSET/V,N.PFILE/V.N.CARDN0 $ 



4.63-1 



MODULE FUNCTIONAL DESCRIPTIONS 

2. Stress data recovery output. 

XYTRAN XYCDB.0PPC2.0qPC2,0UPVC2.0ESC2.0EFC2/XYPLTF/C.N.FREQ/C.N,PSET/V.N,PFILE/ 

V,N,CARDN0 $ 

3. Random response output. 

XYTRAN XYCDB.PSDF,AUT0.../XYPLTR/C,N.RAND/C,N.PSET/V.N.PFILE/V.N.CARDN0 $ 

4.63.3.4 Transient Response - Modal Formulation. (Rigid Format 12) 

1. Vector data recovery output. 

XYTRAN XYCDB.0UHV2.0PNL2.,./XYPLTTA/C.N.TRAN/C.N.HSET/V.N,PFILE/V.N,CARDN0 $ 

2. Stress data recovery output. 

XYTRAN XYCDB,0PP2.0QP2.0UPV2,0ES2,0EF2/XYPLTT/C.N,TRAN/C.N.PSET/V.N.PFILE/V.N,CARDN0 $ 

4.63.4 Input Data Blocks 

XYCDB - XY Output Control Data Block. 

0UDVC2 - Output displacement vector requests (solution set, S0RT2, complex). 

0PPC2 - Output load vector requests (solution set, S0RT2, complex). 

0QPC2 - Output forces of single-point constraint requests (solution set, S0RT2, complex) 

0UPVC2 - Output displacement vector requests (p set, S0RT2, complex). 

0ESC2 - Output element stress requests (S0RT2, complex). 

0EFC2 - Output element force requests (S0RT2, complex). 

PSDF - Power Spectral Density Table. 

AUT0 - Autocorrelation function table. 

0UDV2 - Output displacement vector requests (solution set, S0RT2, real). 

0PNL2 - Output nonlinear load requests (solution set, S0RT2, real). 

0PP2 - Output load vector requests (p set, S0RT2, real). 

0QP2 - Output forces of single-point constraint (p set, S0RT2. real). 

0UPV2 - Output displacement vector requests (p set, S0RT2, real). 

0ES2 - Output element stress requests (S0RT2, real). 

(3EF2 - Output element force requests (S0RT2, real). 

0UHVC2 - Output displacement vector requests (solution set, S0RT2, complex). 

0UHV2 - Output displacement vector requests (solution set, S0RT2, real). 



4.63-2 



FUNCTIONAL MODULE XYTRAN (XY - OUTPUT DATA TRANSLATOR) 
4.63.5 Output Data Blocks 



XYPLTFA - 

XYPLTF - 

XYPLTR - 

XYPLTTA - 

XYPLTT - 

4.63.6 Parameters 



XY-Plot output requests prepared by XYTRAN for direct plotting by XYPLTT. 



CARDN0 - Input and output-integer-defauU value = 0. CARDN0 is incremented by one and 
punched in columns 73-80 of each card punched by XYTRAN. 

PFILE - Input and output-integer-default value = 0. PFILE is incremented by one for 
each frame XYTRAN defines for output by XYPL0T. 

- Input-BCD- 2-word-constant distinguishes the problem as frequency response. 

- Input-BCD 2-word-constant distinguishes the problem as transient response. 

- Input-BCD 2-word-constant distinguishes the problem as random response. 
DSET - Input-BCD 2-word-constant distinguishes the input vector as the d set. 

- Input-BCD 2-word-constant distinguishes the input vector as the p set. 
■ Input-BCD 2-word-constant distinguishes the input vector as the h set. 



FREQ 
TRAN 
RAND 



PSET 
HSET 



4.63-3 



MODULE FUNCTIOKAL DESCRIPTIONS 



4.63.7 Method 



4.63.7.1 The following diagram illustrates the process of serially reading through the XYCDB 
data block's first record and performing the XYTRAN data processing. 




Figure 1. Flowchart for reading the first record of XYCDB 



4.63-4 



FUNCTIONAL MODULE XYTRAN (XY - OUTPUT DATA TRANSLATOR) 

4.63.7.2 Phase I 

In Phase I the XYCDB data block is further read to: 

1. Determine the type of XY-output curves desired. (Response, Autocorrelation, 
or Power Spectral Density Function); 

2. Determine the type of data (displacements, stresses, etc.,) and subcases 
desired; 

3. Determine which types of XY-output are requested of XYPUNCH, XYPEAK, XYPRINT. and 
XYPL!3T (XY-output requests are described in section 4 of the User's Manual). 

4. Determine the point-component curve relationships for a frame. 

The data for all curves of a given frame (upper and lower, or whole) are then collected 
and stored in core. 

4.63.7.3 Phase II 

The operations of Phase II involve the analysis of the curve data in conjunction with the 
XY-output specifications stored to this point as a set of values, and the computation and 
setting of dynamic curve limits. When all processing is complete, output to the printer, the 
punch, and the XYTRAN output data block is accomplished. 

4.63.8 Subroutines 

4.63.8.1 Subroutine Name: XYDUMP 

1. Entry Point: XYDUMP 

2. Purpose: To perform phase II as described above. 

3. Calling Sequence: CALL XYDUMP (lARG.ITYPE) . 

lARG - 201, GIN0 output data block number. 
ITYPE - 1 for RESP0NSE, 2 for PSDF, 3 for AUT0. 

4.53.8.2 Subroutine Name: XYFIND 

1. Entry Point: XYFIND 

2. Purpose: To position one of the XYTRAN input data blocks (2 thru 6) to the 
beginning of a data set record for a particular ELEMENT-ID or POINT-ID of a specific 

4,63-5 



MODULE FUNCTIONAL DESCRIPTIONS 

data type. 

3. Calling Sequence: CALL XYFIND ($n^ ,$n2,$n3,MAJID,IDZ) 

n = Return taken in the event an end-of-file is sensed when an E0F should not be hit. 

n = Return taken in the event an end-of-record is sensed when an end-of -record. 

should not be hit. 
n = Return taken if the data requested could not be found. 
MAJID = An array of the eleven data type major-IDs. 
IDZ = Pointer into the Z array of open core to an ELEMENT-ID or POINT-ID. 

4.63.8.3 Subroutine Name: XY0UT 

1. Entry Point: XY0UT 

2. Purpose: To output to the system printer unit an xy-output summary or to output 
to the system printer and/or punch unit(s) an xy-output coordinate pair. 

3. Calling Sequence: CALL XY0UT (lARG.BUFF) 

( <0 implies print summary. 

lARG = ) ,. . . 

I >p implies print and/or punch coordinate pair. 

BUFF = Array containing data to be output. 
4.63.8.4 Subroutine Name: XYLfIG 

1. Entry Point: XYL0G 

2. Purpose: To analyze the input arguments VI and V2 and to reset these arguments to 
powers of ten bracketing the original values. An example follows. 

VI 

V2 

lARG 

VI 

V2 

lARG 



4.63-6 




FUNCTIONAL MODULE XYTRAN (XY - OUTPUT DATA TRANSLATOR) 

3. Calling Sequence: CALL XYL0G(V1 ,V2,IARG) 

VI = Smaller input real variable. 
V2 = Larger input real variable. 

lARG = Number of logrithmic cycles needed to bracket VI and V2. (Set by XYL0G before 
return) 

4.63.8.5 Subroutine Name: XYTICS 

1. Entry Point: XYTICS 

2. Purpose: To accept user-specified xy-plot edge-tic specifications and compute 
actual edge-tic beginning and ending values, their increments to the successive edge-tics, 
and their scientific values with powers of ten. 

3. Calling Sequence: CALL XYTICS (I0UT,i3UT,IARGl ,R1 .R2,ISKIP) 

I0UT = Integer output array j 

[ One and the same array. 
0UT = Real output array ) 

lARGl = Number of edge-tic divisions desired by user. 

Rl = Minimum coordinate value of edge. 

R2 = Maximum coordinate value of edge. 

ISKIP = Edge-tic skip count indicating which edge-tics are to have a value printed 

along with the tic-mark. 

4.63.9 Design Requirements 

1. The XYTRAN design requires that for a particular frame all of the curve data for the 
curves of that frame fit in core. If this condition is not possible, one curve at a time 
will be cancelled, with a warning message output, until the condition is met for the frame 
in question. 

2. The following C0MM0N blocks are used in the subroutines of module XYTRAN. 

a. C0MM0N/XYW0RK/ 

This common block contains variables required in the processing of the user output 

requests. 



4.63-7 



MODULE FUNCTIONAL DESCRIPTIONS 

b. C(i(MM0N/XYTRZZ/ 

Defines open core for the module. 

4.63.10 Diagnostic Messages 

All XYTRAN diagnostic messages are of a USER-WARNING nature. There are no FATAL type 
error diagnostics. XYTRAN is in all cases expected to make a normal return. 



4.63-8 



FUNCTIONAL MODULE RAND0M (RANDOM ANALYSIS MODULE) 

4.64 FUNCTIONAL MODULE RAND0M (RANDOM ANALYSIS MODULE) 

4.64.1 Entry Point: RAND0M 

4.64.2 Purpose 

To compute power spectral density functions and autocorrelation functions from frequency 
response data. 

4.64.3 DMAP Calling Sequence 

RAND0M XYCDB,DIT.PSDL,0UPVC2,0PP2,!2QP2,0ESC2,0EFC2,CASECC/PSDF.AUT0/V.N.N0RAND $ 

4.64.4 Input Data Blocks 

XYCDB - XY Plotter Control Data Block. 

DIT - Direct Input Tables. 

PSDL - Power Spectral Density List. 

0UPVC2 - Output displacement vector requests (p set, S0RT2, complex). 

0PP2 - Output load vector requests (p set, S0RT2. complex). 

0QP2 - Output forces of single-point constraint (p set, S0RT2, complex). 

I2LSC2 - Output element stress requests (S0RT2, complex). 

0EFC2 - Output element force requests (S0RT2, complex). 

CASECC - Case Control Data Table. 

Notes: 1. If XYCDB is purged, RAND0M returns. 

2. DIT cannot be purged if PSDL points to tables in DIT, 

3. If PSDL is purged, RAND0H returns. 

4. 0UPVC2, 0PP2. 0QP2. 0ESC2, 0EFC2 must contain thp requested outputs. 

5. CASECC cannot be purged. 

4.64.5 Output Data Blocks 

PSDF - Power Spectral Density Table. 
AUT0 - Autocorrelation function table. 
Motes : PSDF and AUT0 cannot be purged. 



4.64-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.64.6 Parameters 

N0RAND - Output-integer-no default. N0RAND = -1 , if no random analysis is requested; 
0, otherwise. 

4.64.7 Method 

4.64.7.1 Overview of the Method 

The Random Analysis Module calculates power spectral density functions, autocorrelation 
functions and mean deviations for selected displacements, loads, forces of single-point constraint, 
and element forces and stresses. 

4.64.7.2 Module Initialization 

The following 4 steps of subroutine RAND7 comprise module initialization. 

1. The XYCDB must be present or RAND0M returns. 

2. A set of RANDPS Bulk Data cards from PSDL must be selected in CASECC or RAND0M returns. 

3. The frequency list is extracted from the first non-empty data file. 

4. The selected RANDPS cards are read in and stored. The tables referenced are 
prepared by subroutine PRETAB. The RANDPS (see section 2.4 of the User's Manual) card 
defines the functions 

S^^(f) = (X + iy) F|^(f) (1) 

where a is the subcase id of the excited load set; b is the subcase id of the applied 
load set (a < b); (x,y) is a complex number such that if a = b, then y must be 0.0; and 
K is the table identification number of a TABRNDl Bulk Data card which defines F^(f), 
a power spectral density as a tabular function of frequency. 

If on any RANDPS card a f b. the equations are called coupled, otherwise they are called 
uncoupled. 



4.64-2 



FUNCTIONAL MODULE RAND0M (RANDOM ANALYSIS MODULE) 



4.64.7.3 The Uncoupled Case 

The following eight steps are accomplished in subroutine RAND5. 

1. The XYCDB is read for a list of requested points. This list is stored in core. 
(Subroutine RAND6). 

2. Core is allocated for as many points as possible at one word per frequency. If 
all points will not fit in core, another pass will be made on this file. 

3. Compute S^g(f) at each load change (subroutine TAB). 

4. Read in the data from the S!ZIRT2 data block and compute: 

where Uj.(f) is the response of the j**^ point at frequency f. 

5. These are summed over all loads to form the power spectral density function: 

S^.(f) = |S.^(f). 
where 'a' runs over all subcase id's on the RANDPS cards. 

6. When all subcases for the points in core have been processed, the mean response q". 

J 

is calculated in subroutine RAND3 for each point j: 



(2) 



(3) 



^J ={? 'l, t^^j(^i)^Sj(^i.l)^(Vl-^i)}'^^ 

where N = number of frequencies. The mean response is output with both the PSDF and 
the autocorrelation function. 

7. If PSDF for point j is requested, one id and data record are written on the PSDF 
data block. 

8. If an autocorrelation function is requested for point j, the S.(f) are transformed 

J 

to the time domain to give the autocorrelation function: 



(4) 



i(^) 



N-1 



'-'U-'^\ L (^>l -fi) 



[cos(27TT^f^^^) - cos(2TrT^f.)] + 



2^^ [S.(fH-l) sin (2TrT/.,^) - S.(f.) sin (2TrT/.)] . 



(5) 



4.64-3 



MODULE FUNCTIONAL DESCRIPTIONS 



Where i is the index of the frequencies; N is highest frequency; t^ is defined by 



m 



m 



(t„,„-tJ. (6) 



R ^"^max ■ "^0 



where i is the starting time lag, M is the number of time lag intervals, and t^^^^ 
is the maximum time lag (o < x^ < t^) . all of which are defined on a RANDTl Bulk Data 
card. Note that if, in Equation 5, t^^ » 0, then 

R. (x ) = q.. (7) 

j ^ m' ^j 

If more points for this data block remain to be done, the file is rewound and another 
pass is made. If additional file types are requested, steps 1 through 8 outlined above are 
repeated. This completes the uncoupled case processing. 

4.64.7.4 The Coupled Case 

The following 6 steps are accomplished in subroutine RANDS. 

1. A list of unique subcase id's is extracted from the RANDPS cards. 

2. The XYCDB is read for a list of requested points. This list is stored in core 
(subroutine RAND6). 

3. An array of core is reserved for each point as follows: 

Let NFREQ = the number of frequencies used and NUN0 be the number of unique subcase id's 
mentioned on the RANDPS cards. Each point requires 2 NFREq*NUN0 words of storage. 

As many points as possible are done at once. The data file is read and the data are 
stored (real/imaginary) for each point until all subcases for all points in core have 
been processed. 

4. For each RANDPS card S , (f.) is looked up for all f (subroutine TAB). 



'ab^'i- 
For each point in core S.(f) is computed: 

J 

where H. (f) denotes the value of point j for subcase a. The bar over the third 

ja ^ 

factor in Equation 8 denotes the complex conjugate. These Sj(f) are summed over all 

RANDPS cards to form S.(f): 

J 



4.64-4 



(8) 



FUNCTIONAL MODULE RAND0M (RANDOM ANALYSIS MODULE) 

Sj(f) = IgH.^(f) S^^(f)ir.j^(f)l. (9) 

Note that S, = S,, , the complex conjugate. 

5. The mean response and autocorrelation functions are computed as in Equations 

5, 6 and 7. 

6. If more points for this file remain to be done, the file is rewound and another 
pass is made. 

If additional file types are requested, steps 1 thru 6 are repeated. If not, the 
coupled case processing is complete. 

4.64.8 Subroutines 

4.64.8.1 Subroutine Name; RAND7 

1. Entry Point: RAND7 

2. Purpose: To initialize for both the coupled and uncoupled cases. 

3. Calling Sequence: CALL RAND7(IFILE,NF1LE,PSDL.DIT.IC0UP,NFREQ,NPSDL,NTAU,LTAB, 

CASECC.XYCDB). 

PSDL,DIT,CASECC,XYCDB are GIN0 file numbers for their respective data blocks - 

- integer - input. 

IFILE - Array of 6IN0 file numbers of data files to P.AND0M - integer - input. 

NFILE - Number of files in IFILE - integer - input. 

IC0UP - -1 No RAND0M analysis to be done. 

- uncoupled algorithm to be used - integer - output. 

- 1 coupled algorithm to be used. 

NFREQ - Number of frequencies - integer - output. 

NPSDL - Number of RANDPS cards selected - integer - output. 

NTAU - Number of t's on RANDTl cards - integer - output. 

LTAB - Amount of core taken up by table storage - integer - output. 

C0MM0N/RANDMX/ 

RAND7 stores most of its output data in /RANDMX/. See core storage layout of /RANDMX/ 
(section 4.64.9), 



4.64-5 



MODULE FUNCTIONAL DESCRIPTIONS 

4.64.8.2 Subroutine Name: RAND5 

1. Entry Point: RAND5 

2. Purpose: To compute uncoupled PSDF and AUT0 numbers. 

3. Calling Sequence: CALL RAND5(NFREQ,NPSDL.NTAU,XYCDB,LTAB,IFILE,PSDF,AUT0,NFILE) 

PSDF,AUT0 - GIN0 file numbers of respective files - integer - input. 
Other variables are as in RAND7 (section 4.64.8.1). 

4.64.8.3 Subroutine Name: RANDS 

1. Entry Point: RANDS 

2. Purpose: To compute coupled PSDF and AUT0 numbers. 

3. Calling Sequence: CALL RANDS (Same as RANDS). 

4.64.8.4 Subroutine Name: RANDl 

1. Entry Point: RANDl 

2. Purpose: To put one OFP type ID on PSDF and AUT0. 

3. Calling Sequence: CALL RANDl (FILE, MID, TYPE, ID, C0MP,Q). 

FILE - GIN0 file number of output file - integer - input. 

MID - File type (PSDF = 4001, AUT0 = 4002) - integer - input. 

TYPE - Curve type - DISP,VEL0,ACCE,L0AD,SPLF,ELF0, or STRE - BCD, input. 

ID - Point id - integer - input. 

C0MP - Point component - integer - input. 

Q - Mean deviation - real - input. 

4.64.8.5 Subroutine Name: RAND2 

1. Entry Point: RAND2 

2. Purpose: To read a S0RT2 type output file until it finds a point id selected by 
the user in a list. 

3. Calling Sequence: CALL RAND2 (FILE,ILIST,L0AD,IF,LEN,LLIST) 

FILE - GIN0 file number of the S0RT2 data file - integer - input. 



4.64-6 



FUNCTIONAL MODULE RAND0M (RANDOM ANALYSIS MODULE) 

ILIST - List of user desired points - input and output. 

L0AD - Subcase id of first data record in ILIST - integer - output. 

IF - Format of data - real /imaginary or magnitude/phase - integer - output. 

LEN - Length of the data line for this record - integer - output. 

LLIST - Length of the ILIST array. 

4.64.8.6 Subroutine Name: RAND3 

1. Entry Point: RAND3 

2. Purpose: To compute the mean response q". 

3. Calling Sequence: CALL RAND3 (F.S.Q.N) 

F - Array of frequencies - real - input. 

S - Array of power spectral density functions - real - input. 

Q - Mean response - real - output. 

N - Length of the F and S arrays - integer - input. 

4.64.8.7 Subroutine Name: RAND4 

1. Entry Point: RAND4 

2. Purpose: To compute the autocorrelation function R(t). 

3. Calling Sequence: CALL RAND4 (F.S.TAU.R.N) 
F,S,N are as described in RANDS. 

TAU - T point at which R is to computed - real - input. 
R - Autocorrelation function at TAU - real - output. 

4.64.8.8 Subroutine Name: RAND6 

1. Entry Point: RAND6 

2. Purpose: To extract from the XYCDB a list of user requested points for RAND0M output. 

3. Calling Sequence: CALL RAND6 (XYCDB,BUFFER,NP0INT,IZ, INPUT) 
XYCDB - GIN0 file number of the XYCDB data block - integer - input. 
BUFFER - GIN0 buffer - array - input. 

NP0INT - Number of points requested by the user for this file - integer - output. 



4.64-7 



MODULE FUNCTIONAL DESCRIPTIONS 

IZ - Array in which RAND6 stores the list of requests - integer - output. 
INPUT - GIN0 file number of data file for which list of request is desired. 

4.64.9 Design Requirements 



Open Core at /RANDMX/ is arranged as follows: 

C0MM0N/RANDMX/ 



'1 



'NFREQ 



RANDPS 

Card 

Data 



'NTAU 



Table Data 
From PRETAB 



NFREQ frequencies 



5 words per card: 

Subcase ID 
Subcase ID 

X 

Y 
Table 



NTAU Taus 



LTAB Table data 



NPSDL cards 



The above data are placed in core by RAND7 and are the same for both the coupled and 
uncoupled cases. The remaining data are core dependent. 
Uncoupled case data: 



^aa^^l) 
Saa(^2) 



^aa^^NFREQ^ 



Requests from 
RAND6 



NP0INT of 
them 5 words/ 
point 



These are evaluated each time the 
Subcase id changes. 



1) 


Data Block 


2) 


Point ID 


3) 


Component 


4) 


Request Type 




1 = PSDF 




2 = AUTi3 




3 - Both 


5) 


Destination 




1 = Print 




2 = Punch 




3 = Both 




4 = Plot 



4.64-8 



FUNCTIONAL MODULE RAND0M (RANDOM ANALYSIS MODULE) 



Coupled case data: 



Sj(f) 



Vi(^) 



NFREQ 



NFREQ 



S.(f) for each point in the 

J 

request list (spill is possible 
here) 



3 GIN0 buffers 



Sab(^l) 
^ab^^NFREQ^ 



ID 



L 



Request 



^(^) 



Hj,(f) 



Sj(f) 



AUT0 



PSDF 



Input 



These are re-evaluated for each RANDPS card 



UniQiie subcase ID's from RANDPS cards 
NUNQ of u.em 

As in uncoupled request list 
2*NFREQ 



Repeated for each 
NUNQ \ point in request 
of H's / list (spill 

possible here). 



NFREQ 



3 GIN0 buffers 



4.64-9 



MODULE FUNCTIONAL DESCRIPTIONS 

4.64.10 Diagnostic Messages 

RAND0M is defined as an output processor and thus must not stop due to user input error. 
Hence all messages are of a warning nature. 
Random may issue message 3048. 



4.64-10 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 

4.65 FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 

4.65.1 Entry Point : TRD 

4.65.2 Purpose 

To solve the transient problem. 

4.65.3 DHAP Calling Sequence 

TRD CASECC,USETD,DLT,TRL,NLFT.DIT,KHH,BHH,MHH,GMD,G0D,PHIDH/UHVT,PDT,PST,PPT,PNLH/V,N, 

FiaRM/V,N,LUSETD/V,N,MPCFl/V,N,SINGLE/V,N,0MIT/V,N,N0NCUP/V,N,N0UE $ 

4.65.4 Input Data Blocks 

CASECC - Case Control Data table. 

USETD - Displacement set definitions table-dynamics. 

DLT - Dynamic Loads Table. 

TRL - Transient Response List. 

NLFT - Non-Linear Forcing Table. 
DIT - Direct Input Tables. 

KHH - Modal stiffness matrix - h set. 

BHH - Modal damping matrix - h set. 

MHH - Modal mass matrix - h set. 

GMD - Multipoint constraint transformation matrix - dynamics. 
60D - Omitted coordinate transformation matrix - dynamics. 

PHIDH - Transformation Matrix from d - set to modal coordinates. 

Notes : 

1. CASECC cannot be purged. 

2. USETD cannot be purged. 

3. DLT cannot be purged if a dynamic load was selected in CASECC. 

4. TRL cannot be purged. 



4.65-1 



MODULE FUNCTIONAL DESCRIPTIONS 

5. NLFT cannot be purged U nonlinear loads are selected in CASECC, 

6. GMD cannot be purged if MPCFl > 0. 

7. G0D cannot be purged if 0MIT >^ 0. 

8. PHIDH cannot be purged if F0RM = M0DAL. 

4.65.5 Output Data Blocks 

UHVT - Modal transient solution vectors - h set. 

PDT - Linear dynamic load matrix for transient analysis - d set. 

PST - Linear load vector for transient analysis - s set. 

PPT - Linear dynamics loads for transient analysis - p set. 

PNLH - Nonlinear loads in modal transient problem - h set. 

Notes : 

1. UHVT cannot be purged. 

2. PDT cannot be purged. 

3. PST cannot be purged if SINGLE > 0. 

4. PPT cannot be purged. 

5. PNLH cannot be purged if nonlinear loads are selected. 

4.65.6 Parameters 

F0RM - Input-BCD-no default. If F0RM = M0DAL a modal formulation will be used, 
otherwise a direct formulation will occur. 

LUSETD - Input-integer-no default. LUSETD indicates length of p set. 

MPCFl - Input-integer-no default. If MPCFl > multipoint constraints are present. 

SINGLE - Input-integer-no default. If SINGLE >_0 single-point constraints are present. 

0MIT - Input-integer-no default. If 0MIT >_ omitted coordinates are present. 

N0NCUP - Input-1nteger-no default. If N0NCUP = -1 an uncoupled solution will be done. 

N0UE - Input-integer-no default. N0UE Indicates the number of extra points-used in 
nonlinear load formulation. 



4.65-2 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 

4.65.7 Method 

4.65.7.1 Overview of the Method 

The Transient Analysis module integrates, over specified time periods, equations of 
motion of a structure having time dependent loads. A general structure may be used with real 
stiffness, mass and damping matrices. Non-linear effects may be calculated by specifying 
certain loading functions on the free, physical displacements of the system. This analysis 
is particularly useful when shock loads are applied to a structure. It is also more efficient 
than frequency analysis or complex eigenvalue analysis when the applied loads are well defined 
and the frequency characteristics are secondary to damping and peak load characteristics. This 
analysis is also the only dynamic general system analysis which allows non-linearities. 

4.65.7.2 Logical Phases of Solution 

1. The applied load vectors are assembled. The time increment from the TRL data block 
is used to identify the times at which the loads are assembled. The initial conditions 
are assembled. 

2. The loads are reduced to the solution coordinates, 

3. The left hand matrix of the general integration equation, Equation 15 below, and the 
two right hand matrices are assembled. The triangular decomposition of the left hand 
matrix is performed. 

4. The solution loop of the program may now proceed until the time increment is 
changed. The steps are: 

a. Compute the non-linear load for this time step. Add this load to the load 
vectors computed in Step 2. 

b. Multiply the displacement vectors into the right hand matrices and add the 
resultant vectors to the applied load vector. 

c. Solve for the left hand displacement vector by performing a back substitution 
into the triangular decomposition of the left hand matrix. If this is an output 
time step, the velocity and acceleration are computed using differences of the 
displacement vectors. 



4.65-3 



MODULE FUNCTIONAL DESCRIPTIONS 

d. If the time increment changes for the next time step, the program returns to 
step 3. If the increment is the same, steps 4a thru 4cl are repeated. 

5. If the equations are in the uncoupled modal formulation form (i.e., no transfer 
functions, direct input matrices, or non-11near functions), the solution logic is 
much faster. For each coordinate, the displacement, velocity and acceleration may be 
computed independently versus time. Steps 3 and 4 are omitted, 

4.65.7.3 Algorithms for Each Logical Phase 

1. Assembly of Applied load vectors: CASECC is read and the selected time step, load, 
non-linear load, and initial condition set ids are extracted. The initial displacement 
and velocity vectors are packed on a scratch file for later use. The computation and out- 
put data on the TSTEP card are stored in core. The DLT is read to build a list of load 
"id's", and table "id's" and scale factors for the simple components of a load. Core is 
zeroed, and loads for as many times as possible are constructed in core and output. 
Two types of loads are available, TL0AD1 and TL0AD2. 



For the TL0AD1 load, 

where F is a user input table. 
For the TLt)AD2 load. 



P(t) = AF (t-T), (1) 



p(t) = / '^t^®'^* "S (27Tf t + P) < t i T2-T1 (2) 

)o elsewhere 



where t = t -T, - t and T, , Tp, f, P, C and B are user input coefficients. 

(Subroutines TRDIA, PRETAB and TAB). 

2. Reduction of loads to the solution coordinates: 

I 

If m's are present (MPCF1>0), 



HH 



% (=^^r^^ (3) 



<Pne> = ^<^' ^Pm> ' ^^ne>- (^) 



4.65-4 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 
If s's are present (SINGLE > 0), 



(P ^ V . P 



S 

{Pg} Is reduced to the output times and output on data block PS 
If o's are present (0MIT ^ O), 



->=^{?i}. (5) 



"■te'-^^-r-)' (6) 







{Pj} = [Gjf {Pq} + ^Pd^- (7) 



{Pj} 1s reduced to the output times and output on data block P0. 
If this is a modal formulation (F0RM = M0DAL), 



{P } is reduced to output times and output on data block PP. 
3. Solution of the coupled equations: The matrix 



tPh> = ^'^dn>^ ^Pd>- (8) 



[D] =(-J-[M] +-L[B] +i[K]| . (9) 

\At^ 2At "* 



is formed and decomposed. The matrix 

[C] - 



|_i_ [M] - ^ [K]j . (10) 



is formed and saved. The matrix 

[E] = 

is formed and saved. 



li- [M] + -L [B] - i [K] 

At^ 2At -^ 



(n) 



The solution loops then proceed until a time step change occurs. The initial conditions 
are brought in and the starting equation 



4.65-5 



MODULE FUNCTIONAL DESCRIPTIONS 



[D] {u,} = ^ [P]^ + Pj + P^} + {H^} + [C] {u^} + [E] {u\}, (12) 

is solved for {u-,}, where {u } 1s the starting displacement vector; 



{u^,} = {Ujj} - {lig} At. (13) 



{u } Is the starting velocity vector; 







(Pj} = [K] {Ujj} + [B] {U^}; (14) 



{N } is the non-linear load calculated from {u^}; and 



[P]•^} ' [K] {^\}* [B] {u^} - {pj} - At [K] {ti^}. (15) 

Note that the load computed at t - Is never used but Is replaced by {P^^}. Cug) 
through {u } are now computed from the general equation: 



(16) 



[D] {u^^2> = I ^^1 ^ Pl+1 ^ Pi+a^ ' 
{N^^.^} + [C] {u,+t} + [E] {u^}. 

If non-linear loads are selected, they are evaluated directly at the solution points for 
time step by the following process. N0LIN1 loads are computed as, 



Pi(t) = S T (uj(t)), (17) 

where T is a user selected table, 1 is the loaded solution point, j Is the deflecting 
point, u. is the previously computed displacement at point j. N0LIN2 loads are computed 

J 

as, 

P^(t) =■ S Uj (t) u,^ (t), (18) 

where i, j, and k are as in N0LIN1 loads. 



4.65-6 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 



N0LIN3 loads are computed as, 



Pi(t) = { 



N0LIN4 loads are computed as, 



Pi(t) -\ 



S {u.(t}}A, u.(t)>0 

J J 



. Uj{t)<0 



■S {-u^(t)}A, u^(t)< 
, u^(t) > 0. 



(19) 



20 



The user specifies the set of times at which data is to be saved. If the current time is 
an output time, the displacement vector for time t = t. is output. 

The velocity vector given by: 



^^^ = 2At t^^+1^ - ^^-l^^' 



(21) 



is output. 

The acceleration vector given by 



^■^i^ = A^-tfu..^} + {u._^} - 2 {u.}]. 



(22) 



ime 



is output. 

If the time step is scheduled to change at t.^^ from At, to At^, the displacement for tir 

i + 1 has been calculated. (u._.|}, {u-}, and {u^^.^} are saved along with {P^+^}. The matrices 

are formed and decomposed as in Equations 9,10, and 11 for At = Atp. 

The following equation is used for computing {u. „}, 



[D] {u.,^} = ^ {p! + Pi,T + P^,^} + {N.,,} + [C] lu.,^} + [E] {u|}. 
The vectors {P^.} and {u^.} in the above equation are calculated as follows. Define 



(23) 



4.65-7 



MODULE FUNCTIONAL DESCRIPTIONS 



^Vl^ = TJT7(tu^,T}-{u^}). (24) 



{u]} =■ {u.^^} - {u^^^} Atg, (26) 



then: 



t2 
{uj} - (u^,i}-At2{ii,i}-H^ruVl>. (27) 

(P]} - [M] {u^+^} + [B] {u}} + [K] {uj}. (28) 

4. Solution of Uncoupled Modal Equation: If the method of matrix formulation is modal 
and no transfer functions or direct input matrices are used, the equations may be 
solved in a more accurate, more direct manner. The diagonal terms of MHH, BHH, and KHH 
are stored in core. The following data are necessary to solve the transient behavior of 
a modal coordinate (SJ. 

m. = Modal mass of mode (MHH) 

b, = Modal damping coefficient (BHH) 



K. = Modal stiffness (KHH) 



"oi " (K^/'"-i)^^^ (29) 



^i - ^ • (30) 



«: 



z 



i i"oi 



u>^4 - eM. (31) 



4.1. 

tj = time of the j time step, 



4.65-8 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 

XL 

h. = time increment after the j time, 

f. . = applied load on coordinate i at the j time. 

The following coefficients are generated for each distinct time increment and stored in 
core. 

There are four cases, (e = 10" and the subscript i is implied). 

a. If 0)^ > &^ + e (underdamped) : 

F = e"^"^ (cos wh + I sin oil) , (32) 

G = 1 e"^^ sin i^ . (33) 

A = ^ {e-^^ [(ii^^ - gh) sin a)h - (M + hoj) cos i^h] + ^ . (34) 
^'o "'o "'o 

S = i ^^'^^ ^(- ^^'^^^ ^i" "t^ ' ^ "^ "h] ^.h-^} , (35) 

%' '^o' "o' 



•^o' „ -6h „, 



— e ^" sin wh , (36) 



G' = e"^^(cos wh - -^ sin uh) , (37) 



A' = |;^ ie'^^ {(6 + hoj^) sin uh + cacos oih} - w] , (38) 



^' " hito t"^'^^ ^^sin wh + w cos coh) + u] , (39) 



b. If |w^^ - 6^1 < e (critically damped): 



F = e-^^1 + eh) . 



(40) 



6 = he-S^* . (41; 



4.65-9 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

A = Hk'^f -f^'^^ (2 + 2hB + h^ &ni . (42) 

B = W^l-^^ ^^^ e"^^ (2 + Bh)] , (43) 

F' = -e^he"^^ . (44) 



G' = e-^^1 - $h) . (45) 

A' = ^ [e-^^ (1 + he + h'&') -1] . (46) 



B' = Hk f^l - ^"^^ (^^ ^ ^^^ • ('l^) 



c. If iii J^ < 6^ - e (over damped); 



F = e'^'^ (cosh wh + i sinh uh) , (48) 



G = 1 e'"*^ sinh ojh , (49) 



^ {e-^^ [(iilJLll - he) sinh coh - (M + ho)) cosh a)h] + M} . (50) 

"o' "o' '"o' 



B = ^ ie-^^ [iilJLll sinh coh + M cosh ^] + oh - Mii} . (51) 



F' = - ^ e'^^ sinh (Oh , (52) 

G' = e"^*^ (cosh til - ^ sinh wh) , (53) 



01 



A' = 1^ [e"^^ {(6 + hw^^) sinh uh + oi cosh wh} - u] , (54) 



B' ' {^ [- e'^^ (B sinh wh + u cosh uh) + u] . (55) 



4.65-10 (12-1-69) 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 
d. If 0)^ = e = (undamped) : 

F = 1, (56) 

G - h. (57) 

A = hV3in, (58) 

B = hVem, (59) 

F' " 0, (60) 

G' - 1. (61) 

A' = h/2m, (62) 

B' - h/2m. (63) 

The equations for each displacement, velocity, and acceleration In terms of the 
applied loads and previous displacement and velocity are: 



^i.j+i ' ^i^ui'^i^i.r^i'ur^i'ui^^ ' (64) 



^U+l " ^'l^1.j*^'l^1.j*'^'lfl.d*^'l^1.j+l • (65) 

^•^ ' m^ m^ m^ 



4.65-11 



MODULE FUNCTIONAL DESCRIPTIONS 

4.65.8 Subroutines 

Utility routines PRETAB, TAB, SSG2A, CALCV, SSG2B, ADD, and DECAMP are used. See 
subroutine descriptions, section 3 for details. 

4.65.8.1 Subroutine Name: TRDIA 

1. Entry Point: TRDIA 

2. Purpose: To assemble the loads at all time steps. 

3. Calling Sequence: CALL TRDIA (DLT,TRL,CASECC,DIT,PPA,IC,LUSETD.NLFTP,N6R!2UP, 

ITRL.MUDAL) 

DLT, TRL, CASECC, DIT are GIN0 file numbers of their respective data blocks - integer - 
input. 

PPA - GIN0 file number of applied loads - p set - for all times - integer - input. 

IC - GIN0 file number of initial condition matrix - integer - input. 

LUSETD - Length of p set - integer - input. 

NLFTP - Non-linear load set Id selected in CASECC - integer - output. 

NGRJIUP - Number of time step changes - integer - output. 

ITRL - Number of records to skip in TRL to obtain selected TSTEP card - Integer - 
output. 

M0DAL - If M0DAL = 1, a modal formulation is being used - integer - input. 

4.65.8.2 Subroutine Name: TRDIB 

1. Entry Point: TRDIB 

2. Purpose: To reduce the applied loads to the solution set and remove all but 
output time loads. 

3. Calling Sequence: CALL TRDIB {PPA,USETD,GM|8,G|3D,PHIDH,MPCF1 ,SINGLE,0MIT,F|3RM, 

PD,PS,PP,PAPPLD,SCR1,SCR2,SCR3,SCR4,NGR0UP,TRL,ITRL) 



4.65-12 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 

PPA - Same as for TRDIA 

USETD,GM0, ^ 

G0D,PHIDH,PD,i' - GIN0 file numbers of their respective data blocks - integer - input. 

ps.pp.TRL ; 

nil I - GIN0 file numbers of 4 scratch files. 

MPCFl .SINGLE, \ m ^ i • * . , . _, . 

0MIT,F0RM / " ^°'^^^^ ^"P"* parameters as explained in section 4,65.6. 

NGR0UP,ITRL - Same as for TRDIA - integer - input. 

PAPPLD - GIN0 file number of applied loads - integer - input. 

4.65.8.3 Subroutine Name: INITL 

1. Entry Point: INITL 

2. Purpose: To form [C] and [E] matrices and to form and decompose the [D] matrix. 

3. Calling Sequence: CALL INITL (0FFSET, DELTA) 
C0MM0N/TRDXX/ See section 4.65.8.4. 

0FFSET - Length of reserved area of core - integer - input. 
DELTA - Current time increment - real - input. 

4.65.8.4 Subroutine Name: TRDIC 

1. Entry Point: TRDIC 

2. Purpose: To solve the coupled equations. 

3. Calling Sequence: CALL TRDIC (IC, PAPPLD, NGR0UP,NLFTP,UDV, I, SCRl ,DIT,NLFT,N0UE 

M0DA1 ,PNL) 

IC,NGR0UP\ - Are as described In TRDIA - integer - input. 
NLFTP ) 



UDV 
NLFT 



f PNL /" '^'"^ ^'^'^^ ^^^^ numbers of their respective data blocks - integer - input. 

SCRl - GIN0 file number of a scratch file. 

PAPPLD - Is as described in TRDIB. 

N0UE - Module parameter. 

4.65-13 



MODULE FUNCTIONAL DESCRIPTIONS 

MjJDAI - -1 1f F;»RM t MUDAL. 1 if FjJRM = MUDAL - integer - input. 

I - Current loop count. Runs from 1 to number of time step changes - 

integer - input. 
C0MM0N/TRDXX/IK(7)IM(7),IB(7),C,ULL,LLL,E,SCR1,SCR2,I|»PEN 

IK(7) - Matrix control block for K matrix. 

IM(7) - Matrix control block for M matrix. 

IB(7) - Matrix control block for B matrix. 

C - GIN0 file number for C matrix. 

ULL.LLL - 6IN0 file numbers for decomposition products of D matrix. 

E - GIN0 file number for E matrix. 

SCRl.SCRZ- GIN0 file numbers for 2 scratch files. 

I0PEN - 1 implies CULL, ILL, and E are open. 
implies C.ULL.LLL. and E are closed. 

4.65.8.5 Subroutine Name: F0RM1 

1. Entry F(JRM1 

2. Purpose: To compute {u,-,}, {P^}, and {P,-,} for starting the integration procedure. 

3. Calling Sequence: CALL F0RM1 {U(3,UD0T«),UI,P0,PI,DELTAT,IBUF) 
U0 - Array of core containing {u^} - real - input. 

UD0T0 - Array of core containing {0^} - real - input. 

UI - Array of core for storage of {u_^} - real - output. 

P0 - Array of core for storage of {P^} - real - output. 

PI - Array of core for storage of {P_i} - real - output. 

DELTAT - Current time step size - real - Input. 

IBUF - GIN0 buffer 

C0MM0N/TRDXX/ (see above h 

4.65-14 (7/1/70) 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 

4.65.8.6 Subroutine Name: MATVEC 

1. Entry Point: MATVEC 

2. Purpose: To form the product{X} = fX} + [A] {Y} where [A] is a matrix and {Y} is a vector. 

3. Calling Sequence: CALL MATVEC (Y.X.FILEA.IBUF) 

Y - Array of core containing Y array real - input. 

X - Array of core containing X array real - input/output. 

FILEA - Matrix control block for A. If FILEA(l) _< 0, (-lATVEC will return. 

IBUF - GIN0 buffer. If IBUF <_ 0, MATVEC will assume the file is already in core. 
COMMOM/TPnxx/ (Spp section 4.65.8.4) 

4.65.8.7 Subroutine Name: STEP 

1. Entry Point: STEP 

2. Purpose; To integrate forward 1 time step. 

3. Calling Sequence: CALL STEP {U2,U1 ,U0,P,IBUF) 

U2 - Array which will contain {u.^p^ " ^^^^ - output. 

Ul - Array containing (u^^i) - real - input. 

U0 - Array containing {u.} - real - input. 

P - Array containing combined load - real - input. 

IBUF - GIN0 buffer - Input. 

C0MM(3N/TRDXX/ (See section 4.65.8.4) 

4.65.8.8 Subroutine Name: INTFBS 

1. Entry Point: INTFBS 

2. Purpose: To perform the forward-backward substitution necessary to solve the system 
of equations: [A] {Y} = {X} for {Y}. 

3. Calling Sequence: CALL INTFBS (X.Y.IBUF) 

X - Load vector (I.e. right hand side) - real- input. 

4.65-15 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

Y - Solution vector - real - output. 

I^UF - GIN0 buffer. 

C0MM0N/TRDXX/ (See section 4.65.8.4) 

CeiMM!JN/INFBS/FILEL(7) ,FILEU(7) 

FILEL - Matrix control block of the lower triangular factor from the decomposition 

of A. 
FILEU - Matrix control block of the upper triangular factor from the decomposition 

of A. 

4.65.8.9 Subroutine Name: TRDID 

1. Entry Point: TRDID 

2. Purpose: To compute the non-linear loads at each time step. 

3. Calling Sequence: CALL TRDID 

C0MM(3N/TRDDl/NLFT,DIT,NLFTP.Nj)UT,IC0UNT.IL00P,M0DAl,NZ.IC(3RE,IU2,IP4,IPNL(7),NM0DES, 

NSTEP.PNL 
The variables DIT,NLFT,NLFTP,M0DA1 and PNL are defined as in TRDIC (see section 4.65.8.4), 

N0UT - Output interval - integer - Input. 

IC0UNT - Current time step counter - integer - input. 

IL00P - Current time change counter - integer - Input. 

NZ - Length of open core - integer - Input. 

IC0RE - Pointer to first unused cell of open core - integer - input. 

IU2 - Pointer to displacement vector - 1 - Integer - input. 

IP4 - Pointer to load area -1 - integer - input. 

IPNL - Matrix control block for PNL - integer - Input/output. 

NM0DES - Number of modes if modal formulation is being used - integer - input. 

NSTEP - Number of times steps for this time increment - integer - Input. 



4.65-16 (7/1/70) 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 
4.65.8.10 Subroutine Name: TRDIE 

1. Entry Point: TRDIE 

2. Purpose: To solve the uncoupled modal equations. 

3. Calling Sequence: CALL TRDIE (MHH.BHH.KHH.PH.UHV.NGRflUP) 

MHH BHH KHH 

PH UHV * " ^^^^ ^^^^ numbers of their respective data blocks - integer - input. 

NGR0UP - Number of time step changes - integer - input. 
4.65.8.11 Subroutine Name: F0RM2 

1. Entry Point: F0RM2 

2. Purpose: To compute {up and {Pp when changing time steps. (See Equations 23 
through 28) 

3. Calling Sequence: CALL F0RM2 (UDDIPl ,UDIP1 ,UIP,PIP,IBUF) 

- Array of core containing Cu.^■^} - real - input. 

- Array of core containing (u.^, } - real - input. 

- Array of core containing {uif} - real - output. 

PIP - Array of core containing {Pj} - real - output. 
IBUF - GIN0 buffer 
C0MM0N/TRDXX/ (See section 4.65.8.4) 



UDDIPl 

UDIPl 

UIP 



4.65-17 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

4.65.9 Design Requirements 

1. Open core at /TRDAl/ is illustrated as follows: 



C0MM0N/TRDA1/ 



Load ID^ 
Scale, 
Load ID2 
Scale^ 



Table ID-, 
Table IDo 



Tables 



Load at T 



Load at T, 



Load at T^ 



PRETAB Buffer 



DLT Buffer 



PP Buffer 



> Load ID'S + Scale factors for current 
DL0AD 



List of unique table ID's referenced by 
loads (NTABL id's) 



\ Table data used by PRETAB/TAB 



LUSETD + NTABL | These are repeated for 
/ as many times as core 
) will hold. 



Gone when loads are in core 



2 GIN0 Buffers 



[here must be enough core to assemble one time step load. 



4.65-18 (7/1/70) 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 



2, Open Core at /TRDIX/ is illustrated as foil 



ows: 



C0MM0N/TR1X/ 



Open Core 
for DEC0MP 
and ADD 



Number of steps 



At 



Output Internal 



Repeated for each time step change 



4.65-19 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 



This table Is at the bottom of open core through the module. 
3. Open Core at /TRDCl/ is illustrated as follows: 

C8IMM0N/TRDC1/ 



^1 



PI 



P2 



P3 



P4 



Type 



Table ID's 



Table's for TAB 



Tab Buffer 



C Buffer 



D Buffer 



ULL Buffer 



LLL Buffer 



Solution Buffer 



Load Buffer 



Utility Buffer 



NR0U 
NR0U 
NRIiiW 
NR0VJ 
NR0U 
NR0VJ 

NR0W 

5 words for each non-linear load card 
selected. 

Table ID's selected on N0L1N cards. 



Used only If non-linear loads are 
selected. 



GIN0 Buffers 



4.65-20 (7/1/70) 



FUNCTIONAL MODULE TRD (TRANSIENT ANALYSIS - DISPLACEMENT) 



4. Open Core at /TRDEl/ is illustrated as follows: 
C0MM0N/TRDE1/ 



MHH 


Each section 


BHH 




KHH 




F 




G 




A 




B 




F' 




G' 




A' 




B' 




'i 




S>1 




^j 




^'J*l 




'i 




'3^1 








PH Buffer 




UHV Buffer 


' 2 GIN0 Duffers 




4.65- 


■21 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

4.65.10 Diagnostic Messages 

TRD may issue the following messages 

3001, 3002, 3003, 3005, 3007, 3008, 3031, 3044. 3045, 3046, 



4.65-22 (7/1/70) 



FUNCTIONAL MODULE GKAM (GENERAL K ASSEMBLER MODAL) 

4.66 FUNCTIONAL MODULE GKAM (GENERAL K ASSEMBLER MODAL) 

4.66.1 Entry Point : GKAM 

4.66.2 Purpose 

To assemble the modal mass, damping and stiffness matrices. 

4.66.3 DMAP Calling Sequence 

GKAM USETD,PHIA,MI,LAMA,DIT,M2DD,B2DD.K2DD,CASECC/MHH,BHH,KHH,PHIDH/V,N,N0UE/C,Y, 
LM0DES/C,Y,LFREQ/C,Y.HFREQ/V,N,N0M2PP/V,N,N0B2PP/V,N,N(3K2PP/V,N,N0NCUP/V,N, 
FM0DE $ 

4.66.4 Input Data Blocks 

USETD - Displacement set definitions table dynamics. 

PHIA - Eigenvectors matrix giving the eigenvectors (displacements) in the a set. 

MI - Modal mass matrix. 

LAMA - Real Eigenvalue Table. 

DIT - Direct Input Table. 

M2DD - Direct input mass matrix - d set. 

B2DD - Direct input damping matrix - d set. 

K2DD - Direct input stiffness matrix - d set. 

CASECC - Case Control Data Table. 

Notes: 



1. USETD may be purged if N0UE < 0. 

2. PHIA cannot be purged. 

3. MI cannot be purged. 

4. LAMA cannot be purged. 

5. DIT cannot be purged if SDAMP ?« in CASECC. 

6. CASECC cannot be purged. 

7. M2DD cannot be purged if N0M2PP >_ 0. 

8. B2DD cannot be purged if N0B2PP > 0. 

9. K2DD cannot be purged if N0K2PP > 0. 

4.66-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.66.5 Output Data Blocks 

MHH - Modal mass matrix - h set. 

BHH - Modal damping matrix - h set. 

KHH - Modal stiffness matrix - h set. 

PHIDH - Transformation matrix from d set to modal coordinates. 

Note : No output matrix can be purged. 

4.66.6 Parameters 

N0UE - Input-integer-no default. N0UE indicates presence and number of extra points. 
LM0DES - Input-integer-default = 0. LM0DES selects the first LM0DES eigenvectors (or all 

if there are less then LM0DES) to use for the modal coordinates. 
LFREQ - Input-real-default = 0.0. If LM0DES = 0, eigenvectors with eigenvalues between 

LFREQ and HFREQ are used in the modal formulation. 
HFREQ - Input-real -default = 0.0. See LFREQ. 

N0M2PP - Input-integer-no default. If N(3M2PP < 0, M2DD will not be used. 
N0B2PP - Input-integer-no default. If N0B2PP < 0, B2DD will not be used. 
N0K2PP - Input-integer-no default. If N0K2PP < 0, K2DD will not be used. 
N0NCUP - Output-integer-no default. If no direct input matrices exist the problem is 

considered uncoupled and N0NCUP is set to -1. 
FM(?DE - Output-integer-no default. The mode number of the first selected eigenvector 
is stored in FM(2IDE. 

4.66.7 Method 

The general system assembly nradule for the modal method is used when the real eigenvalues 
for the structure have been determined. With this n^thod, it is possible to decrease the order 
of the problem without sacrificing accuracy. The nx)dule forms the conversion matrix between 
modal displacements and all free physical displacements of the system. It then forms the general 
matrices in terms of displacements of the modes and the extra points. 



4.66-2 



FUNCTIONAL MODULE GKAM (GENERAL K ASSEMBLER MODAL) 

CASECC is read, and the selected structural damping table "id" is stored. 

LAMA is read and the selected eigenvalues are stored in core. If an eioenvalue is 
selected, the corresponding column of PHIA is copied onto PHIDHl , a scratch file. 

If extra points are not present (N0UE < 0), PHIDH = PHIDHl. If extra points are present; 



t*dh^ 







(i: 



This is accomplished in subroutine GKAMIB. 
The "H" matrices are formed: 



[M, J = 


m. 




'- hh-' 





I 


t^h^ = 





i °~ 
- 1 — 

1 °_ 


tw - 


\ 


1 o~ 





I 



' [^dhJ' t^dd^ to,,] , 



'■ dh-" '- dd-" "^ dh-' ' 



' ^W' tK^] C^dh^ ' 



(2) 



where m^ = diagonal terms of MI, and 



b. = m. to. g (oj. ), 



k. = m. ^. . 



(5) 
(6) 



OJ. is the frequency for the mode from LAMA and g (to.) is the tabular structural damping table 
selected in CASECC. If no selection is made g (w.) e 0.0. The "H" matrices are formed using 
subroutines GKAMIA, SSG2B, PRETAB, TA3, CALCV, MERGE. 



4.66.8 Subroutines 



4.66.8.1 Subroutine Name: GKAMIB. 

1. Entry Point: GKAMIB. 

2. Purpose: To construct [$,,] if extra points are present. 



4.66-3 



MODULE FUNCTIONAL DESCRIPTIONS 

3. Calling Sequence: CALL GKAMIB (USETD.SCRI ,SCR2,PHIOH,PHIDH1,M0DES,C!3RE,LHSET.N0UE) 

USETD - GIN0 file number of USETD - integer - input. 

SCR1 - GIN0 file number of 1st scratch file - integer - input. 

SCR2 - GIN0 file number of 2nd scratch file - integer - input. 

PHIDH - GIN0 file number of PHIDH - integer - input. 

PHIDHl - GIN0 file number of PHIDHl - integer - input. 

M0DES - Number of modes selected - integer - input. 

C0RE - Array of open core. 

LHSET - Length of h set - integer - output. 

N0UE - Extra point flag N0UE >^ indicates presence of extra points - integer - input. 

4.66.8.2 Subroutine Name: GKAMIA. 

1. Entry Point: GKAMIA. 

2. Purpose: To form [M^^^], [B^^], or [K^^^]. 

3. Calling Sequence: CALL GKAMIA (MI, PHIDH, DIT, SCRl ,SCR2,I0PT,IHH,NJ8I2DD,C0RE,M|»DES, 

SDITD,LHSET,I2DD,IMSKIP,SCR3) 

MI - GIN0 file number of MI - integer - input. 

PHIDH - GIN0 file number of PHIDH - integer - input. 

DIT - GIN0 file number of DIT - integer - input. 

SCRl - GIN0 file number of scratch 1 - integer - input. 

jCR2 - GIN0 file number of scratch 2 - integer - input. 

SCR3 - GIN0 file number of scratch 3 - integer - input. 

IHH - GIN0 file number of HH file (M, B, or K) being constructed - integer - input. 

I2DD - GIN0 file number of 2DD file being used with IHH (K2DD, M2DD or B2DD) - 
integer - input. 

I0PT - Flag for equation to use 

1 =^ MHH 

2 ===> BHH 

3 =^KHH 

4.66-4 



FUNCTIONAL MODULE GKAM (GENERAL K ASSEMBLER MODAL) 

- integer - input. 

N0I2DD - N0I2DD < implies I2DD purged - integer - input. 

M0DES - Number of modes selected - integer - input. 

SDTID - Id of structural damping table to ba used for BHH - integer - input. 

LHSET - Length of H set - integer - input. 

IMSKIP - Number of records to skip in MI before extracting diagonal terms - integer 
input. 

C0RE - Array of modes selected. 

4.66.9 Design Requirements 

Three scratch files are necessary. Open core at /GKAMlX/is used for mode storage. One 
oacked eigenvector must be held in core. 

4.66.10 Diagnostic Messages 

Fatal error messages 3007 and 3008 may be issued by GKAM. 



4,66-5 



FUNCTIONAL MODULE DDRl (DYNAMIC DATA RECOVERY - PART 1) 

4.67 FUNCTIONAL MODULE DDRl (DYNAMIC DATA RECOVERY - PART 1) 

4.67.1 Entry Point : DDRl 

4.67.2 Purpose : To transform modal solutions to physical solutions: 

{Uj} = [*dh] {u^} . (1) 

4.67.3 DMAP Calling Sequence 
DDRl UHV,PHIDH/UDV $ 

4.67.4 Input Data Blocks 

UHV - Solution set displacement vectors. 

PHIDH - Transformation matrix from d set to modal coordinates. 

4.67.5 Output Data Blocks 

UDV - Displacement vectors - d set. 

4.67.6 Parameters 

None 

4.67.7 Method 

Subroutine SSG2B is called to compute (u .} as in Equation 1. 

4.67.8 Subroutines 

DDRl has no auxiliary subroutines. See section 3.5.13 for a description of SSG2B. 

4.67.9 Design Requirements 

One scratch file is needed. 



4.67-1 



FUNCTIONAL MODULE DDR2 (DYNAMIC DATA RECOVERY - PART 2) 

4.68 FUNCTIONAL MODULE DDR2 (DYNAMIC DATA RECOVERY - PART 2) 

4.68.1 Entry Point : DDR2 

4.68.2 Purpose 

To compute mode acceleration displacements. 

4.68.3 DMAP Calling Sequence 

DDR2 USETD.UDV, PDF, K2DD,B2DD,MDD,FRL,ULL,LLL,DM/UDV1,UEVF,PAF/V,N,TYPE/V,N,N0UE/V,N, REACT/ 
V.N.FRQSET $ 

4.68.4 Input Data Blocks 

USETD - Displacement set definitions table dynamics. 

UDV - Displacement vectors - d set. 

PDF - Dynamic load matrix for frequency analysis - d set. 

K2D0 - Direct input stiffness matrix - d set. 

B2DD - Direct input damping matrix - d set. 

MDD - Dynamic mass matrix - d set. 

FRL - Frequency Response List. 

ULL - Upper triangular factor of KLL - i set. 

LLL - Lower triangular factor of KLL - I set. 

DM - Rigid body transformation matrix. 



Notes: 



1. USETD must not be purged. 

2. UDV must not be purged. 

3. PDF must not be purged. 

4. FRL must not be purged if TYPE - FREQ. 

5. MDD must not be purged. 

6. ULL, LLL must not be purged. 

7. DM must not be purged if REACT > 0. 



4.68-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.68.5 Output Data Blocks 

UDVl - Displacements after mode acceleration - d set. 

UEVF - Displacements at the extra points. 

PAF - Equivalent load vector for mode acceleration computations - a set. 

4.68.6 Parameters 

TYPE - Input-BCD-no default. TYPE determines the type of mode acceleration which will be 
used, TRAN for transient or FREQ for frequency response. 

N0UE - Input-integer-no default. N0UE >^ indicates presence of extra points. 

REACT - Input-integer-no default. REACT >_ indicates presence of supports. 

FRQSET - Input-integer-no default. FRQSET chooses the frequency list if TYPE = FREQ. 

4.68.7 Method 

The equivalent load vector is computed: 

{P^} = iP,} - [K^^] {u,} - [b2^] {u,} - [M,,] {u,} . (1) 

For a transient analysis problem (u,}, (Uj), and {li,} are given explicitly. For Frequency 
Response Analysis : 

{u^} = ioj {uj} , (2) 

{u^} = -i^' (Ujl. (3) 

where oj is the forcing frequency and {u.} is the complex response vector, w comes from FRQSET 
in FRL. The vector {P^} is the sum of applied loads and inertia loads due to the motion of the 
system approximated by its lower modes. The static solution using these loads will provide a 
better answer for displacements. 



4.68-2 



FUNCTIONAL MODULE DDR2 (DYANMIC DATA RECOVERY - PART 2) 
If extra points are present (N0UE ^0), tKen 



{P-} => ^..24 . (4) 



(u } is placed in data block UEVF. Subroutines CALCV and SSG2A perform this calculation. 



If supports are present (REACT > 0), then 



{Po> =>!----!> , (6) 



V 



p„ 



..> -) i-:^i . 



Solve for (u^}: 

a 



^^19) t^u^ K^ = K^ ■ (8) 



This is accomplished in subroutine SSG3A. 
If supports are present, then 



({u^ + [D] (u J] 



a ^ 



otherwise, {uf} = {u^}. Subroutine SD^IB performs this calculation. 

a Xf 



4.68-3 



MODULE FUNCTIONAL DESCRIPTIONS 



If extra points are present, then 

{uj} <— --?- . (10) 

Note: If the problem type is transient, {u^} must be merged with {ii ,} and {u .}. 

4.68.8 Subroutines Called 

CALCV - See section 3.5.5. 

SSG2A - See section 3.5.7. 

SSG2B - See section 3.5.13. 

SS63A - See section 3,5.18. 

SDRIB - See section 3.5.8. 

4.68.8.1 Subroutine Name: DDRIA. 

1. Entry Point: DDRIA. 

2. Purpose: To construct the equivalent load vector (Pj)- 

3. Calling Sequence: CALL DDR1A(PDF,K2DD,B2DD,MDD,UDV,PAF,FRL,FRQSET,SCR1 ,SCR2,SCR3,SCR4, 

TYPE,SCR5). 

PDF 

K2DD 

B2DD 

MDD 

GIN0 file number of appropriate data block - integer - input. 
UDV 

PAF 

FRL 

SCRl-5 

FRQSET - Frequency set 11st id - integer - input. FRQSET will be used only if TYPE = FREQ. 

TYPE - Problem type - BCD - input. 



4.68-4 



FUNCTIONAL MODULE DDR2 (DYNAMIC DATA RECOVERY - PART 2) 



4.68.8.2 Subroutine Name: DDRIB 



1 . Entry Point: DDRIB. 



2. Purpose: To merge displacements with previously computed velocity and acceleration in 
a transient problem. 

3. Calling Sequence: CALL DDRIB (UDV.UAD.UADV) . 

UDV - GIN0 file number of displacement, velocity and acceleration file - intener - innut. 

UAD - GIN0 file number of equivalent displacements - integer - input. 

UADV - GIN0 file number of new displacements, velocity and acceleration - integer - input, 

4.68.9 Design Requirements 

Open core for DDR2 begins at /DDRIX/. Open core for DDRIA begins /DDRAl/. Open core for 
DDRIB begins /DDRBl/. Six scratch files are needed. 

4.68.10 Diagnostic Messages 
None. 



4.68-5 



OUTPUT MODULE XYPL0T (X-Y DATA PLOTTER) 

4.69 OUTPUT MODULE XYPL0T (X-Y DATA PLOTTER) 

4.69.1 Entry Point : XYPL|3T 

4.69.2 Purpose 

To process Information supplied by module XYTRAN through a single data block and output 
to either PLTl (BCD plot tape) or PLT2 (binary plot tape) for labeling and plotting X-Y data 
on an off-line plotter. 

4.69.3 DMAP Calling Sequence 
XYPL0T XYPLTT// $ 

4.69.4 Input Data Blocks 

XYPLTT - Plotting Control Values Table. Note if XYPLTT is purged, XYPL0T returns 
control without action. 

4.69.5 Output Data Blocks 

None. (All output consists of physical tapes produced for off-line plotters and 
possibly user warning messages to the installation output unit for printing). 

4.69.6 Parameters 
None. 

4.69.7 Method 

XYPL0T initially determines open core size and assigns buffers for its input file and 
output file. The remaining core is used to store data points read in for each plot. The 
input file is then opened and spaced forward over the header record containing the data block 
name. Should the system not be able to locate this file, a warning message is output and 
XYPL0T returns control to the calling program without further action. Otherwise XYPL0T reads 
in the first I.D. record from the input file. A check is made to determine if the word count 
of this record is correct. If not, the following records are checked until either the correct 



4.69-1 



MODULE FUNCTIONAL DESCRIPTIONS 

word count is found or the error count reaches a specified limit. If the specified limit is 
reached, XYPL0T assumes the input file is invalid and returns control to the calling program 
after printing a warning message. 

If the I.D. record had the proper word count, XYPL0T checks if new axes are necessary. 
If not, the next data record is read, and the data pairs are plotted on the previous axes. When 
new axes are necessary, a check is made to determine if they go on the lower half of a plot. If 
not, XYPL0T makes a number of I.D. data validity checks. Whenever possible, where I.D. data are 
questionable, default values are assigned and processing continues following a warning message 
that this particular plot may be invalid. 

After the validity checks, XYPLjlT terminates the previous plot and initializes the plotting 
parameters for the NASTRAN plotting software. This is done for each new plot so that it is 
possible to produce alternate plots on two different plotters. Normally, however, plots will be 
done for only one plotter on any single entry to XYPL0T. If required, a new plot is initiated, 
and curve and axes titles are prepared from the I.D. data and generated. If not a new plot, only 
the axes titles are done. 

At this time XYPL0T computes the constants which will be used to transform the curve data 
into actual plotter counts. These constants are saved and used until new axes are drawn. 

Following this, XYPLf)T determines if any tick marks are to be placed along the X axis and 
at the X maximum and X minimum lines. If there are to be tick marks, the number and spacing 
(linear or logarithmic) is computed for them and plotted. As the X direction tick marks are 
prepared, a check is made to determine if Y grid lines are requested. If so, a grid line is 
prepared at each tick mark and plotted. Logarithmic tick mark labels are prepared and plotted 
at the same time as the tick marks and X grid lines, if any. 

After the tick marks are completed, the X and Y axes are plotted if requested. Finally 
the linear tick marks are labeled in both the X and Y directions if requested. 

Once the curve titles, tick marks, and labeling have been accomplished, XYPL0T reads in 
the next record from the input data file. Normally all the data pairs for any I.D. record can be 
brought into core memory with a single read. However, provision is made for additional reads if 
the open core space is not sufficient to contain all the data on the initial read. A check is 
made to determine if there are an even number of data values (i.e., an X and Y value for each data 

4.69-2 (12-1-69) 



OUTPUT MODULE XYPLF (X-Y DATA PLOTTER) 

point). If not, a warning message is printed and the last value ignored. The data are then 
checked against the previously defined X and Y minimums and maximums. Any data outside these 
limits are ignored and not plotted. The remaining data points are then converted to plotter counts 
and plotted in one of three modes. The three modes are: point plot with choice of symbol; line 
plot; combination of the first two. 

After finishing the data, XYPL0T reads in the next I.D. record and continues' as before until 
an end-of-file is reached. At this point it closes the input file, terminates the current plot 
and returns control to the calling program. 

4.69.8 Subroutines 

XYPL0T calls the following plotter utility subroutines: AXIS, LINE, PRINT, S0PEN, PLTSET, 
STPL0T, SYMB0L, TIPE, TYPFLT, and TYPINT. The descriptions of these subroutines may be found in 
section 3.4. 

4.69.9 Design Requirements 

4.69.9.1 Allocation of Core Storage 

XYPL0T uses open core for two GIN0 buffers and the remainder as one large buffer for data 
points. It appears as follows: 



4.69-3 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

Normally the data pairs buffer will be sufficiently large to hold all the data pairs for 
a single curve at one time. However, this is not necessary and XYPL0T could operate if the data 
pairs buffer were only two words long, although not efficiently. As an output module, XYPL0T 
has been programmed to avoid any system fatal errors. The worst condition that should occur is 
that no plots are produced. In all cases XYPL0T returns to the calling program so that other 
system functions may be continued. 

4.69.9.2 Environment 

The beginning of open core for XYPL0T is defined by /XYPLXX/. XYPL0T uses no scratch 
files. Common storage requirements consist of /XXPARM/ and /PLTDAT/ which are defined in the 
block data deck PL0TBD which must be loaded with XYPL0T. /CHAR94/ and SYMBLS/ are also defined 
in PL0TBD and are necessary for the subroutines called by XYPL0T. See section 2.5 for a 
description of these common blocks. 

When XYPL0T is called, there must be at least one physical tape set up to receive the 
plotted output, otherwise XYPL0T returns to the calling program without further action, 

4.69.10 Diagnostic Messages 

Diagnostic messages 991 through 997 may be output on the installation printer device as 
a result of XYPL0T operation. Generally they are self-explanatory and usually point out 
particular plots which are questionable rather than giving the user a precise method of 
solving the problem. This is not possible since XYPL0T receives all its information 
through a series of other modules rather than from the user directly. See section 6 of the 
User's Manual for details. 



4.69-4 



OUTPUT MODULE 0FP (OUTPUT FILE PROCESSOR) 

4.70 OUTPUT MODULE 0FP (OUTPUT FILE PROCESSOR) 

4.70.1 Entry Point : 0FP 

4.70.2 Purpose 

0FP outputs to the system output file, in user-oriented, self-explanatory formats, data 
blocks prepared for output by other functional modules, 

4.70.3 DMAP Calling Sequence 

0FP DB1,DB2,DB3,DB4,DB5,DB6//V,N,CARDN0 $ 

4.70.4 Input Data Blocks 

One to six input data blocks in the output order desired. Any or all input data blocks 
may be purged. 

4.70.5 Output Data Blocks 
None 

4.70.6 Parameters 

CARDN0 - Input and output - integer - default = 0. CARDN0 is incremented by one 
and punched in columns 73-80 for each card punched by 0FP. 

4.70.7 Method 

4.70.7.1 Overall Logic Flow 

The (3FP logic consists of defining one 6IN0 buffer and then entering one overall loop of 
six passes (one pass for each data block). All input data blocks are then handled identically 
one at a time. 

Within each data block, each odd numbered (Identification) record and its respective 
immediately following even numbered (Data) record are considered as a pair, and is a completely 
separate entity. There is, and need be, no correspondence between these two records and the 
previous two records, or between these two records and the following two records. 



4.70-1 



MODULE FUNCTIONAL DESCRIPTIONS 

Thus, within the loop for a given data block, after the file on which the data block resides 
is opened and its header record is skipped, 0FP reads an Identification record, defines various 
pointers and descriptors, and then, if any data are present in the Data record, processes this 
data line by line until the end-of-record is reached. This process continues for all Identifica- 
tion-Data record pairs. 

4.70.7.2 Defining Descriptors and Pointers 

Because (IFP was confronted with outputting a vast array of data classes having many data 
format and heading format configurations, it was decided that in order to keep UFP from be- 
coming a matimoth module of format statements, a system of pointers would be used in conjunction 
with all the different micro-format elements required. 

Information in the Identification record is sufficient to select an initial class pointer. 
This class pointer, with the addition of a subclass pointer, points to an array of six pointers, 
five of which define five micro-line formats (from the master set of micro-line formats), and one 
of which points to a string of micro-data format pointers. These micro-data format pointers then 
each point to a micro-data format capable of outputting a single variable. 

This design is such as to make possible the definition of macro-formats and to allow for 
easy modification and addition of more output data classes. 

4.70.8 Subroutines 

4.70.8.1 Subroutine Name: 0FPPUN 

1. Entry Point: UFPPUN 

2. Purpose: To write output on the system punch unit. 

3. Calling Sequence: CALL 0FPPUN (BUF,NWDS,I0PT,IDD,PNCHED) 
BUF - Array to be output. 

NWDS - Number of words in BUF to output. 
J ll = Vector output. 

"2 = General output. 

.0 = SgiRTl (1st word Integer). 
1 = SgiRT2 (1st word Real). 



4.70-2 



OUTPUT MODULE (3FP (OUTPUT FILE PROCESSOR) 

i -FALSE- = Punch heading cards. 
•TRUE- = Do not punch heading cards. 

4.70.8.2 Subroutine Name: iilFPI 

1. Entry Point: 0FP1 

2. Purpose: To call PAGE and write five micro-Hne formats. 

3. Calling Sequence: CALL (JFPl 

4.70.8.3 Subroutine Name: (JFPIA 

1. Entry Point: 0FP1A 

2. Purpose: An auxiliary routine to 0FP1. Called by 0FP1 only. 

3. Calling Sequence: CALL 0FP1A(LINE) 

LINE - Integer - Branch to format pointer. 

4.70.8.4 Block Data Subprogram Name: 0FP1BD 
0FP1BD defines common block /(ilFPBDl/. 

4.70.8.5 Block Data Subprogram Name: (JFPZBD 
0FP2BD defines common block /0FPBD2/. 

4.70.8.6 Block Data Subprogram Name: 0FP3BD 
0FP3BD defines common block /0FPBD3/. 

4.70.8.7 Block Data Subprogram Name: 0FP4BD 
0FP4BD defines comnr.on block 70FPBD4/. 

4.70.8.8 Block Data Subprogram Name: 0FP5BD 
0FP5BD defines common block /0FPBD5/. 



4.70-3 



MODULE FUNCTIOMAL DESCRIPTIONS 

4.70.9. Design Requirements 

The common blocks listed above interface between the main subroutines (JFP and 0FP1A. In 
addition C0MM(JN/0FPXXX/ is used to define open-core which contains the following. 



LI 
L2 
L3 
L4 
L5 

ID 



BUFF 



Five words which indicate the five format numbers 
defining the heading for the current data being output. 



A fifty word buffer for storage of the first fifty words 
of an identification record from the data block to be 
output. 



A GINU buffer. 



The pointer system required by the design operates as described below. The arrays B,C,D,E, 
and ESINGL, referenced in the discussion below appear in subroutine 0FP. 

1. The variable I is set equal to the Data type specified in the data block. The variable 
J is set equal to the class of data: 1 = Real - SjJRTl , 2 = Complex - S0RT1, etc. Then the 
base pointer, CP0INT = B{I,J), is found. 



B array 



Data type 1 
Data type 2 



Data type N 



S0RT 1 


S0RT 2 


Real 


Complex 


Real 


Complex 





130 


120 


132 


2 


134 


122 


136 


4 


138 


124 


140 


• 








• 








. 








, 








. 

















Example : 
For I = 2, J = 4. 



CP0INT = B(I,J) 
= 136 



For Futurei Expansion 



4.70-4 



OUTPUT MODULE laPP (OUTPUT FILE PROCESSOR) 

2. CP0INT is a index into the C array. Define: DP0INT = C(CP0INT). DP0INT is an Index 
into the D array. Also 

LI = C(CP(ilINT +1), 

L2 = C(CPUINT + 2), 

L3 = C(CP0INT + 3), 

L4 = C(CP0INT + 4), 

and L5 = C(CP0INT + 5). 

These are the 5 line format numbers which make up the heading format for the type of data 
currently being processed. 



C array 



1 


25 


2 


10 


3 


12 


. 


. 8 




^V 


• 


p"v. 


• 


• 


136 


DP0INT 


137 


LI 


138 


L2 


139 


L3 


140 


L4 


141 


L5 


• 


• 


* 


• 


^ 


.^ '~*v_^'^ v..^ 


F 


uture Expansion 
4.70-5 



MODULE FUNCTIONAL DESCRIPTIONS 

3. Word DPUINT of the D array defines the beginning of a string of pointers into the E array. 
This string is terminated by the first word containing a zero. Each word of this string thus 
defines a string of words in the E array which contains Hollerith data for construction of 
a format. Should a word in the D array be negative, the absolute value is used to point into 
the ESINGL array which contains Hollerith data also. 

D array 



DPjlINT-1 

DPUINT 

DP0INT+1 



\ 



-4 



10 




Future Expansion 



4.70-6 



OUTPUT MODULE 0FP (OUTPUT FILE PROCESSOR) 

4. The E array contains Hollerith data pertaining to the output of a variable; the ESINGL 
array contains Hollerith data pertaining to spacing and carriage control only. 



E array 



IPEl 



6.6, 



IPEl 



7.6. 



Flo. 



4.. 



E21, 



E22. 



ETC. 



Future Expansion 



ESINGL array 



IX. 



/15X 



/IHO 



IJote 



implies BCD 
blank 



ETC. 



Future Expansion 



4.70.10 Diagnostic Messages 

If, during some phase of outputting a data block, 0FP encounters an error condition, work on 
that data block will cease, a warning message will be printed, and a call to the NASTRAN table- 
printer for table printing of this data block will be made. 0FP will then continue processing the 
remaining input data blocks. 



4.70-7 



OUTPUT MODULE MATPRN (GENERAL MATRIX PRINTER) 

4.71 OUTPUT MODULE MATPRN (GENERAL MATRIX PRINTER) 

4.71.1 Entry Point : MATPRN. 

4.71.2 Purpose 

To print general matrix data blocks. 
^^.71.3 DMAP Calling Sequence 

MATPRN KGG,PL,PG,B2PP,UPV// $ 

4.71.4 Input Data Blocks 

KGG - Any matrix data block. 
PL - Any matrix data block. 
PG - Any matrix data block. 
B2PP - Any matrix data block. 
UPV - Any matrix data block. 

Notes : 

1. Any or all input data blocks can be purged. 

2. If any data block is not a matrix, the TABPT routine will be called. 

4.71.5 Output 

The non-zero band of each column of the input matrix is unpacked and is printed in single 
precision format on the system output file. 

4.71.6 Parameters 



None. 

4.71.7 Method 

Subroutine MATDUM is called for each non-purged input file. 

4.71.8 Subroutines 

MATDUM - See subroutine description, section 3.4.28. 



4.71-1 



OUTPUT MODULE MATGPR (DISPLACEMENT METHOD MATRIX PRINTER) 

4.72 OUTPUT MODULE MATGPR (DISPLACEMENT METHOD MATRIX PRINTER) 

4.72.1 Entry Point : MATGPR 

4.72.2 Purpose 

To print displacement method matrices, identifying values with external grid point numbers. 

4.72.3 DMAP Calling Sequence 

MATGPR GPL,USET,SIL,ANYMAT//C,N.C0LSET/C,N.R0WSET $ 

4.72.4 Input Data Blocks 

GPL - Grid Point List (This may also be GPLD if extra points are present.) 

USET - Displacement set definitions table (This may also be USETD if extra points 

are present.) 
SIL - Scalar Index List (This may also be SILD if extra points are present.) 
ANYMAT- Any displacement method matrix. 

Notes : 

1. Unless C0LSET = R0WSET = 'H'. GPL. USET and SIL must be present. 

2. If ANYMAT is purged, MATGPR will return. 

4.72.5 Output Data Blocks 

The non-zero terms of ANYMAT are given external identification and printed on the 
system output file. 

4.72.6 Parameters 

C0LSET - Input-BCD-no default. C0LSET indicates the set to which the columns of ANYMAT 
belong. If C0LSET is not one of the following: M.0.R.SG.SB.L.A,F.S.N.G.E.P.NE.FE.D,H then MATGPR 
will return. 

R0WSET - Input-BCD-default = X. R0WSET indicates the set to which the rows of ANYMAT 
belong. If R0WSET is not a legal set name, R0WSET = C0LSET. 



4.72-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.72.7 Method 

The BCD parameters C0LSET and RjJWSET are converted to bit positions in USET. C0LSET must 
be one of the following 17 symbols: M.0.R.SG.SB,L,A.F.S.N.G.E,P.NE.FE.D.H or else MATGPR will 
return. If ROWSET is not a legitimate symbol R0WSET = C0LSET. 

GPL, USET, and SIL are placed in core. Each column and non-zero row element is identified 
according to the following scheme: 

1. USET is searched for the number of members belonging to the g set (p set if USETD is 
used) before the current member of the matrix set. 

2. This number Is looked up in SIL to obtain the internal grid point number and type of 
point (scalar, grid, or extra). 

3. The Internal grid point number points into GPL for the external ID. 

4.72.8 Subroutines 

MATGPR has no auxiliary subroutines. 



4.72.9 Design Requirements 

1. Open core Is defined at /MPRTX/. 

2. Layout of open core is as follows: 

CgM MgN/MPRTX/ 
GPL 
USET 
SIL 



\ LGPL 
I LUSET 
I LSIL+1 



Buffer 



\ GINU buffer 



4.72-2 



OUTPUT MODULE MATGPR (DISPLACEMENT METHOD MATRIX PRINTER) 
4.72.10 Diagnostic Messages 

MATGPR may issue the following diagnostic messages: 
3007 and 3008. 



4.72-3 



OUTPUT MODULE MATPRT (MATRIX PRINTER) 

4.73 OUTPUT MODULE MATPRT (MATRIX PRINTER) 
4. 73 J Entry Point : PRTINT 

4.73.2 Purpose 

To print a matrix data block. 

4.73.3 DHAP Calling Sequence 
MATPRT X//C,N.RC/C,N,Y $ 

4.73.4 Input Data Block 

X - Matrix data block to be printed. If X is purged, then nothing is done. 

4.73.5 Output Data Blocks 
None. 

4.73.6 Parameters 

RC - Indicates whether X is stored by rows (RC = 1 ) or columns (RC = 0) - integer - input. 
Y - Indicates whether X is to be printed (Y < 0, do not print Xj Y > 0, print X) 
- Integer - input - default value = -1. 

4.73.7 Method 

Each column (or row) of the matrix is broken into groups of 6 terms (3 terms if complex) 
per printed line. If all the terms in a group = 0, the line is not printed. If the entire 
column (or row) = 0, it is not printed. If the entire matrix = 0, it is not printed. 

4.73.8 Subroutines 

4.73.8.1 Subroutine Name: INTPRT 

1. Entry Point: INTPRT 

2. Purpose: To print a matrix data block using subroutine MATPRT. 

3. Calling Sequence: CALL INTPRT (A,CR,0,NAME) 



4.73-1 



MODULE FUNCTIONAL DESCRIPTIONS 

where: 

A - Storage for 1 column (row) of the matrix + 1 GIN0 buffer. 



CR 



if the matrix is stored by columns. 

1 if the matrix is stored by rows. 



„ ( if the matrix is not to be printed. 
^ ■' 1 if the matrix is to be printed. 

NAME - 8 character name of the matrix (2 words, 4 characters per word). 

3. Method: Subroutine MATPRT is called to print the matrix. Whenever MATPRT returns 
for a matrix name or column/row id to be printed, the name of the matrix (NAME^ ,NAME2) 
or the column or row id (as indicated by 'CR'). is printed. 

4.73.8.2 Subroutine Name: MATPRT 

1. Entry Points: MATPRT, PRTMAT 

2. Purpose: To print a matrix data block. 

3. Calling Sequence: CALL MATPRT ($N^ ,$N2,A,i3PT.C(2LNUM) 

CALL PRTMAT (iN^.SNg) 

C0MM0N/XXMPRT/MCB(7) 

where: 

N-, - F0RTRAN statement number defining the return executed whenever a new page 
has been started (the calling program is expected to print the matrix and 
column id, C0LNUM = current column number), 

N„ - F0RTRAN statement number defining the return executed whenever the column 

id must be printed in the middle of a page (CCILNUM = current column number). 

A - Storage for 1 column of the matrix + one GIN0 buffer. 

0PT - See subroutine description for VECPRT, below, for the explanation of 
this argument. 

C0LNUM - Current column number being printed (output). 

MCB - Matrix control block. 



4.73-2 



OUTPUT MODULE MATPRT (MATRIX PRINTER) 

3. Method: The matrix is unpacked and printed one column at a time. Whenever either of 
the nonstandard returns ($Np$N2) is executed, the calling program must call PRTMAT to 
continue the printing of the matrix. 

4. Additional Subroutines Called: VECPRT. 
4.73.8.3 Subroutine Name: VECPRT 

1. Entry Points: VECPRT, PRTVEC 

2. Purpose: To print a vector. 

3. Calling Sequence: CALL VECPRT ($Np$H2'P''^''^>0PT} 

CALL PRTVEC ($N-|,$N2) 
where: 

N^ - FORTRAN statement number defining the return executed whenever a new page 

has been started (the calling program is expected to print the vector id and 
any other subtitles desired). 

Ng - F0RTRAN statement number defining the return executed whenever the vector 
id is to be printed in the middle of a page. 

P - Vector type and precision. 

N - Number of components in the vector. 

A - Location of the vector. 

= if all the vector components are to be printed, regardless of its 
sparsity, and if it is to be printed starting on a new page if it 
will not fit on the current page. 



0PT - 



+1 if only the printed lines which would have at least one non-zero 
component are to be printed, and if the vector is to be printed starting 
on a new page if it will not fit on the current page. 

-1 if only the printed lines which would have at least one non-zero 
component are to be printed, and if as much of the vector as possible 
is to be printed on the current page. 

3, Method: The vector will be printed as a single precision real or complex vector. The 
components will be printed 6 per line if real, 3 per line if complex. In addition, the 
first and last components of each line will be identified on each side of the line by 
their respective component members. In addition whenever either of the nonstandard 



4.73-3 



MODULE FUNCTIONAL DESCRIPTIONS 

returns ($N,,$N2) is executed the calling program must call PRTVEC to continue the printing 

of the vector. 

4. Additional Subroutines Called: F0RMAT. 

4.73.8.4 Subroutine Name: F0RMAT 

1. Entry Point: FORMAT 

2. Purpose: To print a line of 1 to 6 real numbers (optionally centered) preceded and 
followed by integer id's of the first and last number printed. 

3. Calling Sequence: CALL FORMAT (A.Nl .N2.N3,L1 ,L2) 

where: 

A - Array from which the 1 to 6 real numbers are to be printed. 

Nl - Index of the 1st number in the array to be printed. 

N2 - Index of the last number in the array to be printed. 

N3 - Increment to be used In extracting the 2nd, 3rd, etc., numbers in the 

array to be printed. 

LI - Integer id of the 1st number to be printed. 

L2 - Integer id of the last number to be printed. 

3. Method: If LI and L2 are both positive, the numbers will be centered on the page. 
If either LI or L2 is not positive, the numbers will be printed based upon the 
centering of 6 numbers. 

4.73.9 Design Requirements 

Open core is defined at /XXPRTI/. Open core contains one GINI3 buffer followed by one 
unpacked real or complex single precision column of the matrix. 



4.73-4 



OUTPUT MODULE SEEMAT (PICTORIAL MATRIX PRINTER) 

4.74 OUTPUT MODULE SEEMAT (PICTORIAL MATRIX PRINTER) 

4.74.1 Entry Point : SEEf^AT 

4.74.2 Purpose 

To show nonzero matrix elements on printer or plotter output positioned pictorially by 
row and column within the outlines of the matrix. 

4.74.3 DMAP Calling Sequence 
SEEMAT M1.M2,M3,M4,M5//C,N,|^^^|/V,N,PFILE/V,N,PACK/C,N,PL0TTER/C,N,M0DELN1/C,N, 

M0DELB1/C,N,M0DELN2/C,N,M0DELB2 $ 

Note that parameters PL0TTER, MjIDELNl , M0DELB1 , M(3DELN2 and M(3DELB2 are all described in 
paragraph 4 in section 4.74.6. 

4.74.4 Input Data Blocks 

Ml 

M2 

M3 ) Matrix Data Blocks, any of which may be purged. 

M4 

M5 

4.74.5 Output Data Blocks 

None. The formatted matrix picture is output on the system output file or on a plot tape 
depending on the value of the first parameter. 

4.74.6 Parameters 

1. PRINT implies use of the system output file. (Any value other than PL0T iniplies PRINT). 
PL0T implies use of one of the plotters. Either of the plotter tapes PLTl or PLT2 will be 
used, depending on the type of plotter requested. 

2. PFILE is the plot number (Used only if first parameter is PL0T). 

Input/output variable integer parameter. Frame or sheet number. The value of this 
parameter will be incremented by one (1) for each frame (sheet) created by SEEMAT. 

The default value for this parameter is 0. 

3. PACK is reserved for a future modification that will allow the representation of a nonzero 
block of the matrix with a single character. This parameter may be specified as C,N only, 
(see example in paragraph 4 below) 

4.74-1 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

4. Plotter Name and Model Identification (Used only if parameter 1 = PL0T.) 

Each plotter name has associated with it two model identifiers. Each of these model 
identifiers may either be an integer (M0DELNi) value or BCD (M0DELBi) value. If model 
identifier "i" (i = 1, 2) is an integer, insert its value for M0DELNi; if model identifier 
"i" (i = 1, 2) is BCD, insert its value for M0DELBi. In either case, specify the other 
value for model identifier "i" (M0DELBi and M|3DELNi , respectively) as C.N only. 

Below is a list of model identifiers allowable for each plotter name. A detailed 
explanation of this list can be found in section 4 of the User's Manual. Each plotter has 
associated with it a default model and several optional models. The model underlined is the 
default model. To access this default model, do not specify any of the last four DMAP 
parameters. For example to specify the CALC0MP 765, 205 (see section 4 of the User's Manual) 
the following DMAP statement may be used: 



SEEMAT 



Ml ,M2,M3,M4,M5//C,N,PL(3T/V,N,PFILE/C,N/C.N,CALC|i)MP $ 



Plotter Name 



BL 



EAI 
SC 



CALC0MP 



Model Identifiers 



i LTE.30 \ 
lSTE,3Q) 

i 3500.300 \ 
(3500.45 / 



4020.0 

765.205 
TStTTfO 

765,105 

765,110 

763,205 

763,210 

763,105 

763,110 

565,205 

565,210 

565,105 

565,110 

565.305 

565,310 

563,205 

563,210 



4.74-2 (12-1-69) 



OUTPUT MODULE SEEMAT (PICTORIAL MATRIX PRINTER) 



Plotter Name 



DD 



NASTRAN 



Model Ident i f i ers 

563,105 

563,110 

563,305 

\ 563,310/ 

80, B 

MjO 

t!o 

0,0 
M,l 
T.l 
0.1 



where: 



BL is a Benson-Lehner plotter 

EAI is an Electronic Associates plotter 

SC is a Stromberg Carlson plotter 

CALC0MP is a California Computer plotter 

DD is a Oata Display plotter 

NASTRAN is the NASTRAN general purpose plotter 

4.74.7 Method 

The matrix is partitioned into blocks which can be printed on a single sheet of output paper 
or plotted on a single frame or sheet of plotter output media. Only blocks containing nonzero 
elements will be printed. Row and column indices are indicated. The user of this module is 
cautioned to make sure that his line count limit is large enough. A default of 20,000 lines is 
provided by NASTRAN. This may be changed via the statement "MAXLINES = value" in the NASTRAN 
Case Control Deck, The transpose of the matrix is always printed. 

The columns of the matrix are examined for nonzero terms. Let the matrix be partitioned 
into blocks, where a block consists of NL columns and 100 rows, where NL is the number of data 
lines per page obtained from /SYSTEM/. For each block containing nonzero terms, a BCD block 
image is stored in open core in packed bit format. Only blocks containing nonzero terms are 
stored. When NL columns have been passed, the blocks containing nonzero terms are printed on 



4.74-3 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

the system output file or plotted. Note that since NASTRAN matrices are stored by column, the 
transpose of the matrix is what actually appears on the printed or plotted output. Blocks used 
for the first NL columns may now be re-used for subsequent groups of NL columns. This process 
i continued until all columns of the matrix have been processed. As many as five matrices may 
be handled during a single call to SEEMAT. 

4.74.8 Subroutines 

The plotter environment subroutines are utilized by SEEMAT. See section 3.4 for descriptions 
of the plotter utility routines. 

4.74.9 Design Requirements 
4.74.9.1 Open Core Design 



C0MM(aN/SEEMTX/ 





block 1 


• 
■ 


; block 2 


• 


' block 3 


' 


, 


block i 


\ 




block n 


1 
\ 


unused open core 


• 


GIN0 buffer 


• 


S6IN0 buffer 
(if needed) 



\ 











Typical Block 


/' Word 


1 

2 
3 

6 
10 


1st row no. - 1 


Word 


1st col no. - 1 


Word 


Col 1 


(100 bits (3 32 bits/word) 


Word 




Col 2 (100 bits @ 32 


; 


bits/w 


ore 


1 


Word 












; 








\ 
\ 


Col NL 


( 


00 bits (332 bits/word) 


v._.. 


not used 



4.74-4 (12-1-69) 



OUTPUT MODULE SEEMAT (PICTORIAL MATRIX PRINTER) 

4.74.9.2 Data Requirements and Restrictions 

1. All nonpurged input data blocks must be matrices. Error diagnostics will occur in the 
unpacking routines if an attempt is made to input a table data block to SEEMAT. 

2. If the number of blocks needed overflows the available open core (e.g., a large full 
matrix can do this), a nonfatal diagnostic message will be output on the System Output File 
and processing for that matrix will be terminated. The user may decrease NL by adding a 
Case Control Card LINE = NL as a means of overcoming this restriction (printer only). Since 
the type of matrix for which one is interested in seeing the topology is usually sparse and 
at least partially banded, this restriction should not prove serious. 

4.74.10 Diagnostic Messages 

Diagnostic conditions detected by SEEMAT are nonfatal and result in appropriate error 
messages and termination of the processing of the current input matrix data block. The one 
exception is the condition of no open core for GIN0 buffers, which should not occur in practice. 



4.74-5 (12-1-69) 



OUTPUT MODULE TABPT (TABLE PRINTER) 

4.75 OUTPUT MODULE TABPT (TABLE PRINTER) 

4.75.1 Entry Point : TABPT. 

4.75.2 Purpose 

To print table data blocks. 

4.75.3 DMAP Calling Sequence 

TABPT TAB1,TAB2,TAB3,TAB4,TAB5// $ 

4.75.4 Input Data Blocks 

TAB! - Any NASTRAN data block. 

TAB2 - Any NASTRAN data block. 

TABS - Any NASTRAN data block. 

TAB4 - Any NASTRAN data block. 

TABS - Any NASTRAN data block. 

Note: Any or all input data blocks can be purged. 

4.75.5 Output 

Each word in a data block is identified as real , BCD, or integer and printed on the system 
output file. The trailer data is also printed. 

4.75.6 Parameters 
None. 

4.75.7 Method 

Subroutine TABPRT is called for each non-purged input file. 

4.75.8 Subroutines 

TABPRT - See subroutine description, section 3.4.29. 



4.75-1 



OUTPUT MODULE PRTMSG (MESSAGE WRITER) 
4.76 OUTPUT MODULE PRTMSG (MESSAGE WRITER) 

4.76.1 Entry Point : PRTMSG 

4.76.2 Purpose 

To process a data block of user-oriented messages. 

4.76.3 DMAP Calling Sequence 
PRIMSG MSG// $ 

4.76.4 Input Data Blocks 

MSG - Messages to be printed (if purged, nothing is done). 

4.75.5 Output Data Blocks 
None 

4.76.6 Parameters 
None 

4.76.7 Method 

In addition to messages, the MSG data block may contain titles and subtitles. Before 
the first message is printed, a new page is started. From then on, a message count is main- 
tained so as to start another new page when the maximum number of lines per page is exceeded. All 
messages are assumed to be only one line long. However, there is logic included to provide 
for messages of more than one line, forcing a new page at any time, and the alteration of 
titles and subtitles at any time. The description below of subroutine WRTMSG details all the 
included logic capability. 

4.76.8 Subroutines 

PRTMSG uses the utility routines EJECT and FREAD (see sections 3.4.62 and 3.4.15). 
4.76.8.1 Subroutine Name: PRTMSG 



4.76-1 



MODULE FUNCTIONAL DESCRIPTIONS 

1. Entry Point: PRTMSG 

2. Purpose: To print the user messages in the MSG data block. 

3. Calling Sequence: CALL PRTMSG 

C(JMM0N/0UTPUT/TITLE(32,6) - See 0UTPUT miscellaneous table description in section 2.5. 

Where: 

TITLE = NASTRAN title, subtitle, label, and three extra subtitles. 

4. Method: Open the MSG data block, and skip record 0. If the MSG data block does not 
exist, nothing else is attempted. Otherwise, the three extra subtitles are set to all 
blanks, and WRTMSG is called. 

4.76.8.2 Subroutine Name: WRTMSG (General purpose subroutine) 

1. Entry Point: WRTMSG 

2. Purpose: To process a data block of user-oriented messages. 

3. Calling Sequence: CALL WRTMSG (MSG) 

C(ilMM(»N/SYSTEM/ - See SYSTEM table description in section 2.4.1.8. 

Where: 

MSG = GINU file name of the MSG data block, 
and in /SYSTEM/ 

MAXLIN = Maximum number of lines permitted per page. 

CI8UNT = Number of lines thus far printed on the current page. 

4. Method: 

a. Save the current NASTRAN title, subtitle, and label. Force the first message 
to start on a new page (C|aUNT=MAXLIN). 

b. Read one word (N) from MSG. If an end-of-record condition occurs, force the 
first message in the next record to start on a new page (C0UNT=MAXLIN). Then 
repeat this step . 

c. If N < 0, the next 32 words are assumed to be a replacement for TITLE (1-32, N). 
Force the next message to start on a new page (C0UNT=MAXLIN). Repeat step b . 



4.76-2 



OUTPUT MODULE PRTMSG (MESSAGE WRITER) 

d. If N > 0, a list and format follow. The next N items are assumed to be 
the list items. If N = 0, only a format follows. 

e. Read one word (NF) from MSG. If NF < 0, NF = number of lines to be generated 

by this message ( repeat this step ). If NF = 0, this message will be printed starting 
on a new page. (C0UNT=MAXLIN, repeat this step ). Unless otherwise instructed, this 
subroutine assumes that each message will generate only 1 line of output. In either 
case, integer function EJECT is called to maintain the page line count. If this 
message will not fit on this page, any extra title(s) explicitly specified are printed 
below the NASTRAN title, subtitle, and label. 

f. If NF > 0, NF = size of the format (the format must be a continuous string of 
characters, contrary to the usual NASTRAN method of specifying at most 4 characters per 
word). The next NF words are assumed to be the format to be used with the list 

items read in step d , in one the following F0RTRAN statements: 

WRITE (M0,F0R) [if no list is specified], 
or 

WRITE (M0,F0R) (LIST(I), I = 1 ,N) 
Repeat step b . 

g. When the end of the MSG data block is encountered in step b, the NASTRAN title, 
subtitle, and label are restored, and the MSG data block is closed with a rewind. 

5. Design Requirements: 

a. The message data block (MSG) must be opened before calling WRTMSG. 

b. In general, a set of messages is one record of the data block. Each set of 
messages will start on a new page. 

4.76.9 Design Requirements 

Open core is defined at /XXPMSG/, and is used only for one GIN0 buffer which is defined 
at the beginning of open core. 



4.76-3 



OUTPUT MODULE PRTPARM (PARAMETER AND DMAP MESSAGE PRINTER) 
4.77 OUTPUT MODULE PRTPARM (PARAMETER AND DMAP MESSAGE PRINTER) 

4.77.1 Entry Point : PRTPRM 

4.77.2 Purpose 

To print parameter values and DMAP messages. 

4.77.3 DMAP Calling Sequence 
PRTPARM //C.N.a/C.N.e $ 

4.77.4 Input Data Blocks 
None 

4.77.5 Output Data Blocks 
None 

4.77.6 Parameters 

a - Integer value (no default value) 

6 - BCD value (default value = XXXXXXXX) 

4.77.7 Method 

As a parameter printer, use a = 0, There are two options: 

1. 3 = parameter name will cause the printout of the value of that parameter. 
Example: PRTPARM //C.N.O/C.N.LUSET $ 

2. e = XXXXXXXX will cause the printout of the values of all parameters in the 
current XVPS. Since this is the default value, it need not be specified. 

Example: PRTPARM //C.N.O $ 
As a DMAP message printer, use a ^ 0. There are two options: 

1. a > causes the printout of the j message of category 2 where j = |a| and g is one 
of the values shown below. (The number of messages available in each category is also 
shown). 

Example: PRTPARM //C,N,1/C,N,DMAP $ 

4.77-1 



MODULE FUNCTIONAL DESCRIPTIONS 

2. a < causes the same action as a > with the additional action of program 
termination. Thus, PRTPARM may be used as a fatal message printer. 
Example: PRTPARM //C,N,-2/C,N,PLA $ 

4.77.8 Remarks 



1. & is always a value. 



TABLE OF B CATEGORY VALUES 



Number of 
Rigid Format 

Static Analysis 

Static Analysis with Inertia Relief 

Normal Mode Analysis 

Static Analysis with Differential Stiffness 

Buckling Analysis 

Piecewise Linear Analysis 

Direct Complex Eigenvalue Analysis 

Direct Frequency and Random Response 

Direct Transient Response 

Modal Complex Eigenvalue Analysis 

Modal Frequency and Random Response 

Modal Transient Response 

DMAP 

3. For details on error messages for the i Rigid Format see section 3.(1 + 1).2 
in the User's Manual. 



Value of Beta 


Messages 


STATICS 


4 


INERTIA 


4 


M0DES 


4 


DIFFSTIF 


6 


BUCKLING 


7 


PLA 


6 


DIRCEAD 


5 


DIRFRRD 


6 


DIRTRD 


5 


MDLCEAD 


6 


MDLFRRD 


7 


MDLTRD 


7 


DMAP 


1 



4.77.9 Subroutines 



PRTPRM has no auxiliary subroutines. 



4.77-2 



OUTPUT MODULE PRTPARM (PARAMETER AND DMAP MESSAGE PRINTER) 
4.77.10 Diagnostic Messages 

Values of a and e inconsistent with the above under "Method" will result in diagnostic 
messages from PRTPARM. 



4.77-3 



MATRIX MODULE ADD (ADD TWO MATRICES) 

4.78 MATRIX MODULE ADD (ADD TWO MATRICES) 

4.78.1 Entry Point : DADD 

4.78.2 Purpose 

To compute [C] = a [A] + & [B]. 

4.78.3 DMAP Calling Sequence 

ADD A,B/C/C,Y,ALPHA=(1.0,2.0)/C,Y,BETA«(3.0,4.0) $ 

4.78.4 Input Data blocks 

A - Any matrix ^ B 
B - Any matrix j* A 

Note : A and/or B can be purged. 

4.78.5 Output Data Blocks 

C - Matrix. 

The type of C is maximum of the types of A, B, a, g. The shape of C is the shape of A if A 
is present. Otherwise it is that of B. 

Note : C cannot be purged. 

4.78.6 Parameters 

ALPHA - Input-complex-no default value. This is the scalar multiplier for A. 
BETA - Input-complex-no default value. This is the scalar multiplier for B. 

Note : If Im(a) or Im(6) = 0.0, the parameter will be considered real. 

4.78.7 Method 

If [A] is not purged, the number of columns, rows, and form of [C] = number of columns, rows, 
and form of [A]. Otherwise the [B] descriptors are used. The type of [C] is the maximum 
compatible type of [A], [B], ALPHA and BETA. ALPHA and BETA are assumed to be real if their 
imaginary parts are zero. 



4.78-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.78.8 Subroutines 

ADD - See subroutine description, section 3.5.10. 

4.78.9 Design Requirements 

Open cor-e Is defined at /DADDA/. 



4.78-2 



MATRIX MODULE MPYAD (MULTIPLY ADD) 

4.79 MATRIX MODULE MPYAD (MULTIPLY ADD) 

4.79.1 Entry Point : DMPYAD 

4.79.2 Purpose 

MPYAD performs the muUi plication of two matrices and, optionally, addition of a third 
matrix to the product: [D] = [A][B] +[C] 

4.79.3 DMAP Calling Sequence 

MPYAD A.B,C/D/C,N,T/C,N,SIGNAB/C,N,SIGNC/C,N,PREC $ 

4.79.4 Input Data Blocks 

A - Left hand matrix in the matrix product [A][B] 
B - Right hand matrix in the matrix product [A][B] 
C - Matrix to be added to [A][B] 
Notes : 

1. If no matrix 1s to added, C must be purged. 

2. A, B, C must be physically different data blocks. 

3. A and B must not be purged. 

4. Either A or B (but not both) may be a NASTRAN diagonal matrix. In this case, 
C must be purged. 

4.79.5 Output Data Block 

D - Matrix resulting from the MPYAD operation. 
Note : D may not be purged. 



4.79.6 Parameters 



- Integer-input-no default. 



1, perform [A] [B] 
0, perform [A][B] 



4.79-1 



MODULE FUNCTIONAL DESCRIPTIONS 

C+1, perform [A][B] 



SIGNAB - Integer-input-no default. 



SIGNC 



Integer-input-no default. 



PREC - Integer-1nput-no default. 



SIGNAB 



SIGNC 



PREC 



^-1, perform -[A][B] 

;+l. add[C] 
(-1, subract [C] 

J, elements of [D] will be output in 
jslngle-precision. 

h, elements of [D] will be output in 
(double-precision. 



4.79.7 Examples 

1. [D] = [A][B] + [C] {D double precision) 
MPYAD A,B,C/D/C.N,0/C,N.1/C,N,2 $ 

2. [D] = [A]^[B] - [C] (D single precision) 
MPYAD A,B,C/D/C,N,1/C,N,1/C,N,-1/C.N,1 $ 

3. [D] = -[A][B] (D double precision) 

MPYAD A,B,/D/C,N.0/C,N.-1/C,N,0/C,N,2 $ 

4.79.8 Method 

DMPYAD reads the trailers for the data blocks A, B and C. /MPYADX/ is initialized. If 
neither [A] nor [B] is diagonal, MPYAD is called, the trailer for D is written, and the module 
exits. Otherwise, /DMPYX/ is initialized, and DMPY is called to perform the diagonal 
multiplication. If the matrix [C] is present, /ADDX/ is initialized, and ADD is called to perform 
the matrix addition. The trailer for D is written and the module exits. 

4.79.9 Subroutines 

DMPYAD calls the following matrix operations: 

MPYAD (see section 3.5.12 for details) 
DMPY (see section 3.5.21 for details) 
ADD (see section 3.6.10 for details) 

4.79.10 Design Requirements 
4.79.10.1 Allocation of core storage 



4.79-2 



MATRIX MODULE MPYAD (MULTIPLY ADD) 

See descriptions for MPYAD, DMPY and ADD. 
4.79.10.2 Environment 

The module MPYAD consists of one subroutine, DMPYAD. One scratch file is used. Three 
common blocks define open core, one for each of the three overlay segments containing the 
matrix operations: 

/MPYAID/ included at end of segment containing MPYAD. 
/MPYA2D/ included at end of segment containing DMPY. 
/MPYA3D/ included at end of segment containing ADD, 



4.79-3 



MATRIX MODULE S!3LVE (SOLVES THE MATRIX EQUATION [A][X] = [B]) 



4.80 MATRIX MODULE S0LVE (SOLVES THE MATRIX EQUATION [A][X] = [B]) 

4.80.1 Entry Point : S0LVE 

4.80.2 Purpose 



To solve the matrix equation. 



4.80.3 DMAP Calling Sequence 



[A][X] = + [B] 



S0LVE A,B/X/V,Y.SYM/V,Y,SIGN/V,Y.PREC/V,Y,TYPE $ 

4.80.4 Input Data Blocks 

A - A square real or complex matrix. 
B - A rectangular matrix. 

Note: If B is purged, the identity matrix is assumed. 

4.80.5 Output Data Blocks 



- A rectangular matrix. 



4.80.6 Parameters 



SYM - Input-integer-default = 



- use unsymmetric decomposition 

1 - use symmetric decomposition. 

'-1 - try symmetric decomposition, ust 
unsymmetric if [A] is singular. 



(1) 



SIGN - input-integer-default = 1 



PREC - Input-integer-default = 1 



TYPE - Input-integer-default = 1 



1 - solve [A][X] = [B] 
-1 - solve [A][X] = -[B] 

1 - use single precision arithmetic 

2 - use double precision arithmetic 

1 - output type of matrix [X] Is real 

single precision 

2 - output type of matrix [X] Is real 

double precision 



4.80-1 



MODULE FUNCTIONAL DESCRIPTIONS 



3 - output type of matrix [X] is complex 
single precision 

4 - output type of matrix [X] is complex 
double precision 

4.80.7 Method 

Depending upon the SYM flag and the type of [A], either SDC0MP CDC0MP, or DEC0MP 
is called to form 

[A] = [L][U] . (2) 

FBS or GFBS is called to solve 

[L][Y] = 1 [B] . (3) 

and 

[U]CX] = [Y] . (4) 

4.80.8 Subroutines 

The above mentioned subroutines are the only ones called by S0LVE and are documented 
in section 3.5. 

4 . 80 . 9 Design Requirements 

The appropriate subroutines should be referenced for the design requirements peculiar 
to each routine. 

4.80.10 Diagnostic Messages 

The individual routines should be referred to for diagnostic messages. 



4.80-2 



MATRIX MODULE DEC0MP (MTRIX DECOMPOSITION) 



4.81 MATRIX MODULE DEC0MP (MATRIX DECOMPOSITION) 

4.81.1 Entry Point: DDC0MP 

4.81 .2 Purpose 

To decompose a square matrix [A] into lower [L] and upper [U] triangular factors. 

4.81.3 DMAP Calling Sequence 

DEC0MP A/L,U/V,Y.KSYM/\/.Y.CH0LSKY/V.N.MINDIAG/V,N.DET/V.N,P0WER/V.N.SING $ 

4.81.4 Input Data Blocks 

A - A square matrix. 

4.81.5 Output Data Blocks 



L 
U 

4.81.6 Parameters 

KSYM 

CH0LSKY 

MINDIAG 
DET 

P0WER 

SING 
4.81.7 Method 



Lower triangular factor of [A]. 
Non-standard upper triangular factor of [A], 



- Input-integer-no default. 1 . use symmetric decomposition. 0, use 
unsymmetric decomposition. 

- Input-integer-default = 0. 1, use Cholesky decomposition. 0. do not 
Cholesky decomposition. 

- Output-real-no default. The minimum diagonal term of [U]. 

- Output-complex single precision-no default. The scaled value of the 
determinant of [A]. 

- Output-integer-no default. Integer P0WER of 10 by which DET should 
be multiplied to obtain the determinant of [A]. 

- Output-integer-no default. SING is set to -1 if [A] is singular. 



use 



Depending upon the type of [A] and the KSYM flag, a calli 



ng sequence is set up, and either 



4.81-1 



MODULE FUNCTIOMAL DESCRIPTIONS 

CDCjIMP, DEC0MP, or SDC(3MP is called. 

4.81.8 Subroutines 

The major subroutines used are DEC0MP. CDC0MP and SDC0MP. Descriptions of these sub- 
routines can be found in sections 3.5.15. 3.5,16. and 3.5.14 respectively. 

4.81.9 Design Requirements 

The individual subroutine writeups should be consulted for the particular restrictions 
of each routine. 

4.81.10 Diagnostic Messages 

See the appropriate subroutine descriptions. 



4.81-2 



MATRIX MODULE FBS (FORWARD-BACKWARD SUBSTITUTION) 

4.82 MATRIX MODULE FBS (FORWARD-BACKWARD SUBSTITUTION) 

4.82.1 Entry Point : DFBS 

4.82.2 Purpose 

To solve the equation, 

[L] [U] [X] = ± [B] (1) 

where [L] and [U] are the upper and lower triangular factors obtained via matrix module DEC0MP. 

4.82.3 DMAP Calling Sequence 

FBS L,U,B/X/C,N,A/C,N,B/C,N,C/C,N,D $ 

4.82.4 Input Data Blocks 

L.U - Matrices output from module DEC0MP. 
B - Rectangular matrix. 

4.82.5 Output Data Blocks 

X - Rectangular matrix. 

4.82.6 Parameters 

1 matrix [L][U] is symmetric 



- Input-integer-no default. -j 

matrix [L][U] is unsymmetric 

. . , P s°1ve [L][U3[X] = [B] 
Input-integer-no default,< 

<-l solve [L][U][X] = -[B] 

I 1 - use single precision arithmetic 
Input-integer-no default.] 

' 2 - use double precision arithmetic 



D 
4.82.7 Method 



"i: 



- Input-integer-no default.fl - output [X] in single precision 

.2 - output [X] in double precision 



Depending upon the value of the parameter A, either FBS or GFBS is called. 



4.82-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.82.8 Subroutines 

The above routines are the only ones called by DFBS. Their descriptions are given in 
section 3.5.17 for FBS and 3.5.19 for GFBS. 

4.82.9 Design Requirements 

The appropriate routines should be referenced for their individual requirements. 

4^82.10 Diagnostic Messages 

The individual subroutines should be referred to for the messages. 



4.82-2 



MATRIX MODULE PARTN (PARTITION A MATRIX) 

4-83 MATRIX MODULE PARTN (PARTITION A MATRIX) 

4.83.1 Entry Point : PARTNX. 

4.83.2 Purpose 

To partition [A] into [All], [A12], [A21] and [A22]: 



[A]==> 



All ■ A21" 
I 



A12 1 A22 



(i: 



4.83.3 DMAP Calling Sequence 

PARTN A,RP,CP/A11,A12,A21,A22/V,Y,SYM/V,Y.TYPE/V.Y,F0RM1/V,Y,F0RM2/V,Y.F0RM3/V,Y.F0RM4 $ 

4.83.4 Input Data Blocks 

A - Matrix to be partitioned. 

RP - Row partitioning vector - single precision column vector. 

CP - Column partitioning vector - single precision column vector. 



Notes 



1. If A is purged, PARTN returns. 

2. If RP is purged, A is partitioned as follows: 



[A]==> 



All 



A12 



3. If CP is purged and SYM > 0, A is partitioned as foil 



ows; 



[A] =^ [Alii A21]. 
4. If CP is purged and SYM ^ 0, A is partitioned as follows: 



[A] =^ 



All I A21 



Lai 2 ' A22_ 



where RP is used as both the row and column partitioner. 
5. RP and CP cannot both be purged. 



(2) 



(3) 



(4) 



4.83-1 



MODULE FUNCTIONAL DESCRIPTIONS 



4.83.5 Output Data Blocks 

A11 - Partition of A. 
A12 - Partition of A. 
A21 - Partition of A. 

A22 - Partition of A. 

Notes: 



1. Any or all output data blocks can be purged. 

2. For the shape of outputs (number of rows and columns) see section 4.83.7 below. 

4.83.5 Parameters 

SYM - Input-integer-no default. SYM chooses between a symmetric partition and an 

unsymmetric partition. If SYM < 0, CP is used as RP. If SYM > 0, CP and RP are 
distinct. 

TYPE - Input-integer-no default. TYPE of output matrices. < TYPE <. 8. 

F(ilRMl - Input-integer-no default. Form of All. 

F0RM2 - Input-integer-no default. Form of A12. 

F(3RM3 - Input-integer-no default. Form of A21 . 

F0RM4 - Input-integer-no default. Form of A22. 
4.83.7 Method 

Let Nl = number of non-zero terms in RP. 
Let N2 = number of non-zero terms in CP. 
Let NR0WA = number of rows in A. 
Let NC0LA = number of columns in A. 

CASE: 1 RP purged. 

All is a {NR0WA-N2) x NC0LA matrix. 
A12 is a N2 X NC!3LA matrix. 
A21 is not written. 
A22 is not written. 



4,83-2 



MATRIX MODULE PARTN (PARTITIOM A MATRIX) 

CASE 2: CP purged and SYM > 0. 

All is a NR0WA x (NCi2LA - Nl ) matrix. 

A12 is not written. 

A21 is a NR0WA x Nl matrix. 

A22 is not written. 

CASE 3; CP purged and SYM £ 0. 

All is a (NR0WA - Nl ) x (NC0LA - Nl ) matrix. 

A12 is a Nl X (NC0LA - Nl) matrix. 

A21 is a (NR0WA - Nl ) x Nl matrix. 

A22 is a Nl x Nl matrix. 

CASE 4: Neither RP nor CP purged. 

All is a (NR(3WA - N2) x (NC0LA - Nl ) matrix. 
A12 is a N2 X (NC0LA - Nl ) matrix. 
A21 is a (NR0WA - N2) x Nl matrix. 
A22 is a N2 X Nl matrix. 

In general if a^ . e [A], then: 

a.. £ [All] if RP(J) = CP(I) = 
a., e [A12] if CP(I) / 0, RP(J) = 
a. J e [A21] if CP(I) = 0, RP(J) f 
a. J e [A22] if CP(I) / 0, RP(J) ^ 

4.83.8 Subroutines 

PARTN - See subroutine description, section 3.5.6. 

4.83.9 Design Requirements 

Ope;i core is defined at /PARTNl/. 



4.83-3 



MATRIX MODULE MERGE (MERGE MATRICES TOGETHER) 



4.84 MATRIX MODULE MERGE (MERGE MATRICES TOGETHER) 



4.84.1 Entry Point : MERGEX 



4 . 84 . 2 Purpose 



To form 



[A] <= 



All i A21 



.A12 : A22J 



(1) 



4.84.3 DMAP Calling Sequence 

MERGE An,A12,A21,A22,RP,CP/A/V,Y,SYM/V,Y.TYPE/V,Y.F0RM $ 

4.84.4 Input Data Blocks 

All - Matrix / A12, A21, A22. 

A12 - Matrix f All, A21 , A22. 

A21 - Matrix ?* All, A12, A22. 

A22 - Matrix / All, A12, A21 . 

RP - Row partitioning vector - single precision vector. 

CP - Column partitioning vector - single precision vector. 

Notes : 

1. Any or all of All, A12, A21 , A22 can be purged which implies [AIJ] = [0]. 

2. RP and CP cannot both be purged. 

3. See method section for meaning when RP or CP is purged. 

4.84.5 Output Data Blocks 

A - Merged matrix from All, A12, A21 , A22. 
Notes: A cannot be purged. 



4.84-1 



MODULE FUNCTIONAL DESCRIPTIONS 

4.84.6 Parameters 

SYM - Input-integer-no default. SYM < 0, CP is used as RP. SYM > 0, CP and RP are 
distinct. 

TYPE - Input- integer-no default. Type of A. 1 implies A is real single precision, 

2 implies A is real double precision, 3 implies A is complex single precision, 
4 implies A is complex double precision. 

F6IRM - Input-integer-no default. Form of A (see section 2.2). 

4.84.7 Method 

MERGE is the inverse of PARTN in the sense that if All, A12, A21 , A22 were produced by 
PARTN using RP, CP, F0RM, SYM, and TYPE from A, MERGE will reproduce A. See PARTN (section 
4.83) for options on RP, CP and SYM. 

4.84.8 Subroutines 



MERGE - See subroutine description, section 3.5.6. 
4.84.9 Design Requirements 

Open core is defined at /MERGEl/. 



4.84-2 



MATRIX MODULE TRNSP (TRANSPOSE A MATRIX) 

4.85 MATRIX MODULE TRNSP (TRANSPOSE A MATRIX). 

4.85.1 Entry Point : DTRANP 

4.85.2 Purpose 

To form [A] given [A]. 

4.85.3 DMAP Calling Sequence 
TRNSP A/AT $ 

4.85.4 Input Data Blocks 

A - Any matrix data block. 

Note : If [A] is purged, TRNSP returns. 

4.85.5 Output Data Blocks 

AT - The matrix transpose of [A]. 
Note : AT cannot be purged. 

4.85.6 Parameters 
None. 

4.85.7 Method 

Subroutine TRNSP is called. 

4.85.8 Subroutines 

TRNSP - See subroutine description, section 3.5.25. 

4.85.9 Design Requirements 

Open core is defined at /DTRANX/. Eight scratch files are used. 



4.85-1 



llATRIX MODULE SMPYAD (STRING MULTIPLY ADD) 
4.86 MATRIX MODULE SMPYAD (STRING MULTIPLY ADD) 

4 . 86 . 1 Entry Point : SMPYAD 

4.86.2 Purpose 

To multiply a series of matrices together. 

4.86.3 DMAP Calling Sequence 

SMPYAD A,B,C,D,E,F/G/C,N.N/C,N,SIGf!X/C,N,SIGNF/C.N,PG/C,N,TA/C,N,TB/C,fJ,TC/C,N,TD $ 

4.86.4 Input Data Blocks 

A 
B 

p( - Up to 5 matrices to be multiplied together, from left to right. 

E 

F - Matrix to be added to the above product. 

Notes : 

1. If one of the five multiplication matrices is required in the product (see 
parameter "N" below) and is purged, the multiplication will not be done. 

2. If the F matrix is purged, no matrix will be added to the product. 

4.86.5 Output Data Blocks 
G - Resultant matrix (may not be pre-purged). 

4.86.6 Parameters 

N - Number of matrices Involved in the product - integer - input. 

SIGNX - Sign of the product matrix (e.g., [A][B][C][D][E]) - integer - input. 

1 for plus, -1 for minus. 
SIGNF - Sign of the matrix tc be added to the product matrix - integer - input. 

1 for plus, -1 for minus. 
PG - Output precision of the final result - integer - input. 

1 for single precision, 2 for double precision. 



4.86-1 



MODULE FUNCTIONAL DESCRIPTIONS 

TA) 

l^> - Transpose indicators for the [A][B][C] and [D] matrices (1 if transposed 

In j matrix to be used in the product; if untransposed) - integer - input. 

Note: All the parameters except "N" have default values. They are these: 

1. SIGNX = 1 (sign of product is plus) 

2. SIGNF = 1 (sign of added matrix 1s plus) 

3. PG =1 (single precision result) 

4. TA \ 

j^ > =0 (use untransposed [A], [B], [C], and [D] matrices in the product) 
TD ) 

4.86.7 Method 

The method is the same as for the MPYAD module with one exception and one addition: 

1. None of the matrices may be diagonal. 

2. Except for the final product, all intermediate matrix products are generated 
in double precision. 

The matrices are multiplied together from right-to-left, i.e., the first product calculated 
is the product of matrix n-1 and matrix n. 

4.86.8 Subroutines 



MPYAD is called (see section 3.5.12 for details). 
4.86.9 Design Requirements 

1. Two scratch files are required. 

2. Open core is the /MPYADX/ common block, the same one as used by the MPYAD module, 
(see section 4.79). 



4.86-2 



STRUCTURAL ELEMENT DESCRIPTIONS 

4-,87 STRUCTURAL ELEMENT CESCRIPTIONS 

The finite structural element subroutines used in NASTRAN have a number of different calcu- 
lations associated with them. These subroutines are found in the modules SMAl , SHA2, SSGl , SDR2, 
DSMGl . PLA3 and PLA4. 

The element subroutines in the SMAl (Structural Matrix Assembler - Phase 1) module generate 
element stiffness matrix partitions. The stiffness matrix, [K], for a structural element consists 
of a 6 by 6 partition for each combination of the connected grid points. For example, a R0D 
element is connected to two grid points, "a" and "b". The stiffness matrix partitions are: [K ], 
'■'^ab-'' '■'^ba-' ^"'^ '■'^bb-'" ^ triangular element (e.g., TRMEM) is connected to three foints. It will 
generate nine partitions: [K^^], [K^^]. [K^^]. [K^^^], [K^^], [k^^], [k^^], [k^^] ^nd [K^^]. In 
order to generate a particular partition, [K.-], it is often necessary to generate [K]. However, 
only those partitions [K^j], where i is the pivot point (see section 1.8) and j = l,2,...,n (n 
being the number of grid points associated with the element), are output by an element stiffness 
matrix generation subroutine, e.g., KR0D. These partitions are output from an element subroutine 
in the form of calls to the "insertion" subroutine SMAIB (see section 4.27). There is one call 
for each 6 by 6 partition if the element is a structural element, and one call for each 1 by 1 
"partition" if the element is a scalar element. The unused partitions are recalculated and used 
when j ^ i appears as a pivot point in a subsequent ECPT record. An alternate procedure for 
matrix generation, which is not used, would be to calculate all of the element matrices once and 
store them on an auxiliary storage unit for use when needed. The alternate procedure is less 
efficient for large problems, where efficiency really counts, because the recalculation time is 
less than the time required to recover element matrices from the auxiliary unit. 

Element structural damping matrices, [K^^], are proportional to the element stiffness matrices, 
the proportionality constant being g^, the structural damping coefficient input on a material 
(e.g., MATl) bulk data card. An element stiffness matrix generation routine, e.g., KR0D, of 
module SMAl will output, through the calling sequence to subroutine SMAIB: 1) an element stiffness 
matrix partition, 2) the structural damping coefficient, and 3) a flag, which will signal SMAIB 
that the scalar multiplication of the matrix by the structural damping coefficient is to take 
place. 

The element subroutines (e.g., MR0D, MC0NMX) in the SMA2 (Structural Matrix Assembler - Phase 
2) module generate element mass matrix partitions. The remarks in the second paragraph above 

4.P,7-1 



MODULE FUNCTIONAL DESCRIPTIONS 

concerning element stiffness matrix partitions apply here also when the reader makes the substi- 
tutions: "mass" for "stiffness". "[M]" for "[K]", "MR0D" for "KR|3D", and "SMA2B" for "SHAIB". 

Only the elements VISC and DAMPi generate viscous damping terms which contribute to the 
damping matrix, [3 ], and conversely, the only elements which contribute to [B ] are the VISC 
and DANPi elements. These terms are calculated in module SMA2. The damping matrix partitions 
are passed to subroutine SMA2B in a fashion similar to that for mass matrix partitions. 

Element static loading functions due to temperature and enforced deformations are generated 
in the SSGl (Static Solution Generator - Phase 1) module, and the mathematical descriptions for 
these functions are given in this section (4.87). (See the Module Functional Description for 
SSGl, section 4.41, for the equations governing direct applied loads and gravity loads.) The 
output of an element routine are load vectors which are placed in the {P } load vector (see 
section 4.41) . 

Element stresses and forces due to displacements are calculated in the SDR2 (Stress Data 
Recovery - Phase 2) module. These calculations are performed in two phases. Phase 1 generates 
element stress matrices for each element for which the user has requested element stress and/or 
force output. These element stress matrices are written on a scratch file for use in phase 2. 
In phase 2, the displacement vector for the current subcase is read into core, and, for each 
element for which stress and/or force output is requested, the corresponding element stress 
matrix is read and passed to the phase 2 element subroutine. The phase 2 element subroutine 
then calculates element stresses and forces. A list of the stresses and forces output in phase 
2 for each element is given in sections 2,3.51 and 2.3.52 respectively. 

Differential stiffness matrix partitions are calculated for some elements. These are calcu- 
lated in module DSMGl (Differential Stiffness Matrix Generator - Phase 1) for large displacement 
analysis and buckling problems. The output of an element routine of the DSMGl module are the 
6 by 6 differential stiffness matrix partitions, [K,'Ji where i is the pivot point. The "insertion" 
subroutine for module DSMGl, similar to subroutine SMAIB of module SMAl , is DSIB. 

Nonlinear, plastic effects in the structure may be determined by solving for the element 
stress and modifying the elastic properties of an element in an iterative loop. Element stresses 
are calculated in the PLA3 (Piecewise Linear Analysis - Phase 3) module, and element stiffness 
matrices with modified elastic properties are calculated in the PLA4 (Piecewise Linear Analysis - 
Phase 4). The outputs of an element subroutine of the PLA3 module are: 1) element stresses, 

4,87-2 (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 

which have the same formats as the element stresses output from a phase 2 element subroutine of 
module SDR2, and 2) updated incremental stress data in the ESTNLl data block, which are used as 
input to the PLA3 module in the next pass of the Piecewise Linear Analysis (PLA) Rigid Format 
DMAP loop. The outputs of an element subroutine of the PLA4 module are: 1) element stiffness 
matrix partitions (the remarks on element stiffness matrix partitions in the second paragraph 
apply here as well, except that the "insertion" subroutine is PLA4b) and 2) updated incremental 
stress data in the ECPTNLl data block, which are used as input to the PLA4 module in the next pass 
of the PLA Rigid Format DMAP loop. 

The following data are needed to generate the element matrices in the above modules. 

1. Element Connection and Properties Table (ECPT) Data. 

2. Transformation matrices, [T^.], from the global coordinate system to the basic coordinate 
system. 

3. Material Property Data. 

4. Element Deformation Data (used only in modules SSGl , SDR2 and DSGMl). 

5. Grid Point Temperature Data (used only in modules SSGl, SDR2 and DSGMl). 

The ECPT data are input to an element subroutine by a module driver from the ECPT data block 
or the EST (Element Summary Table) data block. The data in each of these data blocks are identical, 
from an individual element subroutine point of view. The ECPT data block is used in modules SMAl , 
SMA2 and DSGMl; the EST data block is used in modules SSGl and SDR2, For the special case of 
Piecewise Linear Analysis, the ECPTNL (Element Connection and Properties Table for Nonlinear 
Elements) data block is used in module PLA4, and the ESTNL (Element Summary Table for Nonlinear 
Elements) data block is used in module PLA3. The ECPT and EST data blocks are generated in the 
Table Assembler (TAl) module (see section 4.26) from the following data blocks: ECT (Element 
Connection Table, section 2.3.4.1), EPT (Element Property Table, section 2.3.2.5), BGPDT (Basic 
Grid Point Definition Table, section 2.3.3.5), and GPTT (Grid Point Temperature Table, section 
2.3.7.2). 

The ECPT data for an element consist of four separate parts: 1) connection data 2) property 
data, 3) basic grid point definition data and 4) the element temperature for material properties. 
The connection data consists of data on a connection bulk data card (e.g., CR0D), except for the 
property identification number (the property identification number on the connection and property 



4.87-3 



MODULE FUNCTIONAL DESCRIPTIONS 

cards is used only to relate the two cards during the assembly of the ECPT and EST data blocks, 
and it does not appear in either the connection data or property data). Note also that grid point 
identification numbers have been converted to internal numbers, Scalar Index List (SIL) nurriers, 
which correspond to degree of freedom numbers. Property data consist of data on a property bulk 
data card (e.g., PR0D) with the above noted exception. Basic grid point definition data consist 
of, for each grid point connecting the element, 1) the identification number of the coordinate 
system in which displacements are defined at the grid point and 2) the coordinates of the grid 
point in the basic coordinate system. The element temperature for material properties is the 
average of the temperatures at all grid points defining the element. The temperature for 
material properties, t , for a k0D element, for example, is 1/2 (t^ + t^^) , where t^ and t^^ are 
the temperatures at the grid points a and b which define the end points of the RflD; similarly, 
for a triangular element, say TRMEM, the temperature for material properties would be 
1/3 (t + t, + t ), etc. This temperature is computed in the Table Assembler module from the grid 

d D C 

point temperatures in the GPTT data block and the set identification number, n, from the 
TEMPERATURE (MATERIAL) = n card in the user's Case Control Deck. Note that n is transmitted to the 
Table Assembler via the tenth word of /SYSTEM/ (see section 2.4.1.8). 

The transformation matrices, [T.], fi'om the global coordinate system to the basic coordinate 
system, are supplied to an element subroutine by the utility routines TRANSD and TRANSS. These 
utility routines use the CSTM (Coordinate System Transformation Matrices, section 2.3.3.4) data 
block in conjunction with the basic grid point definition data at a point i to compute [T^]. 
Hence all modules which deal with element calculations require the CSTM data block as input. 
TRANSD returns, to an element subroutine, a double precision matrix, [T^], used by element 
routines in the following modules which use double precision arithmetic: SMAl , SMA2, DSGMl and 
PLA4; TRANSS returns, to an element subroutine, a single precision matrix, [T^], used by element 
routines in the following modules which use single precision arithmetic: SSGl , SDR2 and PLA3. 

Material property data are contained in the MPT (Material Properties Table, section 2.3.2.6) 
and the DIT (Direct Input Tables, section 2.3.2.7) data blocks. Both of these data blocks are 
output from the IFP (Input File Processor) Preface module. The utility routine MAT (see section 
3.4.36) fetches required material property data for element routines. These data are returned 
in single precision form. 

Element deformation data are contained in the EDT (Element Deformation Table, section 2.3.2.8) 



4.87-4 



STRUCTURAL ELEMENT DESCRIPTIONS 

data block which is output by the IFP Preface module. Element deformation data is admissible only 
for the R(JD (including C0NR0D), TUBE and BAR elements. 

Grid point temperature data are contained in the GPTT (Grid Point Temperature Table, section 
2.3.7.2), which is output by the GP3 (Geometry Processor - Phase 3) module. The temperature data 
contained in this data block are used for static loading functions due .to temperature. 

Table 1 on the following page gives reference to the Theoretical and User's Manuals where 
more information on the elements can be found. 



4.87-5 



MODULE FUNCTIONAL DESCRIPTIONS 



Table 1. Structural Element References. 



Bulk Data Connection 
Card Mnemonic 

CBAR 

CC0NEAX 

CDAMPl 

CDAMP2 

CDAMP3 

CDAMP4 

CELASl 

CELAS2 

CELAS3 

CELAS4 

CMASSl 

CMASS2 

CMASS3 

CMASS4 

C0NM1 

C0NM2 

C0NR0D 

CQDMEM 

CQDPLT 

CQUAD1 

CQUAD2 

CR0D 

CSHEAR 

CT0RDRG 

:traprg 

CTRBSC 

JTRIA1 

CTRIA2 

CTRIARG 

CTRMEM 

CTRPLT 

CTUBE 

CTWIST 

CVISC 

Note The bulk data connection and property card descriptions in section 2 of the User's Manual 
should also be consulted. 



Programmer's Manual 
Reference 


User's Manual 
Reference 


Theoretical Manual 
Reference 


4.87.2 


1.3.2 


5.2, 


7.2 


4.87.9 


1.3.6 


5.9 




4.87.7 


1.3.8 


5.6 




4.87.7 


1.3.8 


5.6 




4,87.7 


1.3.8 


5.6 




4.87.7 


1.3,8 


5.6 




4.87.7 


1.3.8 


5.6 




4.87.7 


1.3.8 


5.6 




4.87.7 


1.3.8 


5.6 




4.87.7 


1.3.8 


5,6 




4.87.7 


1.3.8 


5.6 




4.87.7 


1.3.8 


5.6 




4.87.7 


1.3.8 


5,6 




4.87.7 


1.3.8 


5.6 




4.87.8 


1.2.3 


5,5 




4.87.8 


1.2.3 


5.5 




4.87.1 


1.3,3 


5.2, 


7.2 


4.87.4 


1.3.5 


5.8, 


7.3 


4.87.5 


1.3.5 


5.8 




4.87.6 


1.3.5 


5.8. 


7.3 


4.87.6 


1.3.5 


5.8, 


7.3 


4.87.1 


1.3.3 


5.2, 


7.2 


4.87.3 


1.3.4 


5.3 




4.87.12 


1.3.7 


5.11 




4.87.11 


1.3,7 


5.10 




4.87.5 


1.3.5 


5.8 




4.87.6 


1.3.5 


5.8, 


7.3 


4.87.6 


1.3.5 


5.8, 


7.3 


4.87.10 


1.3.7 


5,8 




4.87.4 


1.3.5 


5.8, 


7.3 


4,87.5 


1.3.5 


5,8 




4.87.1 


1.3.3 


5,2, 


7.2 


4.87.3 


1.3,4 


5.3 




4.87.14 


1.3.3 


5.2 





4.87-6 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.1 The Rjap. CglNRgP and TUBE Elements 

4.87.1.1 Input Data for the R0D, TUBE, C0NR0D Elements 

1. The ECPT/EST entries for the R0D and CiaNR|i!D are: 

Symbol Description 

^^""a* ^^'"b Scalar indices for grid points a and b 

H^, Xg, Y^, Zg 

( Local coordinate system number and basic 

M y V 7 ( coordinates of grid points 

Mat I. D. Material identification number 

A Cross-section area 

J Polar inertia 

U Nonstructural mass per unit length 

C Shear stress coefficient 

t Temperature for material properties 

2, The TUBE element has the same characteristics as the R0D except for different 
input properties. The TUBE has d, the outside diameter, and t, the thickness, given. 
The conversion to R0D properties is: 

A = TT(d - t)t 

J = Ia {(d - t)2 + t^) 

C = ^ 
^ 2 

3. Coordinate system data 

Given N^, X^, Y^, Z^, N^^, X^, Y^^ and Z^^ and the CSTM (Coordinate System Transformation 
Matrices) data block, the 3 by 3 global-to-basic coordinate transformation matrices [T ] and 
[T^] are calculated using the utility routine TRANSD or TRANSS. 



4.87-7 



MODULE FUNCTIONAL DESCRIPTIONS 



4. Material data 

Given the "MAT I.D." and t , the material routine, MAT, returns the following data: 

E - Modulus of Elasticity 

G - Shear Modulus 

V - Poisson's ratio 

p - Density 

a - Thermal expansion coefficient 

T - Reference temperature 

g - Structural damping ratio 

0. - Stress limit, tension 

- Stress limit, compression 

a - Stress limit, shear 

4.87.1.2 Stiffness Matrix Calculation CSubroutines KR0D and KTUBE of Module SMAl ) 

1. Calculate the length of member, (Jl) : 



I - V(Xa - '^b)' ' (^a - ^b)' ' ^h - h^' • 



(1) 



2. Calculate a normalized direction vector {n} in basic coordinates: 



"n 




[Xa-^bl 


"2 


1 


^a-^b 


."3. 




^h-hi 



(2) 



3. Form the extensional stiffness matrix, [Djj^]: 







-»? 


"l"2 


"l"3 


^h^ 


-. AE 


"l"2 


4 


"2"3 






"l"3 


"2"3 


4 



(3) 



4.87-8 



STRUCTURAL ELEMENT DESCRIPTIONS 



4. Form the torsional stiffness matrix [D ]: 



[D,] 






"l"2 



"l"3 



"l"2 



"2"3 



"l"3 



"2"3 



(4) 



5. [T^] and [T|^] are the matrices which transform displacement components in the global 
coordinate system to the basic system, 

6. Transforming to global coordinates and combining the results give the partitions of the 
element stiffness matrix: 



t^a^ 



t^b^l 





'I \ \ 










^I ^ ^a 




'I \ \ 










^I ^ \ 




'I h \ 







1 


i ^ \ 




__ 1 


_ 



(5) 



(6) 



t^b^ 



The element damping matrices are equal to the stiffness matrices times g , the Structural 
damping coefficient. 

4.87.1.3 Lumped Mass Matrix Calculation (Subroutines MR0D and MTUBE of Module SMA2) 
The total mass of the element, m, is 



(7) 



(8) 



m = pAJl + \il 



(9) 



4.87-9 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



The partitions of the element mass matrix are: 



t"aa^ = t"bb] = 7 



J 



(10) 



[M,J = [M,J = [0] 



'ab 



ba^ 



(11) 



4.87.1.4 Element Load Calculations (Subroutine EDTL of Module SSGl ) 

The element loading calculations are calculated using the EST data, the grid point loading 
temperatures t and t^^, and the enforced deformation 6. 

1. Calculate «., {n}, [T^^] and [T|^] as in section 4.87.1.2. 

2. Calculate: 



t = (t^ + t^)/2 - T„. 



(12) 



tPa> 



EA R^a^'' 
^ L""o"J 



{n} (5 + ailt), 



(13) 



to \ = _ I^ 



Pbi' 



{n} (6 + alTj. 



(14) 



3. {P } and iPu) are placed in the load vector in positions corresponding to points a 
a D 

and b. 
4.87.1.5 Element Stress Calculations (Subroutines SR0D1 and SR0D2 of Module SDR2). 
The stress functions calculated in phase 1 (Subroutine SR0D1 ) are: 
[Sh = I M^ [TJ. 0x3); 



(15) 



4.87-10 



STRUCTURAL ELEMENT DESCRIPTIONS 



Th 



[Sj] = - f {n}T [Tf^], (1x3); (16) 

[S^] = |^{n}'^ n^-], (1x3); (17) 

[Sj] = -f-Cn}"^ [Tj^]. (1x3). (18) 

Sy = - oiE, (19) 

h - - i- (20) 

e miscellaneous constants A, 7-, T , a. , o and a are also saved for phase 2 calculations. 



Note J/C is set to zero if C = 0. The superscripts t and r denotes translational and 
rotational stress matrices respectively. 

The stress and force values are calculated in phase 2 (Subroutine SR0D2) using the 
displacement vectors {u } and (u. }, the loading temperatures t and t. , and the enforced 

deformation 6. Note that {u}} and {u^} (i = a, b) denote the 3 by 1 translational and rotational 
components of {u. }. 



1. Partition 



."a . 
{U3}=> j-J--) . (21) 



, t , 
{u.}=$> l_%__[ . (22) 



2. The stresses are; 

a = [S^] {u*} . [Sj] {uj} + S^6 + S^[ j (t^ + tj,) - T^] . (23) 

T = [S^] {u^} + ESJ] {uj} . (24) 

The margins of safety (M.S.) are calculated as follows: 
If a > then: 

4.87-11 



MODULE FUNCTIONAL DESCRIPTIONS 






M.S. 



(25) 



Integer "1". a. < 



If a < 0, then: 



L^+ 1 . o^ > 
M.S. = . (26) 



'Integer "1", a^. <. 



The forces are: 



P = Aa . (27) 

T . = ^ T . (28) 

4.87.1.6 Differential Stiffness Matrix Calculation (Subroutine DR0D of Module DSMGl) 

The data input from the ECPT, MPT and CSTM data blocks are as listed in section 4.87.1.1. 
The following variables are calculated in the same manner as those for the stiffness matrix, 
variables (section 4,87.1.2): 

i length of rod 

"l 



The direction cosines of the rod axis (+ from b to a) 
2 ^ in the basic coordinate system 

n-, 



n 
^3 



[T ], [T, ] The transformation matrices from global coordinates to 
the basic coordinate system at the grid points. 

Only the linear translational displacements at the grid points are extracted from the 

displacement vector. Call these {u,} and {u. } (3x1 single precision vectors.) 

a D 



4.87-12 (7/1/70) 



STRUCTURAL ELEMENT DESCRIPTIONS 



1. Calculate the axial load in the element (+ implies tension): 



^ _ AE 

Si ~ 17 



{ {n}^[[T^] {uj} - [Tj^J {uj}] -6 -«MVLy - ^0 } • (29) 



2. A pair of axes perpendicular to the rod axis is constructed. Select the smallest 
component of {n}. Define n. as the component of {n} which is the smallest; let j 
and k be the other two components. Construct {m} such that 

"li = 1. nij = m,^ = 0. (30) 

Let 

i.,\ - {m} X {n} , , 

^^^ - Km) X {n}| ' (31) 



and 



j-tI - {n} X {y} , , 

^^^ - lini X {y}| • (32) 



where x denotes the cross product. 

The actual partitions of the differential stiffness matrix relating to displacements 
in global coordinates are: 

^■^aa^ = f[T^f [{y}(y>"^+{z}{z}^] [T^] . (33) 



d -F.. 



f^ab^ = r^ [Ta^^ L{y}{y}^ + {z}{2}T] [Tj^] . 



(34) 
(35) 



<^ - <^' ' (36) 



4.87-13 



MODULE FUNCTIONAL DESCRIPTIONS 



The actual 6x6 partitions are formed by expanding: 



l<.^ => 



_aa^__,etc. (37) 

_0 T oj 



4.87.1.7 Piecewise Linear Analysis Calculations (Subroutine PSR0D of Module PLA3 and 
Subroutine PKR0D of Module PLA4) 

The additional ECPTNL and ESTNL entries are: 

Eg - The previously computed strain value once removed. 

e* - The previously computed strain value. 

E - The previously computed modulus of elasticity. 

T* - The previously computed torsional moment (present in the ESTNL entry only). 

All of the above values are initially zero with the exception of E*. which is initially the 
original modulus of elasticity present on a MATl card. 

For both stress calculation and stiffness matrix generation, the quantities i and {n} 
are generated as in section 4.87.1.2. 

Using {Au*} and {Auh, the 3x1 translational displacement vectors, calculate the 

Si D 

Increment of strain: 

Ae = 1 {n}^ [Tg] {AuJ} - [T^] {AuJ}! , (38) 

Ae* = e* - e* . (39) 

Define the following terms: 

£, = e* + Ae, (current strain); (40) 

* ^ ( Ae + Y*^A£*)(Y-t-l) , Y *(Ae - y*Ae*) (y+1 )^ . (41 ) 

>-2 = ^ "■ (l+Y*) n+Y^T 

(estimated next strain); 



4.87-14 



STRUCTURAL ELEMENT DESCRIPTIONS 

where y is the ratio of the next load increment to the present load increment. 

We calculate: 

o■^ = f (e^). (42) 

a^ = f (cg). (43) 



where f is the tabular stress-strain function. (When z* = 0, define a. =££•,) 



For stiffness matrix generation, the new material properties are: 






(44) 



E*, if eo = £-1 



and 

G = f G^. (45) 



where E^ and G^ are elastic moduli obtained from the MATl bulk data card via subroutine 
MAT. 

For plastic element stresses and forces the values are: 

0=0^, (46) 

P = Aa^, (47) 



T = ^ {n}"^ ([TjCAu^} - [T^] {AuJ}) + T* 



(48) 



where 



T = y^ (t = if C = or J = 0), (49) 



G* = r- G^ . (50) 





4.87-15 



MODULE FUNCTIONAL DESCRIPTIONS 



The new ESTNL and ECPTNL entries are: 



^Sn = 


e* 


» 




^1 


* 


^l - 


02 -a, 


£2 ■ 


■ ^1 


'*n - 


T 





(51) 

(52) 
(53) 

(54) 



4.87-16 



MODULE FUNCTIONAL DESCRIPTIONS 

4,87.1.8 Coupled Mass Matrix Calculation (Subroutine MCR0D of Module SMA2) 

1. The length of the element, I, the normalized direction vector, {n}, and the mass of the 
element, m, are calculated as in Equations 1 and 2 in section 4.87.1.2 and Equation 9 in section 
4.87.1.3 respectively. 

2. The 3 by 3 matrix 



[AM] 



m 
T7 



"l"2 



"l"3 



"l"2 



"2"3 



"l"3 



"2"3 



(55) 



is calculated. 

3. The 3 by 3 element mass matrices in basic coordinates are 



■^"'aa^ = tm^b] = 



1/2 











m/2 











m/2 



- [AM] 



(&5) 



and 



t"i.h^ = C"'hJ = [AM] 



ba^ 



(57) 



4. In global coordinates the 6 by 6 mass matrix partitions are: 



^^W 



'i\'i \ 


I 



(58) 



for i=a or b, j = a or b and where [T.] is the global-to-basic coordinate transformation 
matrix for point i. 



4.87-16a (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 
4. 8/. 2 The BAR Element 
4.87.2.1 Input Data for the BAR Element 

1. The ECPT/EST entries for the BAR are: 

Sy"ibo1 Descriptions 

^^""a' ^^^b Scalar indices of grid points a and b 

N , X , Y , Z ) 

^ ^ ^ A \ Local coordinate system number and location 

\' ^b* ^b' ^b ) ^'" ^^^"^^ coordinates of the grid points 

^T ^2' ^3 Orientation vector (see Figure 1 in section 1.3 

of the User's Manual) 

F Flag for orientation vector definition 

"^a* ''b Pi" fl^gs for either end 

^^* ^- ^- Material property identification number 

^ Cross-sectional area 

^T h Bending inertials in element coordinates about 

axes normal to reference planes 1 and 2 respectively 

^12 Cross-product bending inertia 

J Torsional Inertia 



a , a , a 
x' y' z 



Nonstructural mass per unit length 



Vectors defining offset distances between 

b . b , b ( ?AR ends and grid points (see Figure 1 in section 

^ y ^J 1.3 of the User's Manual) 

K^ , ^2 Shear factors 

c^ , c^, d^ , dj I Positions on cross section of four points for 

f f n fi t stress calculations (see section 1.3.2 of the 

M' ^2' 9r 92 ) LJcer's Manual) 

*p Temperature for material properties 
2. Coordinate system data 

The location (X., Y • , Z.) and local coordinate system number (N.) of each 

grid point (i = a or b) are used to calculate the 3 by 3 global-to-basic coordinate 

transformation matrices, [T ] and [1.1. 

a D 



4.87-17 



MODULE FUNCTIONAL DESCRIPTIONS 



3. Material data 

The material identification number "Mat I.D." and t^ are used to select the 
following: 



E - Modulus of elasticity 

G - Shear modulus 

V - Poisson's ratio 

p - Density 

a - Thermal expansion coefficient 

T - Referehce temperature 

q - Structural damping ratio 
^e 

a^ - Stress limit, tension 

a - Stress limit, compression 

a - Stress limit, shear 



'4.87.2.2 Stiffness Matrix Calculation (Subroutine KBAR of Module SMAl) 

1, If the orientation flag F is nonzero, transform the given vector to basic 
coordinates: 



otherwise, 



'^3. 



(^3 



2. Transfer the relative beam end locations to basic coordinates: 



^al I'x 



^2/ = [TJ j^i , (3) 

'as) (^z 



4.87-18 



STRUCTURAL ELEMENT DESCRIPTIONS 



*bl 


^2 > 


«b3 



^\^ 



(4) 



3. The center axis of the beam, defined as {i} is calculated as: 



{V.} 



a b al bl 



'.-\' ^a2 - «b2 



Z^ - Z. + (5 _ - 6. , 
a b a3 b3 



(5) 



^ = (V?i - V?^ . V23) V2 , 



{i} = 1(V.}. 



(6) 
(7) 



4, The bending axis of the beam in plane 2 is: 



{k} = ^i> ^ ^V 



|{i} X {Vq}| 



(8) 



5. The bending axis of the beam in plane 1 is: 



{j} = {k} X {i} 



(9) 



6. The 6x6 matrix for transforming element displacements in the element coordinates to 
basic coordinate displacements is: 



t^eb^ 



fiiiJ. 



iJi 




{k} J 



^""•TiT^-TjTriB- 



(10) 



7. The 6 by 6 matrices for transforming global coordinate displacements to basic 
coordinate displacements are: 



tt^a^ 



a 
- —I 

I 



! 



(n) 



4.87-19 



MODULE FUNCTIONAL DESCRIPTIONS 



[ChI = 



r " 

I T 



b-J 



(12) 



8. The 6 by 6 matrices for transforming displacements of the arid points to disolacements 
of the element ends are: 



t^a^ = 



TOO, a^ 

1 I -a, 

I ^ 
1 



'y 


-\ 





] 











1 











1 



(13) 



t^J 



10 b 



1 -b^ 



z y 

b. 






1 


^ 


-\ 









1 
















1 















1 



(14) 



4.87-20 



STRUCTURAL ELEMENT DESCRIPTIONS 

9. The 6 by 6 partitions of the element stiffness matrix in element coordinates 
are: 





r AE 






















«1 


e 





-7 


ri 







6 


R2 





T2 


^ 


t^LJ = 











GJ 

T 













^ 
-^ 







h 


4^ 




_ 


'f} 







4^ 


•=1 - 




AE 














"^ 







-«1 


-6 







1^^ 







-B 


-R2 







¥ 


b^ = 










f-2 


GJ 




^4 










"Tl 







-#« 


"3 



(15) 



(16) 



[<J = [K^.f . 



abJ 



(17) 



4.87-21 



IIODULE FUNCTIONAL DESCRIPTIONS 



t^bb] = 



AE 

I 









GJ 

I 


le 


f-z 





"2^1 


2^ 






^ 
^ 


- ^ R 


T2 


-|» 








4 


4^« 


3 '^ 


h 



(18) 



The terms are defined as: 



If 1^2 = ° •■ 



3 = 



12EI, 



1 + 



12EI^ 



-1 



(19) 



(20) 



12EL 



1 + 



12EI2 
KgAGS,^ 



-1 



(21) 



Note: If K. A G = 0, set 



K. A G 



0. i = 1 or 2 



If 1^2 / 



12EI, 



(22) 



12EL 

I' 

12EI 



12 



(23) 



(24) 



4.87-22 



STRUCTURAL ELEMENT DESCRIPTIONS 



Note: In this case no shearing deformations are calculated. 



For both cases 









e "i 

4 ^1 ' I 



(25) 

(25) 
(27) 






(28) 



10. Process the end condition ("pin") data. The nonzero digits of the "pin flag" 
integers P^ and P^^ specify the following: 



P = 



1 implies no forces are transmitted to the element in the x-direction at the pinned end 

2 implies no forces are transmitted to the element in the y-direction at the pinned end 

3 implies no forces are transmitted to the element in the z-direction at the pinned end 

4 implies no forces are transmitted to the element in the e^-direction at the pinned end 

5 implies no forces are transmitted to the element in the 6 -direction at the pinned end 

6 Implies no forces are transmitted to the element in the e^-direction at the pinned end 



1) Nonzero digits of the number P specify the unconnected degrees of freedom 
on the end of the BAR. 

2) Construct the overall element matrix and perform the following operations: 
a) 



aa 

e 

ba 



ab 

e 
bb 



Ml 



^21 



n2 



'12,12 



(29) 



4,87-23 



MODULE FUNCTIONAL DESCRIPTIONS 

b) Convert the pin numbers to row numbers in the [k] matrix. If a pin number refers to 
end "a", it corresponds to the row number. If it refers to end "b", the row number is 
obtained by adding six to the pin number. 

c) For each row of the [k] matrix perform the following operation to obtain the new 
stiffness matrix [k'] 



'^j^ 



,, _^ U = 1....12. JM ^ (30) 
j^ k7. \^ , 1,...12, 9. ^ i 



and k. = for j = i or Jl = i , where i is the row number obtained from the pin number 
as in b). 

i L- 

This operation causes the i row and column to be zero, and disconnects 
that degree of freedom from the matrix. Repeat for each pin index. 

d) Repartition the matrix into the four original sections, carrying 
the zero rows and columns along. 

11. The equations to convert the partitions to global coordinates are: 



[K^J = ^tI.C E )T Ck^ 1 {T^C E ) , (31) 



aa eb a a "- aa-' eb a a 



t^ab^ = <'.'/ ^^b^^'Wb^ . (32) 

[k,,] = [k^t,^T _ (34J 



4.87-24 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.2.3 Lumped Mass Matrix Calculation (Subroutine HBAR of Module St4A2) 

"m/2 



where: 



[M^] = [\] 



m/2 



ni/2 







(35) 



m = Z {pA + u) , 



(36) 



and: 



^"aa^ = < ^, E |T tM 1 (tT c^ El . 



(37) 



^"bb^ = ^4 Cb W' ^V ^^Ib % Eb> 



(38) 



[\,1 = tMba^ = tO^ 



(39) 



The equations for the generation of the "consistent" or coupled mass matrix for the BAR are 
given in section 4,87.2.8. 

4.87.2.4 Element Load Calculation (Subroutine BAR of Module SSGl ) 



Form i, fi), [C^], [C^], [E^] and [£^] as in section 4.87.2.2. 



Then: 



tPa^ = [EjT rc/ {i} f (S + att) , 



^^b> = -l\l' ic^^' il^ '^ U - an) . 



(40) 
(41) 



where: 



* = 7 (*a ^ t,) - T^ . 



(42) 



and 5 is the element deformation from the EOT data block, and t^ and t^ are grid point temperatures 
for loading obtained from the GPTT data block. 



4.87-25 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 
Note: If the "1" index exists in either "pin flag", all the above loads are zero. 

4.87.2.5 Element Stress Calculations (Subroutines SBARl and SBAR2 of Module SDR2) 

The stress and force data are calculated in two phases. The first phase (subroutine 
SBARl) calculates unique stress versus displacement, temperature and enforced deformation 
functions for each element. The second phase (subroutine SBAR2) applies the various 
subcase displacement vectors to produce the element forces and stresses. 

Phase 1 calculations are as follows: 

1. Using the algorithms given in the description of the stiffness matrix calculations 
for the element (section 4.87.2.2), calculate the following data: 

[T u] - 6x6 element coordinate transformation 

[E ], [E, ] - Offset transformation matrices (6x6) 

[C ], [C, ] - 6x6 global to basic coordinate transformations 

[k;'] - 12x12 stiffness matrix in element coordinates with 
^ pin joint effects 

i - Length of BAR 

2. Partition the stiffness matrix [K^] saving only the upper 6x6 matrices, 
[^^a^^^^Ckab^- 



[k:]=> 



aa 



""ba 



^ab 



^bb 



(43) 



3. The stress matrices are: 



t^aJ - [^a][W[Ca][EaJ. 



tSb] = [^b3tTeb^'tC,][E^]. 



(44) 
(45) 



4.87-26 



STRUCTURAL ELEMENT DESCRIPTIONS 
4. The temperature and enforced deformation coefficients are; 

S^ = AEa, (46) 

h - r- (47) 

Phase 2 element force calculations are as follows: 

1. The static element forces are calculated by the equation: 

{P} = [Sg^u^} + [S^,]{u^^}. (48) 

where {u^} and {u^} are the global displacements. 

2. The element axial force is: 

F^ = - [Pi + S^ At + S^ 5] . (49) 

where 

t + t, 
At = — — _ .T^ . (50) 

3. The element shear loads are: 

V] = -P2 . (51) 

^2 = -P3 . (52) 

4. The torque and moments are: 

T = -P4 . (53) 

"la = -Pe. (54) 

"23 = h . (55) 

"lb = ^, - Vi^ . (56) 

"2b = "2a - h^ ■ (57) 
4.87-27 



MODULE FUNCTIONAL DESCRIPTIONS 

Phase 2 element stress calculation are as follows: 
1. The stresses due to bending are: 



Mo Ii, - M, I, 
^a I I - l2 



k = 1^ T2 2a 1 ^ (59) 

h ^2 n2 



°ca = ha <^1 ' ^2a ^2' ^^°^ 

°da = ha^l ^4ad2. (61) 

^fa = ha h ^ 4a 'z' ^"^ 

V = ha 9l " 4a 92- ("' 

For a u. a^^, o., , a , use the above equations interchanging the subscripts for b and a. 
cb' db fb' gb 

2. The axial stress is: 






ax 



(64) 



3. The maxima and minima are: 



'^a max = ^'ax ^ ™>^ (°ca' °da' '^fa' °ga^ ' ^^^^ 

% max = '^^ax ^ '"^^ ^^cb' ^db' "fb- ^b^ • ^^^^ 

^a min = °ax " '"'^ ^'^ca' ^^^da' "'fa' ^ga^ • ^"^ 

b min ax cb' db' fb' gb 

4.87-28 



(68) 



STRUCTURAL ELEMENT DESCRIPTIONS 



4. The margins of safety in tension, M.S.., and compression, M.S. , are as follows: 



V'^amax °bmax 



^, <- _ , , ^M,.. bmax/ ' ^t "^ ° 

t - ) (69) 

Integer "1" • <^t ^ ° 



If M.S.^, > 1.0, then M.S.^ is set to integer "1". 



in (!c_ . !^) 
M.S.^ = <- Vamin ^bmin/ ^^^^ 



min I;; , ^ 1+ 1 > °^ > 



Integer "1" , a < 

If M.S.^> 1.0, then M.S.^ is set to integer "1". 

4.87.2.6 Differential Stiffness Matrix Calculation (Subroutine DBEAM of Module DSMGl ) 

Many of the equations used in this calculation routine are identical to the stiffness 
matrix and element force calculations. Refer to sections 4.87.2.2 and 4.87.2.5 for details. 

1. Calculate [T^^l, [C^], [Cj^], [E^], [E,^] and [K], the matrices used in the BAR 
stiffness matrix generation, section 4.87.2.2. 

2. Calculate the forces in the element using the equations in section 4.87.2.5. 

3. The number 2, 3, 4, 5, 6, 8, 9, 10, 11 and 12**^ rows and columns of the 
12 by 12 differential stiffness matrix are given in Figure 1. The first and 
seventh rows and columns are zero. The terms are identical to the element forces 
calculated for output (Equations 51, 52 and 54 through 57 of section 4.87,2.5) with the 
following notational changes: 



M 
ay 


= 


M2a 


^az 


= 


^la 


'y 


= 


^1 



V 


s 


'^2b 


^bz 


= 


"lb 


'z 


= 


h 



4.87-29 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 



1 


o 


erf 


o 


X 

u_ o 

erf n 

1 


^-12 


o 


erf 


o 


X 

u ^ 

erf — 


cr 


xlo 


> 


X 

erf cn 

1 


o 


o 


1 


> 

i 


X 

Ll 

CVl 


UO 


o 




N 
ro erf 

5-, 


X ct 

•^ erf 

1 


erf 


N 
erf 




5:: 

1 


xl CC 

Ll- CNJ 

■O erf 


>■ LD 

erf 

1 


1 


o 


X 

Ll erf 
LO [lo 

1 


nI 
£: 1 

1 


^1° 


O 


o 


X 


fO erf 


1 


o 

L 


X 

Ll o* 

UD in 


O 


1 


o 


L.1° 


X 


O 


(T3 erf 

1 


o 


1 

L.X^ 


xlo 
u_ [• — 

1 


o 


e^ 

1 


o 




L.-!? 


O 


> LO 
ej 


o 


X 

U- o 
>=^ n 

1 


c 


1 


5> 

1 


erfTLT) 
C\J|.— 


o 


o 


i 


> lO 

erf 


X 

Ll O 

erf ro 
t 


o 

i 




M 

JD erf 


X ct 
U- CM 
'^ erf 


>J 

erf 


1 


1 


N 


X <: 

Ll_ CM 

•-D erf 

1 


>J 

=» lO 


N 

=> LO 
erf 


o 


X 

U- erf 
1X3 LO 




LlX|° 


o 


o 


X 

Li_ erf 
LD 

I 


N 

OS erf 


xlo 


O 


KO IlD 


O 


>J 

5: 


o 


xlo 
u_ !.— 

1 


X 

LL- LD 
LO 

1 


o 


re e^ 

e: 


o 


Xlo 

1 






I — 



E 



4-> 

C 



E 






o 

<4- 






no 









4.87-30 



STRUCTURAL ELEMENT DESCRIPTIONS 

4. The effects of "pin joints" are added by aoplying the elastic stiffness 
constraints. The elastic stiffness matrix, [K^], with no pin joints is equivalent 
to the matrix [k] in Equation 29. If coordinate number j is released by a oin flag 
the differential stiffness matrix must be modified as follows: 

a. If i ?* j and £ i^ j, i = 1, 2 12 and Jl = 1 , 2 12: 



^''M'm ^^i£^m-l 



/B ^e 



d*, 



JJ 



ji ^^^j^m-l , hi ^ii ^ ^S-J^m-1 (71 



JJ 



JJ 



where m is the (row) index of the pin joint number, 1 <_ m <_ 12. For m = 0, define 



<^o - (<.) • 



(72) 



b. If i or j = l 



d* 

r. 
ij 



= 



d* 



i = 1 12 , 



j = 1 12 



(73) 
(74) 



5. The 12 by 12 matrix [K ] is now partitioned into 6 by 6 matrices related 
to each grid point 



[K<^*] 



d* 

r 

aa 



^ba 



d* 
^ab 

d* 



(75) 



6. If point "p" is the pivot point (p = a or b). the matrices generated in global 
coordinates are: 



<^ = ([t,k]'[cJ[e J)T [kJ*] ([T„J[C 1[E J) . 



pa 



eb^ ^^p-"--pJ^ L-p^j vL.g(,jL^aJ 



(76) 



K^-^ 



[[Tebf [Cp][Ep])T [kJ^] ([T^,f [C,][E,]) 



(77) 



4.87-31 



MODULE FUNCTIONAL DESCRIPTIONS 

4.87,2.7 Piecewise Linear Analysis Calculations (Subroutine PSBAR of Module PLA3 and 
Subroutine PKBAR of Module PLA4) 

The additional ECPTNL and ESTNL data block entries for a BAR element are: 

* 
e - The previously computed axial strain value once removed. 

* 
e - The previously computed axial strain value. 



* 



* 

^1 

* 

^2 



The previously computed modulus of elasticity. 



J* \ - The previously computed element forces and moments. 

* 

M, 
la 

* 

"2a ^ 

All of the above values are initially zero with the exception of E , which is initially the 
original modulus of elasticity present on a MATl bulk data card. 

For both stress (subroutine PSBAR) and stiffness matrix (subroutine PKBAR) calculations, 
the following data are generated: 



t, [Tg^j], [Cg], [C^], [Eg], [E(j3, [k|g], and \y.\^ as in Equations 6, 10, 11, 12, 13, 14 and 



30 in section 4,87.2.1. Note that: a) [k^ ] and [k^.] are the partitions of the stiffness 



matrix with pin joint effects taken into account; b) for stress calculations, E is used 



to compute [k^ ] and [k^^]; 3"^ c) for stiffness matrix calculations E, (see Equation 84 



below) is used to compute [k^ ] and [k^, ] 



Using the incremental displacement vectors, Uu^} and {Au, }, calculate the incremental 
strain: 



^- - it-^ebll' 



[Cb][Eb]{AUt,} - [C,][Ej{AUg} 



(78) 



where {Tg^j-j} is the first column of [T^i^]. If coordinate "1" of either P or P. (the pin flags) 
is "on", the element is treated as linear. This determination is made in the Piecewise Linear 



4.87-32 



STRUCTURAL ELEMENT DESCRIPTIONS 



Analysis pre-processor module, PLAl . 

Calculate the extensional strains: 



* * 



(1 + Y ) (1+/) 



E 



■^2 " ''l 

^pr^ ' ^^ "2 ^ ^1 



and 



(79) 



* 
£■, = e + Ae , (80) 



(81) 



where y is the ratio of the next load increment to the present load increment. 
The stresses 

O] = f(ei), (82) 

^2 = f(£2)' (33) 

are computed, where f is the tabular stress-strain function. (When c* = 0, define 
^i = E^e^. where E^ is the modulus of elasticity on the MATl card) 

For stiffness matrix generation the new material properties are: 



1 " \ ; (B4) 

* 

E , if Ep = £, 



El 
Si = E^ S • (85) 



where Eq and Gq are elastic moduli obtained from the MAT! bulk data card via subroutine MAT. 
Note that F^ is calculated in PSBAR only to predict the next value of E, i.e., to update 
the ESTNL entry. 



4.87-33 



MODULE FUNCTIONAL DESCRIPTIONS 

For plastic element stresses and forces, the values are calculated in a fashion similar 
to that found in the phase 2 subroutine, SBAR2, (see section 4.87.2.5) of the SDR2 module. 

They are: 

^^P> = tk,,][T,;^f [C^][E^]{AU^} ^ [k^b^[T^t,f [C^][Ej,]{AUt,}. (86) 

Fj( = A0^, (87) 

^1 ' - APj + V* , (88) 

V2 = - AP3 + V* . (89) 

T = - AP^ + T* , (90) 

Mia = -^^e^^a • (91) 

"lb = "la - ^1^' (93) 

M2b ■ "2a ■ ^2^- (9*) 

The stresses due to bending, the axial stress, the minimum and maximum stresses, and 
the margins of safety are computed as in Equations 58 through 70. 

The new ESTNL and ECPTNL entries are: 



Eq = e . (95) 



E* = ep (96) 



E* = E, , (97) 



4.87-34 



STRUCTURAL ELEMENT DESCRIPTIONS 

V* = V^ . (98) 

^2=^2. (99) 

T* = T , (TOO) 

M2a = M23 . (102) 



4.87-35 



MODULE FUNCTIONAL DESCRIPTIONS 



4.87.2.8 "Consistent" Mass Matrix Calculation (Subroutine MCBAR of Module SMA2) 



1. Generate the 12 by 12 matrix: 



[M^] 



m 
^20 



175 

156 

156 



SYM 









35 




















22JI 





54 











-13. 


22«, 











54 





13£ 





























4.2 











-13. 





-3.2 







4.2 





13£ 











-3.2 




175 























156 











-22. 










156 






22. 



4.2 






4.2 



(103) 



where 



(pA + u). 



(104) 



2. If "pin joints" exist (P^ or P^^ nonzero), generate the "unpinned" 12 by 12 stiffness 



matrix in element coordinates, [K ], as in Equation 29, section 4.87.2.2. 



For each pin joint of index j, perform the operations for i 
i = 1 12: 



,.,12 and 






After each pin joint j operation, replace [M^] by the "pinned" matrix [mP]. 
4. Partition the matrix into 6 by 6 submatrices: 



(105) 



4.87-36 



STRUCTURAL ELEMENT DESCRIPTIONS 



[M] = - 



M, 



aa 



ba 



'ab 



bb 



(106) 



5. The matrices are converted to global coordinates by the equation: 



[Mf.] 



[T,,]'[C.][E.] 



[M..] 



[Teb^'LCjOUj] 



(107) 



where i is the pivot point (a or b) and j is used twice (for both a and b), 



4.87-37 



MODULE FUNCTIONAL DESCRIPTIONS 

4.87.3 The SHEAR Panel and TWIST Panel Elements 

4.87.3.1 Input Data for SHEAR and TWIST Panels 

1. The ECPT/EST entries for shear (SHEAR) and twist (TWIST) panel elements are: 

Symbol Description 

SIL., 1=1,2,3,4 Scalar indices for the connected points 



Ni.X..Y..Z. ^ 
i = 1,2,3,4 ) 



N^ ,X,. ,Y,. ,Z^ ) Local coordinate system number and basic co- 

ordinate location for each of the connected 
points. 



Mat I.D. Material identification number 

t Panel thickness 

li Nonstructural mass per unit area 

t Temperature for material properties 

2. Coordinate system aata 

Using N^ , X., Y., Z. , i = 1,2,3,4 the program constructs [T^], i = 1,2,3,4, the 3 by 3 
global-to-basic transformation matrix for each point. 

3, Material data 

MAT I.D. and t are used, by utility routine MAT, to produce the following terms from the 
MPT and DIT data blocks: 



Symbol Description 

E Modulus of elasticity 

G Shear modulus 

V Poisson's ratio 

p Density 

a Thermal expansion coefficient 

T Reference temperature 

g Structural damping coefficient 

't' '^c' ^b Stress limits 



4.87-38 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.3.2 Definition of Element Geometry 

A mean plane is defined as parallel to the two diagonal lines and halfway between them. The 

projections of the points at the corners of the element onto the plane and the normal to the plane 

define the element coordinate system. Using standard vector algebra, the steps are: 

1. Define: 



^Vm) = Y, , {V,,} = 



"01 



02' 



Yj ) , etc. 



(1) 



2. Define diagonal vectors: 



{v,,} = {V.,} - {V„,} . 



03^ ^'OV 



^^Hp) = {V„,} - {V,,} 



'd2 



04' '^'02' 



(2) 
(3) 



3. Define normal vector (x denotes cross product); 



(V - (v,^} X {v^2> . 



(4) 



{k} 






A = -J- Ul<^}| (the projected area of the element). 
4. Define the vectors along the side of the element (see Hgures 2 and 3) 



(6) 
(6) 



{V,,} = {V,„} - {V,,} . 



'12 



02' ^'OV 



^^i> = tVoi}- (V04} 



(7) 
(8) 



4.87-39 



MODULE FUNCTIONAL DESCRIPTIONS 



5. Define transformation matrix [T ], which transforms element coordinate to basic coordi- 
nates, using unit vectors: 



{vfg} = {v^2^ - ({v^g^""" {k}){k} . 

{V?o} 



{i} = 



•M' 



Kvf^JI 



(9) 
OO) 



{j} = {k} X {i} , 



01) 



[T,] = 



^1 Jl" 



ig J2 



^3 ^3 



(12) 



6. Transform the four corner point of the element from basic coordinates to the element 
system: 



{r,} = 



Xl^ rO 



.yj ^0 



(13) 



^2) V^12l 



{rg} = 



^Z' 



{r^} - 



[Tel' {v,^} . 



^3 



{r^} = 



[T^f {V,^} 



^4 



The four corners of the element are now projected onto the mean plane. 



(14) 



(15) 



(16) 



4.87-40 



STRUCTURAL ELEMENT DESCRIPTIONS 

7. The following conditions should be met. Otherwise, the interior angle at the 
indicated point is not valid. 



^3 



> 



(If not, the interior angle at point 2 > 180°) , (17) 



^3 ^ yT ^4 



(If not, the interior angle at point 4 > 180 ) , (18) 



^4 



> 



(If not, the interior angle at point 1 > 180 ) , (19) 



x^ < Xg - (x2 - X3)— (If not, the interior angle at point 3 > 180°) . (20) 



4.87.3.3 Coefficient Generati 



on 



The shape of the panel may be a parallelogram, a trapezoid, or a general quadrilateral, and 
the equations will be different for each case. The slopes of the opposite sides are checked for 
parallel effects, and the correct routine is used for each possibility. 

1. Check for parallel effects: 

If 



>3 -^4 
X3 - x-^ 



sides 1 and 3 of the panel are parallel (e = 10" ) 



< e. 



-6\ 



(21) 



If 



V^vi2) - y3'<4 



X^(X3-X2) 



< e, 



(22) 



sides 2 and 4 are parallel. If both terms are less than e, (i.e., the panel is a 
parallelogram), go to step (4). If both terms are greater than c, go to step (5). If the 
one pair of parallel sides is 1 and 3, go to step (2); if the one pair of parallel sides is 2 
and 4, go to step (3). 



4.87-41 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 

2. In this case the line connecting points 3 and 4 Is approximately parallel to the line 
connecting points 1 and 2. The equations are; 



^2^3^4 



(23) 



Pi = yp - y^ (1 = 1.2.3,4) , 



(24) 



X2y3X4 

'p = ypvy4W^ 



(25) 



a = 



(^)- 



(26) 



-{^)- 



(27) 



P1P2 A 



{1 ■^77Tr:Tr(a^ + ac + c^)} 



V^m: ^' ^iut;j) 



(28) 



3. In this case the line connecting points 1 and 4 is approximately parallel to the line 
connecting points 2 and 3. The equations are: 



d = 



^4 ^ ^^3 " ^2 
^4 ^3 . 



(29) 



^3 " ^4 
\ - U- y^. y^ y^ 



(30) 



4.87-42 



STRUCTURAL ELEMENT DESCRIPTIONS 



Pi = [(Xq - X.) -y.d] /y=3f= (i = 1.2.3.4) . 



+ d' 



(31) 



(Xq - x^)d + y^ 



(32) 



Z = fifi A ._ _2 .2 , ,, ^ ,2, 



P^ ^ ^1 ^KTRT ^^ ' bd + d^)}. (33) 

4. In this case the panel approximates a parallelogram. The equations to solve 



are: 



Pi = 1. (i = 1,2,3,4), (34) 



d - -i 



/x^ X3-X y3-y^. 



7 _ A ,, . 2d^, 

^ "-SlTt (^ "■ W- (36) 



5. In this case no parallel effects exist. The equations are: 

(X3-X4) 
\ ' '''i- Tiyy^ ^4 • (37) 



4.87-43 



MODULE FUNCTIONAL DESCRIPTIONS 



X. 



y 



"^ y 



Pi = I^t^N - N-^ ■^i''^ ^' ° ^,^,^^) . 



3 

P2 



4.87-44 



(38) 



p = T^xHW^ ' 

^zysh (39) 



VVV^^p' • ^''^ 



\' 'P . (41) 



(42) 



C = i- - d . (43) 



b = -i.e. (44) 

P4 



^ - d. (45) 



STRUCTURAL ELEMENT DESCRIPTIONS 



Let: 



Then: 



2jI^ J 3 e 



+ [(c+d) + I (c^+d^) + I (c^+d^)] logg |c+d| 



[(b+c) + I (b^+c^) + ^ (b^+c^)] logg |b+c| 



- [(d+a) + I (d^+a^) + ^ (d^+a^)] log^ |d+a| 



+ ^ [(a^-c^) (b^-d^) + (b^-d^) (a^-c^)] 



- i [(a-c) (b'^-d^ + (b-d) (a^-c^)]} . 



Z = 



(46) 



^^ {"'^h^'-l'^} . (*7) 



4.87-45 



MODULE FUNCTIONAL DESCRIPTIONS 
4.87.3.4 Stiffness Matrix Formulation For a SHEAR Panel (Subroutine KPANEL of Module SMAl ) 
1. Calculate the lengths of the diagonals: 



h3 = V'3^^y3^ 



^24 



2. Calculate the unit vectors along the diagonals: 



^1 


= 


"3 


= 


'^3 

^13 ' 


^1 


= 


^3 


= 


^3 
^13 


"2 


= 


U4 


= 


X4-X2 

^24 

^4 



^2 = ^4 - I^ • 



3. The loads along the diagonals in terms of the average shear stress along 
side 1 are: 



(48) 



= Vv^^/^V • (^^' 



(50) 
(51) 
(52) 

(53) 



fl - ^^2^4^13 (54) 

^ - - 2(x4y3 - x^y^) ' 



4.87-46 



STRUCTURAL ELEMENT DESCRIPTIONS 



2 ^x^Ya- xgy^ - xgtyg-y^)) 



(55) 



Aj = -A^ , 



(56) 



A4 = -A2 



(57) 



4. The loads at grid point i in terms of the displacements at grid 



grid point j may be 



expressed in terms of a (3x3) matrix [k. .] where 






(58) 



i = 1. 2. 3. 4 , 



i = 1. 2, ...i 



5. The 3x3 matrices are related only to deflections and forces. The terms in the 
6x6 matrices, [K.^], corresponding to rotations are zero. Expand the matrices to 6x6: 



[K^j] = 



k. . 



The element structural damping matrix is equal to g^. the structural damping 
coefficient, multiplied by the stiffness matrix, [K..]. 

4.87.3.5 TWIST Element Stiffness Matrix Generation (Subroutine KPANEL of Module SMAl ) 

The following data for the SHEAR panel element are used for generati .n of the 
element stiffness matrix for the TWIST panel. 



(59) 



4.87-47 



MODULE FUNCTIONAL DESCRIPTIONS 



t^e^ 



^2 »^3 '^4*^3 '^4 



The 3x2 transformation matrix (Equation 12). 

The locations of the corners in the element 
system (Equations 14, 15 and 16). 

The energy coefficient (Equation 28, 33, 36, 
or 47). 



"l'^2"3^4 I 
Vl^2^3^4 ) 
A-. [Ap |Ao ,A^ 



Unit vector coefficients at the corners 
(Equations 50 throuqh 53) 

Load coefficients for the corners (Equations 
54 through 57) 

3x3 global-to-basic transformation matrices 



[T^].[T2],[T3].[T4] 

1. Generate the three by three matrices relating the moments at point i to the 
rotations at point j: 

,2 

nTr- . / 'U .. . ,Tr. nTr 



A.A.t 



C^ij] = 4^tT,]'[T^] (-VjU.}'[T^]'[T.]. 

f i I 

These are generated only for one point i (the pivot point) and j = 1,2,3 and 4. 

2. The 3x3 matrices [q..] are expanded to 6x6 matrices [K. .] having zeros in the 
translational displacement rows and columns. 



(60) 



[K,J 



t 



l^i: 



(61) 



4.87.3.6 Mass Matrix Generation (Subroutine MASSTQ of Module SMA2) 

The mass at each point is determined by cutting the quadrilateral into four overlapping 
triangles. Each triangle is defined by three of the four points as follows : 



4.87-48 



STRUCTURAL ELEMENT DESCRIPTIONS 



Triangle No. Connected Points 



K 



ii j2 23 



I 4-1-2 

n 1-2-3 

III 2-3-4 

IV 3-4-1 

The area of each triangle is determined by the equation : 



K ~ 2'^-oj2^--^'ojl^^ ^ ^^%j3^-^%jl^^l . (62) 



A. = -i(lV .2}-(V .,}) X ((V„,,}-{V„,,})| . 



where [^ ^.^} is the location vector of the first point definino the triangle, 
{y^-^} the second point, and ^^^3} the third point. 

The mass of each triangle is divided equally among its connected points. The 



mass 



at each point is 



"^1 = H^ (A, - ^ - A^) . (53) 



m^ = ii4-£tl (,^ ^ ^^ ^ ^^^ _ ^^^^ 



m 



3 = il4^t) (A2,A3.A,). (65, 



'4 = ■H^(A3.A, .A^). (66, 



4.87-49 



MODULE FUNCTIONAL DESCRIPTIONS 



For each point a six by six diagonal mass matrix is constructed. The matrix is 



[M^,.3 = 



m. 
1 



(67) 



J 



4.87.3.7 SHEAR Element Stress and Force Calculations (Subroutines SPANLl and SPANL2 of Module SDR2i) 

The stress and force calculations are performed in two phases: phase 1 in SPANLl; 
phase 2 in SPANL2. 

PHASE 1 



1. Calculate the 1 by 3 matrices [S^.], i = 1, 2, 3. 4 



tS,-] = -m ^- : Vi> tTef [T,-]. 



(68) 



Where A., Z, t, u^, v., [T^] and [T.] are as given in sections 4.87.3.2 and 4.87.3.3. 
2. The [S] terms and the following parameters: 



1 * 2* T^' 



Pg P^Pg P^Pg 



^3 ^4 



are saved on a scratch file for phase 2 calculations, p^, where i = 1, 2, 3 and 4 are 
calculated using the equations in section 4.87.3.3. 



4.87-50 



STRUCTURAL ELEMENT DESCRIPTIONS 
PHASE 2 
1. The average stress along side 1 is: 

4 



i=l 
{u.} are the translational vectors where: 



h = ^l [S,.]{uf}. (69) 






2. The stresses on the corners are : 



P2 :. 



P4 
3. The average and maximum stresses are defined as: 



(70) 



^1 = p7 ^1 . (71) 



"l - 
^2 = pT h • (72) 



PlP2 - 
"^3 = "V s^. (73) 



P3 



P1P2 - 
T4 = -2- s^ . (74) 



^avg = J (^1 + ^2 ■" ^3 ^ •^4)' (75) 



^max = ^'^ (It-,!. It^I. IT3I, It^I). (75) 



4.87-51 



MODULE FUNCTIONAL DESCRIPTIONS 



4. The margin of safety in shear is defined by : 



''^ - 1 . if a > 



M.S.^ 



■ ' ■' 's 
max 



Integer "1", if a^ < 



(77) 



5. The net loads on the corners in the diagonal direction are 



^u - '^ ^^' ' ^''^ 



P24 = ^2 s^t . (79) 



4.87.3.8 TWIST Element Stress and Force Calculations (Subroutines SPANLl and SPANL2 of Module 
SDR2) 

The stress and force calculations are performed in two nhases, as for the SHEAR 
panel element. 

PHASE 1 



1. Calculate for i = 1, 2, 3, 4 



[S^] = -Tjif-Vi ; u^.}[t/ [T.]. (80) 



2. The [S.] terms and the following data: 



P2 P^P2 P1P2 

are saved on a scratch file for phase 2 calculations. 
PHASE 2 

1. The mean outer fibre shear stress along side 1 is: 

4 
i=l 



T^ - I [s.] {u^}, (81 : 



4.87-52 (7/1/70) 



STRUCTURAL ELEMENT DESCRIPTIONS 



where {u^} are the three rotational displacements: 



2. The stresses are : 



'>'^&r\ 



pT^t 



(82) 



^iP 



in 



P2 ' 



(83) 



P1P2 



^r 



(84) 



, . P1P2 
P4 



(85) 



^avg = 4 ^''l ^ ^2 + "^3 ^ °4^> 



(86) 



^max = ™x(kil, 102!. 103!, la^l) 



(87) 



3. The margin of safety in shear is defined by 



max 



1 , a^ > 



M.S. 



Inteaer "1", cr < 



4. The moments are : 



(88) 



A,t' 



'13 



^T 



(89) 



4.87-53 (7/1/70) 



MODULE FUNCTIONAL DESCRIPTIONS 



'24 






(90) 



4.87.3.9 SHEAR Panel Differential Stiffness Calculations (Subroutine DSHEAR of Module DSMGl) 

1 . Data 

The data necessary for analysis are included in the ECPT, CSTM, MPT and UGV 
data blocks. The following data are generated as in sections 4.87.3.2, 4.87.3.3, 
and 4.87.3.4 . 

a. [T.], i = 1,2,3,4, the 3x3 transformation matrices between global and 
basic coordinates, at the four corners of the shear panel. 

b. [T ], the 3x2 transformations between basic and element coordinates. 

c. {k}, the unit vector normal to the plane in basic coordinates. 

d. u., v., i = 1,2,3,4, the unit vectors along the diagonals in element 
coordinates. 

e. A., i = 1,2,3,4, the load coefficients for the corners. 

f. Z, the energy coefficient for the panel. 

g. i^3 and l^^, the lengths of the diagonals. 
2. Algorithm 

a. The load in the diagonal between points 1 and 3 is : 



13 



A-, 4 



H 



]. I A.(u. ! v.}T [t/[T.] 



i=l 



Mi 
^2i 



^3i 



(91) 



4.87-54 



STRUCTURAL ELEMENT DESCRIPTIONS 

Where {x-} is the vector of the three translations in global coordinates for point 
(i). 

b. The load in the other diagonal is : 

^24 ~ K^ ^^3 • (92) 

c. Construct a perpendicular, which is defined in basic coordinates, to each diagonal 
vector in the plane of the panel. 



U,} - [T^] 



^i?^ = [T ] 



■^1 



^1. 



■"2 



[k?4] = -F24tT2^^ [U2>{12>^+ fk}{k}T][TJ. 



(93) 



^2^ - LI3J ^ ^ . (94) 

u. 

d. The nonzero partitions of the overall differential stiffness matrix for 
the displacements are: 

^^?i^ = Fiat^T^^Ti^.^j^.^jT^ ^^j^^^TJ ^^^-j^ ^^^^ 

[k?3J = -F;3[T,f [{jyijyT , (k}{k}T| [T3], (96) 

■^^33^ = F^gLTgjM^JiKli}^ + {k}{k}T] [T3] . (97) 

^4^ = f^?3j'. (98) 

d 



(99) 
(100) 



4.87-55 



MODULE FUNCTIONAL DESCRIPTIONS 



[kj4] 
4^ 



24 



[T^f [{J2}{J2}^ + {k}{k}^] [T^] 



[kjp] = [k24-l » 



(101) 
(102) 



where : 



F' = ^ 
13 ^13 



F' = -^ 



(103) 
(104) 



5. The actual 6x6 partitions are 



[<,] 



k?. ; 



1 _ 



(105) 



and 



[d] = [K?^^ 



(106) 



4.87-56 



STRUCTURAL ELEMENT DESCRIPTIONS 



SIDE 3 



SIDE 4 




SIDE 2 



SIDE 1 



Figure 2. Shear panel element coordinate system and element forces. 



SIDE 2 



SIDE 4 




Figure 3. Twist panel element coordinate system and element fo 



rces . 



4.87-57 



MODULE FUNCTIONAL DESCRIPTIONS 

4.87.4 TRMEM and QDMEM Elements 

4.87.4.1 Input Data for the TRMEM and QDMEM Elements 

1. ECPT entries for the TRMEM and QDMEM are: 

Symbol Description 



TRMEM 




QDMEM 


SIL^ 




SIL^ ^ 


SILg 




SIL2 


SIL3 




SIL3 


"i 




Ni 


^i 




h 


i = 1 


.3 


1 


'i 




Yi 


h 


9 


h 


Mat 


I.D. 
t 

y 
t 





Scalar indices of the connected grid points. 



i = 1.4 



Local coordinate system numbers and location 
coordinates in the basic system for the 
connected grid points. 

Anisotropic material orientation angle 
Material identification number 

Thickness 

Nonstructural mass per unit area 

Temperature for material properties 



2. Coordinate system data 

The numbers N., X., Y. and Z. are used to calculate the 3 by 3 global-to-basic coordinate 



transformation matrices [T. ] for points i = 1, 2, 3, and 4. 



4.87-58 



STRUCTURAL ELEMENT DESCRIPTIONS 

3. Material data 

Symbol Description 

[Gg] 3x3 stress-strain matrix 

p Mass density 

Cj^.oiy.a Three thermal expansion coefficients 

Tq Reference temperature 

9q Structural damping coefficient 

CT^.a^.a^ Stress limits for tension, compression and shear 

4.87.4.2 Basic Equations For TRMEM 

1. The element coordinate system is defined by the following equations (see Figure 4) 



h " ^1 



{Vi2} = ^2- Yt . (1) 



^2-^1 



X3 - X^ 



^^13^ = {^3- ^ll . (2) 

^3-^1 



ti> = —^ . (3) 



{i} X {V,,} 

{k} = IL_ 



{1} X {V^3}| 



(4) 



{J} = {k} X {i} . (5) 

2. The displacement transformation matrix from basic coordinates to in-plane 
coordinates is : 



4,87-59 



'lOUULE FUNCTIONAL DESCRIPTIONS 



[E]' 



^1 ^2 ^3 



J] ^2 ^3 



(6) 



3. The coordinates of the points in the element coordinate system are 



X-, = y-| = y2 = . 



(7) 



KVT?>i . 



X3 = {V^j}"'' {i} , 



yj = id} X {V^j}! 



(8) 
(9) 
(10) 



The area is 



A = 2 ^2 y^- 



[ID 



4. The transformations from displacements at the points to strains are 



[C^] 



i&-l) 

y3\x2 ; 



w^-1 



y^\^ 



3\^2 



(12) 



4.87-60 



STRUCTURAL ELEMENT DESCRIPTIONS 



[Cg] 



-1 
V3 



"3 



(13) 



[C3] = 






i 

1-^3 



^3 



(14) 



4.87.4.3 Stiffness Matrix Calculation for TRMEM (Subroutine KTRMEM of Module SMAl ) 
1. The equation used in the stiffness matrix generation in global coordinates is: 



[ki .] = At([C.][Ef [T.])T[Gg]([Cj[Ef [T ]) . 



(15) 



where "i" is the pivot point number, and j = 1, 2, 3 are the three connected 
points, [k- J is a 3x3 matrix. 

2. For use in the overall structural matrix, the matrices are expanded to 6x6 to 
form : 



t^ij^ = 



^•J 



(16) 



4.87-61 



MODULE FUNCTIONAL DESCRIPTIONS 



4-.87.4.4 Mass Matrix Calculation for the TRMEM Element (Subroutine MASSTQ of Module SMA2) 



The mass is generated by the following algorithm. 
The vectors defining the sides are : 





/ X2 - x^ 


{y,,} - 


^2 - ^1 




( ^2 - ^1 




( ^3 - ^ 


«13^ = 


\h-h 




ih-h 



(17) 



(18) 



The area is 



A = ^|{V^2^ X {V^3}| 



(19) 



The mass at each ooint is : 



m = J (ot + y) , 



(20) 



which is one-third of the total mass. 



For each point the diagonal mass matrix is 



[M,.] 



. i = 1,2,3. 



(21) 



Oj 



4.87-62 



STRUCTURAL ELEMENT DESCRIPTIONS 



4.87.4.5 Element Load Calculations For The TRMEM Element (Subroutine TRIMEM of Module SSGl ) 

Using the loading temperature on the three grid ooints t^ , t^, and t, given in the 
GPTT data block, the triangular membrane routine generates force vectors ay the equation: 



{P.} 



iJ = At[T.f[E] [C.f LG^]{a}t . for i = 1. 2. 3 



where 



and {P.} is a 3x1 vector. 



(22) 



t = J (t^ + t2 + t3) - T^ . (23) 



The forces are placed in the PG load vector data block. 

4.87.4.6 Element Stress Calculations For The TRMEM Element (Subroutines STRMEl and 
STqME2 of Module SDR2) 

1. Calculations performed in STRMEl (Phase 1 calculations). 

a. Using the formulae given in section 4.87.4.2, calculate the following terms : 

[C^] i = a, b, c (3x2) 

[T^] i = a, b, c (3x3) 

[E] (3x2) 

[Gg] (3x3) 

The transformations from displacements to stress are : 

[Si] = [GgJLC.JEEfCT,-]- (24) 



4.87-63 



MODULE FUNCTIONAL DESCRIPTIONS 



The temperature to stress relation is : 



{S^} 



[Gg]{a} 



where 



{a} = 



a ^ 1 




for isotropic materials, {a} is input by the user for anisotropic materials. 

2. Calculations performed by STQME2 (Phase 2 calculations) 
The equation for stress is : 



.z [s.Ku } 

i=a,b,c ^ 



+ {S,} 



t + t. + t^ 
a b c 



xyi 



where t , t, and t are the loading temperatures obtained from the GPTT data block. 



The principal stresses are: 



(25) 



(26) 



[27) 



:^) YM^ *" 



2 

xy 



(28) 



(^) -i^] * 



2 

°xy • 



(29) 



1 



e = ^arctan (57^) 
where 9 is limited to : -90° < 6 < 90° 



(in degrees) 1 



(30) 



4.87-64 



STRUCTURAL ELEMENT DESCRIPTIONS 



The maximum shear is : 



/(^^) 



2 



+ a^ or 

xy ^ "^ ' ' 



4.87.4.7 Differential Stiffness Matrix Calculations for the TRMEM Element {Subroutine 
DTRMEM of Module DSMGl) 

1 . Input Data. 

ECPT for element 

i - Pivot point scalar index 

fu^}, {u^f, i^2' ' Displacements of pivots on triangle (UGV) 

t. - Loading temperature at the grid points of the element (GPTT) 

CSTM - coordinate systems 

MPT - Material properties table 

2. Output Data. 

[K^lJ, [K^2J> ^1^13] - partitions of the differential stiffness matrix. 

3. Solution Algorithm. 

a. The planar stresses in the element, a , a and a , are calculated as in 

X y xy 

the SDR2 (Stress Data Recovery] module. The follov-rfinn data are saved for use 
in the differential stiffness calculation : 

{il, {j}, {k} - Unit vectors defining the element coordinate 
system. 

A, t - Area and thickness 

X2. x^, y^ - Locations of the points, element coordinates 
[T^], [T2], [T^] - Global-to-basic coordinate transformations 

a^, , o - Stresses in element system 



4.87-65 



MODULE FUNCTIONAL DESCRIPTIONS 



b. In generalized coordinates the differential stiffness matrix is 



[K°] = At 



xy 





xy 

^x 




a + <y 
X y 



(32) 



c. The transformation from displacements at the points to rigid body rotations are 











Y3-Y2 


EC?] = 








y^ 




Y2 - Y3 


^1 
■ 7" 







2 





(33) 



[C^] 



^3 
7- 



^1 
7- 



-Y3 

■^1 




(34) 



[d] 



^2 




(35) 



^2 



4.87-66 



where 



STRUCTURAL ELEMENT DESCRIPTIONS 



(36) 



1 
^2' 



(37) 



^2^3 



(38) 



d. The partitions (3x3) of the differential stiffness matrix in global 
coordinates are : 



LK.j] = ([C^] [E'^f [T.])T [KJ] [Cj] [E^f [Tj] . 



(39) 



where 



1 = pivot point 
j = 1, 2 and 3 



[E'']^ 



{i}' 



[3x3) 



(40) 



4.87.4.8 General Calculations for the QDMEM by the QDMEM Driver Routines (Subroutine; 
KQDMEM of Module SMAl , SQDMEl of Module SDR2, DQDMEM of Module DSMGl), 



1. The quadrilateral is divided into four triangles as shown in the figure bel 



ow: 



4.87-67 



MODULE FUNCTIONAL DESCRIPTIONS 





The thickness used for each triangle is one-half that given for the quadrilateral. 
Since no special calculation time is saved by generating a unique element coordinate 
system, the basic locations of the points are used to calculate individual coordinate 
sysuems for the triangles. 

An integer mapping matrix [M] containing the quadrilateral point numbers is 
used to convert point numbers for the triangles to point numbers for the quadrilateral, 



[M] = 



Triangle Point No. 



I— a 



c -1 



1 


2 


4 


2 


3 


1 


3 


4 


2 


4 


1 


3 



Triangle No. 

(I) 
(II) 
(III) 
(IV) 



(41) 



The data corresponding to the point numbers in each row of the matrix are transferred to 
the triangular membrane routine. The pivot grid point i is also transferred. 

2. Material orientation for subtriangles. 

The material orientation angle for the QDMEM element must be transformed to a set 
of angles related to the base of each subtriangle. This requires the following 
steps: 



4.87-68 



STRUCTURAL ELEMENT DESCRIPTIONS 
1. The element coordinate system is defined as follows: 



^Vi> =■ {y. > i = 1. 2. 3. 4. (42) 



^i 



id^-^} = i^l^} - {V^} , (43) 

(d ,} 

(i) =— ^J— . (44) 

^^41} = {V^} - {V^} . (45) 



{i} X {d.,} 

{k} = ^^— . (46) 

|{i} X {d^^}| 



{j} = {k) X {1} . (47) 

The material is oriented for each triangle as follows: 

s^ = sin (9) , (48) 

c^ = cos (9) , (49) 

{p} = c^ {i} + s^{j} , (50) 

{V{j} = {V3} - {V2}. (51) 



{Vfjj} = {V,} - {V3} . 
{V* } = {V,} - {V.} . 



(52) 



IV> = tV^> - iV^) , (53) 



4.87-69 



MODULE FUNCTIONAL DESCRIPTIONS 



'^i 



s. 



{v¥{p} 

—4 = cos (9.) (54) 

i = II, III and IV 

({vh X {p})''"{k} , ^ 

. '—r = sin (9.) . (55) 

|{V?} 



The values s. and c- may be passed to the triangular memSranp subroutines in lieu 
of the angles 6. . 

4.87.4.9 Stiffness Matrix Calculations for the QDMEM. 

Three stiffness matrices, which the triangular membrane routine calculates for each sub- 
triangle, are added to the four matrices which will be output. (Note: only three triangles are 
needed for each pivot point.) For example, consider the case where point 2 is the pivot grid 
point, (i.e., the second SIL value in the grid point connection list equals the pivot grid point 
SIL value). Triangle I is calculated by entering the geometry and property data for the 1 , 2 and 
4 points on the quadrilateral, with number 2 as the pivot point. The outputs from the stiffness 
matrix generation routines for the TRMEM are: 

LKg-iJj [K22J» L'^24-' 

Data for triangles II and III are also entered, and their corresponding matrix partitions are 
added. Triangle number IV is not connected to point 2. 

4.87.4.10 Element Stress Calculations for the QDMEM (Subroutine SQDMEl and STQME2 of 
Module SDR2). 

The solution for stress in the quadrilateral involves two phases. In the first 
phase (SQDMEl) the triangular membrane partitions are solved for their stress-displacement 
matrices. These matrices are modified to correspond to the element coordinate system. They 



4.87-70 



STRUCTURAL ELEMENT DESCRIPTIONS 

are added together to form four 3x3 matrices relating displacements in global coordinates to 
element stress. A vector is also calculated which transforms temperature to stress. 

The second phase (STQHE2) involves the acquisition of the displacement and temperature 
data and the calculation of the net stress. 

The following steps are used to set up an element coordinate system and obtain triangle 
to element stress transformations. 



Phase 1, 



1. The following quantities are calculated: 



^i' 



{V^} = ^ Y. J, i = 1, 2, 3. 4 . (56) 



1 



{d^} = {V3} - {V^} , (57) 

{d^} = {V^} - {V2} . (58) 



{d,} X {d„} 



{3^2^ = ^^2} - {V^} , (60) 

{323} = {V3} - {V2} , (61) 

{a^^} = {V^} - {V^} . (62) 

{^34} = {^4^ - {^3> . (63) 



4.87-71 



MODULE FUNCTIONAL DESCRIPTIONS 



h = {a^2^' {k} 



(64) 



h is the perpendicular distance between the diagonals. The mean Diane of the element 
lies halfway between the diagonals. 

2. The unit vectors along the edges of the four triangles, projected on the mean plane, 
are calculated from: 



^2 = Ua-|2-^ " ^^'^•''1 • 



(65) 



{i} = 



{a^2> - h{k} 



(66) 



{j} = {k} X {j} , 



(67) 



[R] = 



iiiL 



(2x3) , 



^^12> =|i|' 



{v^-j} = [RJ{a.j} ij = 23. 34, 41 . 



(68) 
(69) 
(70) 



{w^} 



= {J|- 



i.'h - 



v^ 



{V23} 



(71) 
(72) 



^"'"^ = ITV^ ^^34> 



(73) 



(w^Vj 



lNl>l 



^^1> . 



(74) 



3. For each triangular membrane, e = I, II, HI, IV, of the quadrilateral, the subroutine 
STRMEl is called to calculate the three stress functions [S.] where 



4.87-72 



STRUCTURAL ELEMENT DESCRIPTIONS 



,1, ^'i^ 'W • 



(75) 



'^2 



triangle 



vvhere l^u^^.} are the displacements in global coordinates of the traints on the trianqle. 
LSj] is calculated using the full thickness of the oanel for triangle B. 

4. The stress functions, Equation 24, are transformed to the element coordinates by the 
matrix [T ]: 



^^^i^element " ^"^ ^I^^i^' 



(76) 



where 



[T^] 



"•? 


4 


-2w,W2 


4 


-? 


2w,W2 


_"l"2 


"^1^2 


2 2 



(77) 



and 



= {w^^} 



(78) 



for triangle 6=1, II, III, IV. 



5. Using the mapping matrix [M], Equation 41, the matrices are added. The actual equati 
are: 



ons 



l^rrl 



II 



-IV. 



[Si] = ;^[S^] + [S^^J + [S^^]) . 

[S2] = j-([sj] + [S^^] + [sji^]) . 



(79) 
(80) 



4.87-73 



MODULE FUNCTIONAL DESCRIPTIONS 



[S3] = laslh + IS^h + [Sj^]) . (81) 

[S4] = |{[sj] + [Sj"] + [S^^]) , (82) 

^V = T(fs{} + {$11} + {s"I} + {Sl^}). (83) 

*' t t 

where [S?] i = a, b, c, are the stress matrices in Equation 76 and {SI} is the vector in 
Equation 25. 

Phase 2 

1, In phase 2 the stresses are calculated from: 



^x 



% 



= ^S^}! + .1^ [S.] {u^^^} . (84) 



\''xy, 



where 

t = \ t^ (t. - T^) . (85) 

and t. are the loading temperatures at the grid points, obtained from the GPTT data block. 

2. The principal stresses and the angles are calculated in exactly the same manner 
as for the TRMEM element, 

4.87.4.11 Mass Matrix Generation for the QDMEM Element (Sifcroutine MASSTQ of Module SMA2). 

The mass is generated by the following algorithm. 
The vectors defining the sides and the diagonals are: 



{V.j} = < Y^ - Y. V , ij = 12, 23. 34, 41, 13. 24 (86) 




4.87-74 



STRUCTURAL ELEMENT DESCRIPTIONS 



The area of the subtriangles defined by the integer mapping matrix [M], Equation 41, is: 



Ajii = i |{V23}x {V34}| . 
Aiv = i |{V34}x{Vi4}| . 



(87) 

(88) 
(89) 
(90) 



The area of the quadrilateral is: 



\ = i UVi3}x{V24}| 



(91) 



The mass at each point is: 



(A, + A ) 

—4-9- (p + pt) , 

(An + A ) 
" 3 ^ (y + pt) . 



(Attt + AJ 



'III 



^ (y + pt) . 



(Ai„ + A ) 
^\ ^ iu + pt) 



(92) 
(93) 
(94) 
(95) 



For each point, the diagonal mass matrix is: 



[M^^] = 



m. . 
m. 1 


lO 
1 

- i 1 



i = 1. 2, 3, 4 



(96) 



4.87-75 



MODULE FUNCTIONAL DESCRIPTIONS 

4.87.4.12 Thermal Load Computation For The QOMEM. 

The thermal loads are calculated using the triangular membrane routine. The EST 
data are rearranged to correspond to each of the four subtriangles. and each triangle produces 
a load in global coordinates. 

4.87.4.13 Differential Stiffness Computations For The QDMEM (Subroutines DQDMEM and DTRMEM 
of Module DSMGl). 

The differential stiffness matrices for the QDMEM element are generated by rearranging 
the ECPT data into four sets of TRMEM data. The TRMEM differential stiffness routine 
calculates the stresses, generates the differential stiffness matrix partitions in global 
coordinates and inserts them in the overall matrix. 



4.87-76 



MODULE FUNCTIONAL DESCRIPTIONS 

4.87.4.14 Piecewise Linear Analysis Calculations (Subroutines PSTRM and PSQDM of Module PLA3 and 
Subroutines PKTRM and PKQDM of Module PLA4) 

The additional ECPTNL and ESTNL entries are: 



- The previously computed strain value once removed. 

- The previously computed strain value. 

- The previously computed modulus of elasticity. 



X 

* 

'y 

* 

^xy 



The previously computed membrane stresses 



All of the above values are initially zero with the exception of E , which is initially the 
original modulus of elasticity present on a MATl card. 

For both PLA3 and PLA4, the element stress matrix calculations are generated in the same 
manner as Equation 24 of section 4.87.4.6 (Equations 79 through 82 of section 4.87.4.8 for 
the QDMEM), with the exception that for all DMAP loops (of the Piecewise Linear Analysis Rigid 
Format) after the first, the 3 by 3 material properties matrix [G ] is replaced by a stress- 
dependent 3 by 3 material properties matrix [G ] defined as follows 



^%^ 



'-^ 


-Vn^SyF 


'W/ 




-4^ 


<y'y' 


(sym) 




2(l+v)+4Fo 



xy 



(97) 



where 



r *2 * 



* *2 *7 

a„ + cf ' + 3a 

y y xy 



] 



F = 



o~5f 

4TfE 



1/2 



(98) 



(99) 



4.87-76a (12-1-69) 



MODULE FUNCTIOMAL DESCRIPTIONS 



* * 
3 



(100) 



* * 

2a - a 

y X 

s = — "^ 

y 3 



(lOi; 



and 



E and \i are the linear type 1 material properties. If E = 0, or x^ = 0, then [Gp] = [0]. 
Calculate the incremental element stresses: 



Aa. 



Aa, 



Z [Si](Au i) 

i=a,b,c ' 



(102) 



Ao 



xy 



where [S-] is given in Equation 24 of section 4.87.4.6, and {Au^.} are the 3 by 1 translational 
displacement vectors. 

Define the element stresses for output and for updating the ECPTNL and ESTNL: 



"^xl = 


\ ' ^°x 


°yi = 


'I ' % 


°xyl ' 


* 

a + Aa 
xy xy 



(103) 

(104) 
(105) 



In PLA3, using the element stresses above, the principal stresses are calculated in the same 
manner as in Equations 28 through 31 in section 4.87.4.6. 

Estimate the next elastic coefficients as defined by the following equations: 

1/2 



M 



"xl - °xl°yl " °yl " 2°xyl 



(106) 



e, - r\.,) 



(107) 



where f is the tabular stress-strain function. (When t^ is outside the range of the function, 

it it ic 

define E, = 0, e, = e , and e = £„). 



4.87-76b (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Calculate: 



'^e = ^1 - e . (108) 



•ff "k it 



^1 = 


1 4 - .\ ' '°' ^2 ^ =1 




V , for eg = £■] 



The new ESTNL and ECPTNL entries are: 



* 

^0 


* 

= e 


* 




e 


= ^1 


* 
E 


= ^1 


* 




^x 


= °xl 


* 




°y 


= ''yi 


* 




'^xy 


= ^xyl 



(no) 



Eg = £] + Y(Ae) , 

where y is a load ratio parameter calculated by the module driver (PLA3 or PLA4). 
Calculate: 

^2 = ■•'(^2^ • (111) 

where f is the tabular stress-strain function. 

Then the estimated next modulus of elasticity, E, , is given by: 



(112) 



(113) 
(114) 
(115) 
(116) 
(117) 
(118) 



In module PLA4, the element stiffness matrices are calculated in the same manner as 
Equations 15 and 16 of section 4,87.4.3 (or as in section 4.87.4.9 fcr the QDMEM) , with the 

4.87-76C (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



exception that [G ] matrix is replaced by the [Gp] matrix (Equation 97). In the calculation for 

[G ], E (Equation 112) is used for E*. and the newly calculated membrane stresses (Equations 103, 

* * , * 
. a and a 
x' y xy 



ir "k "it 

104 and 105) are used in place of a , a and a 



4.87-76d (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 




Figure 4. Triangular membrane element. 



4.87-77 



MODULE FUNCTIONAL DESCRIPTIONS 

4,87.5 The TRBSC. TRPLT and QDPLT Elements 

4. 87. 5 J Input Data for the TRBSC and TRPLT Elements. 

1. The ECPT/EST entries for the TRBSC and TRPLT are: 

Symbol Description 

SIL , SIL , SIL Scalar indices for the connected grid ooints 

M v Y Z ) Reference numbers for local coordinate system 

i' i' i' i \ and locations in basic coordinates of the three 

i = 1^ 2, 3 / connected grid points 

I Bending moment of inertia per unit width 

t Effective thickness for transverse shear 

u.^ Ijj Material property identification number for bending 

'b 

l^3|._ i(j_ Material property identification number for shear 

e Material orientation angle 

■^ Nonstructural mass per area 

7 7 Fiber distances for stress calculations 

t Temperature of element for material orooerties 

u 

2. ECPT entries for the QDPLT. 

The entries are the same as those for the TRPLT exceot that four points are used. 

3. Coordinate system data 

Using N. , X., Y.. Z. and the CSTM data block the 3 by 3 global-to-basic coordinate trans- 
formation matrices [T^] are produced for each point i via subroutines TRANSD or TRANSS. 

4. Material data 

Using the material property identification numbers, the orientation angle, the element 
temperature and the MPT and DIT data blocks, the following data are calculated: 



4.87-78 



STRUCTURAL ELEMENT DESCRIPTIONS 



Symbol 

for Mat Id, 

b 

for Mat Id. 



[G,] 



Description 

3x3 elastic property matrix 
Structural damping coefficient 

Shear coefficient 



For the TRPLT and the QDPLT, the orientation of the material relative to each sub- 
triangle must be calculated from the geometry and the orientation aiven for the 
whole element. The details of this calculation are given in the next section. 

4.87.5.2 General Calculation for the TRBSC Element 

1. The coordinate system is defined by the three connected points a, b and c. 

{i}. {j} and {k} are the unit vectors along the x, y and z axis in basic coordinates. 

X., Y. and Z. are the location coordinates of the three points. i=a, b. c. (The element 

coordinate system for the basic bending triangle is shown in Figure 2 of section 5.8 of 
the Theoretical Manual). 



^ \ - ^, 



^Vab> = < 



a J 



(1) 



^Vac> = <! 



h - h^ 



'c - ^a 



a J 



(2) 



The X axis is defined by the unit vector: 



{1} 






(3) 



Calculate: 



{k} = 






(4) 



4.87-79 



MODULE FUNCTIONAL DESCRIPTIONS 



The y axis is defined by the unit vector. 



{J} = {k} X {i} 



2. The locations of the points in element coordinates are: 



(5) 



y, = Vh = 



(6) 



l<U>l ' 



x^ = (V^^}' {i} , 



J r. 



yc = ^V> ^J^ = 1^^^' ^Vl 



(7) 
(8) 
(9) 



3. The 3 X 6 transformation matrix from the six displacements in element coordinates 
to the three degrees of freedom used in the plate is: 



[E]' 



"^1 


h 


h 








" 











^'l 


^2 


^3 











h 


h 


^3 



(10) 



4. The coefficients used for the plate are: 



[D] = I[Gu] . 



[Go] = t. 



G, 



(11) 
(12) 



4.87-80 



STRUCTURAL ELEMENT DESCRIPTIONS 



where [G^] is the 3 x 3 material matrix for bending and G^ is the coefficient for 
transverse shear. The area of the triangle, A, the locations of the e.g.. x and 7, 
and the radii of gyration about the origin, p^. p2 and p^^ are given by: 



^ = I '^b ^c • 



T ^^c ^ ^b^ 



(14) 



^ = I^c • 



:i5) 



,2 _ 1 ,..2 
'x 



^■'^ - ^ ^\ ^ \ ^-^ ^ ^ 



c 1) 



;i6) 



2 1 2 

Py = FVc 

2 y 



xy 



12 ^>^b " 2x,) . 



(17) 
(18) 



rhe stiffness matrix in generalized coordinates lal is: 



y^] - 4A 



^11 



' "l3 

4- _ 



xD 



12 



D- 



-I 



3xD 



12 



11 



3xDi 



I 33 I °23 [ ^^"13 



I °22 I 3xDl2 \^ 



SYMMETRICAL 



/2v^3 

XD23 
^2y-D33 



xDpp 
.2vD23_ 

3pJd12 

Xg 



1^« 



D22 + 



3yD 



12 



3vD 



23 



3yD 



[»x°,^ \.,;i^,^ ■Ka_^_ 



22 



^P:y°23 ' 
iPy°33 



3°xyD22 



9py'^22 



(19) 



4.87-81 



MODULE FUNCTIONAL DESCRIPTIONS 

6. The transformation from generalized coordinates to grid point displacements (relative 
to point "a" of the triangle) with no transverse shear is: 



[H] = 



-2x^ 



-2x 



Cc 



-3xf; 



2 ,. 3 



2 3 

V y„~ x^' X y V 
^c c c c-'c 'c 



2y 
■'c 



-y 
•'c 



-3xt 



2x„y„ 3y„ 
c-'c •'c 



-y'- 
'c 



(20) 



where {q} = [H]{u} (no transverse shear) 

7. If transverse shear effects are to be calculated (G^ t^ ^ 0), the followina 
steps are followed: 

a. Define 



t1 



[J] = [Gg]' 
b. Calculate the transformation matrix of the shear coordinates: 



[H ] = 

yq 



. _| _|_ I — — . — I 

G I I I 6(J^2°11^J22°13> ] Jl2^2D^2^4D33)+6J22D23 I^^J] 2°23^'^22D22) 



(2i; 



(22) 



4.87-82 



STRUCTURAL ELEMENT DESCRIPTIONS 



where 






%,^ ^q^ 



(23) 



c. The stiffness matrix of the shear terms is added to the bending stiffness matrix. 



[K^] = [kX] , A[H^,q]T [G^] [H^q] . 



(24) 



d. The effects of shear deflection on the transformation from general to displacement 
coordinates is calculated: 



[H] = [Hj 



xJl.. x,H.. x,H 



If no shear exists, [H] = [H] 



8. The matrix [H] is inverted: 



^b'Vq,4 ^b\q^5 Xb"yq 



16 


















X H 

'^ Yqi4 

+y H 






























X H 
c yq 



15 



X H 
c yq^g 



+V„H 



c vq 






25 



+v H 
c yq 







26 



[Hq,] = [H]-l . 



(25) 



(26) 



9. The rigid body effects are given by the matrices [B, ] and [B J defined as follows: 



4.87-83 



MODULE FUNCTIONAL DESCRIPTIONS 



1 



1^,1 = 





1 













1 




1 


^c 


-\ 


[B,] = 





1 













1 



(27) 



(28) 



10. The 3x3 stiffness matrix partitions in element coordinates are calculated as 
follows: 



[K] = [H'^f [k'I] [H-1] . 



(29) 



[K]=> - 



^bb 



'cb 



^bc 



cc 



[k^^] = -[k,b^ [B^] - [k,,] [B,] . 



[\^] - -[k,,] [B,] - [k,^] [B^] . 



t^a^ = -^\^' t^ba^ - tBc^' tk^a^ 



(30) 

(31) 
(32) 
(33) 



tW = t^ca^ ' 



(34) 
(35) 



t^ab^ = t^ba^' • 
4.87.5.3 Stiffness Matrix Calculations for the TRBSC Element (Subroutine KTRBSC of Module SMAl ) , 

1. If the basic triangle is used by itself as a TRBSC element, the stiffness matnces 
are: 



[K,j] = 



t"^ ; 



m [k,jl[E]' 






(36) 



4.87-84 



STRUCTURAL ELEMENT DESCRIPTIONS 



where 



1 = a, b and c 
j = a, b and c 



2. The structural damping matrices are calculated using g^, the structural damping coeffi- 
cient. for the referenced bending material. The 6 by 6 damping matrix partitions are: 



4.87.5.4 Stress Calculations for the TRBSC Element. 

The stress calculations involve two phases. The first phase is used to calculate the 
matrix relations between element forces and grid point displacements. 

1. The relation between element forces and generalized coordinates is: 



(37) 



[k^] = 



where 



2D 



11 



2D 



12 



2D 



13 



2D 



13 



2D 



23 



2D 



33 



2D 



12 



2D 



22 



2D 



23 



M 



/ M 
S xy 

v.. 



\ V / 



6xD 



6xD 



6xD 



-6D 



-6D 



11 



13 



2xD^2+ 



11 4yD 



13 



2xD22+ 



1 2 4yD 



23 
2XD23+ 



13 4yD 



33 



-2^12- 



4D 



33 



-6D 



23 



[K3] {q} 



6yD 



12 



6yD 



22 



6vD 



23 



-6D 



23 



-6D 



22 J 



(38) 



(39) 



4.87-85 



MODULE FUNCTIONAL DESCRIPTIONS 



Note: When the basic triangle routine is used for stress recovery in the TRPLT or 
QDPLT, the values x and y in the above matrix are replaced by x^, and y^ or x and y^. 

2. The matrix [H] is calculated and inverted. The [B] matrix is calculated ([B] is a 
6x3 matrix, the [B, ] matrix (Equation 27) comprising the first three rows and the [B^] 
matrix. Equation 28, comprising the last three rows). The [E] matrix and the global-to- 
basic transformation [T ], [T. ], [T^] are generated. [H]' is partitioned. 



[H]" 



tHlb 1 ^^ic^- 



(40) 



The element force - global displacement matrices are: 



[S3] = -[k^lLHj-HBjLEf 



^alO 



u° 1 \ 



(41) 



^V 



[k3][H^,][E]T 



]b|_0_ 
IT, 



(42) 



[SJ = [k3][H^,][E3' 



(43) 



3. The second stage of stress calculations involves the use of the disnlacement 

vectors {u }, {u, } and (u }. The element forces are: 
a b c 

^ 

M. 



xy/ 



i=a,b,c 



[s^Ku.}. 



(44) 



The stresses are: 



"«,) 



yi 



T- \ y 



i = 1.2 



(45) 



xyi; 



xy 



4.87-86 



STRUCTURAL ELEMENT DESCRIPTIONS 

The principal stresses and their orientation are calculated in the same manner as those for 
the TRMEM element, section 4.87.4.6. 

4.87.5.5 Stiffness Matrix Calculations for the TRPLT Element (Subroutine KTRPLT of 
Module SMAl). 

The NASTRAN bending triangle (triangular plate element. TRPLT) is fabricated from three basic 
bending triangles. The geometry and notation are shown in Figure 5. The general approach is to 
calculate the stiffness matrices for all three subtriangles or basic triangles and use the con- 
straint equation of equal slope at the midpoints of the connected edges to calculate a reduced 
stiffness matrix. Since only the partitions of the stiffness matrix related to one noint 
(the pivot grid point) are used for each calculation, the extra partitions are not used. 
In the NASTRAN system, the basic bending triangle calculations are in subroutine form, 
and the variables necessary to call it are: x^^, x^, y^, the property and material 
coefficients, and the transformations for orienting the anisotropic materials. The 
following steps are used to calculate the overall stiffness matrix for the composite triangle. 

1. The element coordinate system is defined by the location of the three grid points 
in basic coordinates, {x(l)}, {x(2)} and {x(3)}: 

{V2} = {x(2)} - {x(l)} , (46) 

{V3} ■- {x(3)} - {x(l)} . (47) 

h - ItVgll . (48) 

{V2} 
{i} = — . (49) 



V3 = |{i} x {V3}| . (50) 



ii} X {V,} 
{k} = — _ 3 ^ (5^j 

^^3 



4.87-87 



MODULE FUNCTIONAL DESCRIPTIONS 



{j} = {k} X {1} , 



[E] = 



{k}j_ ;_o_ 

I {i} l{j} 
L I 1-1 



(6 X 3) 



(52) 



(53) 



The locations of the points in this coordinate system are: 



{Rd)} = ) 

(} = 

( 



{R(2)] 



X3 = {V3}' {i}. 



(54) 
(55) 

(56) 



{R(3)} = 



(57) 



{R(4)} = ^ 



1 j'^2 ^ '^31 



(58) 



2. For use in transferring points to the subtriangles, the integer matrix [M] is 
f rmed : 



[M] = 



Point a 

1 
2 
3 



Point b 

2 

3 
1 



Point c 

4' 

4 

4 



Subtriangle B 

I 

II 
III 



(59) 



The Roman numerals I, II and III indicate the subtriangle numbers. Points 1 , 2 and 3 are 
the corners of the whole triangle whose centroid is denoted by 4. Points a, b, and c are 
the corners of the subtriangles. Point c in the subtriangles is always the center point, 4. 
(see Figure 5). 

Note: Steps 3 through 7 are performed for each subtriangle. 



4.87-88 



STRUCTURAL ELEMENT DESCRIPTIONS 



3. The location of the three points for each subtriangle, 6, is defined by the 
vectors {r.(a)}, {r.(b)}, {r.(c)}. In terms of the original vectors these are: 



r^-(a) = R.(M(e.l)) 
r.(b) = R.(M(e,2)) 
r,-(c) = R (4) 



i = 1 . 2 , 



(60) 
(61) 
(62) 



where M(3, i) is the (e, i) element of the [M] matrix. 

4. The variables necessary to calculate a basic bending triangle are x^^, x and y since 
the local coorcinate system for each subtriangle is chosen such that the "a" point lies on 
the origin and the "b" point lies on the x axis. 

For each triangle the following are calculated: 



£ = 



^irAh] 



•"1(3)] + [r2(b) - r2(a)]^ (length of base), 
Wi = J (r^{b) - r^(a)), 
W2 = J ir^ib) - r2(a)) . 



5. The matrix [T] used for transforming the element coordinates to subtriangle 
coordinates is formed: 



(63) 
(64) 
(65) 



[T] = 



1 



"1 "2 



-W2 w^ ^ 



(66) 



The material orientation angle, e^^. is calculated for each subtriangle. The equation 



s are: 



sin (e^) = w^ sin (9) - Wg cos (6), 



cos (9^) = w^ cos (6) + W2 sin (9) 



67) 



(68) 



4.87-89 



MODULE FUNCTIONAL DESCRIPTIONS 

The displacements in the subtriangle system are equal to [T] times the displace- 
ments in the original system (note det [T] is unit length, X|^ = Ri(2), x^ = Ri(4) and 
y = RjC^) for subtriangle I). 

5. The parameters x, , x and y^, are then computed: 

X|3 = w^[r^{b) - r^(a)] + W2[r2(b) - r2(a)3 , (69) 

x^ = w^[r^(c) - r^{a)] + W2[r2(c) - r2(a)] . (70) 

^c " -W2[ri(c) - r^(a)] + w^[r2(c) - r2(a)]. (71) 

7. The stiffness matrices are formed as in the basic bending triangle (Equations 30 through 
35) and give: 

[k^,], [k^b^. [ki,]. [k^J [k^b^. [k^^] i = pivot grid point. 

They relate forces and displacements in the subtriangle coordinate system and are trans- 
formed to the overall element coordinate system (i.e., the same system as subtriangle I). 

Since the stiffness matrices for each pivot grid point are calculated separately, 
not all of these partitions are used. For each pivot grid point, i, the following 
partitions are used: 

[K.^], [K.2]. [K.3] , 

and 

[K-i^], [K2^3, [^34]. [K44J . 

The integer mapping matrix [M] is used to determine if and where to add the oartitions. 
The steps used for pivot point i and triangle 3 are: 



4.87-90 



STRUCTURAL ELEMENT DESCRIPTIONS 



a) [Tf [kg^] [T] is added to LK^_4], m = M(S.l) 
[T]^ [k^^] [T] is added to [K^ 4], m = M(e,2) 



[if [k^^] [T] is added to [K^^^] 

b) IfM(3,l) = i: 

[T]^ [kgg] LT] is added to [K..J 
[T]^ [k^f,] [T] is added to [K.^], i = M(e,2) 
or if M (6,2) = i 

[if [k^^] [T] is added to [K^^] 

[if [kg^]^ [T] is added to [K.^], i = M{3,1) 

c) The above is repeated for each of the three subtriangles. 

8. The number 4 point in the middle is a dummy point, and since the displacements at point 
4 are functions of the other cisplacements, it will be removed from the problem by including 
the calculations for the point 4 displacements in the calculations for the corner displace- 
ments, as shown in steps 8a, 8b, 8c and 8d. 

a. Calculate the following geometric constants: 



', = U*'l)' 



/2 



(X. 



^c)^^^^ 



1/2 



(72) 



(73) 



(74) 



Xk - x^ 
b c 



(75) 



(76) 



4.87-91 



jDULE functional DE.SCRIPTIONS 



h 



ill) 



b. The forirulas for the locations of the midpoints are: 



M - Z\ 



[78) 



'l = 2^c 



(79) 



D C 



(80) 



H '- 2^c 



m: 



c. The [H ] matrix is calculated as foil 



ows: 



t%] 



-2x^ c^ ^lh-^1^1 2yiSi -3x^0^ y^(2x^s^ - y^c^) Zy]s^ 
2X2 C2 X2S2 + y2C2 2y2S2 3X2C2 y2(?X2S2 + y2C2) 3y2S2 



The slopes in terms of the deflections of points a, b and c ere defined by the 
matrices: 



^ViV^ = ^V^"^'' 



(83) 



C%a^ 



[H.J[H] 

V 



-1 



[B] + 



°^1 '^l 
S2 C2 



(84) 



1-1 



where [H]" and [B] are calculated while generating the stiffness matrices. [H]' 



is the inverse of the 6x6 matrix in Equation 25, and [B] = 

where [B^^] and [B^] are calculated in Equations 27 and 28 respectively. 

These are transformed to element coordinates by: 



is a 6x3 matrix 



l^J - [H^J [T] . 



(85) 



d. Each row of the matrix corresponds to the slope angle of the mid-point of the sicies 



4.87-92 



STRUCTURAL ELEMENT DESCRIPTIONS 

The first row defines the slope of the normal to the line connecting point "a" to the 
center point. The second row defines the slope of the normal to the line connecting 
point "b" to the center point. Using the [H^J matrices, four 3 by 3 matrices. [G^]. 
are formed as follows: 



The [MJ matrix is now used: 



[H] 



c 

2 4 

3 4 
1 4 



I 

II 

III 



(86) 



For the [H^J^ matrix, (a = a. b and c; 6 = I, II or III), the number M(S,a) which identifies 
the matrix [G^] is found. The three terms in the first row of [H ]^ are added to the 
M(g,l) row of the [G^] matrix. The three numbers in the second row of [H, }^ are added to 



ifia" 



the M(B.2) row of the [G^] matrix. This procedure is repeated for the three [H f matrices 
for each triangle g. 



The stiffness matrix partitions of the whole plate are computed from: 



[K^j] = [K..1 - ([G4r1[G.])T[K.^jT . [K.^lCG^r^CG .] 

+ (LG4]-^[G.])^[K,,][GJ-^[G.] for i = 1. 2. 3 

^ .1 = 1, 2. 3 • 

where [K. .] are computed as in step 7. 

9. Using the locations of the three grid points in basic coordinates, the 3x3 
transformation matrices [Tj], j = 1. 2. 3. are calculated. The 6x6 matrices [C] 
are formed as: 



(87) 



[Cj] 



:f^j^ I 



i [T,-] 



1. 2. 3 



10 



The stiffness matrix partitions in global coordinates for oivot point i are 
computed from: 



(88) 



4.87-93 



MODULE FUNCTIONAL DESCRIPTIONS 



[Kf .] = [C.f [E][K^ ][Ef [Cj] (6x6) . 



where: 



[K^.] was calculated in step 8 
[E] was calculated in step 1 



[C], [C] were calculated in step 9 



Figure 5, The triangular plate element, TRPLT. 

1, 2, 3 = GIVEN GRID POINTS 

4 = CENTROID OF TRIANGLE 

I, II, III = BASIC SUBTRIANGLES 

a, 'J, c = ORDERED VERTICES OF SUBTRIANGLES 



(89) 




4.87-94 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.5.6 Structural Damping Matrices for the TRPLT Element, 
The structural damping matrices are: 

[<j] = geCK?,.]. (90) 

where g^ is the structural damping coefficient for the bending material referenced. 

4.87.5.7 Stress and Element Force Calculations for the TRPLT Element (Subroutines STRPLl 
and SBSPL2 of Module SDR2). 

For stress recovery, the relationship between the center point and the corner points 
is used to describe the stress functions for each subtriangle. The stresses in each sub- 
triangle at the center point are averaged to provide the final element stress and forces. 

1, STRPLl is used to calculate the phase 1 stress-displacement relations. 

The following data are calculated using the sare equations as those for the stiffness 
matrix generation routines, 

[C^-] - i = 1, 2, 3 - Global-to-basic transformations 



[E] - element to basic coordinate transformati 



on 



Xjj, x^, y^ - subtriangle point locations 

, sine, cose - material orientation 
Values computed for 

each subtriangle ) ^1 ' ^2 ' element-to-subtriangle coordinate 

transformation 

'^^a-'' ^\h^' t^^ii/c-' " "°'^^1 slope angle relation- 
^ ship matrices 

For each subtriangle, 6=1, II, III, the following matrices are formed: 



4.87-95 



MODULE FUNCTIONAL DESCRIPTIONS 



[V*"] 









1 
















[T^] 


' 



_0 


^1 


"2 




t 




"-? 




4 




-2w,W2 










4 




"? 




2w,W2 










^1^2 




-W^Wg 




w2-w3 

























^1 


-W2 


_ 














Wo 


w 



(91) 



(92) 



1 -^ 



For each subtriangle 6, three 5x3 transformations are calculated, [S^], a = a, b. c. 

These are transformed and added to the corresponding matrices for each point with the equation: 



[S,^] = ^ Z [V^][S5[T^] . 



(93) 



Where the a, which denotes points on the subtriangle, corresponds to the grid point M 
on the overall triangle. 

CH^„] = [iT^^] [T] a = a, b, c . 

The [H^J matrices are added to the corresponding [G^^] matrix with the appropriate 
row interchanges. When the data for all three subtri angles have been generated, the 
following operations are pertormed: 



(94) 



[Sj] = [Sj] - [sJlCG^r^CG.] 

for M = 1, 2, 3; 

[S„] = [S^][Ef[C.] 
for M = 1, 2, 3 . 



(95) 



(96) 



4.87-96 



STRUCTURAL ELEMENT DESCRIPTIONS 



2. Phase 2 

a) The vector of forces is computed first. 



My 



% / = ^ [S.J (u.}. (97) 

X 

b) The stresses are then calculated from the equatior 

M Z. 
°xi = ^ ) (98) 

M Z. 
'^yi = "V^ / i = 1.2. (99) 

M Z. , 
'^xyi = ^y_ 1 / (100) 

The principal stresses and angles are calculated using the same formula as those for the 
membrane element (see section 4.87.4.6, Equations 28, 29 and 30). 

4.87.5.8 Stiffness Matrix Calculations for the QDPLT Element (Subroutine KODPLT of 
Module SMAl) 

The quadrilateral plate element uses two sets of overlapping triangles as shown in 
Figure 6. The logic is the same as that for the quadrilateral membrane except that the order of 
the points of the triangles is chosen to place the triangle coordinate systems along the 
diagonals. 

1. The following equations are used to calculate the three unit vectors, {i}, {j} 
5nd {k), which define the element coordinate system. 



4.87-97 



MODULE FUNCTIONAL DESCRIPTIONS 



{V.} 



. i = 1. 2, 3. 4. 



(101) 



The diagonals are: 



{d,} = {V,} - {V,} , 



{dg} = {V^} - {Vg} . 



(102) 
(103) 



The area is calculated from: 



A = ^1 ({d^} X {dg})! 



(104) 



The normal to the Diane is calculated from: 



{k} = 



{d^} X {d2} 
|{d^} X {d2}| 



(105) 



{a,} = {Vp} - {V,} , 



h = {a^}' {k} . 



(106) 
(107) 



The vectors lying in the new plane are computed from: 



{i} = 



{a^} - h{k} 
|{a^} - h{k}| 



(108) 



{,i} = {k} X {i} . 



(109) 



The nonzero positions of the points in the plane are computed from: 



4.87-98 



STRUCTURAL ELEMENT DESCRIPTIONS 



h = ^^-^ ^■'^ • (110) 



h - ^d^}^ {i} . (Ill) 



^3 = fdi>"^^J"J . (112) 



X4 = X2 + ({dg}"^ {i}) . (113) 



^4 = ^<^2^ ^J^ • (114) 



{R(i)} = 



^• 



Y. 
1 



2. Element interior angle tests. 

The interior angles of the quadrilateral must be less than 180°, The followinq 
checks accomplish this task. 

ISil Point with angle greater than 180° 

If Y4 < T 

If Y3 < 2 

If X, > X2 - (X2 - X3) ^ 3 

If X3 < y- X^ 4 

3. The relative data for each subtriangle must be calculated and oassed to the 
matrix calculation subroutine. The integer mapping matrix [M] denotes which points. 
1, 2, 3, and 4 of the quadrilateral, are used in the subtriangle. The row position 
indicates the subtriangle to which the point belongs, and the column position 
indicates the corresponding point in that subtriangle. 



(115) 



4.87-99 



i^'ODULE FUNCTIONAL DESCRIPTIONS 



Point a Point b 



[MJ = 



4 
1 
2 
3 



Point c 



Triangle 

No. 



I 

II 

III 

IV 



4. For each triangle the stiffness matrix is calculated in its own coordinate 
system. This system has its origin at point a, point b lies on the x axis, 
and point c has a positive y component. {R(i)} values are transferred to {r(a)} values 
(a = a, b, c), and the following calculations are performed: 



{v(b)} = {r{b)} - {r(a)}. 



(116) 



{v{c)} = {r(c)} - {r(a)}. 



(117) 



{v(b)} 
|{v(b)}| 



(118) 



x^, = |{v(b)}| , 



:ii9) 



"] "2 



.W2 w^ 



{v(c)} 



(120) 



X, , X and y are the point locations needed by the subroutine, 
b* c ■'c 



[T] = 




w. 



(121) 



4.87-100 



STRUCTURAL ELLMENT DESCRIPTIONS 

w^ is the X component of the new x axis and W2 is its y component, [T] transforms 
the z displacement and the two angles from the quadrilateral system to the triangle 

system. 

In order to calculate the material matrices in the basic triangle routine, the material 

orientation angle, 6 , is : 

m' 



sin9_ 



= w^ sine - W2 cose , (122) 



cose^ = w^ cose + W2 sine . (123) 

w^ and W2 are the cosine and sine of the angle made between the base of the triangle 
and the material orientation axis. 

5. The output of the basic bending triangle routine are the 3x3 matrices: 

t^aa^' t^ab^' ^Kb^' ^Kc^' l^c^- C^^c^ • 
To transform these to the quadrilateral system the following equation is used: 

[K^j] = i [Tf [k.j][T] . (124) 

These matrices are added to the current positions in the quadrilateral matrix 
partitions Uiing the [M] matrix in step 3. 

6. For each pivot point i the following 3x3 partitions are formed: 



[kij], for ,1 = T, 2, 3. 4. 

7. Using the geometry data, the 3x3 global-to-basic transformations [TJ 
are formed for j = 1, 2, 3, 4. These are expanded to the 6x6 matrices [C.]: 



4.87-101 



MODULE FUNCTIONAL DESCRIPTIONS 



[Cj] = 



^j 



(125) 



8. The stiffness matrix partitions in global coordinates are found from: 



[Kfj] = [C^f [E][k^j][E]^[Cj] . 



(126) 



where [E] is defined in Equation 53. 

4.87.5.9 Stress and Element Force Calculations for QDPLT Element (Subroutines SQDPLl and 
SBSPL2 of Module SDR2) 

1. SQDPLl calculates the phase 1 stress-displacement relations. A coordinate system 
matrix [E], the subtriangle base vectors {w.] , W2} and the global-to-basic trans- 
formation matrices are calculated with the same equations as those used in the plate element 
stiffness matrix calculations. For each subtriangle, 6, the following matrices are formed: 



[T^] = 



1 

w 





w^ 



'1 J 



(127) 



[V'^] 



-; 


-2 


-2w,W2 


4 


w^ 
'^1 


Zw-jW^ 


^f2 


-«1«2 


(w^-w^) 





















(128) 



4.87-102 



STRUCTURAL ELEMENT DESCRIPTIONS 

For each subtriangle the stresses must be calculated at the intersection point of the 
diagonals. In the quadrilateral system: 



X2 X3 y^ 



=^3^4 ^ ^^^2 - '^4^^3 



(129) 



For each subtriangle: 



^5 = 3^ X5 



(130) 



(V5} = {r(a)} - 



; X = KVJJ; V = 0; 



^5^ 



(131) 



Where x^ and y^ denote the location of the intersection of the diagonals of the quadrilateral in 
the subtriangle coordinate system. The stresses are calculated at this point. 

a 

[T ] transforms the translation and two rotations in the element system to the sub- 
triangle system. [V^] transforms the three moments and two shears of the subtriangle to the 
element system. For each subtriangle e. three 5x3 transfonnations are calculated [S^] 
a = a, b, c. These are transformed and added to the corresponding mtrices for each 
point with the equation: 



[sj]. = I I [v^JCsejCT^] . 



(132) 



where the a. which denotes points on the subtriangle. corresponds to the grid point M on the 
quadrilateral . 



2. Using the basic-to-element and global -to-basic transformations, the stre 
matrices [S^^] in global coordinates are formed from: 



ss 



[S^] = [S^][E]T 



:[TJ" 



(133) 



3. The additional data for phase 2 calculations a 



re 



4.87-103 



MODULE FUNCTIONAL DESCRIPTIONS 

I, Z,, Z2 from the ECPT data. 

4. Phase 2 (Subroutine SBSPL2) 

The 5 by 6 [S„] matrices are used in the same manner as the TRPLT elements (see Equations 
97 through 100). 

4.87.5.10 Lumped Mass Matrix Generation for the TRBSC. TRPLT, and QDPLT Elements (Subroutine 
MASSTQ of Module SMA2). 

The lumped mass matrices are calculated in the same manner as the triangular or quadrilateral 
membrane except that the material density is not used (see Equations 86 through 96 in section 
4.87.4.10). The only contribution to the mass matrix from these elements is the nonstructural 
mass, \i. 



4.87-104 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

4.87.5.11 Coupled Mass Matrix Calculations for the TRBSC Element (Subroutine MTRBSC of Module 
SMA2). 

The mass properties of the two-dimensional elements are defined by their geometry, the mass 
density given by the material, the thickness of the element and the nonstructural mass. The 
normal execution of NASTRAN will result in the calculation of the total mass of the element and 
distribute it as lumped masses at the connected grid points (subroutine MASSTQ of module SMA2). 
If the parameter C0UPBAR is set by the user, the elements with bending properties will have their 
mass distributed according to their elastic properties. This results in element mass matrices 
with directional properties and coupling terms between points in an element. Since the thickness 
of the TRBSC element is zero, a coupled mass matrix for this element does not exist. The MTRBSC 
subroutine is used exclusively by subroutines MTRPLT and MQOPLT. 

1. The mass matrix [M] in generalized coordinates is calculated in the following steps, 
a. Integral values I.^ used in the mass matrices are calculated from the formulas: 



^J = 



^b 
FT 



"b - '^c 



j+i 



J = 0,1, ...6 



(134) 



^j 



-wTui^jw ' rFj^A.-i.j . ] = o:?::::6 



(135) 



1J 



(X,) 



i+1 



1+TT. 



(yJ 



(yj' ' (i+l)(i+j+2) ^ 



i+j+2 



i = 0,1,... 6 
J = 0,1, ...6 



(136) 



lij = n.[A^B ] . 



i = 0,1, ...6 
j = 0,1, ...6 



(137) 



where m is the nonstructural mass, and where x^, x^ and y^ are computed in Equations 7, 
8, and 9 respectively. 



4.87-104a (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



b. Partition [M] into submatrices. 



[M]==> 



^aa 1 "ar 


"Ir 1 "rr 



(138) 



Where [R ] is a 3 by 3 matrix, [M ] is a 3 by 6 matrix and [M^^] is a 6 by 6 matrix. 
c. The mass matrix [M,^] is given by: 

da 



t^aa^ 



'^OO ^01 "■'iQ 



^01 ^02 "hi 



'ho "hi ^20 



(139) 



d. The other matrices, [M^^] and [M„„], are less simple. The algebraic expressions for 



ar 



rr 



the elements of these matrices are given in Tables la and lb below. 



Table la. Elements of the 3 by 6 Matrix [M J. 



Notes: H is contracted to H.., where [H ] is computed in Equation 22. 

"ar. . is contracted to M., , where H., represents an element of [M] given 

1 J IK IN 

in Equation 138. 



"l4 = ^20 



"15 = hi 



"l6 = ^02 



"i7 ' ho "" ^i4ho ^ "24^01 



4.87-104b (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



Table la (con'd). Elements of the 3 by 6 Matrix [M ] 



ar-" 



"i8 = hz ' ^^5ho ^ h5^o^ 



% - ^03 ^ H^gl^Q 4 H26lo^ 



"24 = ^21 



'^25 = ^2 



"26 = ^03 



M27 = I3i+Hi4lll -H24IQ2 



^28 = ^13 ' "15^11 ^ "24^02 



"29 = ^04 ^ "lehl ^ H26I02 



"34 = -I30 



"35 = -h^ 



^36 = -^12 



"37 = -^0 - ^14^20 - "24^11 



"38 = -^22 - "15^20 - "25^1 



''39 = -^3 - "l6^20 " "26^11 



4.87-104C (12-1-69) 



i-V)'-ll FUMCTIONAL DESCRIPTIONS 
Table lb. Elements of the 6 by 6 Matrix [M^^]. 



Notes 



. H is contracted to H..; M^„ is contracted to H.^. where M.^ represents 
an element of [M] given in Equation 138; lA.. = A--. 



\a " ^40 



M45 '- ^31 



^^46 = ^22 



\l - I50 ' "14^30 ' ^24^21 



^48 = ^32 ' '^15^30 " "25^1 



^^49 = ^23 * ^16^30 ^ ^26^21 



"55 '-^ hi 



^56 = ^3 



M57 = ^41 * "14^21 ^ "24^2 



M58 = ^23 * "15^21 ^ "25^2 



M59 = ^4 ' '^15^21 " "26^2 



f^66 = ^04 



^67 = ^32 ^ ^14^2 " "24^03 



^68 = ^14 ^ ^15^2 ^ ^25^03 



^69 = ^05 " ^16^2 " "26^03 



2, 



f'V7 = ^50 ' '""uUo ' 2H24I3I ' ("14^^20 " 2H-,4K24l„ - (H24) I 

4.87-104d (12-1-69) 



02 



13 



04 



MODULE FUNCTIONAL DESCRIPTIONS 



Table lb (con'd). Elements of the 6 by 6 Matrix [M ] 



+ H24H15I11 + H24H25IQ2 

^79 = ^33 ^ ^16^40 ^ ^26^31 ^ "14^13 ^ ^^14^^16^20 " "uVll ^ »24^ 

M88 = I24 ' 2H15I22 + 2H25l^3 + (ti^fl^^ . 2"l5»25^11 ' ^h/'oz 

'"89 = ^15 ^ "16^22 ^«26H3-^'^15h3^ "15^16^20 " "15^26^11 + "25^04 
' hih^'u ' »25»26l02 



4.87-104e (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



2 The mass matrix [M ] in element coordinates is calculated from the following equation: 



tM„.ass^ = 



-H'^B 



T _ 



Xr ! ^r ' 
I 



-H"^B 



(140) 



where [I] is a 3 x 3 identity matrix. [H]"^ is calculated as in Equation 25. [B] = 
calculated as in Equations 27 and 28. 

The calculations are broken down into the following steps where: 



is 



t^ass^ = 



"aa 


\^. 


1 


^c 


'^ba 


\ \b 




^c 


"^ca 


1 




"cc 



and [M. .]. 1 = a. b. c and j = a. b, c are 3 by 3 matrices, 
a) Compute: 

[M] = [H-h^ [M,J [H"^] . 



(141) 



(142) 



b) Partition: 



c) Compute: 



[M]==> 



'bb 



'cb 



'be 



cc 



,-1- 



[M^i] = [M,,]["-] 



(143) 



(144) 



d) Partition: 



[M^i]ze> [M,t,i M,,] 



(145) 



4.87-104f (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



e) Calculate: 



t^ab^ = tM,t,] - [b/CM,,] - [b/[M^^^] 



^^c^ 



t^aa^ 



f^aJ 



t"ca3 



t"ac3 - tBb]'[Mb,] - [BJ^EM^J 



c-" ■■ CC-' 
TfM iT ro nTr„ nT 



t^aa^ - tBb]'[M,b]' " [Bc]'["ac^ 



^V ■ 



(146) 
(147^ 
(148) 

(149) 
(150) 



4.87.5.12 Mass Matrix Calculations for the TRPLT Element (Subroutine MTRPLT of Module SMA2) 

1. The general calculations for the mass matrix of the triangular plate element, TRPLT, are 
the same as those for the stiffness matrix calculations (See Equations 46 through 71). 

2. For each subtriangle the output from the basic bending triangle subroutine are the nine 
3x3 matrices given in Equation 141: 



"aa 




"'ab 




"ac 


"ba 


—1 


'^bb 




-^bc 


"ca 




"cb 




"cc 



They relate forces and accelerations in the subtriangle coordinate system and must be trans- 
fonned to the overall element coordinate system (i.e., the same system as subtriangle I). 

The matrix partitions in the subtriangles are added to the correct matrix partition for 
the whole triangle. For example, for subtriangle number II. m J is transformed and added 
to [M22]. [M^jj] is transformed and added to [M23], [M^^] is transformed and added to [M,^], 
i^\g) is transformed and added to [M32]. etc. 



'24^ 



4.87-104g (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 

Since the mass matrices for each pivot grid point are calculated separately, not all of 
these partitions are used. For each pivot grid point, i. the matrices which are used will be: 

[M.,], [M.o], [M.,] . i = point 1 , 2 or 3 of composite triangle 



and 

[M^4]. [M24]. [M34]. [M44] . 

3. The number 4 point in the middle is a dunmy point and is removed from the problem in the 
same manner as in the computation of the stiffness matrix (see Equations 72 through 86). 

The mass matrix partitions of the whole plate are: 

[M^j] = [Mij] - ([G4r^[G,.])'[Mj4f - [M.4][G4]-^[G.] (151) 

+ ([G4]-^[G^])^ [M44] [34]-! [Gj] i : ]; \\ I . 

Notice that if i and j were interchanged the matrix would be transposed; this indicates 
that the whole mass matrix is symmetric. 

4. Using the locations of the three grid points in basic coordinates, calculate the 3 x 3 
transformation matrices [T^]. j = 1 . 2. 3. Form the 6 x 6 matrices: 



[C.] 



^J 



h 



(152) 



5. The 3 x 3 mass matrix partitions are expanded to 6x6 size and transformed to global 
coordinates using the logic: 



(153) 



where m is the nonstructural mass, and t^, Y3 are the x- coordinate and i^ coordinate of points 
2 and 3 respectively, 

4.87-104h (12-1-69) 



MUDULL FUNCTIONAL DESCRIPTIONS 



[M?-] 

TJ-' 



n 



'21 



'31 



'12 



'22 



'32 



'13 



'23 



'33 



(154) 



For i = j = 1 , 2 or 3; and 







11 



'21 



'31 



12 



'22 



'32 



13 



'23 



'33 



(155) 



for i ?* j. 



The mass matrix partitions in global coordinates are: 



[Mfj] = [Cif[E][M^j][Ef[Cj] . 



where 



[C^] 



■^i 



(156) 



(157) 



4.87-104i (12-1-69) 



OUULl 



jiJLriOi<AL DESCRIPTIONS 



is the global-to-basic transformation matrix, 



and 



[E] 



{i} j {j} 

T 

I 
|_ I 









{i} 





{j} 





{k} 



(158) 



is the 6 X 6 element-to-basic transformation matrix, 
4.87.5.13 Mass Matrix Calculations for the QDPLT Element (Subroutine MQDPLT of Module SMA2). 

1. The general calculations for the mass matrix of the quadrilateral plate element, QDPLT, 
are the same as those for the stiffness matrix calculations (see Equations 101 through 123), 

2. For each subtriangle, the output from the basic bending triangle subroutine are the 
nine 3 X 3 matrices: 



M 
"aa 


^ab 




'^ac 


'^ba 


"bb 


1 


"be 


^a 




^b 




%c 



These are transformed to the quadrilateral system by the following equation: 



[Mij] = J [if [M.j] [T] . (159) 

where [T] is given in Equation 121. 

These matrices are added to their corresponding positions in the quadrilateral matrix 
partitions [M?.], in the same manner as that for the stiffness matrix partitions of the 
quadrilateral (See step 3 of Section 4.87.5.8). 

3. For each pivot point i, the following 3x3 partitions are formed: 

[M^]. for j = 1, 2, 3. 4 . 

4. The mass at each point in the plane of the element is due to the mass of the attached 
triangles. The masses of the triangles are: 



4.87-104J (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



m^ = m .& ..& 



J\ ^c ' i^ = I. II. ni and IV , (igQ) 

where m is the nonstructural n,ass, and x^^ and y^ are the x-coordinate and y-coordinate of 
points b and c respectively of subtriangle e. 



The masses at the points are: 



m 



= I [m^ + m^^ + m^Vj 



nip 



m^ 



1 I L"i - m + m J , (,g,. 



jLmWm^^ +r,^^^] , ^^g^) 






(163) 



'^ " 3 L'" -^ '" -^ m J . (164) 

5. The 3 X 3 mass matrix partitions are expanded to 6 x 6 matrices and the in-plane mass 
effects are added using the logic: 

i ^-ti 

'"z = ~r • (165) 

z " 4 • (166) 



4.87-104k (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



[MtJ 



m. 



m. 



m. 



-ml 







Mn Ml 2 



"21 hz^^l "23 



M31 •^32 



^13 ° 



M33 ^ 'I 



(167) 



for i = j = 1 or 3; and 



t^j^ = 



m. 



m. 



"11 "12 



'21 



Ml3 ° 



M22 - ll M23 



M31 M32 







M33^^z 



(168) 



for i = j = 2 or 4; and 



4.87-104JI (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 











































[M^j] = 








"n 


'"12 


^u 






ll 



M 







21 



COM. 



31 



•'22 '^'23 



''32 '''33 



(169) 



for i ^2. 



6. Using the geometry data, the 3 x 3 global-to-basic transformations [T.] are formed for 
j = 1, 2, 3, 4. These are expanded to 6 x 6 matrices: 



[Cj] 



T. 
J 



I 



7. The 6 x 6 element-to-basic transformation matrix is: 



— 








1 


1 1 


{i} 


{j} 


{k} 

_ 





1 

[_ 


I 
















_ 








{i} 


I {j} 

r 


1 {k} 
1 _ 



CE] 



The 6 X 6 matrices are transformed to global coordinates using the equation: 



(170) 



(171) 



[M?j] = [C.]T [E] [M^.] [E]T [c.] 



(172) 



4.87-104m (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 




a) Definition of plane 





b) Subtriangles 



Figure 6. Geometry of the quadrilateral plate element, QDPLT. 

4.87-105 



MODULE FUNCTIONAL DESCRIPTIONS 

4.87.6 The TRIA1 . TRIA2. QUAD! and QUAD2 Elements 

These elements have the properties of both membranes and bending plates. The TRIAl 
and QUAD! elements are triangles and quadrilaterals which may use separate thicknesses 
and materials for membrane, bending and transverse shear action. The TRIA2 and nUAD2 
elements are triangles and quadrilaterals which use one thickness and one material to 
simulate a homogeneous plate with consistent membrane, bending and transverse shear 
properties. 

If these elements use anisotropic materials (defined on a MAT2 bulk data card), the 
material is oriented with respect to the element coordinate system. The definition of the 
coordinate system is as follows: the vector from the first point to the second point defines 
the base or x axis. The z axis is normal to the average plane of the elements, and the third 
and fourth points have positive y values. 

Mass matrices, thermal loads, and differential stiffness matrices for these elements 
use only the membrane properties. 

4.87.6.1 Input Data for the TRIAl, TRIA2, QUADl and QUAD2 Elements 
1. The ECPT/EST entries for the TRIAl or QUADl elements are: 
Symbol Description 

SIL-, i = 1,2,3 ) Scalar indices of the connected grid points, 

or i = 1,2,3,4 

"i 
i I i = 1,2,3 or Referenced local coordinate system and location 



''i \ i = 1,2,3,4 
^i 



in basic coordinates of connected grid points. 



6 Material orientation angle. 

MAT ID„ Material identification number for membrane 

m . . 

properties. 

t^ Membrane thickness. 

MAT ID, Material identification number for bending 

properties. 



4.87-106 



STRUCTURAL ELEMENT DESCRIPTIONS 

Symbol Description 

I Bending inertia 

MAT ID^ Material identification number for transverse 

shear properties. 

tj Transverse shear thickness 

y Nonstructural mass per area 

■^1 • ^2 Outer fiber distances for stress calculations. 

tp Temperature for material properties 

2. ECPT Entries for the TRIA2 or QUAD2 Elements. 

Symbol Description 

Scalar indices of connected grid points. 



Referenced local coordinate system and location 
vector in basic coordinates of connected 
grid points. 



9 Material orientation angle. 

^^^ ^D Material identification number 

\ Element thickness 

y Nonstructural mass per area. 

*p Temperature for material properties 

4.87.6.2 Stiffness Matrix Calculations (Subroutine KTRIOD of Module SMAl). 

The TRIAl or QUADl element ECPT data are rearranged to correspond to the (TRMEM or QDMEM) 
membrane ECPT form, and the routine of the TRMEM or QDMEM element is used. The ECPT data are 
then rearranged to correspond to the ECPT data of a TRPLT or QDPLT element and the respective 
plate routine is used. Each routine is entirely independent. 



4.87-107 



SIL. 


i 


_ 


1,2,3 or 




i 


= 


1.2,3,4 


N. 








h 


i 


ss 


1,2,3, or 


) 
Y. 


i 


= 


1,2,3,4 










^i 









MODULE FUNCTIOMAL DESCRIPTIONS 

The TRIA2 and QLIAD2 elements are treated in the same manner except that the arrangement of 
the ECPT data is different. The type "2" element uses the single material for all three material 
properties of the type "1" element. The membrane and transverse shear thickness equal the single 
thickness of the type "2" element. The bending inertia, Ij^, for the plate property is: 

^b = 4 (1) 

4.87.6.3 Lumped Mass Matrix Generation (Subroutine MASSTQ of Module SMA2) 

The bending properties are disregarded for the lumped mass matrix calculations, and the 
element mass matrices are computed exactly as the ones for the TRMEM and QDMEM elements, 

4.87.6.4 Thermal Load Calculations (Subroutine EDTL of Module SSGl) 

The bending properties are disregarded for the thermal load calculations, and the thermal 
load vectors are computed exactly as the ones for the TRMEM and QDMEM elements. 

4.87.6.5 Element Stress and Force Calculations (Subroutines STRQDl and STRQD2 of Module SDR2) 

As with the stiffness matrix calculations, the data are rearranged and the stresses for both 
the membrane and plate deformations are calculated. The element forces are calculated for the 
plate only. 

1. For the TRIA2 and QUAD2 elements the outer fiber distances Z-. and l„ are: 

Z2 = -| (3) 

The membrane and plate stresses are added together as follows for Z,: 






^^ I composite ^ ^^ ' membrane ^ ^•^ ' bending 



4.87-108 (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



and for Zp, 

°x2 \ / °x \ / °x2 

°y2 I = K ' °y2 

°xy 2 / composite \ °xy /membrane \ °xy2/ bending 

2, The principal stresses and their orientation are calculated from the above results, as 
in Equations 28, 29 and 30 of section 4.87.4.6. 

4.87.6.6 Differential Stiffness Matrix Calculations 

The element differential stiffness matrices are formed using the membrane properties only. 
The element differential stiffness matrix routines, DTRMEM and DQDMEM, are called directly from 
subroutine DSIA of module DSMGl (see sections 4.87.4.7 and 4.87.4.13). 

4.87.6.7 Coupled Mass Matrix Calculations (Subroutine MTRIQD of Module SMA2). 

In the lumped mass case these elements are processed using the membrane mass calculation 
routines (subroutine MASSTQ of module SMA2). When coupled mass is requested, the plate mass calcu- 
lations will be used instead. The ECPT data are rearranged to the appropriate TRPLT or QDPLT 
format, and the respective plate routine is used. The mass per area is now calculated using the 
material mass density p and the thickness t for the membrane definition of the element and added 
to the nonstructural mass: 

m = M + p t|^ . (6) 



m is now used instead of \i for the plate calculations. 



4.87-109 (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.6.8 Piecewise Linear Analysis Calculations (Subroutines PSTRIl, PSTRI2, PSQADl, and PSQAD2 
of Module PLA3 and PKTRIl, PKTRI2, PKQADl and PKQAD2 of Module PLA4) 

The additional ECPTNL and ESTNL entries are: 

E - The previously computed strain value once removed. 

£ - The previously computed strain value. 

E - The previously computed modulus of elasticity. 
* 

* 
a ) The previously computed membrane stresses. 

* 
°xy 

* 

* 

M ) The previously computed element forces (ESTNL only), 
xy 

* 
* 

* 
All of the above values are initially zero with the exception of E , which is initially the 

original modulus of elasticity present on a MATl card. 

In module PLA3, the incremental element stress matrix is calculated by first rearranging 
the ESTNL data to correspond to the ESTNL data for a TRMEH or QDMEM, and then the membrane 
stresses are calculated in the same manner as Equations 103 through 105 of section ^.87 A. 1^. 
Then the ESTNL data are rearranged to correspond to the EST data for a TRPLT (or QDPLT) and 
the incremental bending forces for the TRPLT (or QDPLT) element are calculated in the 
same manner as in Equation 97 of section 4.87.5.7. However, if the bending material properties 
are the same as the membrane material properties, then the 3 by 3 bending material properties 
matrix ([G, ] in Equation 11 of section 4.87.5.2) is replaced by the matrix given in Equation 97 
of section 4.87.4.14. In addition the displacement vector {u^} in Equation 44 of section 

4.87-109a (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



4.87.5.4 (or Equation 97 of section 4.87.5.7) are replaced by an incremental displacement vector 
{AU.}. 

The results are incremental stresses and forces for the membrane and bending properties 
defined as follows 



°xl = '^x ^ ^°x \ (7) 

* I 
a 1 ~ °u ■*■ '^°v / Membrane stresses , (8) 



^y1 


= V"xy 


^xl 


= mVam^ 


^^ 


= M* + AM^ 


^yl 


= <y^^"xy 


\^ ^ 


= \''\ 


^1 = 


- v^ 



(9) 
(10) 
(11) 

Bending forces . (12) 

(13) 
(14) 

The total bending stresses are calculated using the total bending forces given in Equations 10 
through 14 in conjunction with Equations 98 through 100 of section 4.87.5.7. 

The membrane and bending stresses are added together as follows for Z-,: 

''^xi \ ^xn r^i 

"yi [ = ryi \ ' W ^ ' (15) 



xyl / composite v xyl / membrane v"xyl / bending 



4.87-109b (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



and for Zg: 



^y2 






\2 



+ / 



'xy2 / compos i te ^ xyl / membrane 



y2 
^xy2 ^ bending 



(16) 



The principal stresses and their orientation for output are calculated from the above results, 
as in Equations 28 through 30 of section 4.87.4.6. 

In module PLA4, the bending properties are disregarded, and the ECPTNL data are rearranged to 
correspond tc the ECPT data for the TRMEM or QDMEM, and the stresses are calculated exactly as the 
ones for the TRMEM or QDMEM elements (see section 4.87.4.14). 

In modules PLA3 and PLA4, after the above stress calculations have been completed, the next 
elastic coefficients are calculated in the same manner as Equations 106 through 112 of section 
4.87,4.14. 

The new ESTNL and ECPTNL entries are: 



= E, 



= a 



xy 



xl 

°yi 

°xy1 



= M 



xl 



M 



xy 



= M 



xyl 



(17) 
(18) 
(19) 
(20) 
(21) 
(22) 
(23) 
(24) 
(25) 



4.87-109C (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



In module PLA4, the ECPTNL data are rearranged, and the element stiffness matrices are calcu- 
lated in the same manner as for the TRMEM or QDMEM elements in section 4.87.4.14. 



4.87-109d (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



4.87.7 The ELASi, MASS1 and DAMPi Elements 

The scalar elements (ELASi, MASSi and DAMPi, i = 1,2,3,4) are connected to scalar 
components of grid points or to scalar points. The ELASi elements contribute only to: 
a) the stiffness matrix, [K^ ], for i = 1,2,3,4; and b) to the structural damping matrix, 
[K ], for i = 1,2,3. The MASSi elements contribute only to the mass matrix, [M ], and the 
DAMPi elements contribute only to the viscous damping matrix, [B„„]. 

The scalar elements do not require material or geometric properties in their calculations. 
Only the ELASi elements are used for stress or force calculations. 

4.87.7.1 Input Data for the ELASi, MASSi and DAMPi Elements 
The ECPT/EST entries for the scalar elements are: 



Symbol 


Description 


SIL^, SIL2 


Scalar indices of connected 
scalar points 


Ct C2 


Component numbers correspon( 
SIL-, and SILg. 


K 


Spring constant 


9e 


Damping factor ) 


S 


Stress coefficient ) 


B 


Viscous damping coefficient 


m 


Mass coefficient 



Elements 
All 

Types 1 and 2 

All ELASi elements 

ELASI , 2 and 3 

All DAMPi elements 
All MASSi elements 



4,87.7.2 ELASi Stiffness Matrix Generation (Subroutine KELAS of Module SMAV 



1. The two connected scalar indices are i, and i^ given by: 



SIL-i + (c-j - 1), if Point 1 is a grid point 
SIL-,, if Point 1 is a scalar point 



4.87-110 



STRUCTURAL ELEMENT DESCRIPTIONS 



j SIL2 + (cg - 1), if Point 2 is a grid point 
^ SIL21 if Point 2 is a scalar point 



2. The following terms are added to the [K*^ 1 matrix: 

gg 

+K in position (i,, i,) and in position (i„, i„), 
-K in position (ig, ij and in position (i,, i„). 



3. If point 2 is not defined, add +K to position (i,, i„) 

4. The damping terms are: 



k"^ = Kg^ . (1) 

These are added to [K ] in the same manner as the stiffness terms were added to fK^ 1 
gg '- gg-" 

4.87.7.3 MASSi Mass Matrix Generation (Subroutine MASSO of Module SMA2) 

These elements are treated like the ELASi elements except the "m" term is added to the 
four positions in [M 1. 

gg 

4.87.7.4 DMAPi Damping Matrix Generation (Subroutine MASSD of Module SMA2) 

These elements are treated like the ELASi elements except the "B" term is added to the 
four positions in [B 1, 

gg 

4.87.7.5 ELASi Stress and Force Recovery (Subroutines SELASl and SELAS2 of Module SDR2) 
The element force is: 



F = K(U2 - u^), (2) 

where u^ and U2 are the displacements at scalar index numbers i-, and ip. 



4. 87-111 



MODULE FUNCTIONAL DESCRIPTIONS 



The element stress is: 



a = SF. (3) 



4.87-112 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.8 Concentrated Mass Elements C0NM1 , C(aNM2 

Two types of grid point mass data are available, C0NM1 defines the mass matrix directly 

at the point, with the axes defined by a given local coordinate system. C0NM2 defines the 

same matrix for a body with a mass and three inertias with a center of gravity offset from 
the grid point. 

4.87.8.1 ECPT Entries for the C0NM1 Mass Element 



Symbo 1 



Description 



'r 


X. Y. Z 








^11 










""21 


, m22 








■"31 


1^22 »^3'5 








""41 


.^42.^43, 


."144 






^^ 


.m52.ni53, 


.^54, 


■"^55 




^1 


'V''"63' 


.ni64. 


■%5' 


'\6 



Local coordinate system number in which the 
mass matri'v is defined. 

Local coordinate system number and basic 
coordinates of the point. 



Terms of mass matrix given in row form (out 
to the diagonal term). 



4.87,8.2 Mass Matrix Calculations for the C0NM1 Element (Subroutine MCUNMX of Module SMA2) 

1. Using the synmetrical relationships, fill out the remainder of the 5x6 matrix, 
[m]: 



ij 



m.. 



(1) 



2. Using the basic coordinates of the point and the local coordinate system definition, 
the 3x3 transformation matrices [T ] and [T ] are generated, and the mass matlrix in global 
coordinates is: 



4,87-113 



MODULE FUNCTIONAL DESCRIPTIONS 



[M] = - 










[m] 



7r< 







(2) 



where [T ] is the transformation from global-to-basic coordinates at the point, and 
[T^] is the transformation from the coordinates defined by the mass local system to 
the basic coordinate system. 



4.87.8.3 ECPT Entries for the CPM2 Mass Element 



Symbol 



Description 



Local coordinate system number in which the 
mass terms are defined. 



Ng. X. Y, Z 



Local coordinate system number and basic 
coordinates of the point. 



Concentrated mass 



x.y.z 



Offset of center of gravity in mass coordinate 
system 



^11 



^21' ^22 
^31* ^32' ^33 



Inertias about the center of gravity qiven in 
row order out to the diagonal term 



4.87.8.4 Mass Matrix Calculations for the C0NM2 Element (Subroutine MCJ3NMX of Module SMA2) 
1. The transformation from the offset to the grid point is: 



[D] = 



(3) 



4.87-114 



STRUCTURAL ELEMENT DESCRIPTIONS 



2. The mass matrix referenced to the offset point is: 



[m,] = 



I 

_ I 

m I 



Ii, -I 



11 '21 '31 



'_T 

I ^21 



1-^31 



I22 -I32 
■^32 "^33 



(4) 



3. The mass matrix about the grid point along the given coordinates is: 



[m] = [D]^[m^][D].. 
The actual nonzero terms of matrix [m] are calculated directly from the equations: 



(5) 



■"11 ° ""22 = ""33 = "^ 



■"15 ° ""51 ' "'"24 " "'"42 " "^^"^ • 



""16 = ""61 = -"^34 = -'"43 = -y^ 



mnc = m, 



26 - '"62 - -'"35 - -""BS 



xm 



""Ad = In + (y^ + z^)!" 



2 . .2v- 



"■55 = ^22 "*■ ^^ ■*■ "^ )'" ' 



■"66 = I33 + (x + y )ni , 



m. c = m, 



'45 '"54 - "'21 



I,, - xym , 



(6) 
(7) 
(8) 
(9) 
(10) 

(11) 
(12) 
(13) 



4.87-115 



MODULE FUNCTIONAL DESCRIPTIONS 

%6 = ""64 = -^31 - ^^ . (14) 

"^56 = ""65 = -^32 - y^"" • (15) 

4. The matrix [m] is transformed back to global coordinates using Equation 2. 



4.87-116 



STRUCTURAL ELEMENT DESCRIPTIONS 
4.87,9 The CgNEAX Element 
4.87.9.1 Input Data for the C0NEAX Element 

1. The ECPT/EST entries for the C0NEAX element are: 
Symbol Description 

^^'■a' ^^"-b Scalar indices of the n^*^ harmonic of the 

connected rings 

" Harmonic index 

Radii at points a and b 

Projected distances along the axis 

Membrane thickness 

Membrane material identification number 

Bending coefficient 

Bending material identification number 

Shear thickness 

Shear material identification number 

Outer fiber distances for stress calculations 

(J^, i = 1 to 14 Angles defining points around element 

\ Temperature for material properties 

M Nonstructural mass 

4.87.9,2 Stiffness Matrix Calculations (Subroutine KC0NE of Module SMAl). 

1. The shell orientation is given by: 



•"a- 


'b 


\' 


h 


\ 




MAT 


'\ 


I 




MAT 


'^ 


\ 




MAT 


'^ 


h' 


h 



f/^'-b - ^)' ^ (^ - ^a)' • (1) 



sin^ = '-^^ , (2) 



cos^ = ^^ . (3) 

4.87-117 



MODULE FUNCTIONAL DESCRIPTIONS 

2. The transformation matrix [E] from element coordinates to ring cylindrical 
coordinates is: 



[E] = 



■q 


sin 


* 


cos 


'l> 








1 





















cos 


i' 


-sin 


^ 
























sin ijj 















1 





















cos i|; 



(4) 



3. The serial steps for the balance of the stiffness matrix computations unique to the 
axlsyranetric conical shell element are explicitly described in the NASTRAN Theoretical 
Manual section 5.9.5.7 (Suimiary of Procedures). 

4.87.9.3 Mass Matrix Computation (Subroutine MC0NE of Module SMA2) 



t"aa] = 



m 




















m 




















m 


































































(5) 



where 



m = n{-^ + ^) (pt + p) 



(6] 



4.87.9.4 Element Load Calculations (Subroutine C(9NE of Module SSGl). 

The Fourier coefficients of the temperatures are stored in the GPTT data block. The 
loads are generated by the elements, which reference the connected rings and harmonics in- 
directly by the grid point scalar indices. The scalar indices are used with the SIL (Scalar 
Index List) data block to obtain the temperatures. The following steps are used to aenerate 
the loads: 

1, The data for a logical element are read from the EST data block. The harmonic 



4.87-118 



STRUCTURAL ELEMENT DESCRIPTIONS 
number, n, is extracted from the element ID, H , by the equation: 

Ng = lOOON + (n + 1) , (7) 

where N is the total number of harmonics plus one in the problem. 

The temperatures for this particular element and harmonic (T^ and T*^) are extracted from 
the GPTT data block. (No default nonzero temperatures are allowed). 

2. The following data are generated in the same manner as in the stiffness matrix routine, 
KC(3NE: 

r^, r^, z^, z^ - Ring locations 

a - Linear distance 

sinip, cosi^j - Inclination functions 

[E] - Element-to-global transformation matrix (6x5) 

t - Element thickness 

[E|^] - Material matrix (3x3) 

a^ = a = a - Temperature coefficient 

3. The geometry coefficients, I^^^, are calculated as in the stiffness matrix routine by the 
equation: 



= n/s%^-"ds = ^/ 



I„_ = n / s-" r^-" ds = ^ / s"" r^-" dr . (8) 



mn 

"& r. 



a 



r, - r 

where r = a + bs,a = r, ,b = — -j — =■ 

a K 



4, The loads are generated in generalized coordinates, {p''}, with the equations: 



n 



^Pln> = "(^Ol^'^ll^^ • (9) 



4.87-119 (12-1-69) 



where 



MODULE FUNCTIONAL DESCRIPTIONS 

{P3,} = sin^ (loi^ + ^n^n) • (11) 

{P^^} = cos^(Io^A^+ I^^B^) . (13) 

IPg^} = cos*(I^^A^ + l2iBj . (14) 

(Py = cos*(l2^A^+ l3iB^) . (15) 

{Pg,} = COSMI31A, -^ l4iB^) . (16) 



{Pg^} = , (17) 



(PlO^ = . (18) 



^ = t^lZ^VS^^tEzZ^V;) . (19) 



^n = |(Tn-Tn)(Ei2as^E22«J. (^^^ 



Cp = ^En(a3T^)+tE,2Vn) ' ^^' 



°n = l(1"n'-^;)(hl-s^h2«J- (22) 



4.87-120 



STRUCTURAL ELEMENT DESCRIPTIONS 

5. The transformation from generalized coordinates to element coordinates, [G ], is 
calculated if no transverse shear material or thickness is given (i.e., MAT ID =0 
or t^ = 0). 

CV = W\ (23) 

where [II] is given explicitly in the stiffness matrix calculations. 

6. If transverse shear exists, the shear matrix, [B], is generated. Additional 
material terms are: 

[D] = I^CEb^' where [E^^] is the bending material 3x3 matrix. 
G-]^ = G = Shear coefficient of transverse shear material. 
The nonzero terms of [B] are: 

^4.1 = ^,^ - i tD^^n cos^ (i^ - 1 ) . n ^^^^ ^.^^ Ig^ ^^^^ ^ ^D^^)] . (24) 

^4,2 = ^9.2 = ^[D^2^'^7f^-l"5^""1^"s^^(3D33 + D22) +|nD33COS*^]. (25) 

^4,3 = h.3 = J tr "^3^°^* -r^ • (26) 

^4,4 = ^9.4 = i ^7 ^\3^°^^ -T 3 • (27) 

^4,5 = ^9.5 = ^^"^2(7 -?)- "^^i"^-r (2033^022)] • (28) 



2 1 I 

^4,6 ^ ^9,6 = ^[012?;;^- "^Si"*-?- (2033^^22) *-r(2"S3+ si"^'^D22)]. (29) 



2 2 2T 
^4,7 = ^9,7 = J [2D,T (r^ - r^) + D^2 ^ * IT^ (2n%3 " ''"^^ 022^30) 

- n^ sinil^ -|^ (2D33 + D22)], 



4.87-121 



MODULE FUNCTIONAL DESCRIPTIONS 



2 3 31 
^4.8 = ^9.8 = 7rt-DnSn"°12l^"-#^2n2D33+sin2*D22) 



(31) 



n^sinij; —- (2D33 + D22)]. 



^4,9 ■ ^9.9 " ^ 



^ [-n sinij- -^ (D22 + D33)], 



(32) 



^4.10 = S.10 = l[ni(Di2-'°33) -" ^^"^'-T^(°22*°33)^' 



(33) 



where 



r + r. 



Iq2 1^033 + sin^^ D22 



"sSTar 



(34) 



7. The transformation [H] transforming displacements in the element coordinate system to 
displacements in generalized coordinates of the power series is: 



[H] = 



1 



































1 



































1 
































1 














cosi^ 
^a 











n 











1 





1 


i 
































1 


I 
































1 


i 


i' 


£3 









1 2Jl Si -1 



cosifi icosij; Q Q IL. Hi HL. Ml 



^b *"b 



^b ^b '"b *"b 



1 i 



(35) 



4.87-122 



STRUCTURAL ELEMENT DESCRIPTIONS 



8. The transformation [H ] for nonzero transverse shear is: 



[Hqu^ = ([H] - [B])-' (10x10) 



(36) 



9- [H ] is partitioned into two 10x5 matrices 



t"au^ = tH, 1 HJ 



a ' fa- 



(37) 



10. The loads in global coordinates are calculated with: 



{P^} = CE][H^f {P^} . 



(Pb) = [E][Hj^]^{Pj} 



(38) 
(39) 



4,87.9.5 Element Stress Calculations (Subroutines SC0NE1 , SC0NE2, SC0NE3 of Module SDR2) 

1. For each element the following quantities are calculated as in section 4.87.9.2: 
i, sin^. cos^. [E], [Hg], [H^]. [H^^]. [H^^]. [H^^] (using s = f . r = ^^^-^). 

2. Using the material properties, the following matrices are calculated: 



m 



(1 - vf) 



-Vi 



-^1 1 



1 - V, 



(40) 



4.87-123 (12-1-69) 



MODULE FUNCTIONAL DESCRIPTIONS 



[DJ 



E^I 



(1 - vp 



-Vo 



1 - Mr 



(41) 





p3 


0~ 


[G3] = 





'3. 



(42) 



where [E ], [D. ] and [G ] are computed for membrane, bending and shear materials 
respectively. 



3. The stress matrices are then calculated: 



[K3] 



^Cy [H,q] 



[n] [H^,] 



t3[G3] [H^^] 



(8x10) 



(43) 



[Sg] = [K^lCHglLE] .(8x6) 



(44) 



[S[^] = [KglCHj^lEE] . (8x6) 



(45) 



4. Each entry in the EST data block contains data pertaining to the n harmonic motion 
of the C0NEAX element. The elements in the EST are ordered by harmonic and C0NEAX 
I.D. number. All harmonic elements for each C0NEAX are grouped together. 

a. When the harmonic, n, of an element is zero, this indicates it is the first 
of a group of elements. Storage space is allotted for fourteen 8 by 1 vectors 
defining the element forces at points. Two UGV vector data blocks must be used 

to calculate stresses on points. These data blocks correspond to the two subcases "C" 
and "S" and are solved simultaneously using the same data. 

b. Using the [S ] and [S. ] matrices and the 6 by 1 displacement vectors, {u}, 
by their SIL numbers, stress and force vectors are computed. 



4.87-124 



If n / 0: 



STRUCTURAL ELEMENT DESCRIPTIONS 



-°?n \ 



(jjn 



^Ln 



sn 

(|)n 

^^ 
sn 



\ <j)n 



t^an^ ^"an> ^ ^^.J (u=,^}. 



(46) 



sn 



^Jn 



°s<l>n 



sn 
(J)n 



t^an^ ^"an> ^ [S,^l (u^^}. 



(47) 



S(i)n 

s 

sn 

s 
$n I 



4.87-125 



If n = 0: 



MODULE FUNCTIONAL DESCRIPTIONS 



so 



$0 



S(t>0 



so 



(t)0 



S())0 



so 



\ %o 



Cs,J HuL) ^ iu'}) - Ls.l {{uM + {uM), 



ao-" ao 



ao 



(48) 



c. The temperature effects are added using the GPTT data for the two subcases, 
(^a ''' 'l^ 



(4) 



sn 



^ I ^tn (1 ^ -^b) . 



(-51) = i.'i hn (^a ^ ^b) . 



(-s*n) 



scfin 



(49) 
(50) 
(51) 



The same equations are used for the "S" set and when n = 0. 
d. The harmonic stresses are calculated by the equations 
for i = 1,2,3: 



mL ci 



sm 

^(}in 

^S(|)n 






M^_ ci 



mL_ ci 



(O^^-- 



(52) 
(53) 

(54) 



4.87-126 



STRUCTURAL ELEMENT DESCRIPTIONS 

The equations are repeated for the S set and when n = 0, 

e. Principal stresses (a,, a„, e, T„,„etc.) are calculated as with the 

1 ^ Ilia X 

TRIAl or QUAD! element, except that when n / the data are calculated 
for both the S and C sets. 

f. The incremental element stresses or forces for the points on the cone are 
calculated from the following equations for j = 1,2,. ..,14: 

For n f 0: 

<5a^j = (a^^) cos (n<f.j) + {a\^) sin (nc^^) , (55) 

%j = ('^Jn^ ^°^ ("*j) + (^Jj ^i" (n4)j) . (56) 

^"s*j = ^^\J SI'" ("*j) - (°;^j cos [H.) , (57) 

*"s1 = "sn '^°s ("'''j) ^ '^sn S''" ^"*j^' (58) 

*%1 = "Jn =°s ^%-) + Mjn si" ^"*j5 • (59) 

*%j = "sjn si" (n^j) - Ms*n <^°s (n^-,-) . (60) 



5V3. = V^^ cos (n*j) + ys^ sin (n^j). (61) 

*%j = Vjn sin (n<frj.) - vj^ cos (n^.) . (52) 

g. The incremental stress and force values are added to the running sums for the 
points. After the last element is calculated (n = N), the forces and stresses 
for the points are calculated and output. The equations are identical to steps d 
and e of this section except that 1) the "S" and "C" sets are not used and 2) up to 14 
points may be calculated for output for each physical element. 

Since the user may leave some spaces blank on the property card for this element, 
only one of the $. = points is used in the calculation. 



4.87-127 



STRUCTURAL ELEMENT DESCRIPTIONS 



4.87.9.6 Differential Stiffness Matrix Calculations (Subroutine DC0NE of Module DSMGl) 

The data input from the ECPT to the DC0NE subroutine are the same as those given in section 
4.87.9.1. Additional data for the generation of the differential stiffness matrix are as follows: 

{u°l, {u°} - Displacement vectors of the zero harmonic (extracted from the UGV data block) 

ci D 

T°, tP - Element loading temperatures of the zero harmonic (extracted from the GPTT 
a D 

data block) 

The first part of the calculations involves calculation of the element force components. The 
following steps are performed with harmonic number n = 0. 

1. The 10 by 10 transformation matrix [H° ] is computed from: 

where [H ], a 10 by 10 matrix, and (H }, a column vector, are derived in the NASTRAN 
uq Y 

Theoretical Manual, section 5.9.5.3, and {H } , a row vector, is explicitly written out in 

's^ 
Equation 85 of section 5.9 of the NASTRAN Theoretical Manual. 

2. The 10 generalized displacement quantities q^ are 



(q} = [Hjq]-' f— — 5-4 (64) 



where {u°} and {uPi are the 6 by 1 displacement vectors, and [E] is calculated as in 
Equation 4 of section 4.87.9.2. 

3. The strain coefficients are 

Slfl 



4.87-127a (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



s 



^^ ) = T° {«} (66) 

Where T° and T° are the loading temperatures at the grid points, the {a} vector is obtained 

from the MPT data block via subroutine MAT and i is calculated as in Equation 1 of section 
4.87,9.2. 

4. The force coefficients are calculated: 

^0 " ^m ^"12 '^^" "^ "^2 '^ '^°^ '^ '^s^ > (67) 

^1 ^ *m '"12 ^^^" ■^' ^^4 "^ "^ '^ %'' ' (68) 

^2 " Sn ^^12 "^ "^ ^^7 ' (69) 

^3 = *m ^12 =°^ ^ ^8 ' (70) 

''o ^ *m '^22 (^^" * 'I3 ^ ^°^ '^ %"> ' (71) 

''l " ^m ^"22 ^^^" V q4 + cos '^ q^) , (72) 

h = *m ^^22 "^ ^' ^7 ' (73) 

''3 = *m ^^22 "' ^' ^8 ' (74) 



'^o = ^m'^ll (^4 - S^ - ^m ^^12 ^^ ' (75) 

'1 ^-^m'^ll '^S - ^m'^12% ' (76) 

'^o = ^ '^12 (^4 - S^ - ^m ^^22 % ' (77) 

^1 =-*mSi2^S - tm'^22'^^^ • (78) 

4.87-127b (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 

Where G,,, G,^ and Ggo are elements of the 3 by 3 symmetric material properties matrix, [G]. 
5. The geometry coefficients are calculated: 

I = /s"^r1-"ds {"lla'V'yi • (^^) 

mn [n - Q, \ , d, i 



where 



M 



r = r + 1 " : " I s . (80) 



An explicit formula for the evaluation of I^^^ is given in the NASTRAN Theoretical Manual, 

section 5.9.5.8. 

6. The following coefficients for the computation of the differential stiffness matrix are 

calculated: 

'^mn " ^0 ^m. n+1 ^ ^1 ^m+1 , n+1 ^ ^2 ^m+2, n+1 

+ ^3 Vs. n+1 ^S ^m. n' '^l Vl , n ' ^^^^ 

^mn " ''o ^m, n+1 * ^"i ^m+1 , n+1 ^ ^^2 V2. n+1 

^ ''S W3, n+1 " ^0 ^m. n ^ ''l Vl,n ' ^^^^ 

C = A + B . (83) 

mn mn mn 

where m = 0, 1....6; n = 0, 1, 2. 

Note: The index n used above is a dummy index and is not the harmonic number. 
The second part of the calculations involves generating the differential stiffness matrix. 
The remaining steps use n as the harmonic number of the element. 

1. The nonzero elements of the symmetric differential stiffness matrix [K** ], in generalized 

coordinates, are given in Table Ic below. 



4.87-127C (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



Table Ic. Nonzero Elements of the Differential Stiffness Matrix, [k'' ]. 
K^J = cos2*Bq2 + I sin^^Cgg 

k]2 = cos^i|;B^2 ■*• 1 sihiI^Cq^ + | sinVi2 



Ku " jnsin^'C^, 



K^g = ncos)|jBQ2 
K^g = ncosii;B^2 
K?y = ncosi|jB22 



K?o = ncosiJjBgp 



K^^ = 005^22 ■" } So ^ i ^'"^"^11 ^ i sinV22 
^23 = 1 "Si ^ 1 nsin*C^2 
^zi = i"C^l +{nsin^C22 



k5c = ncosipB-ip 



k5, = ncosi()B22 



K^7 = ncos^B32 



kJJ = ncos^B42 



•^33 4 " ^02 



K34 - :^n C^2 



4,87-127d (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



Table Ic (con'd). Elements of the Differential Stiffness Matrix. [K*''']. 



,,qd _ 1 2p 
■^44 " TT 22 



^t - ^\2 



"^56 " ^12 



KgJ = n\, 



^?8 = "'^32 



^66 = '^00^"%2 



^6? = 2A^0^"%2 



^68 = 3A2o + n\2 



"■tl - 4A2o^n'B42 



K^S = 6A3Q + n2B52 



Kll - 9A4Q + n\2 



The formulas for n = are the same as in Table Ic except that they are all multiplied by 2. 
The nonzero terms for n = fall into two uncoupled sets which are 

(n) (12) (66) (67) (68) 

(22) (77) (78) 

^ (88) 

Effect on — ■ ""-' "— — — ^ 

Twisting Effect on Axisymmetric Deformation 

2. The 10 by 10 transformation matrix, [h" ], from generalized coordinates to element 
coordinates, for the n harmonic is computed as in Equation 63. The matrix is inverted and 
partitioned into two 10 by 5 matrices: 

4.87-127e (12-1-69) 



STRUCTURAL ELEMENT DESCRIPTIONS 



Kc,y'=^lMV • (84) 

3. The 6 by 6 differential stiffness matrices in global coordinates are: 

[kJj] = [E] [H.f [K^^^] [H.] [Ef . (85) 

where i = pivot grid point; j = a, b; and [E] is computed as in Equation 4 of section 4.87.9.2. 



4.87-127f (12-1-69) 



MODULE FUNCTIOMAL DESCRIPTIONS 

4.87.10 The TRIARG Element 

4.87.10.1 Input Data for the TRIARG Element 

1. The ECPT/EST entries for the axisymmetric triangular ring (TRIARG) element are: 

Symbol Descriptions 

SIL-, .SILp.SIL, Scalar index numbers for the three grid points. 

Material property orientation angle (degrees) 
Material property identification number. 

Local coordinate system number and location 
in basic coordinates of the three grid points. 

Element temperature for material properties. 
For this element, Y. must equal zero for i = 1, 2 and 3 and, we define: 

{R3} =hl} . (1) 

(X3 




^'1 Jz'! 



ih^ - ihz' - <2' > • (2) 



2. Coordinate system data 

The location (X.,Y.,Z.) and local coordinate system number (N^. ) of each grid point are 
used to calculate the 3 by 3 global-to-basic coordinate system transformation matrices, 
[T.J, i = 1, 2, 3. 

3. Material data 

The material property identification number, Mat I.D., and the element temperature for 
material properties, t , are used to select the followina data items. For this element, 
material properties may be defined on a MATl or MAT3 but not a MAT2 bulk data card. 



4.87-128 



STRUCTURAL ELEMENT DESCRIPTIONS 



Symbol 



Description 



^r'^e'^z 



Young's moduli in the radial, tangential 
and axial directions respectively. 



\9'^ez-^zr 



Poisson's ratios in the three directions 
indicated. 



^9'Sz'^z 



V'^e'^z 



Mass density 

Shear moduli in the three directions indicated. 

Coefficients of thermal expansion in the three 
directions indicated. 



4.87.10.2 General Geometric Calculations 



1. Local coordinate calculations are: 



Thermal expansion reference temperature. 
Structural element damping coefficient. 



mm 



minimum of i^^]'^^2'^s3'^' 



(3) 



{Rl} = i\}. 



(4) 



(Z^} = (Z^} - 



in) 



min) 
min I 



(5) 



2. The transformation from field coordinates to grid point degrees of freedom is 
given by (R|_. and l^^ are the i components of {R. } and {Z. } respectively): 



^v - 



1 


\^ 


^Ll 








~ 













1 


\l 


^Ll 




1 


\z 


^L2 






















1 


R|_2 


hi 


9 


1 


\3 


^3 













-0 








1 


\3 


hz- 


6x6 


4 


87-129 













(6) 



MODULE FUNCTIONAL DESCRIPTIONS 



rr 1 = rr r"' 



(7) 



3. The transformation matrix from two to three degrees of freedom per ooint is: 



^^^qs^ = 



1 























Q- 








1 





























1 
































1 





























1 
































1_ 



6x9 



(8) 



4.87.10.3 Integral Calculations 



1. The integrals over the area of the cross-section are of the fo 



rtn: 



ij 



r^z-^dzdr, 



(9) 



for the values: 

'^.10''^-n*'^00''^10'*20'^30'*0T'^ll''^2T-02''^12'*-12 * 
To accomplish this we integrate in two parts: 

a. From 1 ine Z = K-i^r + m, g to line Z = K-i^r + m, ^ 

where 



^M 



Lj ' ^Li 
\j - \i 



(10) 



and 






(11) 



4.87-130 



STRUCTURAL ELEMENT DESCRIPTIONS 



and from point R. , to point R, ,• 

b. From line Z = K^2'" + '^■\2 ^o ^ = K^^r + m^g and from point R. , to R^o. 
For the case where 



\l = \z °^ 



\z ' \l 



12 



< 10" 



we must integrate differently, that is, from line Z = K^gr + m^^ to Z = K,^r + m,^ 
and from R, , to R, n. 

2. After the integrals are computed, a check is made to determine if an excessive 
amount of round-off error occurred. If round-off was excessive, an approximate 
integral can be calculated. 

These tests are: 

If any 5- .<0, then approximation must be used. 

If 0,2 1 tJnp' °'" ^-12 - "^12' °'^ ^-12 ^ '^02' ^^^" approximation must be usea. 

If Ar < r or AZ <_ Z, then approximation must be used. The terms Ar, AZ, r and Z are: 



Ar 



= max.(|RLT - Rl2I. |Rl2 " ^3!. |Rl3 " R, 



LI 



12) 



r = [min.{R^^, R^_2, Rl3)J/10, 



AZ = max.dZ^i -ZL2I. !Zl2-Zl3|. \\, - \,\). 



(13) 
(14) 



Z = [min (Z^p Z^g. Z^3)]/10. 



(15) 



4.87-131 



The approximation is: 



MODULE FUNCTIONAL DESCRIPTIONS 



where 



'ij = (^a)'(V^'^ 



'a = it\l "\2"\3^' 



^a = T^^Ll ^\l^h2^' 



(16) 

(17) 
(18) 



A = ^[R^T (Zl2-Zl3) + Rl2 (^3-^! ^ * ^3 ^\r\l^^' 



(19) 



3. Form the matrix of integrals: 



[D] = 2Tr 






^10 














00 


«10 


*01 


























«10 








Sin 





5in 






4x6 



(20) 



4.87.10.4 Elastic Constants Matrix Calculations 



1. Generate the transformation from material axis to element geometric axis: 



^\o^ - 



cos Y 





sin^Y 


sinYCOSY 





1 








sin Y 





cos Y 


-sinYCOSY 


2sinYC0SY 





2sinYC0SY 


2 . 2 
COS Y-sin Y 



4x4 



2. Generate the matrix of elastic constants for an orthotropic body with 
respect to cylindrical coordinates: 



(21: 



4.87-132 



STRUCTURAL ELEMENT DESCRIPTIONS 



le„] 



^(^-^ez^ze) 



^r^^e/^zr^ez^ ^e^^-^rz^zr) 



(Syinnetric) 



^r(^zr%r^ze) ^e^^ze-^^e^zr^ ^z^l-Ve^er^ 



^z^- 



4x4 



(22) 



where 



^er = ^re W^r ' 



^ze = ^ez h^h ' 



(23) 
(24) 



rz 



= WE, . 



(25) 



A = 1 - V^g Vg^-Vg, V^Q - V,^ V^, - V^Q Vg, V, ^ - V^^ Vg^ V^g ^ (26) 



3. Calculate the elastic constants matrix in element geometric axes: 



[Eg] = [T,,f [E^][T^„] . 



(27) 



4.87.10.5 Stiffness Matrix Generation (Subroutine KTRIRG of Module SMAl) 
1. Generate the element stiffness matrix in field coordinates: 



4.87-133 



MODULE FUNCTIONAL DESCRIPTIONS 



[K] = 



^22*^-10 

(^12+^22)600 (E^l+2E^2-^E22)6io 

^22^-11-^44*00 (h2+42)*oi-^(^i4''44)*io h2^-^z''^h'[^o^*^'['^^^o 

2tt 

^4*00 (^14+^4^*10 44*0l''^44*10 ° ^44*10 



(28) 



^3*00 (^Is'-^a^^lO 43*01+^4*10 ° ^4*10 ^33*10 J 6x6 



where E.. is an element of [E 1. 
ij g 

2. Transform the element stiffness matrix from field coordinates to grid point 
degrees of freedom: 

[K] = [rgql'^CKlCrgq]. (29) 

3. Transform the element stiffness matrix from two to three degrees of freedom per 
point. 

[K] = LFq^l^WErq^]. (30) 

4. The 3 by 3 partitions [K j] of [K] corresponding to the pivot point p are 
transformed: 

[K^] = [Tpf[K^.J[Tj], J = 1.2.3 (31) 

5. Finally these 3 by 3 partitions are expanded to 6 by 6 partitions: 



4.87-134 



STRUCTURAL ELEMENT DESCRIPTIONS 



^l] 







(32) 



4.87.10.6 Mass Matrix Cal-culations (Subroutine MTRIRG of Module SMA2) 



1. Generate the consistent mass matrix in field coordinates: 



[MJ = 2Tr 



'^ll^lO 



"^11*20 ^^11*30 



"^11*11 '^ll'^21 "^11*12 



(Symmetric) 












'"22'^10 













"^22*20 


^"22*30 











nioo<Sn 


niooiSoT 



.(33) 



6x6 



where 



[ffi] 



■p 0- 

p- 



"n 



"1 



- m22 — 



(34) 



2, Transform the mass matrix from field coordinates to grid point degrees of freedom: 



[M] = [req]'[M][rgq] 



(35) 



3. Transform the mass matrix from two to three degrees of freedom per point: 



[M] = [rq3]'[M][rq3J. 



(36) 



4.87-135 



MODULE FUNCTIONAL DESCRIPTIONS 



4. The 6 by 6 partitions, [M •], are calculated as in Equations 31 and 32. 

r J 



4.87.10.7 Thermal Load Calculations (Subroutine TTRIRG of Module SSGl ) 
1. Form the vector of thermal strains: 



^r 



Pi 
avg Va 



^<^^ = T^aWrt )n, I (37) 



z 



where T is the average loading temperature at the grid points. 

2. Compute thermal load vector in grid point degrees of freedom: 

{F^} = [rgqf[Df[EgJ{a} (6x1). (38) 

3. Transform thermal load from two to three degrees of freedom per point 

{F^} = [rqgj'^CF^} (9x1). (39) 

4. Each partition, {F^}, of length 3 of {Fy} is transformed to global coordinates by 

{F^}g = [T^f {F^} . (40) 

5. These vectors are added to the overall load vector, {P_}. 

g 

4.87.10.8 Element Force and Stress Calculations (Subroutines STRIRl and STRIR2 of Module SDR2) 

Element stress and force data items are calculated in two phases. The first phase 
(subroutine STRIRl) calculates the element stiffness and stress matrices. The second phase 
(subroutine STRIR2) calculates the actual element forces and stresses from the various 
subcase displacement vectors. 



4.87-136 



STRUCTURAL ELEMENT DESCRIPTIONS 



Phase 1 calculations are as foil 



ows: 



1. Form the element stiffness matrix, [K], as in section 4.87.10.5. 

2. Compute the constants: 



"o = J .1^ \i' 



(41) 



T ^ ^Li' 
^ 1=1 ^^ 



(42) 



3, Form the [D ] matrix: 



tDo^ 



1 







4x6 



(43) 



4. Compute the stress matrix 



[S] = [Eg][D,][rgq]. 



(44) 



5. Transform the stress matrix from two to three degrees of freedom per point: 



[SJ = [sjcr^^j 



(45) 



6. Transform the stress matrix from basic to local coordinates: 



[S], = [SJ[Ti23] 



(46) 



4.87-137 



MODULE FUNCTIONAL DESCRIPTIONS 



where 



[T123J = 



T] 1 I 
-- ^ 1__. 

I T2 I 



~\- 



I T, 
I 3 



(47) 



7. Compute the thermal stress vector 



{T5} = [Eg3{5}. 



(48) 



Phase 2 calculations are as follows: 

1. Extract the displacement vector, {A}, at the three translational components of the 
grid points from the global displacement vector. 

2. Calculate the element forces: 



{P} = [K]{A}, 



(49) 



3. Calculate the element stresses: 



{a} = [S]j^{A} - T^{Tg} . 



(50) 



where 



^avg " ^0 



(51) 



4.87-138 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.11 The TRAPRG Element 

4.87.11.1 Input Data for the TRAPRG Element 

1. The ECPT/EST entries for the axi symmetric trapezoidal ring (TRAPRG) element are 

Description 
Scalar index numbers for the four grid points. 
Material property orientation angle (degrees). 
Material property identification number. 




Local coordinate system number and location in basic 
coordinates of the four grid points. 

Element temperature for material properties 
For this element Y. must equal zero for i = 1, 2, 3 and 4, and we define: 



'^l 
X4 



^sl h 



s 



^53 I i h 
^s4 ) ( h 



4,87-139 



MODULE FUNCTIONAL DESCRIPTIONS 

2. Geometry Input 

The location (X- , Y., Z.) and local coordinate system number (N.) of each grid point 
are used to calculate the 3 by 3 global -to-basic coordinate system transformation 
matrices, [T^], i = 1,2,3,4. 

3. Material Property Input 

The material property input for the TRAPRG element is the same as that for the TRIARG 
element (see section 4.87.10.1). 

4.87.11.2 General Calculations 

1. Local coordinate calculations are; 

^min = minimum of (Z^^, Z^2« 2s3' ^54)' (3) 

{\} = {Rj}. (4) 

min 
^\> = ^V- )Zminf . (5) 

' min' 
, min , 

2. Test for a rectangle. Let R^^^ be the i*" component of {R. }, and define: 



R 



M14 = (\l ^ \4^/2. (6) 



R„23 = (Rl2 -^ ^3^/2. (7) 



'" 'tTT^ ' °*°°' '''" 'l1 = \4 = "^MU- 
%^ \ < 0-005 then Rl2 = Rl3 = R^^y 



If R|_^ = R|_^ and R^^2 



= R. 2» then the element is rectangular. 



If R|i = R| . = 0, then the element is a core element. 



4.87-140 



STRUCTURAL ELEMENT DESCRIPTIONS 

3. Generate the transformation matrix from field coordinates to grid point 
degrees of freedom: 



[H] 



1 


\1 


\^ 


\l\l 


























1 


^^ 


^Ll 


Wu 


1 


\2 


^Ll 


hzh] 


























1 


\z 


\l 


\z^u 


1 


\3 


^L4 


^3^4 
















1 



\4 






\4^L4 


1 




\3 



Zl4 



\3^L4 
















1 


\4 


\4 


\4^L4 




[H] = 


[H]-^ 











8x8 



(8) 



(9) 



4. Generate the transformation matrix from two to three degrees of freedom per point: 



^^qs^ = 



1 00000000000 
001 000000000 
000100000000 
000001 000000 
0000001 00000 
000000001 000 
0000000001 00 
000000000001 



8x12 



(10) 



5. If the element is a core element, then: 



*^lj ° ^3j " ° J ° ^'2 8 , 



Ni - h.? = ° 



i = 1,2,. ...8 . 



(11) 



4.87-141 



MODULE FUNCTIONAL DESCRIPTIONS 

where h^. is an element of [HJ. 

4.87.11.3 Integral Calculations 

a. Compute the integrals over the cross-section of the trapezoid that 
are of the form; 



In = // r''z'l drdz 
^ rz 



(12) 



for the values: 

^-lQ'*-ir^-12'^00'^01'^02'ho'hTh2'^20'^21'^22'^30'^3r^32 * 

The limits of integration are chosen depending on the geometric shape of the 
trapezoid. 



4 z 



^3 = ^4 



r = a+bz 



z^ = Z2 2 



r = c+dz 



If the lines between points 1 and 4 and between points 2 and 3 are defined 
by the equations 



r = a + bz, 



(13) 



r = c+dz. 



(14) 



respectively, then: 



4.87-142 



STRUCTURAL ELEMENT DESCRIPTIONS 



"L3 "LZ 
In general, the integration takes the form: 



Z4 c+dz 






-^. 






" - A ! ] il ■ (18) 



= // 



In. = / / r^^ 



Pq ^ J ^ ^ drdz. (19) 



z^ a+bz 



For the case with the side r = c + dz parallel to the axis of synmetry (the 
z axis) we have: 



Ipq = J j r^z'' drdz. (20) 

z-j a+bz 

For the case with the side r = a + bz parallel to the axis of symnetry we 
have: 

z. c+dz 

Ipq = y f '-''z'^ drdz. (21) 

And finally for the rectangle, the integration takes the form 



4.87-143 



MODULE FUNCTIONAL DESCRIPTIONS 



''^ ■// 



c P q 



r z^ drdz. 



(22) 



z^'a 



4.87.11.4 Elastic Constants Matrix Calculation 

The elastic constants matrix in element coordinates, [E ], for the TRAPRG element 
is calculated identically to the elastic constants matrix for the TRIARG element (see 
section 4.87.10.4). 

4.87.11.5 Stiffness Matrix Generation (Subroutine KTRAPR of Module SMAl ) 

1. Generate the terms of the symmetric element stiffness matrix in field coordinates as 
shown in Table 2. Each term must be multiplied by 2tt to form [K]. 

2. Transform the element stiffness matrix from field coordinates to grid point 
degrees of freedom: 



[R] = [Hf[K][H]. 



(23) 



3. Transform the element stiffness matrix from two to three degrees of freedom 
per point: 



[K] = [rq3f[R][rq3]. 



(24) 



4. The 3 by 3 partitions [K .] of [K] corresponding to the pivot point p are 
transformed: 



[K^j] = [Tpf[K^j][Tj], J = 1.2.3,4. 
5. Finally, these 3 by 3 partitions are expanded to 6 by 6 partitions: 



(25) 



^^^^ - 



M 



(26) 



4.87-144 



STRUCTURAL ELEMENT DESCRIPTIONS 
Table 2. Elements of the 8 by 8 Symmetric Stiffness Matrix for the TRAPRG Element. 

Col. 1 Col. 2 Col. 3 Col. 4 



Row 1 E22I.10 



Row 2 (E22-^E^2)^00 (^^ i+2E,2-^E22)Iio 



R°« 3 E22I.11 (^2-^^22)101 ^221-12-^^44^10 



Row 4 (Ei2^E22)Ioi (Eii+2Ei2+E22)Iii (Ei2+E22)Io2 ^h^^^^^2^h2^h^ 

Row 5 



+ E44I20 -^ ^44^0 



'°"' ° ° ^44^10 ^44^20 

ROW 7 E32I00 (Ei3+E23)Iio E23I01 (^13^^23)111 

•'°" ^ ^32^10 (^31^^32)^20 (^23^^44)^11 (El3^E23^E^4)^21 



Col. 5 Col. 6 Col. 7 Col, 



Row 5 



ROW 6 E^^I^o 



Row 7 £331^0 



•^""^ ° ^44^1 E33I20 E33l3o+E44l^2 



4.87-145 



MODULE FUNCTIONAL DESCRIPTIONS 



4.87.11.6 Mass Matrix Calculation (Subroutine MTRAPR of Module SMA2) 



1. Form the coupled mass matrix in field coordinates: 



[M] = 2ir 



"l^lO 



"1^20 "1^30 



M^I„ M^l2T M^Ii2 



^^21 "1^31 "l^22 ^1^32 



Sytrmetric 



Mgl^o 



M2I20 M2I30 



M2I11 M2I21 M2I12 



M2l2T M2l3^ M2I22 M2I32 



8x8 



(27) 



where 



M, = M, = p 



(28) 



2, Transform the mass matrix to grid point degrees of freedom: 



[M] = [H]'[M]LH]. 



(29) 



3, Transform the mass matrix from two to three degrees of freedom per point: 



[M] = [rq3][M][rq3]. 



(30) 



4. The 6 by 6 partitions, [Mn^]i are calculated as in Equations 25 and 26. 



4.87-146 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.11.7 Thermal Load Calculations (Subroutine TTRAPR of Module SSGl ) 
1. Form the temperature gradient vector: 



{AT} = {T} 



(31) 



where {T} is the vector of loading temperatures at the grid points. 
2. Form the thermal expansion coefficient vector: 



{a} 






(32) 



3. Multiply the elastic constants matrix by the thermal expansion coefficient 
vector: 



WB} = [Eg]{a} 



4. Form the [Q] matrix: 



[Q] = 



AB2I00 


AB2I10 




AB2Iq^ 


AB2l„ 


(AB^+AB2)I^0 


(AB^+ABg)] 


20 


(AB^+AB2)I^^ 


(AB^+A 


AB2loT 


AB2I11 




AB2IQ2 


AB2li2 


(AB^+AB2)I^1 


(AB^+ABg)] 


21 


(AB^+AB2)I^2 


(AB^+A 






























'hho 


^^^3^20 




'^^3^11 


'hh^ 


^^^3120 


^hho 


4.8/ 


AB3l2i 
'-147 


AB3I31 



'22 



8x4 



(33) 



(34) 



MODULE FUNCTIONAL DESCRIPTIONS 

5. Partition the transformation matrix [H] to form [H']: 

[H'] = [h'.j] 4x4, (35) 

where 

h'.. = h.. for i = 1,2,4; j = 1,2.. ..,4; and k = 2j-l 

1 J IK 

and h.. are the elements of [H]. 

6. Compute the thermal load in field coordinates: 

{F^} = 2Tr[Q][H']{AT}. (36) 

7. Transform the thermal load to grid point degrees of freedom: 

{fj} = [Hf{V. (37) 

8. Transform the thermal load from two to three degrees of freedom per point: 

(F^} = [rqs]'^{FT}. (38) 

9. Each partition, {F^}, of length 3 of {F^} is transformed to global coordinates by: 

{F^}^ = [T.]^{F^}. (39) 

10. These vectors are added to the overall load vector, {Pg}. 

4.87.11.8 Element Force and Stress Calculations (Subroutines STRAPl and STRAP2 of 
Module SDR2). 

Element stress and force data items are calculated in two phases. The first phase 
(subroutine STRAPl) calculates the element stiffness and stress matrices. The second 
phase (subroutine STRAP2) calculates the element forces and stresses from the various 
subcase displacement vectors. 



4.87-148 



STRUCTURAL ELEMENT DESCRIPTIONS 

Phase 1 calculations are as follows: 

1. Form the element stiffness matrix, [K], as in section 4.87,11.5, 

2. Define a fifth "grid point" to be the average of the other four points: 



\5 = t(\i^Rl2-^\3^\4)' 



(40) 



\5 = ^(^Ll " \l " \z + \^) 



(41) 



3. Form the matrices [D^^ ^],[D^^^],[D^^^J,[D^'^h.[D^^^] 



where 



[d(^')] 



Li 



\s ° 



Li , 

^ 'Li 







1 R^. 1 











k 



Li 



■■Li 



4x8 



(42) 



where i = 1 to 5 denotes the five grid points. 

4. Compute the stress matrices for each of the five grid points in field coordinates: 



[S^'^J = [EgJED^i)]. 



(43) 



4.87-149 



MODULE FUNCTIONAL DESCRIPTIONS 



5. Transform each stress matrix to grid point degrees of freedom: 



-c(i) 



[S-^^n = [S^^^][H] 



(i)- 



(44) 



6. Transform each stress matrix from two to three degrees of freedom per point: 



Ls(i)] = [s^^)][rq^3. 



7. Form the master stress matrix: 



[S] = 



fs^^n 


3(2) 


S(3) 


S(4) 


S(5) 



20 X 12 



8. Transform the stress matrix from basic to local coordinates: 



(45) 



(46) 



where 



[S,] = [S][T^234^ 



1^^1234^ 



:^i \ _i 



; 






-0- 


I 1 


^4 



(47) 



(48) 



9. Compute the thermal stress vector: 



{T3} = [Eg]{a} 



(49) 



Phase 2 calculations are as follows: 

1. Extract the displacement vector, {A}, at the three translation coordinates of each of the 

four grid points from the global displacement vector. 



4.87-150 



STRUCTURAL ELEMENT DESCRIPTIONS 

2. Calculate the element forces: 

{P} = [K]{A} • (50) 

3. Calculate the element stresses: 

M = [Sj^]{A} - T^ {T^}. (51) 

where 

T,- - T , if 1 ?« 5 (T. is the temperature at the 

i^*^ point) (^'-^ 



^avg " ^0' ^^ ^ " ^ (^avg ^^ ^^^ average temperature 

over the four grid points) 



4.87-151 



MODULE FUNCTIONAL DESCRIPTIONS 

4,87.12 The TgRDRG Element 

4.87.12.1 Input Data for the T0RDRG Element 

1. The ECPT/EST entries for the axisynmetric toroidal ring (T0RDRG) element are: 

Symbol Description 

SIL-, , SIL2 Scalar index numbers for the two grid points 

a,, ap Angles of curvature at the two grid points (degrees) 

Y Material property orientation angle (currently not used) 

H , Hj: Membrane and flexure thickness 

m' f 

N-|,Xi,Y,,Z, ) Local coordinate system number and location in basic 






NofXp.Yp.Zo ) coordinates of the grid points. 

t Element temperature for material properties 

For this element Y- must equal zero for i = 1 and 2, and we define: 



^1 
{R} = <! J . 0) 



{Z} = .? S . (2) 



= 11 



2. Coordinate system data 



The location (X. ,Y.,Z.) and local coordinate system number (N^.) of each grid point are 
used to calculate the 3 by 3 global -to-basic coordinate system transformation matrices, 
[T^.]. i = 1, 2. 

3. Material data 

The material property input for the T0RDRG element is the same as that for TRIARG 
element (see section 4.87.10.1) with the following notational changes: 



4.87-152 



STRUCTURAL ELEMENT DESCRIPTIONS 



^ = ^r' h = ^e. M = ^re 



{ALF} = 



4.87.12.2 General Calculations 

1. Compute the following constants used in stiffness matrix generati 



on: 



^ == ^p/^T ■ (3) 

°M = Ep H^/(C - v2,) . (4) 

Db = Ep h3/{12 (C - v2^)). (5) 

2. Determine if the element is a toroidal ring, a conical ring, a cylindrical ring, 
or a shell cap: 

(1) if a^ f a.^, then the element is a toroidal ring. 

(2) if a^ = a2 = 90°, then the element is a cylindrical ring. 

(3) if a^ = a2 ?< 90°. then the element is a conical ring, 

(4) if a^ = 0. then the element is a shell can. 

3. Compute the local coordinate constants for a toroidal element: 

*S = «2 - *1 • (6) 



Rp = — r . (7) 

2 sin (/) 



^\ ^ K^ ' (8) 



4.87-153 



MODULE FUNCTIONAL DESCRIPTIONS 



S = (ct2 - a^)Rp, (9) 



Bfi = R] + ^p [sin(a^ + ^) - sin (a^)], 



^T 



sin (a, + ^) 
' 2 



\jj, = cosCa-j + J-), 



B 

R. 



T sin a-j • 



4j, = cos a-, , 
*, = . 



(10) 



(11) 



(12) 



^i"^"i ^ r^ (13) 

4. Compute the local coordinate constants for a conical or cylindrical ring 

S = [(R2-Ri)^- (Z2-Z^)^]'/' . (14) 

S cos a, 

R - D + L 15 

^8 " 1 2 • 



(16) 



Rp = 0. 07) 



X^ = 0. 08) 



(19) 
(20) 



4.87-154 



STRUCTURAL ELEMENT DESCRIPTIONS 

5. Generate the transformation matrix from field coordinates to grid point degrees 
of freedom: 












1 


























~ 











1 









































1 


























-10 
S3 


-6 

7 





-3 
2S 








10 

7 


-4 

7 





1 
7s 








15 
S^ 


8 

s3 





3 
2S2 








-15 

s4 


7 

7 





-1 

7 








-6 
S5 


-3 

7 





-1 
2S3 








6 

s5 


-3 
S^ 





1 

25^ 


1 















































1 























-3 
S2 











-2 

s 





3 
S2 











-1 

s 





2 











1 

S2 





-2 
S3 











1 

S2 






(21) 



10x12 



4.87-155 



MODULE FUNCTIONAL DESCRIPTIONS 

6. Generate the transformation matrix from local to system coordinates: 

0000 00 



[r,3] = 



cos a- 


sin a. 












sin a 







cos a 































-10 

1 

1 


























sin tto 



cos a2 



sin a.^ cos a.2 



















-1 



















0- 























1 








1 



(22) 



l?xl2 



7. Rearrange the transformation matrix [r^^] such that the membrane and flexure 
terms are reversed. 



t^Bq^ 



•6q 



(2) 



(1) 



Bq 



10 X 12 



(23) 



where [r^^^^^] is the first six rows of [Pg^] and [Fgq^^^] is the last four rows of 



eq 



L^Bq^' 



4.87.12.3 Integral Calculations 

The method used to compute the integrals depends on the geometric shape of the element. 
1, Toroidal ring - basic integrals 

There are six basic integrals to be computed, of which the first three can best be 
evaluated by series expansion, but the last three require numerical integration. 



4.87-156 



STRUCTURAL ELEMENT DESCRIPTIONS 






(-1)^*^^^^^^^^ 



l2^ = Rp"^^^ Jo ct>^sin$d* = RpJ""^ ^=0 (.i+l+2i-+l) (2i+l)! ' (25) 



l3^ = RpJ^^ r^ ,Jcos,d, = RpJ^l r (-^)^"^B'^"^^^'^ . (26) 

■^ "^ -^0 ^ i=0 (j+1+2i) (2i)! 



I^j = RpJ"^ r^ ^%^ ""^ . (27) 



I J = R J+1 



y*6 ^J2sin^coS(^ j^ ^ (28) 



h' - V'' /q*^ i%^ d* . (29) 



where 

B = R, - RpSina, + RpSina-iCOSij) + RpCOsaiSintfi, (30) 

and j = 0, 1, .... 10. 

The summations in l^ and I,'^ arn carried out until the truncation error is in- 
significant. 



4.87-157 



MODULE FUNCTIONAL DESCRIPTIONS 

2. Toroidal ring - required integrals 

The actual integrals required can now be defined in terms of basic integrals. 



6,'^ = (R, - RpSina^)!^'^ + Kpcosa-i I2 + RpSina^I^ , 



(31) 



62 = cosa^Ig + sina^I^'^ , 



&J^ = cos a-i 14^ + sina, cosa-ilg'^ + sin a-i Ig'^ , 



(32) 
(33) 



6.'^ = cosa, lo"^ - sina-.Ig'^ , 



j=0,l,...,10 



(34) 



65"' = sina^cosa^(Ig'' - 1^^^ + jO - 2sin 0^)1^'' , 
&^ = cos a-ilg'' - sina-icosa, Ig'' + sin '^-il/^ . 



(35) 
(36) 



3, Conic ring - basic integrals 



■ -r^'^ 



d? = •^ . j = 0,1 10 



TfT 



(37) 



^2^ = r (of^^'^^"^'-"^'^—^" 



-^i"^---"! 



(38) 



n , Ri+Scosa, 
Io° = r4r- ln{-l-T^ 1-). 



cosa 



n 



(39) 



, , R, Ri+Scosa, 



2 cosa, ■■' COSQ-, 



1 



(40) 



J - § 



. I Scosa, P 

j+1 - (-1)' \-r^ 



IL 



M i=0 (j+l+i) 



. J = 2,3 10 



(41) 



4.87-158 



STRUCTURAL ELEMENT DESCRIPTIONS 



4. Conic ring - required integrals 



6-^{ = R^I^J + *^l/'^\ 



62'^ = sina^I^-' , 



$2^ = sin a, iJ^ , 



V = ^1^1 • 



Sg'J = sina^ ^^l^'' , 



^6^ - ^/l2^. 



J = 0,1 10 



(42) 
(43) 
(44) 
(45) 
(46) 
(47) 



5. Cylindrical ring - basic integrals 



V =r 



U-" = \ ?'^d5 = K^ , j = 0,1.. ..,10 



~FT 



(48) 



Jo n 



1 sJ'^l 



6. Cylindrical ring - required integrals 



6^J = R^I^J +^■^1^^''^ , 



&2 = sina, I-]-' , 



53'^ = sin^ail2'^ , 



°e. °R Oc - u . 



j = 0,1,. ...10 



(50) 
(51) 
(52) 
(53) 



4.87-159 



MODULE FUNCTIONAL DESCRIPTIONS 



4.87.12.4 Elastic Constants Matrix Calculations 



Form elastic constants matrix 



[E] = 



1 



l^ T 2 I 

(1 -E^V' 



^T^PT 



^T^PT 



2x2 



(54) 



4.87.12.5 Stiffness Matrix Calculations (Subroutine KT0RDR of ftodule SMAl) 



1. Define the constants 



A = Rp , 



(55) 



^PT 



(56) 



Ep/E, 



(57) 



2. Form the stiffness matrix terms in field coordinates as shown in Tables 3, 4 ana d. 

3. Transform the stiffness matrix from field coordinates to grid point degrees of freedom: 

[K] = [r^qfCK-JCrgq]. (58) 

4. Transform the stiffness matrix from local to system coordinates: 

[K] = [r^jfCKJEr^^]. (59) 

5. The global-to-basic coordinate system transformation matrices [T^] are expanded 
to 6 by 6 matrices: 



rr. 



LtJ] 



1 i 



. i = 1.2. 



(60) 



4.87-160 



STRUCTURAL ELEMENT DESCRIPTIONS 



Table 3. Columns 1, 2 and 3 of the Symmetric 10 by 10 Stiffness Matrix for the T0RDRG Element. 



Column 1 



Column 2 



Column 3 



ROW 1 D,(^ 6? . 2V ^0 

Row 2 D,(£^ ^! ^ f 4 
Dm(^ x2 ^ 2V ,2 

^ V ^1 + r ^2 

n ,C ^3 , 2V ^3 
°M^^ ^1 * r ^2 

n /C ^4 , 2V ^4 

■^M^^ ^1 ■" r ^2 

Row 7 D„(} 6° + 6°) 
Row 8 D,(J 6° . J aj 



+ V62 + 65) 

n ,2C .1 . V ^2 
°M^5r <^1 + S" ^4 

+ 2V6^2 "^ 4^ 

n ,3C .2 , V p 
"^M^r *1 ^ A *4 

+3V62 + 65) 



Row 3 



Row 4 



Row 5 



Row 6 



Row 9 



Row 10 



h'6 ' Dm(^ 4 

+|V .2 , .2, 
V*2 ^ 63) 

Dg(2V6; + 26^) + D„^ 6j 

4. 2V ^3 . ^3, 
+ j-&2^ 63) 

Db(6V6J+362) +D„(^5} 
. 2V.^ . .5) 
Db(12V62.463) + D„(^65 

^^4-3^) 
0,(20V.3.5.J).0,(^.J 

. 2j 4 . 4) 

Dm(^ ^i ^ ^ «4 ^ VSJ 

Dm(2J 4 ^ i ^4 

+ 2V5^ + 65) 

°M(f 4 ^ M ^ 3V63 



Dg4(C6° + 2V6j + 6g 

, P, ,C ^4 . 2V .4 . ^4^ 

^ ^M^^ ^1 + r *2 ^ ^3) 

Dg6(2C6] + 3V6^ + 6g) 
Dg2(12C6^ + 16V6^ + 46g) 
Dgl0(4C6^3 + 5V6^ + 5g) 

dm(J 4 ^ ^4 

+ V62 + 55) 

n ,oC ^3 . V ^4 
°M^h ^1 ^ I *4 

3 4 
+ 2V52 + 65 

n ,3C ^4 , V ^5 

%^r *1 ^ A *4 

+ 3V62 + 65) 



4.87-161 



MODULE FUNCTIONAL DESCRIPTIONS 



Table 4. Columns 4, 5, and 6 of the Symmetric 10 by 10 Stiffness Matrix for the T0RDRG Element. 



Column 4 Column 5 Column 6 

Row 4 Dg9(4C(5^ + 4V5^ + 6g) 

. D,(^ 6f . 2V ,6 , ,6) 

ROW 5 Dgl2(6C63 . BViJ + 6^) V^^^CaJ + SVe^ . 6^) 

ROW 6 Dgl5(8C65 + GViJ . ,56) Db20(12C55 . yvsj . fi^, OgZSdeCo^ . SVsJ . 6^) 

^ ^m(^ 4 ^ r 4 ^ 4) ' °"^7 '' ' ^ '' ^ '^3) - 0^(7 *!° ^ r- 4° ^ *3°) 

ROW 7 Vj'^^s) ^1*3**5) Dm(^4^4' 

ROW 8 D„(^ 6^ , I 63 D,(C 6^ . V ,5 ^^^C ,5 , V ,6 

' '4 ' «5) + V6^ . 6l) . ,6l + 65^) 

Row 9 D|.{|^ «? + r <5S n (^^ .^^ + ^ ,6 _ ,2C .6 . V ,7 

M A 1 A 4 D^(^ «1 + TT ^4 ^M^S- ^1 + ]^ *4 

^ ^^^2 * %^ + 2V6^ + 6^) + 2V5^ + 5^) 

Row 10 D„# 6^ + r fi^ n ^3C ,5 , V ,7 „ ,3C .7 . V ,8 



A '4 ^M^r ^1 ^ ff *4 



"M^A "1 A "4 D„(^ 6^ + 

^ 3V4 + ^5) 6 7 7 8 



4.87-162 



STRUCTURAL ELEMENT DESCRIPTIONS 
Table 5. Columns 7, 8, 9, and 10 of the Symmetric 10 by 10 Stiffness Matrix for the T0RDRG Element. 



Row 7 
Row 8 

Row 9 
Row 10 



Col. 7 Col. 8 Col. 9 Col. 10 



Dm^6 








¥K ' 4) 


D„(C6° + 2V6j 
.62) 






Dm(2V6J + ^6^ 


0^(206] + 3V6j 


D„(4C6^ + 4V5j 






.61) 


-J) 




Dm(3V64 + &l) 


D^(3C62 4V6j 


D^(6Ci3 + SVSJ 


Dm(9C 




.61) 


.6^) 


-^ 



4.87-163 



MODULE FUNCTIONAL DESCRIPTIONS 



6. The stiffness matrix, [KJ, is partitioned into 6 by 6 matrices: 



LK] ==> 



l^ 



^21 



^2 



^22 



(61) 



7, These 6x6 partitions are transformed to local coordinates: 



[K^j], = [T^f[K^j][T,^J. 



(62) 



where j = 1, 2, and p is the pivot point, p = 1 or 2. 



4.87-164 



STRUCTURAL ELEMENT DESCRIPTIONS 



4.87.12.6 Mass Matrix Calculations (Subroutine MT0RDR of Module SMA2) 
1. Form the mass matrix in field coordinates: 



1 



[M] = 2wpH 





















Symmetric 



"1 
*1 

*1 

r6 



JO 



(63) 



10x10 



2. Transform the mass matrix to grid point degrees of freedom: 



[M] = [r„j'^[M][r, J 



(64) 



3. Transform the mass matrix from local to system coordinates: 

[M] = [r^jf [Mj[r^j] . 

4, The mass matrix, [M], is partitioned into 6x6 matrices, and these 6x6 partitions 
are transformed to local coordinates (see Equations 61 and 62). 



(65) 



4.87-165 



MODULE FUNCTIONAL DESCRIPTIONS 



4.87.12.7 Thermal Load Calculations (Subroutine TT;JRDR of Module SSGl) 



1. Compute the temperature gradient constants: 



'^'l 'l 'o ' 



^jW ., j{^) .T^(m) . 



AT. 



AT, 



(f) _ 



(f) 



. 



. 



(66) 
(67) 
(68) 
(69) 



where T.'""' are the membrane temperatures at point i. 



2. Compute the thermal strain vectors: 



{e-p^°^ = At/'"){ALF} . 



{e/^h = ATg^-^^ALF} . 



{H^^°h = At/^^{ALF} , 



{H^^^h = ATg^^^CALF} . 



(70) 
(71) 
(72) 
(73) 



where {ALF} is a vector of length two; the first component is a and the second a^ 



3. Form the matrices of integrals 



t^ME^°^^ = 2-Hr, 



6-1 26i 36-1 ■^I'^i ^1*^1 ^1 "^1 ^1 '^1 ^1^1 ^1^1 



(74) 



^4 *4 



"4 "4 



'2 °2 _ 2x10 



4.87-166 



STKUCTURAL ELEMENT DESCRIPTIONS 






2TrH_ 



[F 



FE 



(0) 



J = 



2ttH^ 

nrr 



5^ 26^ 35: 

1 ^2 ,3 -4 
4 *4 "^4 *4 












A 


x/^ 


X,6j 


x,«« 


^i4 




4 


^l 


4 


4 


^5 
62 


2_ 








-«? 


-65] 


-126^ 


-206^" 





-; 


-^«J 


-3.5 


-^^4^ 


-s.5_ 



(75) 



2x10 



(76) 



2x10 



[f,<»] . 



27tH^ 








-2« -66e -126, -206 



4-1 



26. -36," -46: .5&i 



4. Compute the thermal load vector in field coordinates 

(Ft> = [F,E(°)]^[E](e,(°)}.[F,E(l)f[EK.,(^h 

-LFp,(°)f[E]V°)}.fF,,(^)f[E]{H,(°)}. 

5. Transform the thermal load vector to grid point degrees of freedom: 



(77) 



2x10 



(78) 



(F,} = [r^ J'{F,} 



(79) 



6. Transform the thermal load vector from local to system coordinates: 



{F,} = [r^^flF,}. 



7. Transform the thermal load vector to basic coordinates: 



(80) 



{F^}b = [Ti2]'{Ft}. 



(81) 



4.87-167 



MODULE FUNCTIONAL DESCRIPTIONS 



where 



[T12] = 



^1 


1 - - 


■ 








1 I 

1 - - 


1 

1 








,0 
1 - - 


1 






I I I I 

' I 



(82) 



and [T.] and [I] are 3 by 3 matrices. 

8. These vectors are added to the overall load vector, {P }. 



4.87.12.8 Element Force and Stress Calculations (Subroutines ST0RD1 and ST0RD2 of Module SDRl ) 

Element stress and force data are calculated in two ohases. The first phase (subroutine 
ST0RD1) calculates the element stiffness and stress matrices. The second ohase (subroutine 
ST0RD2) calculates the element forces and stresses from the various subcase disolacement 
vectors. Stresses are evaluated at both ends and at the mid-span of the element. 

Phase 1 calculations are as follows: 

1. Form the element stiffness matrix, [KJ, as in section 4.87.12.5. 

2. Set up the coordinates of the three stress points: 



{X} = 




S 

12" 



(83) 



3. Compute the constants Xy., ^3. X. as a function of the stress points coordinates, 
a. If the element is a toroidal ring, then: 



(i) _ 



cos (a^ + ^) 



R^ - RpLsin a^ - sin (a^ + J^ )] 



(84) 



4.87-168 



STRUCTURAL ELEMENT DESCRIPTIONS 



sin («! + ^ ) 
R^ - Rp[sin a^ - sin (a^ + ^^)J 



Xj^'^ = -j-^ 1=1.2.3. (85) 



^4^'^ = - X3^''VRp . (86) 



b. If the element is a cylindrical or conical ring, then: 



\ (^^ = cos 0^1 , , 

^2 R^ + X(i) cos a^ • '^^'> 



^3^''' = ■ i = 1.2.3. (88) 

R^ + X(i) cos ex, 

X^^^') = . (89) 

c. If the element is a shell cap. then: 



cos (a + {ii). 

, (i) . ' "^P 

^2 



R^ - Rp [sin a^ - sin (a^ + i^ )] i = 1.2.3 (90) 
X3^'^ = 1/Rp . (91) 

X4^^^ = - l/(Rp^) . (92) 

4. Compute the stress matrix in field coordinates for the three stress points 

as shown in Tables 6 and 7. Note that the factors H and H /12 have been omitted for [S,^^^] 

and [Sp ] respectively. 

If the element is a shell cap, then modify [S^ ] by: 



^12 = ^12 "" ^11 • (93) 



4.87-169 



MODULE FUNCTIONAL DESCRIPTIONS 



$22 = E22 + E^2 • 



S37 = -2 (Ei2 + E^i) . 



^47 = 2 (E22+Ei2) . 



Sgg = 3(E22-4E,t) 



(94) 
(95) 
(96) 
(97) 



5. Fonn the master stress matrix in field coordinates: 



[S] 



^^1 
;(2) 



~S(3) 



15 X 10 



(98) 



4.87-170 



STRUCTURAL ELEMENT DESCRIPTIONS 



Table 6. Terms in Columns 1 Through 6 of the 2 by 10 [S,^^^] Matrix and the 

3 by 10 [§2^^^] Matrix. 



The [S^^^h Matrix 



Col. 1 



Col. 2 



Col. 3 



Col. 4 



Col. 5 



Col. 6 



> (^)e e 

2 ^2 hi 



^2 "22 



+A2^'^E,2X(i) 



-12 



+ A2^^^E22^(^': 



^1 h] 



2ETiX(i) 3E^^X^(i) 

+A2(^')E^2x2(i) ^Xj^^'^E^pX^Ci) +X,('')e 
.2 



3 "12 

2E^2X^(i) 3E^2^^(i) ^/'^E,2 

+ X2^^')E22x2(i) +X2^^'^E2,x3(i) + a,^^) 



22- v; - Ag- -£22 



(X (^^E 
U, E^^ 



1 "u 



{X,"'E 



+ X3^^^E22)X(i) 



The [Sp^^^] Matrix 



Where ^(i) __ i,^i^))^ e,, - X,(%^ -d 



^2 E^2 



Ag t22 



,(0 



Cs^'h - 



(i) 



(i) 



5x10 



4.87-171 



MODULE FUNCTIONAL DESCRIPTIONS 



Table 7. Terms In Columns 7 Through 10 of the 2 by 10 [S^^^'] Matrix and the 

3 by 10 [§2^^'] Matrix. 



The [S^^i)] Matrix 



Col. 1 



Col. 2 



Col. 3 



Col. 4 



Row 1 



(X (^)e 

+ X3(^)E,2X^(i) 






(X (^^E 



(X (^^E 



+ X3(^^Ei2)^^(^) + X3^^5E^2)x'*(i) + X3(^ ^E^g^^^^^'^ 



Row 2 



(X (^^E 
U^ t^2 

+X3(^)E22)x2(i) 



(X ^'h 
^n h2 



(X ^'k 



+ X3(^^E22)X^{i) +X3^^^E22)X^i) 



(X (^^E 
IX^ t^2 

+ X3^'"^E22)X^(i) 



The [S,^^^] Matrix 



Row 1 



Row 2 



Row 3 



-2X2^^"^E^2)^(i) 



-2En 

2X2^^^E22X(i) 

+ 2E^2 

2g^^^X(i) 

- 2X (^"^E 
^A2 t^^ 



- 3X2^''^E^2'<^(^") 

- 6E,^X(i) 

3X2^''^E^2'^^('') 
+ 6E^2^(i) 
3g(i)x2(i) 

- 6X2^^^E^TX(i) 



- 4X2^''^E^2'<^(^') 

- 12E^iX^(i) 

4X2^^^E22X^(i) 

+ 12E^2^^(^"^ 
4g(^)x3(i) 

- 12X2^''^E,^x2(i; 



- 5X2^'')e^2'<'*(^^ 

- 20E^^ X^(i) 

5X2^^^E22X*(i) 
+ 20E^2^^(i) 
5g(^')x4(i) 

- 20X2^''^E^^x2(i) 



- 6E 



11 



- 24E^^X(i) -60E^^x2(i) 



where „(i) 



(i)\2, .^(1)^ 

22 '^4 "12 



g-' = (X,^'0'E„-X/'^E 



and 



fs(i)] 



(1) 



(1) 



4.87-172 



STRUCTURAL ELEMENT DESCRIPTIONS 



6. Transform the stress matrix to grid point degrees of freedom 



[S] = [S][fg^] . 
7. Transform the stress matrix from local to system coordinates 



(99) 



[S] = [S] [r^^] . 



8. Transform the stress matrix to global coordinates 



(100) 



tSJg = [S] [T,2] 



(101) 



9. Compute the thermal stress vector for the three stress points: 

Xi 



(T,(^)) 



^■^/■"^"m^^ll^l + Et2«2) + ^'^Z^''\ ^ ^^ll"'! * ^12«2) 
(f) ^f (f\ ^f^^ 



-AT,(^) 4 (E,,a, + E„a,) - AT ^^^ -^ 



'1 T7 ^'^21«1 ^ ■^22*^2' - ^'2 ^r?? ^4l"l * 42*2 



(E,,a, + E„a,) 



(5 X 1) 
(102) 



AT/^)^X2^'^t(Ell - Ei2)-i MEi2 - E22)a2] 
^^^2^'^iTs{^2^'^'^^t(En -E,2)«l 



+ (E^2 - hz^'^Z^ * '^Ell«l + ^12' 



:«2^| 



where At/""). AT2('"^ At/^^ and AT2<^) are as given in Equations 66 through 



69. 



4.87-173 



MODULE FUNCTIONAL DESCRIPTIONS 



10. Form the master thermal stress vector 



{T^)= \ Tj^^) I • (103) 



Phase 2 calculations are as follows: 

1. Extract the displacement vector, {A}, at the two grid points from the global 
displacement vector. 

2. Calculate the element forces: 

{R} = [K]{A} • (104) 

3. Calculate the element stresses without regard to thermal loading: 



{a-} = [S]g {A} (12 X 1) . (105) 

4. If there is no thermal loading, then 



{o} = {a'} • (106) 

5. If there is thermal loading, then 



J J I bj. ^ 1 bj ^ ^5 



for j = 1 and 2 and 



o. =cj . (108) 

for j " 3, 4, 5. 



4.87-174 



STRUCTURAL ELEMENT DESCRIPTIONS 



4.87.13 The VISC Element 

The viscous element, VISC, has the same properties as the R0D element (see section 4.87.1) 
except that instead of generating a contribution to the stiffness matrix, the element generates 
a contribution to the damping matrix, [B ]. 

4.87.13.1 Input Data for the VISC Element 

1. The ECPT/EST entries for the VISC are: 



Symbol 



Description 



SIL^. SIL, 



Scalar indices for grid ooints a and b 



^''^a-^a'^a . 

^b-^b'^b'^b ^ 
Ci 



Local coordinate system number and basic 
coordinates of grid points. 



Extensional damping coefficient 
Torsional damping coefficient 



Given N^, X^, Y^, Z^, N^, X^, Y,^ and I^ and the CSTM (Coordinate System Transformati 
Matrices) data block, the 3 by 3 transformation m 
using utility routine TRANSD (see section 3.4.37) 



on 



Matrices) data block, the 3 by 3 transformation matrices, [T J and [T. ], are calculated 

a D 



4.87.13.2 Damping Matrix Calculations (Subroutine BVISC of Module SMA2) 



1. Generate {n} as in Equation 2, section 4.87.1.2, and generate the transformation 
matrices [T^] and [T^^], 

2. Calculate: 



[b,] 



'-"? 



"l"2 



"l"3 



"l"2 



"2"3 



"l"3 



"2"3 



(1) 



4.87-175 



MODULE FUNCTIONAL DESCRIPTIONS 







f"? 


"l"2 


"l"3^ 


[b,] 


■ ^2 


"l"2 


.\ 


"2"3 






"l"3 


"2"3 


"K 



(2) 



3. The 6x6 damping matrices are: 



t^aa^ 



''\\\ 



^\\\ 



(3) 



t^ab^ 



tJ^t^ 



■"■IbJh 
a r D 



(4) 



C^bb^ 



^b^Jb I ° 



1 ^b^r^b 



(5) 



tBbaJ 



^J^^t^a 



bra 



(6) 



4. These matrices are added to [B__]. 



4.87-176 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.14 Integral Calculations for the TRIARG. TRAPRG Elements 
Integrals of the form 



Ipq = n r^' rPz^dzdr . (i) 

Jr. Ji 

J mn 



must be calculated for the TRIARG and TRAPRG elements (see sections 4.87.10.1 and 4.87.11.3). 
The integration may be performed for any integer values of p and q. The area of integration 
is defined by the two lines r = R. and r = R., and by the two lines z = b|^^r + a,^ and 



z = b„„R + a„„. 
mn mn 



This integration is performed by the integration "driver" subroutine, F0RTRAN function OKI 
in module SMAl, FORTRAN function DMI in module SMA2. and F0RTRAN function AI in module SDR2. 
The following input data are necessary for these routines: 

p - an integer that defines the power of the r variable. 

q - an integer that defines the power of the z variable, 

{R} - a vector of the r coordinates of all points used to describe the area 
of integration. 

- a vector of the z coordinates of all points used to describe the area of 
integration. 



{Z} 



k.Jl - the subcripts of R, Z defining one of the lines of the limit of 

integration (i.e., the line between points (r , z^ and (r , z )). 

m,n - the subscripts of R, Z defining the second line on the limit of 
integration. 

i.j - the subscripts of R defining the other two lines on the limit of 
integration. 

In the following paragraphs F0RTRAN names of functions auxiliary to DKI are given. The 
corresponding F0RTRAN function names auxiliary to functions DMI and AI can be found in sections 
4.28.8 and 4.46.8 respectively. 



4.87-177 



MODULE FUNCTIONAL DESCRIPTIONS 

The following slopes and y-intercepts are calculated in functions DKK and DKM 

Vk ' '^k^& 
^k. = R, - R^ • 






V^n - Vn 



^mn = -V^, 



lull- 

\n - R^ - R^ 



(2) 

(3) 

(4) 

(5) 



A test for a vanishing area of integration is made: if R. = Rj, then Ip^ = 0; 
'^ ^H ■= ^mn ^"'^ hi = ^n- ^^^" ^pq = °- 

The formulas for evaluation of the integrals are dependent upon the values of p and q 
as given in the following sections. 



4.87-178 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.14.1 Integral Calculation for q > and any p. (Function DKINT) 
Define the function 



fl(x.y) = ^ I Cx%q-^l-tD . 



where 



(x+yR^)P^1+''+1-s 
(p-sjIs^Kp+l+q+l-s) ^°^ (p+1+q+l-s) ^ 



ln|x+yR I 
(p+l+q+l)!(%-2)! ^°^ (p+l+q+1-s) = 



and a = i or j. 



(6) 



( 1 for t = , 

i;^ (q+1+p+l-t) _ p (q+1+p+l-t) 
^ '^ q + 1 + p + 1^ - t ~ ] ^Of" (q+1+P+l-t) f (8) 

In (R^R.) for (q+1+p+l-t) = 

C and D are calculated in functions DKEF and DK.l respectively. 
The integral is 

^pq = ^l^^mn'^n^ ' h^\li\l^ ■ (9) 

4.87.14.2 Integral Calculation for p > and q < - 1 (Function DK89) 



f2(".x.y) = -^ I p!(-x)' D . (10) 

where 



(11 



4.87-179 



The integral is 



MODULE FUNCTIONAL DESCRIPTIONS 



Ipq = ^^^Z^''h!i'\l^ - h^''^m ^n) 



^2'^i'hl'\!i^ * ^Z^j'^mn'^n^^ 



4.87.14.3 Integral Calculation for p< and q< - 1 {Function DKIOO) 



Define the function 



(12) 



f3(«'^'y) = t:^^ 3^=0 



p-q-3 , ^ , 

I (-p-q-3) ! D , 



(13) 



where 



D = 



(-p-q-3-s)!s!(-p-l-s)RJ-P-^-'^ 
(-y)"P'^ In ( 



(-p-DU-q-!?)! 



for (-D-l-s) / 



for (-p-l-s) = 



(14) 



and a = 1 or j. 

The integral is 



Ipq = ^tfgd.ak^^.b^j) - fsd.a^p.b^n^ 



^Z^'^hi'hl'^ ^ ^3^''''mn'*^mn)^ 



(15) 



4.87-180 



STRUCTURAL ELEMENT DESCRIPTIONS 

4.87.14.4 Integral Calculations for p > - 1 and q = -1 (Function DKJAB) 
Define the function 

R^P^'^lndx+yR J) 



f4(a.x,y) = — p+T " - oIt ^2^"'^'^) • (16) 



where f^ is given in Equation 10. 
The integral is 



^pq = h^''\v\l^ - U^''\n\r? 



- U ^^'\v\l^ - ^4(^''^mn'^n) 

4.87.14.5 Integral Calculations for p < - 1 and q = -1 (Function DK219) 
Define the function 



where fj is given in Equation 13. 
The integral is 



Sq = \^''\v\l^ - h^'^\n'\n^ 



h^^'\v\l^ -^S^J'^mn'^n) 



(17) 



ln(|x+yR I) 
fg(a.x.y) = - (."p.T) + -^j f3(a.x.y) . (18) 

" a 



(19) 



4.87-181 



MODULE FUNCTIONAL DESCRIPTIONS 



4.87.14.6 Integral Calculations for p = -1 and q = -1 (Function DK211) 



Define the function 



, for 



yR^=x 



ff.(a,x,y) 



l[ln(|2y R^|)]2 . 



for (yR^)2 = x^ 
and yR / X 



-yR 



ln|x| InlR^l- E 1 [-—]'- . for (yR^)^ < x" 
t=l ^ 



(20) 



7[Tn(|yR^|)]2 + z l^. [-^ ]t , for (yRj^ ^ x' 



t=l t -'a 



The summation term is calculated until its value becomes less than 1.0 x 10" . 
The integral is 



'pq = h^'^hvhi^ - ^e^^'-^mn'^n) 



h^''\i'\l^ - ^e^i'^n'^n^ 



(21) 



4.87-182 



DETERfllNANT METHOD OF EIGENVALUE EXTRACTION 
4.88 DETERMINANT METHOD OF EIGENVALUE EXTRACTION 

NASTRAN contains two double precision versions of the determinant method. One version 
is for the solution of real eigenvalue problems; and one version is for the solution of complex 
eigenvalue problems. The specifications for both versions are discussed in this document. Real 
arithmetic is used for the real problem, complex for the complex problem. 

4.88.1 Fundamentals of the Determinant Method 

The basic notion employed in the determinant method of eigenvalue extraction is very simple. 
If the elements in a matrix [A] are functions of the operator p. then the determinant of [A] can 
be expressed as: 

D([A])= (p-pj (p-pj ... (p.pj. (1) 

where p^, p^. p^ ...p^ are the eigenvalues of the matrix. The value of the determinant 
vanishes for p = p^ , i = l,2,,..,n. 

In the determinant method, the determinant is evaluated for trail values of p, selected 
according to some iterative procedure, and a criteria is established to determine when D([A]) 
1s sufficiently small or when p is sufficiently close to an eigenvalue. The eigenvector is 
then found by solution of the equation: 

[A] {u} = 0, (2) 

with one of the elements of {u} set to unity. 
4.88.2 Evaluation of Determinant 

The most convenient procedure for evaluating the determinant of a matrix employs the 
triangular decomposition of the matrix: [A] = [L] [U] where [L] is a lower unit triangle 
(unit values on the diagonal). The determinant of [A] is equal to the product of the 
diagonal terms of [U]. The matrix [A] may be expressed as 

[A] = -p[M] + [K], (3) 

for real eigenvalue problems and as 



4.88-1 



MODULE FUNCTIONAL DESCRIPTIONS 

[A] = p^[M] + p[B] + [K], W 

for complex eigenvalue problems. 
4.88.3 Iteration Algorithm 

Consider a series of determinants D^^. D^lj . D^^^ evaluated for trial values of the 
eigenvalue p = p^_^, 9^,.y P^- Then a better approximation to the eigenvalue is obtained 
from the following calculations: 



Let 



hk = Pk ■ Pk-T 



h = \/h-)' 



6, = 1 + X,. 



Then 



*^k+l " ^k+1 "k 
Pk+1 ' Pk "■ \+l 



where 



-2 of;) 6, 



X 



(5) 
(6) 
(7) 



(9) 



The (+) or (-) sign in Equation 10 is selected to minimize the absolute value of X|^^-| . 
In the case where p^. p^.^ and p^.2 are all aribitrarily selected initial values (starting 
points), the starting points should be arranged such that iDjilDk.-, Ill^-zl ^"'^ ^^^ ^""^ °'^ 
(-) sign in Equation 10 should be selected to minimize the distance from p^^^ to all 3 
starting points. 

m a real eigenvalue analysis it is possible to calculate a complex X^^^. In order to 



4.88-2 



DETERMINANT METHOD OF EIGENVALUE EXTRACTION 

preclude the use of complex arithmetic in a real eigenvalue analysis problem, only the 
real part of the Xj^^^ should be used to estimate a p. ^, . 

4.88.4 Scaling 

In calculating the determinant of [A], the determinant is scaled by powers of 10 since 
the accumulated product will rapidly overflow or underflow the floating point size of a 
digital computer. All operations using the determinant are calculated in scaled arithmetic. 

4.88.5 Sweeping of Previously Extracted Eigenvalues 

Once an eigenvalue has been found to satisfactory accuracy, a return to that eigenvalue 
by the iteration algorithm can be prevented by dividing the determinant by the factor (p-p.') 
where p^ ' is the accepted approximation to p in all subsequent calculations. 

Thus: 

dO) ([a]) = d(J;a1) (12) 

p-p/ 

should be used in place of D([A]) after the first eigenvalue has been found. In general, the 
reduced determinant used for finding the i+1^* eigenvalue is: 

D(i)([A]) = oMiim DilMi . (13) 

(p-P/) (p-p/)(p-p2') — (p-p.-) 

This sweeping procedure is quite satisfactory provided that all p.' have been calculated to an 
accuracy that is limited only by round-off error. 

For problems in which zero is an eigenvalue, the number of such eigenvalues is specified 
by the user. In using the determinant method, zero eigenvalues should be eliminated from the 
determinant by a preliminary operation, 

d(°)([a]) =MlAJi , (^,) 

p-" 

where m is the multiplicity of the zero eigenvalue. 



4.88-3 



MODULE FUNCTIONAL DESCRIPTIONS 

For problems with conjugate complex eigenvalues (complex eigenvalue analysis with real 
matrices) the conjugates of extracted eigenvalues should also be swept from the determinant. 
Thus 

p(i)(M) = °^'''hi'^) . (15) 

(P-P/)(P-P/) 

where p.' is the conjugate of p.'. It should be noted that the sweeping equations are in- 
determinant for p = p.'. This situation will occur when a root coincides with a starting 
point or a new estimate with a root already extracted. When the first situation occurs, the 
starting point should be moved away trotj the root. When the second situation occurs, D|^^^ 
should be set equal to D|^. 

4.88.6 Convergence Criteria 

Convergence criteria are based on successive values of the increment h|^ in the estimated 
eigenvalue. No tests on the magnitude of the determinant or any of the diagonal terms of the 
triangular decomposition are necessary or desirable. Wilkinson^ ' shows that for h|^ sufficiently 
small, the magnitude of h. is approximately squared for each successive iteration when using 
Muller's method. This is an extremely rapid rate of convergence. In a yery few iterations 
the "zone of indeterminacy" is reached within which h, remains small but exhibits random 
behavior due to round-off error. Wilkinson states that if it is desired to calculate the 
root to the greatest possible precision, the convergence criterion ^or accepting Pj^ as a root 
should be: 

The determinant method accepts this advice, tempered by practical considerations. The first 
of these is that Equation 16 may be falsely satisfied during the first few iterations while the 
root tracking algorithm is picking up the "scent". Thus it must, in addition, be required that 
|h. I, |h, ,|and |h|^ J be reasonably small. The second practical consideration is that we may 
waste a few iterations within the zone of indeterminacy while waiting for Equation IG to be 
satlsfiec. This is avoided by accepting P|^ if lh|^j is sufficiently small. Finally, if the 
number of iterations becomes excessively large without satisfying e, convergence criterion, 
the Determinant Method assumes the existence of one iteration loop, gives up and proceeds to 



4,88-4 



DETERMINANT METHOD OF EIGENVALUE EXTRACTION 



a new set of starting points. 

Figure 1 is a flow diagram of a set of tests which meet the requirements discussed above 
for real eigenvalue problems. The tests are based on calculated values of HI, H2, and H3 
which are defined as: 



^1 



h 



l^-ll/ \/lPkl* (17) 

|hj/ v/TjT (18) 

H3 = l^+il/v] iPkl. (19) 

where P|^ = k estimate of an eigenvalue and h. = p, - p. ,, 

A similar set of tests is described in Figure 2 for complex eigenvalue problems. In 
this case ITl , H2 and H"3 are defined as: 

HI = l\.il. (20) 

^2 = |hj. (21) 

^^3 = 1^+1 1 . (22) 

The magnitude of the convergence criterion e should be selected as a compromise between 
running time and accuracy. Currently e = 10'' \ If failure occurs because the number of 
iterations exceeds the iteration limit, NIT. for two successive sets of starting points, e 
is increased by a factor of 10. If successive pairs of failures still occur, e is again in- 
creased until the number of permissible changes in e is exceeded. The user is informed of the 
reduced precision of the calculations. 

Since eigenvalues are swept out after they are found, all sets cf starting points will 
eventually lead to failure by the preliminary range checks or through successive iteration 
failure. When this occurs it is presumed that all eigenvalues within the range of interest have 
been found and the calculations are halted. If for some reason this does not occur the 
calculation must still be halted. The one remaining avenue for the computer to continue 
calculations indefinitely is if it continues to find roots. To block this avenue, the calcula- 



4,88-5 



MODULE FUNCTIONAL DESCRIPTIONS 

tions are stopped if the number of roots found exceeds the maximum number of H^^^. As a 
safeguard the order in which the roots are found is indicated tc the user, 

4.88.7 Extraction of Eigenvectors 



On 



ice an approximate eigenvalue p. has been accepted, the eigenvector is determined by 



back substitution into the previously computed triangular decomposition of [A(pJ]. Now since 



[A{Pj)]{u} = [L(Pj)][U(p.)]{u} = 0. 



(23) 



we wor 



k only with [U(p.)]. Because partial pivoting (row interchanges) have been used, the last 



diagonal term in [U(pJ] will normally be the only term with a very small value. The normal 

J 



appearance of [U(p.)] is as follows, for n = 7: 

J 




X 
X 
X 
X 





X 
X 
X 
X 



{0} . (24) 



The terms in the upper right corner are zero due to bandwidth. 6 is a very small number. The 
eigenvector may be extracted by assigning an arbitrary value (such as 1.0) to Uy and solvinq 
successively for Ug, Ug etc., from the preceeding rows. Note that this is equivalent to 
placing a load vector {F} on the right-hand side that is null except for the last term which 
is set equal to 6. 

Situations may occur in which U^^ is not the smallest diagonal term. Let U.^ be the 
smallest diagonal term with i < n. The most common reason for this occurrence is that the 
degrees of freedom u^^p "i+2"--« "n ^^^' ^°^ ^°"^ reason, uncoupled to the preceeding degrees 
of freedom. In this case all of the elements in the i*^ row of [U(Pj)] will be very small 
as shown for i = 4, n = 7: 



4.88-6 



DETERMINANT METHOD OF EIGENVALUE EXTRACTION 



X X 

X X 

X 



X 
X 
X 




X 
X 

X 





X 

X 
X 









61,7 

X 

X 

X 



{Q}. 



(25) 



In the event of multiple or pathologically close eigenvalues two or more rows of [U(p.)] 

J 

will consist of very small values, exhibited below for the very exceptional case where the n^*^ 
row is not very small : 



X X 

X X 

X 




X 
X 

X 





X 

X 

&66 







X 

&t7 



= {Q} 



(26) 



In order to accommodate the exceptional cases described above with the more general case 
°^ "^ " ^nn' ^ ^"^^ ^°^^ vector {F} is used for the eigenvector calculations. The load vector 
win also contain elements of the same order of magnitude as the smallest diagonal element of 
the triangularized matrix [U(pj)] in order to prevent digital overflow when the eigenvector 
is calculated. In addition, a distinct load vector is formed for each eigenvalue to ensure 
that independent eigenvectors are calculated for multiple or pathologically close eigenvalue 
problems. The following equations are used for {F}. For real eiaenvalues, we have 



^ 



Jidl 



ij 



1 Ml - 1) j 



(27) 



4.88-7 



MODULE FUNCTIONAL DESCRIPTIONS 



For complex eigenvalues, 

Re(p ) = 1^1 ^'')'\ . (28) 

^ 1.0 + (1.0 - 7^ ) J 

Im(F.) = 0.0. (29) 

where 6 = smallest U.., j = eigenvalue count, i = i*^ element of {F} and n = number of rows. 

There is a possibility that the smallest diagonal element of [U] may be exactly zero for 
some eigenvalue. This will be the case when the accepted eigenvalue (p^) is exactly equal 
to an eigenvalue of the problem. When this occurs, 6 = 1.0 x 10'^ The calculated 
eigenvectors are normalized to a unit maximum real element value. 

REFERENCE 
1. Wilkinson. J.H.. "The Algebraic Eigenvalue Problem". Clarendon Press, Oxford, 1965. 



4.88-8 



Lit,'trc;r!ANT METHOD OF EIGENVALUE EXTRACTION 



Begin Convergence Tests j 




this test forces the routine 
.to complete two iterations 



K = K + 1 



Continue 
"H Iterations 



Yes 




Yes 




Yes 




'Accept P\^ as an\ 
Eigenvalue J 



Accept P|^ as an 
Eigenvalue 



K = K + I 




Continue 
Iterations 



e = lOe 
IC = IC+1 




lA 



e- Convergence Criterion 
K - Iteration Counter 
IC - Criterion Change Counter 



HI = Ihk.il //W\ 



H2 = Ihkl //[Pkl 



R3 



Figure 1. Real eigenvalue problems convergence tests 



4.88-9 



MODULE FUNCTIONAL DESCRIPTIONS 




Accept P|^ as 
an Eigenvalue 



e- Convergence Criterion 
K - Iteration Counter 
IC - Criterion Change Counter 



"1 = l"k.ll 
H2 = Ihkl 

H3 = Ihk+il 



Figure 2. Complex eigenvalue problems convergence tests 



4.88-10 



INTRODUCTION 

5.1 INTRODUCTION 

NASTRAN operates on: 1) the IBM 7094/7040(44) Direct Couple System under the IBSYS operating 
system; 2) the IBM System/360 under Operating System (0S); 3) the Univac 1108 under the Exec 
8 operating system; and 4) the CDC 6600 under the SC0PE 3 operating system. This section dis- 
cusses the interfaces between NASTRAN and these operating systems with respect to: 1) input/ 
output; 2) link switching; 3) overlay considerations and implementation of the open core concept; 
4) the setup of the operating system control cards preceding (and, in the case of the Univac 1108. 
following) the NASTRAN data decks; 5) generation of an executable NASTRAN system; and 6) machine 
dependent routines. 

The vocabulary used in each subsection is the one used by systems programmers familiar with 
the particular operating system being discussed. It is to these system programmers that each 
subsection is addressed. 



5.1-1 (12-1-69) 



rJASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 
5.2 NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 

5.2.1 Introduction 

The purpose of this section is to describe the features of NASTRAN which are unique to 
the IBM 7094/7040(44) Direct Couple System (DCS) implementation. The DCS has had a unique 
place in the design and development of NASTRAN. It is the only second generation machine 
on which NASTRAN runs. In general its operating system was less able to accomodate a program 
of the size and complexity of NASTRAN than third generation operating systems, and hence "set 
the rule" concerning maximum size of programs and links, complexity of overlay, etc. At the 
same time, it was realized that the DCS was an obsolete system and would eventually be replaced 
by third generation machines. Therefore, the design of NASTRAN, especially in executing 
efficiency, was made optimum for the third generation machines often at the expense of per- 
formance on the DCS. 

Conversely, the DCS was the only system operating with enough reliability to allow effective 
development when the project began. Hence all routines were initially checked out on the 
DCS. The DCS remained the development system for the major portion of NASTRAN develooment. 
It is the system on which NASTRAN is maintained. The source library is propagated from the DCS 
to all other machines. In some sense then, familiarity and practical experience on the DCS 
during the development of NASTRAN has compensated for its second generation nature. 

5.2.2 Input/Output 

The machine dependent input/output routines on the DCS can be partitioned into 3 classes. 
Class 1 obtains the available units, classifies them as to disk or tape, and stores pointers 
to these units in the FIAT Executive table. Class 2 communicates with the 7044(40) to perform 
the physical 1/0, manages buffers, handles timing and device errors, etc. Class 3 is actually a 
modified subset of Class 2 and pertains specifically to the generation of olot tapes. 

5.2.2.1 Class 1 - GNFIAT 

GNFIAT establishes the equivalence between FIAT entries and the unit control blocks in 
the system nucleus. Each unit control block (UCB) is checked for availability. If it is 
available, it is checked against the entries in the permanent FIST. These entries are, in 
order: 



5.2-1 



NASTRM - OPERATING SYSTEM INTERFACES 

SYSUTl DATA POOL FILE (P00L TAPE) 

SYSUT5 OLD PROBLEM TAPE 

SYSUT6 NEW PROBLEM TAPE 

SYSUT7 BCD PLOT TAPE 

SYSUT8 BINARY PLOT TAPE 

SYSLB2 SUBSYS TAPE 

SYSLB3 OLD USER'S MASTER FILE (OR SOURCE LIB) TAPF 

SYSLB4 NEW USER'S MASTER FILE (OR OBJECT LIB) TAPE 

SYSUT9 POTENTIAL INPUT TO USER MODULE "INPUT" 

If the available unit is not one of the above or is not a physical tape ("set-up"), a 
pointer to this UCB is placed in the FIAT. If it is a permanent FIST entry and is set up, a 
pointer to this UCB is placed in the permanent FIAT. Note that certain system units are also 
exempt from assignment. These are SYSLBl , SYSCRD. SYSPRT, SYSPCH, SYS0UT, SYSINl and SYSPPl . 
If any unit is a physical tape, this fact is noted in the FIAT entry for that unit. The user 
can cause specific files to be assigned to "free" tapes by use of the FILE DMAP declaration. 

5.2.2.2 Class 2 - GIN0 

The following decks constitute the assembly language GIN0 set on the DCS: 0PENN, CL0SED, 
READD. WRITEN. F0RWRD, BKREC. SELECT, SKIPF, MISC and SYSUNT. GIN0 was written in assembly 
language to allow several improvements on the normal 1/0 routines available on the DCS. These 
improvements include: 1) smaller core resident code, 2) variable buffer sizes, and 3) faster 
execution times. 6IN0 on the DCS uses I0EX to comnunicate with the 7094/44. GIN0 writes unblocked 
records with a current maximum record length of 100. This number can be changed by the use of 
the NASTRAN card as the first card in the Executive Control Deck. Figures 2 through 11 comprise 
a set of flowcharts for the assembly language GIN0 routines for the DCS. 

5.2.2.3 Class 3 - SGIN0 

In order to write long unformatted records, SGIN0 changes the buffer size while it is 
in control. It sets a flag for BCD or binary mode records. It also causes GIN0 to not attach 
its normal control words. These modifications are necessary to meet plotter hardware re- 
quirements. Otherwise, SGIN0 calls the normal GIN0 entry points of 0PEN, WRITE and CL0SE. 



5.2-2 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 

5.2.3 Link Switching 

During the execution of a NASTRAN run it often is necessary to call a module which exists 
in another link of the program. To accomplish this on the DCS, subroutine SEARCH is called. 

CALL SEARCH (J0BSEG,FILNAM,REWFLG) 

J0BSEG - BCD name of the next link desired - BCD - input. 

FILNAM - BCD name of the system unit on which the program links reside - BCD - input. 

REWFLG - Flag to indicate whether the program tape should be rewound or not. 

1 = Rewind ) 

> Integer - inout 
= No rewind ) 

For example, suppose NASTRAN was currently in link 3 and the XSEM3 subroutine determined 
that the next module to be executed resided in link 4. The appropriate call would be: CALL 
SEARCH (6HNS04 ,6HSYSLB2,0) . Note that the links are called NSi , where i = 01,02,.... 
is the link number. SEARCH is scatter-loaded into high core and reads the program links until 
a match is found for J0BSEG. The root segment is loaded into core, and SEARCH transfers control 
to the entry point of the main program in this link. Before SEARCH is called, core resident 
tables are saved on a empty unit, and the file number of this unit is passed through blank 
common. This task is accomplished via ENDSYS. After the new link has been loaded, the main 
program immediately calls EGNSYS to restore these tables. 

On the DCS, link switching is an expensive operation since there is no non-transmitting 
read. Experience has shown that the time to switch from a link to one adjacent to it is 30 
seconds with a maximum switch time to any link of 60 seconds. For small problems this builds 
in a substantial overhead time. However, this time is constant, and its importance decreases 
as the problem size increases. Unfortunately certain classes of iterative problems (Piecewise 
Linear Analysis, Static Analysis with Differential Stiffness, flutter problems, etc.) may 
suffer serious running time additions due to this overhead time. 

5.2.4 Overlay Considerations and Implementation of Open Core 

The execution time of a NASTRAN run is extremely sensitive to the amounts of core storage 
available to certain routines. Small differences (1000 or so) in the number of words available 
can often make differences in running time of factors of 10 or 20. 



5.2-3 



NASTRAN - OPERATING SYSTEM INTERFACES 

With these considerations in mind, the overlay for the DCS has been constantly changed 
to obtain as much data storage space as possible. At the same time, many routines have soill 
logic built in, but often serious inefficiencies result when this code is called into use. 
Two major design decisions were forced on NASTRAN to accomodate the small core size of the 
DCS. One was an assembly language GIN0 for the DCS. This allowed considerable savings in code 
and buffer space over the standard 1/0 routines used in the DCS. For further details on the 
1/0 see section 5.2.2. The second was removing the format conversion routines (FCNV,FI0H) from 
the root segment and allowing only selected modules to reference the system output file. 

At the same time, overlaying is not a cheap operation on the DCS. Hence many routines which 
might only in rare cases require large amounts of core storage were grouped together to minimize 
the number of overlay segments during execution. The DCS overlay structure was duplicated as 
nearly as possible on the other machines in the interest of consistency during checkout and 
simplicity of system maintenance. A pictorial representation of the DCS overlay structure is 
given in the figures in section 5.2.9. 

The only unusual feature of NASTRAN overlay structures on the DCS is caused by the desire 
of several module drivers to reference several matrix routines in common. This can be best 
illustrated by the following figure. 



Al 



Module A 
Driver 



Matrix 
Routine C 



Module A 
Subroutine 
1 



L0NG 

(A dummy 
routine; 



Module B 
Driver 



Module B 
Subroutine 
1 





Matrix 
Routine D 




Module A 
Subroutine2 




Module B 
Subroutine 2 


mQkZlki 











/MODBIX/ 



/M!3DB2X/ 



/M0DA1X/ 



Figure 1. A NASTRAN overlay on the IBM 7094/7040(44) DCS. 



5.2-4 



NASTRAN ON THE IBM 7094/7049(44) DCS (IBSYS) 

Module A and B both wish to call Matrix Routines C and D. To accomplish this, the 
following calls are made. The module A driver is called and loaded. Module A driver calls 
Module A Subroutine 1. This call causes the loader to load Module A Subroutine 1, Matrix 
Routine C and LfJNG. L0NG is a DCS only deck, which is never called and which contains a 
DIMENSI0N statement for a dummy array whose length is longer than the lenath of all module 
drivers origined at Al . Hence, the core allocated for the Module A driver is not disturbed. 
Module A Subroutine 1 returns to Module A driver which calls Module A Subroutine 2 and so on. 
Thus the drivers for modules A and B have access to Matrix Routines C and D without any loss 
of core storage to Matrix Routine D when Matrix Routine C is in execution. 

The nature of open core on the DCS can also be illustrated by this picture. All core 
below /M0DA1X/ is available to Module A Subroutine 1 to do with as it pleases. In order to 
find out how much is available. Module A Subroutine 1 can call function C0RSZ which on the DCS 
computes the number of words between /M0DA1X/ and blank C0MM0N. Thus all unused (by code) 
cells of core are dynatrically made available to each routine. 

Note also that a special version of .L0VRY, a DCS only deck, must be used in con.iunction 
with SEARCH and LNKSTK (see section 5.2.6) in order that the overlays for each link can all be 
stacked on one logical unit. Further details can be found in the .L0VRY listing. 

5.2.5 Execution Deck Setup 

The purpose of this section is to describe the system control cards required to execute 
a NASTRAN run on the DCS. The following list of cards is a general guide to format and type. It 
is unlikely that any run would use every card listed below. Read the appropriate description 
section, and choose those cards relevant to your particular run. 



5.2-5 



imSTRAN - OPERATING SYSTEM INTERFACES 



Table 1. Execution Deck Setup for NASTRAN on the IBM 7094/7040(44) DCS. 



$JOB CSC.J208000tl4903-0.S031*,A ICl. 20, 20000 NASTRAN 



RUN 



SSETUP LB2 

SSETUP UTl 

SSETUP UT5 

SSETUP UT6 

SSETUP UT7 

SSETUP UT8 

SSETUP UT9 

SSETUP LB3 

$SETUP LB4 

SSETUP UT3 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SASSIGN 

SATENO 

SIBJOB CSC 

SIBLOR CALLER 

SIBLOR ,SRCH. 

SOATA 

SSSSSS YOUR 



SUBSYS.0ISIC.C0PY,FC = 27 



THIS 
THIS 
THIS 
THIS 
THIS 
THIS 
THIS 
THIS 
THIS 



THIS PUTS 
WILL MAKE THE POOL A 
WILL MAKE THE OPTP A 
WILL MAKE THE NPTP A 
IS THE BCD PLOT TAPE 

THE BINARY PLOT TAPE 

A USER INPUT TAPE 

NEEDED FOR USING A USERS MASTER FILE 

USED WHILE CREATING A USERS MASTER FILf 



IS 
IS 

IS 
IS 



SUBSYS ON DISK 
PHYSICAL TAPE 
PHYSICAL TAPE 
PHYSICAL TAPE 
— EAI AND B-L 
— SC4n20 



FILE WILL BE USED TO HONOR TAPE REQUESTS 



POOL 

OPTP.NORING 

NPTP 

PLTl 

PLT2 

USER.NORING 

UMF.NORING 

NUMF 

TAPE 

SYSLB2 

SYSLB3 

SYSLB4 

SYSUTl 

SYSUT2 

SYSUT3 

SYSUT<» 

SYSUT5 

SYSUT6 

SYSUT7 

SYSUTB 

SYSUT9 

SYSUTO 

0«77777,3 

GO.ALTIO.NOFLOW.NOMAP.NOSOURCE 

DUMMY MAIN PROGRAM CALLER OBJECT DECK GOES HERE 
SEARCH OBJECT DECK GOES HERE TO BRING IN LINK 1 

NASTRAN DATA DECKS FOLLOW THE SDATA CARD 



01 
02 
03 
04 
05 
06 
07 
08 
09 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 



Note that each card has a number in columns 79-80. Each card or group of cards will 
be described under that number below. 

01 - Standard installation accounting card. Certain standard information is contained on 
this card which will be important to the successful completion of a run. 

Time Limit = 20. This number is an absolute and will override any number on the 
TIME card in the Executive Control Deck. 

Number of Lines of output = 20000. Again this number will override any MAXLINES 
setting in the Case Control Deck. 

02 - This causes the program tape to be placed on the disk ready for execution. The 
program tape can be left as a physical tape but at the expense of execution speed. 



5.2-6 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 

03 - For large problems the Data Pool File (P00L) will contain many millions of words. 
Especially on systems where the disk is "cleaned up" only at the completion of a job, 
large problems may need the Pii)0L set up to save disk space. 

04 - When doing a restart, this tape should be the one generated from previous run. 

05 - When checkpointing, this card is required. You may not checkpoint onto the disk. 
06-07 - One of these cards is required for plots. Both types of plots may be made on 
one run, in which case both cards are required. If the plotter is "on-line", certain 
modifications of these cards may be desirable for faster turn-around, but the form 
shown here is acceptable. The density of these two tapes is not a user option but is 
often set by the hardware of the plotter. 

08 - This tape cannot be used without user programming. Its intent is to allow the user 
to easily input data from another source into NASTRAN. The user then must provide the 
module (INPUT) to process this data into NASTRAN format. 

09 - The User Master File is for bulk data storage. It functions as one alternate 
source of input along with the 0PTP and the card reader. 

10 - If it is desired to create or edit a User Master File, this tape should be set ud. 

11 - SYSUT2-4 are available for use in coniunction with the TAPE ootion in the 
FILE DMAP instruction. 

Note: If any cards between 03 and 11 are not being used, they should simply be 
removed from the deck. NASTRAN will automatically make these units available for 
later use. 

12-24 - Required system ASSIGN cards. Actually, these cards are required only for 
physical units, but it does not hurt to leave them in permanently. 

25 - This card forces a system dump under certain conditions, such as maximum time being 
exceeded, etc. It may be removed or retained as desired. 

26 - This is the standard IBJ0B card. Note the N0MAP and N0S0URCE options. Output 
will start with NASTRAN output, not loader maps. 

27-28 - These cards are replaced by the appropriate binary driver decks. 



5.2-7 



NASTRAN - OPERATING SYSTEM INTERFACES 

29-30 - The $DATA card is followed by the 3 NASTRAN data decks. The contents of these 
decks are described in section 2 of the User's Manual. 

5.2.6 Generation of the NASTRAN Executable System ("Subsysing") . 

In order to generate the executable NASTRAN system, the loader must be called in for each 
link. Unfortunately there is no simple way in IBSYS to join separate outputs from IBLDR. 
However, a special technique was developed by David E. Bluett, Reference 1, called "subsysing", 
which allows one to accomplish this task. The routine which does the subsysing is called LNKSTK. 
Hence, a NASTRAN subsys run consists of 2n (n being the number of NASTRAN links) separate job 
steps with LNKSTK putting each link of NASTRAN on a tape. The resultant program is linked to- 
gether through SEARCH at execution time. The following list gives a set of key cards which 
accomplish the subsysing and gives a brief description of each card. 

Table 2. NASTRAN Subsys Deck Setup on the IBM 7094/7040(44) DCS. 

$JOB CSCf J208000»l'»903-0»S031t.A IC1»90#20000 NASTRAN SUBSYS 01 

$SETUP LB2 SUBSYS NEW SUBSYS TAPE 02 

SSETUP UBH 0BJL»DISK.C0PY»FC=1 OBJECT LIBRARY 03 

SASSIGN SYSLB2 04 

SASSIGN SYSLB3 05 

»ASSIGN SYSLBf 06 

^ASSIGN SYSUTl 07 

lASSIGN SYSUT2 00 08 

SASSIGN SYSUT3 09 

$ASSIGN SYSUT4 10 

SASSIGN SYSUT5 11 

SASSIGN SYSUT6 12 

SASSIGN SYSU17 13 

SASSIGN SYSU78 I'* 

SASSIGN SYSUT9 15 

SASSIGN SYSUTO 16 

SIBJOB KHR ALTIO»NOFLOWfMAP 17 

SIEOIT SYSLB«*»5RCH 18 

SIBLOR SEMDBD 19 

S$ THE REST OF THE ROOT SEGMENT DECKS GO HERE 20 

SORIGIN Al»RtW»SYSCKl 21 

$$ THE DECKS FOR OVERLAY AT Al GO HERE 22 

$4 THE REST OF THE OVERLAY STRUCTURE IS DESCRIBED HERE 23 

SENTRY XSEMl 2H 

SDATA 25 

(3E0F 26 

SIHSYS 27 

SREWINQ SYSLB"* 28 

Si LINK 1 HAS JUST BEEN PROCESSED BY IBLDR. 29 

SID CSC»J208000tO'*013-Or46501»A ICl 30 

SIBJOB ALTIOrNOFLOW 31 

SIEOIT 5YSLB4fSRCH 32 

SIBLDR LNKSTK 33 

SDATA 3t 

NSOl rSYSCK2»SYSCKl»SYSLB2fSYSLB2»RB ^•'. 
©EOF 



5,2-8 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 

Each card in the above listing contains a sequence number in columns 79-80. Each card 
will be discussed under this heading. 

01 - Standard installation dependent accounting card. Note that the subsys time is not 
small. It normally takes between 45 and 60 minutes on a "dry" system. One link at a time 
can be generated and merged into an existing subsys tape using the IBEDIT feature of IBSYS. 

02 - The subsys tape is set up as a physical tape to ensure recovery if a system failure 
should abort the run. 

03 - The object library contains card-to-tape images of the object decks for all NASTRAN 
subroutines. 

04-16 - System ASSIGN cards. 

17 - This is a standard IBJ0B with the exception of the N0FL0W option. NASTRAN will 
not be processed by IBLDR without this option. 

18 - This card instructs the Editor to look for the requested decks on SYSLB4. 

19-20 - One $IBLDR card is given for each deck required in each link. 

21-23 - Normal overlay cards are used to describe the overlay tree. Note that all 
segments must be routed to SYSCKl since LNKSTK expects them there. 

24 - All main programs (XSEMi's) are subroutines and hence require $ENTRY cards. 

25-26 - These cards terminate this job step. 

27-29 - SYSLB4 is returned to the beginning to facilitate searching. A message is 
written on the operator's typewriter to aid in following the job progress. 

30-33 - LNKSTK is brought in to take the core resident (root segment) program on 
SYSCK2 and the overlay segments on SYSCKl and copy them onto SYSLB2. 

34-36 - The data card for LNKSTK describes the position of the overlay tape and the 
output tape as well as controls the rewind options. Note that every link has a name 
beginning with NSi, i = 01, 02, 

The above model is repeated for each link that is being subsysed. The final number of 
files on the program tape is two times the number of links subsysed plus one. 



5.2-9 



NASTRAN - OPERATING SYSTEM INTERFACES 

5.2.7 Machine Dependent Routines 

The material discussed in this section will be the machine dependent features of certain 
routines. There are two classes of machine dependent routines. The first class consists 
of routines whose code is in assembly language and hence varies from machine to machine, but 
whose function remains exactly the same. Examples of such routines would include the MAPFNS 
routines: RSHIFT, ANDF, etc. These are documented in subroutine descriptions, section 3. 
The second class consists of routines which result in different external manifestations on 
each machine. They are treated below. 

5.2.7.1 Clocks 

All times measured on the DCS are wall clock times. 1/0 waiting times, overlay times, 
LINK switching times, etc., are all included. This fact should be born in mind for job time 
estimation on the DCS. Note also that if any forms of interrupt are used, NASTRAN will not 
realize that it has not had sole use of the machine. The support functions such as blocking 
and/or unblocking, plotting, printing, etc., will also reduce the efficiency of the DCS to 
run NASTRAN. This sort of activity can cause large variances in running times even for the 
same problem, A request to run "dry" or "moderately loaded" is usually a must for an efficient 
and predictable NASTRAN run. 

5.2.7.2 DUMP/PDUMP 

During the normal execution of a NASTRAN run, all calls to DUMP or PDUMP are blocked by 
the routine KRDUMP. KRDUMP will give a "backtrace" of the deck name, line number, and location 
for each deck called. This is accomplished by subroutine .JRTLIN. This should be enough to 
allow some error detection. For example, if the following backtrace was given: 

XSEM2 CALLED SMAl AT I FN 74 

SMAl CALLED KC0NE AT I FN 421 

KCj)NE CALLED MESAGE AT I FN 114, 

one could tenatively conclude that the Structural Matrix Assembler module (SMAl) en- 
countered some unexpected difficulty in processing the C(3NE element. 

Often an inspection of the data, along with the error message printed out, immediately 
resolves the difficulty. In case a full dump of the 7094 core is desired, a DIAG 1 card in 



5.2-10 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 

the Executive Control Deck should be used. The resulting dump will be in the "STR" format. 
5.2.7.3 C0NMSG 

During the execution of a NASTRAN run, all messages to the user which are of an informative 
nature are printed at the beginning of the job output. These messages include the start and 
end time for each module, matrix decomposition parameters, warning messages, and any fatal 
errors detected by NASTRAN. This is accomplished by subroutine C0NMSG automatically. If 
in addition the user expects to attend the computer run and wishes to follow the progress of 
NASTRAN (especially for long runs), a DIAG 5 card in the Executive Control Deck will cause 
the beginning time for each module to be typed on the operator's typewriter. Similarly, a 
DIAG 6 card will cause the ending time for each module to be typed. 

5-2.8 Flow Charts for the DCS Machine Language GIN0 Routines 

Figures 2 through 11 on the following pages show the flow of the assembly language GINJI 
routines for the DCS. 

Note : 

Many "flag" tests shown on the following flowcharts indicate an apparent closed loop. These 
are "waits" at positions within the logic where processing cannot continue until a particular con- 
dition (filled/emptied buffer, file re-positioned, etc.) is satisfied. When the necessary con- 
dition is satisfied, I0EX will interrupt any processing (possibly a "wait" loop) and the appro- 
priate flag will be changed. The interrupted processing is then resumed at the point of interrupt. 
This flag change, if holding a loop, will cause the "wait" to terminate. All loops and their 
tested flags operate similarly and asynchronously. This Interrupt capability of I0EX permits 
1/0 and computational overlap. 



5.2-11 



NASTRAN - OPERATING SYSTEM INTERFACES 



( ENTER J 



Save index 
Eteglsten 



Save Location of 
Usen Work Buffer 



Set up Error Exits 



Save File Name 



Divide Usen Woik 
Buffet Into Control 
Table and Two 
Half Buffen 



initialize Buffet 
Pointer to Point 
at 2nd Half 



Set Buffer Word 
Petition Pointer 
to Beginning of 
Buffet 



Search XFIST 
For Match 
On File Name 



c 





-/" r 


MATCH 




/is There\^ 
a File Name 
\^Match "I y 


Pickup Pointer 
to XFIAT Table 


) 


No 






ERKOR EXIT 









Pickup lOEX Unit 
Control Block 
Address From 
XFIAT 



Initialize lOEX 
Calling Sequence 
with UCB Address 




Pickup lOEX Unit 
Control Block 
Address From 
XXFIAT 



Initialize lOEX 
Calling Seqtience 
w ith UCB Address 



ADDDA 



Place UCB Address 
in Control Table 



Initialize Flag 
Bits in Control 
Table and UCB 



Place Pointer to 
Control Table 
And UCB 





, NDSEL 



Set Both Buffers 
Empty Flag On 



InitUUze UCB 
for a Read 





MESAGE 
Fatal Error 



Set File Open 
Flag On 



( RETURN \ 



To System 



( EXIT ) 



F-.gure 2. Flowchart for the DCS assembly language GIM0 routine I3PEN - deck name 0PENN 



5.2-12 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



f ENTER j 



Save Registers 



Pickup File Name 
from User Calling 
Sequence 



Initialize All 
lOEX Calls 





Output 




Pickup Work Buffer 
Index Pointer 






Locate Half Buffer 
Currently Being 
Filled with Data 




Set Close Flag On 



f RETURN J 



Prepare to 
Activate Channel 



^ 



(In WRITE) 



(From WRITE) 




Turn Clo5€ 
Flas Off 




Rewind 



EOF-No Rewind 



.NDSEL 
Write EOF 



.NDSEL 
Backspace Record 



( RETURN J 



.NDSEL 
Rewind File 



Figure 3(a). Flowchart for the DCS assembly language Gm0 routine CL0SE - deck name CLi3SED. 



5.2-13 



NASTRAN - OPERATING SYSTEM INTERFACES 




Ii \ No 
'EOF FUg On IlN 
^File Control 
vTtble r/ 

Yei 



Loute Cumnt 
Half Buffer 




3 




Figure 3(b). Flowchart for the DCS assembly language GIN0 routine CL0SE - deck name CL0SED. 



5.2-14 



NASTRAN OM THE IBM 7094/7040(44) DCS (IBSYS) 



( ENTER J 



Save Registers 




Pickup File Name 



Using Control 
Pointer Locate 
Current Buffer 




CHKFIL 
Get Adrs. of 
f Work Buff Re- 
\lated to File 
Name 



Initialize lOEX 
Calling Sequence 




Turn Prime Buffers 
Flag Off 



Set Both Buffers 
Empty Flag On 



Initialize Error 
Exit! 



-( EOF EXIT ) 



ISWTCH 




Using Buffer 
Position Pointer, 
Pickup Current 
Dau Word from 
Work Buffer 




Prepare to Make 
Channel Request 



Initialize Registers 
for Moving Data 
to Users Buffer 




Set Switch for 
Either Tranimltting 
or Non Trans- 
mitting Mode 



Store Dau Word 
In Users Dau 
Buffer 



Increment Users 
Buffer Pointer 




Increment Work 
Buffer Pointer 



to System 



Figure 4(a). Flowchart for the DCS assembly language GIN0 routine READ - deck name READD. 



5.2-15 



WASTRAN - OPERATING SYSTEM INTERFACES 



ZERON 
CHKEOR 



Place Word 
Position Pointer In 
Control Table 




Turn Redundancy 
Switch On 



Reset Word Position 
Pointer to 
Beginning of 
Buffer 




Inhibit Traps 





Set 'Skip to End 
of Logical Record' 
Flag On 




Set Both Half 
Buffers Empty 
Flag On 



J RETURN ) 



Turn Redundancy 
Switch Off 



Enable Traps 



Enable Traps 



MESAGE 
Paul Error 



Flip Buffer Pointer 
to Alternate Half 
Buffer 



c 




RETXWN 



J 



to System 



Turn Half Buffer 
Empty Flag On 



Figure 4(b). Flowchart for the DCS assembly language GIN0 routine READ - deck name READD , 



5.2-16 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



Enable Traps 



Decrement No. of 
Words (N) to be 
Read by 1 



Flip Buffer Pointer 
to Alternate Half 
Buffer 





Set Get Out 
Switch On 



Enable Traps 



Flip Pointer to 
Alternate Half 
Buffer 



J_ 



Reset Word 
Position Pointer 
to Beginning 
of Buffer 



'This 
'Record Last^ 
Physical Record^ 
" ^f Logical 
ecord> 



Yes 



Turn On 'Skipping 
to End of Logical 
Record' Flag 



Set Both Half 
Buffers Empty 
Flag On 



Inhibit Traps 





Set Half Buffer 
Empty Flag On 




Prepare to Make 
Activity Request 
to lOEX 



Prepare to Make 
Channel Request 



Turn Both Half 
Buffer Empty 
Flag On 



Enable Traps 



GETOUT 




Turn Switch Off 



Compute No. of 
Words Read and 
Place In Users 
Flag Word 



f EXIT j 



Special Exit 



Figure 4(c). Flowchart for the DCS assembly language GIW routine READ - deck name READD 



5.2-17 



NASTRAN - OPERATING SYSTEM INTERFACES 



( ENTER ) 



Save Registers 



Initialize Work 
Buffer Length for 
Later Use 



Turn Finish Flag 
Off 



Pickup File Name 
From Calling Seq. 



Locate Related 
UCB and Work 
Buffer Area 




( RETURN J 



to System 




Load XR7 with 
Half Buffet Data 
Index 



Pickup No. of 
Words (N) to be 
Written 



Place Half Buffer 
Dau Index In 
File Control Table 



EOTFLG 




Turn EOT Switch 
Off 



Restore Registers 
and Serup EOT 
Exit 



( EXIT ) 



-/ RETURN J 



Locate Current 
Half Buffer 



Move One Word 
From User Buffer 
to Half Buffer 



Increment Data 
Pointers 




Decrement N by 1 




Figure 5(a). Flowchart for the DCS assembly language GIN0 routine WRITE - deck name URITEN 

5,2-18 



NASTRAK ON THE IBM 7094/7040(44) DCS (IBSYS) 



Decrement N by 1 





Turn Finish Flag 
On 



Increment Physical 
Record/Logical 
Record Counter 



Store Counter In 
lit Woni of Half 
Buffer 



Locate Current 
Half Buffer 



Inhibit Traps 



Turn Finish Flag 
On 




Increment Physical 
Record/Logical 
Record Counter 



Store Counter In 
1st Woid of Half 
Buffer 



Store Counter In 
2nd Word of Half 
Buffer Indicating 
Last Ftiyslcal Rec. 
Of Logical Record 



Store Record Size 
In 2nd Word of 
Half Buffer 



Reset Half Buffer 
Word Position 
Index 



Enable Traps 



Turn Half Buffer 
Full Flag On 



Flip Buffer Pointer 
to Alternate Half 
Buffer 



InltlallM Call 
Sequence to 
Activate Channel 



Turn Both Buffers 
Filled Flag On 



Enable Traps _ 




Figure 5(b), F1ov;chart for the DCS assembly language GIN0 routine WRITE - deck name WRITEN, 



5.2-19 



NASTRAN - OPERATING SYSTEM INTERFACES 



FWDREC 



[ ENTIR J 



Save Regbtcn 




Pickup File Name 



CHKFIL 



Inidallze Calls to 
lOEX Routine! 




InitUlize for EOF 
Exit 



MESAGE 
Ftul Elior 



( RETURN J 



To Syltcm 




Turn Both Buffers 
Empty Flag On 



Turn Prime Buffers 
FUg Off 



Prepare to 
Activate Channel 




Pickup Location 
of Current Half 
Buffer 




Turn EOF Flag Off 
In File Control 
Table 



Turn Prime the 
Buffer Flag On 



Restore Registers 



c 



J 



Figure 6(a). Flowchart for the DCS assembly language GIN0 routine FWDREC - deck name FjIRWRD. 

5.2-20 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 




Reset Half Buffer 
Dau Index 



Inhibit Traps 




Locate Current 
Half Buffer 




£> 



Enable Traps 




Flip Buffer Pointer 
to Alternate Half 
Buffer 




Enable Traps 



Turn BotfiHalf 
Buffers Empty 
Flag On 







fVe. 


"/ 










Turn Skip to End 
of Logical Record 
Flag On 














Enable Traps 












'V 


/Is Sk 
/End of 


P to Nv 

LogicalX 


rei 




Flip Buffer Pointer 
to Alternate Half 
Buffer 



Enable Traps 



Record Flag 
On ? . 




Turn Half Buffer 
Empty Flag On 



Turn Both Half 
Buffers Flag On 



Prepare to 
Activate Channel 



Turn Skip to End 
of Logical Record 
Flag On 



.ACTV 



Prepare to 
Activate Channel 



( RETURN ) 



J 



Figure 6(b). Flowchart for the DCS assembly language GIN0 routine FWDREC - deck name F0RWRD. 

5.2-21 



NASTRAN - OPERATING SYSTEM INTERFACES 



BCKREC 



( ENTER ) 



Save Registers 




Pickup File Name 
From Users 
Calling Sequence 



Inltialile Calls to 
lOEX Routines 




MESAGE 
Fatal Error 



f RETURN ) 



To System 





Locate Last Half 
Buffer Output 



Pickup the Physical 
Record Sequence 
No (N) from Dau 
Buffer 



AGAIN 



Backspace 
Record 



Decrement N by 1 




Turn On the Prime 
Buffers Flag 



( RETURN j 




POINTR ' 



Reset Half Buffer 
Data Index = 2 



Locate Current 
Half Buffer of Data 




Pickup the Hiyslcal 
Record Sequence 
No. (N) from 
Data Buffer 




Turn EOF Flag 
Off 



Figure 7(a). Flowchart for the DCS assembly language GIN0 routine BCKREC - deck name BKREC. 



5.2-22 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 




/ NDSEL 

/Backspace Record N 
\ lOEX Routine 







Turn Skip Back 
Flag On 






Prepare to 
Activate Channel 







Locate Current 
Half Buffer of Data 



.ACTV 
' Indicates a Read 



Walt Until"] 
Read Is 
Complete dj 





Turn Flag Off 



Flip Buffer Pointer 
to Alttroate Buffer 









(Backspace Record ) 
\ lOEX Routine / 




Pickup the Physical 
Record Sequence 
No. (N) from Data 
Buffer 





Turn EOF Flag 
Off In File Control 
Table 




Backspace ReoDrd ^ 
lOEX Routines 



Figure 7(b). Flowchart for the DCS assembly language GIN0 routine BCKREC - deck name BKREC. 



5.2-23 



NASTRAN - OPERATING SYSTEM INTERFACES 



SEL(+) 
SEL(-) 



( ENTER J 



Save Registers 





Decrement Skip 
File Counter (N) 




Set EOT Flag On 



E> 



Turn Prime Hall 
Buffer Flag On 




Turn Skipping 
Files Flag Off 



Set Half Buffet 
Processed Flag On 



Set Flag In UCB 
to Indicate No 
More I/O for this 
Request 



Flip Buffer Pointer 
to Alternate Half 
Buffer 



( RETURN ) 



■»-/ RETURN J 



^ 



Initialize UCB 



Set System Mode 
Indicator to Binaryl 



Using Buff. Pointer 
Pickup Address of 
Empry Buffer 



J 



Place Address In 
Channel Command 
Instruction 



([^ead or 
\. Requ 


^>v 


Write 


Pickup N 


D. of 


est?/^ 


Written 




Read 








Pickup No. of 
Words to be Read 




Must Write at 
Least 3 Words 










1 



Place No. In 
Channel Command 
Instruction 



Place Channel 
Command Initr. 
Address In System 
Location . RCHX 



Figure. 8(a). Flowchart for the DCS assembly language GIN0 routine SEL+ - deck name SELECT • 



5.2-24 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 




Prepare to Access 
Half Buffer Used 
for I/O Request 



Turn Skip Record 
Flag Off 




Set Redundancy 
Flag On In File 
Control Table 




Set EOF Flag In 
1st Word of 
Current Half 
Buffer 



Turn EOF Flag 
On In File Control 
Table 



Set 'Both Half 
Buffers Empty' 
Flag Off 





Flip Buffer Pointer 
to Alternate Half 
Buffer 



Turn Skip Logical 
Record Flag Off 



Set 'Half Buffet 
Etnpty'Flag Off 



Turn Both Half 
Buffers Empty 
Flag On 



Restore Registers 



f RETURN ) 



Figure 8(b). Flowchart for the DCS assembly language GIN0 routine SEL-f - deck name SELECT. 



5.2-25 



NASTRAN - OPERATING SYSTEM INTERFACES 



3 



Save Register! 



Pickup File Name 




CHKFIL 



Initialize Calls to 
lOEX Routines 



Pickup No. of Files 
(N) to be Skipped 
from Users Calling 
Sequence 




MESAGE 
Faul Error 



c 



3 



To System 



Wait Until All 
Current Activity 
of Channel Is 
Completed 




Decrement N by 1 



Turn EOF Flag Off 



/ NDSEL 
(Backspace File 



Decrement N by 1 




Turn On the Prime 
Buffers Flag 



Reset Data Buffer 
Index 



f RETURN J 



Figure 9(a). Flowchart for the DCS assembly language GIN0 routine SKPFIL - deck name SKIPF 



5.2-26 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 






Inhibit Traps 





Turn Skip Flag 
Off 



Place N in File 
Control Table 



MESAGE 
Fatal Error 



r 



3 



To System 



Turn EOF Flag Off 



Decrement N by 1 




Place N In File 
Control Table 




Turn Skipping 
File Flag On In 
File Control 
Table 



Enable Traps 



Set tlie Prime 
Buffer Plas 



Enable Traps 



Set Skipping File 
Flag On 



Prepare to 
Activate Channel 



f RETURN A 



Enable Traps 



Figure 9(b). Flowchart for the DCS assembly language GIN0 routine SKPFIL - deck name SKIPF. 



5.2-27 



MASTRAN - OPERATING SYSTEM INTERFACES 



( ENTER J 



Save Register 




Pickup File Name 




MESAGE 
Fatal Error 



( RETURN ) 



1 



c 



To System 



Figure 10. Flowchart for the DCS assembly language GIN0 routine E0F - deck name MISC 



5.2-28 



NASTRAN ON THE iRM 7094/7040(44) DCS (IBSYS) 



REWIND ♦ UNUDAD 



c 



Save Registers 



Set lOEX Call for 
Rewind + Unload 



[ entf:. 



Save ifcuisters 



__J 



'Zl._^_ 



Pickup N;a!!c d 
Mir 



r 
-1-. 



/ \ 

CI IK HI. 



Initialize rile 
Address for lOEX 
Call 




/ .^;DSEI. 
Rewind File 



/Has File ~\ Yes 
^ Been Properly ^> — •- 
Opened ? 




To System 



Turn Prime the 
Buffers Flag On 



Turn EOF Flag Off 




-/ RETURN ] 



REWIND t UNUDAD 



Figure 11. Flowchart for the DCS assembly language GIN0 routine REWIND - deck name MISC 

5.2-294t 



NASTRAN - OPERATING SYSTEM INTERFACES 

5.2.9 DCS Overlay Diagrams 

Figures 12, 13, 14, 15 and 16 on the following fold-out pages represent the NASTRAN overlay 
structure for the DCS. Since the DCS overlay structure was duplicated as nearly as possible on 
the other machines, these diagrams can be used to follow the exact overlay Implementation on these 
machines. Note that link 8 does not appear in the following diagrams. This link can be used for 
the addition of a new link (see section 6.11). 



5.2-30 



IM 7094/7040(44) DCS (IBSYS) 



LINK1 



LINK 2 



1 i I 1 1 


re 1 1 iiopi 1 






1 ■I'C 


i: i i "''"' i L' 


CK r [ 1 


1 <tC 




i;;s; 


-", ! 



links 1 and 2 on the IBM 7094/7040(44) DCS. 
5.2-31 ft 













[ c^f»^ 
























t «cs» 
























1 IILPGE 
























1 M-COff 














TZ , i 


; /"oi" , \ 


1 .;-- . i 


1 ia*nc 1 


1 LC.L ; ! I 


...c 1 


L07HO 1 


1 LCBLT 1 




1 .,0.D ! 


L,..C 1 


: L... 


ILLu!«/ 1 


1 /ILH^^J ■ 1 


1 ^\.[T^*, \ 


1 /.innt*/ : 


r LJ5»Pt [ I L 


06»eL 1 


/IiluctS/ i 




1 LC^isn 1 


1 LIC«80 t 


LIIUBC 1 


1 LIJ* 


IOC, , 




1 ^°'' 1 


1 LIIC I 


1 LCES 1 I L 


»" 1 


LD07 I 


1 tis; 1 


1 LDCi 1 


1 LUlO 1 


LCll 1 


! uit 

















OPENN 

CLOSEO 
ttt*DO 






1 




1 t J 1 1 

1 IM* 1 1 IMI 1 1 IMC 
[ 1 1 ( 1 TlIC* 


I ,-. 1 1 ...c 1 


1 /tXAL /I 1 /[> 
L 1 1 


^ / 1 1 WJEInr 


1 „.M , 1 1 ,„., , 1 










1 „«, , 





.1-1\B 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



I IfxCBE) r 


I IfllBO 1 


[ /u'Mii/ I 


1 SEVIM 1 



<B$SC 
Kt^PltS 



1 .ICWBD I 1 »C««C1 i i "BElCC 1 

1 M^BrsD' 1 1 iF>?»r) 1 1 iiicet I 
1 .FAiut [ 1 /irpti t 1 1 /ifPifc/ [ 
1 "scm I 1 it-»)Mii 1 1 'iKjiw/ 1 


1 1 1 /1FSX6 ^1 i I 


1 Ifp 1 

1 IFJIO [ 


1 ,„... , I 



I€I»ICI 



Figure 12. Overlay structure for links 1 and 2 on the IBM 7094/7040(44) DCS, 



5.2-31C. 



NASTRAN ON THE IBM 7094/7040(^4) DCS (IBSYS) 



Figure 13. Overlay structure for links 3 and 4 on the IBM 7094/7040(44) 

5.2-33A 



BISIRP I 



LINK 3 



LINK 4 



1 <«0C 1 


[ ¥.JUPf I 


1 M>•^fL 1 


1 KtDft*- 1 


1 «T»fiC i 


1 HDfLT 1 


1 «L*i 1 


1 nf^u 1 1 



. DF 


fiat 1 


i CI 


>JflC 1 


t 01 


•lec 1 


1 CI 




t 01 


'SBC I 


1 /Ol 


'fOI/ 1 


i /Ol 


•BOJ/ 1 


I /Ol 


►■01/ 1 


r /Ol 


'BO*/ 1 


I /Of 


fioi/ 1 


1 Of 


ffUK I 


01 


• 1 I 


Of 


f l« I 


, /Of 


flUK/ ! 




• fn/ 1 



1 /itryf / 

I &C1LEJI 

1 Of* 




1 C^"*It 1 
1 S*-*}* 1 

1 iikvffc 1 






1 /tf*cca/ 




1 /ClNElll/ I 







1 FHS 


1 1 
1 SSC1« 1 
1 1 


1 /5SC«J / 1 
1 /SSCBi / 1 



DCS, 



^.2-?3e, 



I Cn« 


ilC ! 


I put 


mc 1 


1 INV 


[«0 I 


1 OM 


*Ii ! 


I /HAT 


IN / 1 


1 /H*I 


Otjl/ 1 



1 S-iJ 1 

r s"*?* 1 

1 S"IJH 1 


1 sh«;bo I 


1 /S"«?10/ 1 


1 /SHi^tl/ 1 


I ►■OC 1 


1 •en*- I 


1 f^iiro 1 


I -*iiO I 


1 •T.Ct.c" ! 


i "(lf»" 1 




[ (■tdlllG 1 


I l-IKiPK 1 


1 CHI 1 


I cwil'" 1 




1 Df J 1 


I CutF 1 


1 C-A9 r 


[ Df-lCO 1 




1 c-j«8 r 


1 D-lXt 1 


1 -tO.O« 1 


1 /i"«?x / 1 





DflC 1 




*8C I 




CM. 1 




sen 1 




IID I 




NHC 1 








»f 1 




C 1 




Uhl 1 




FNS 1 




jcr 1 




TRi 1 




*CE 1 




"E 1 

ri 1 




z \ 




«Ci 1 







1 OC'.CCI 1 

1 C»LCV 1 


[ UPHftT 1 1 •'CtH 1 
1 SCtI 1 1 1 




1 ,UP..-,/ 1 1 """ ' 1 



1 ^';;;;; | 


1111 

1 C^»CI« I I tPmiM [ 

I I 1 CPkClC 1 




1 /c»»c»i/ 1 1 r 

1 1 1 /0>*CB1/ I 



^.2-33C. 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



QSHSi t 



I Mffci [ I »nrci I I «A*C« I 






I /nCfOI / I 



Figure 13. Overlay structure for links 3 and 4 on the IBM 7094/7040(44) DCS. 

5.2-33P 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS 



Figure 14. Overlay structure for links 5 and 6 on the IBM 7 

5.2-35,^ 



LINK 5 



1 KSCwdl 


I BIiI«f I 




1 tXCifS 1 


1 HftTlIN 


1 r 







LINK 6 



I 

1 OF 


lac 1 


1 OF 


}ac 1 


1 or 


5BC [ 


1 /OF 


tOl/ I 




ei>?/ 1 


1 /Cfl-BOJ/ I 


1 /Cf»(0*/ ! 


1 /Of 




I OF. 




1 DFi 


Fvfc 1 


1 OFF 

1 


'' i 


1 

I /CfP 




1 /T*B»n>/ 1 
1 1 



JiSDSGk 



I HITOUH I 



1 CF 


tac [ 


1 CF 


2BC 1 


1 OF 








1 CF 








1 /CF 


tDl/ 1 


1 /Of 




1 /CF 








I Of 




I OF 


P^JK I 


[ err 


'* 1 


1 /OFF 


»./ 1 


1 /t*BC«»/ 1 



094/7040(44) DCS. 



^.Z'^'^B 



1 KLltlt 1 
1 CPhCC" 1 

1 /ft»H(,/ I 

rill 

I ^f«Cf 1 1 iitj* 1 
1 SCIIt 1 1 1 




1 1 1 /ise*; / I 
1 /scan /I 1 [ 


1 /SiCBi / 1 

1 1 



MN«M 

■ MCH. 

CLOUD 
WlllfM 

■«acc 

lELfCT 



IPICM 
aaltAt. 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



I isc I 



r FCPii 1 






1 CCt' 1 
t FB^ll 1 


1 ,.s.„., 1 



SSGJt 1 



1 >ILI.fl 1 

I CVMCCII I 

1 /PtH'tC/ I 


t •£»0l 1 1 flEirj 1 

i I 1 "(it* 1 




1 ysciAi /I 1 I 

[ 1 1 ftMOItf t 


1 /INV*«X/ 1 







c^cl 




1 CII^ 








1 /citrt 1 








1 iic* 








1 SCRIM 








1 M*f 








1 tCICET 






/ihvo / 1 


1 EiCC 








1 CFTVl 






/IfcVCI«/ 1 


1 CET») 








1 CEIf* 








1 CfT^l 








1 fCMECt 








t CIIFII 








- 


Of 


IC« 




I /EflCI / 

1 









Figure 14. Overlay structure for links 5 and 6 on the IBM 7094/7040(44) DCS. 



5.2-35CL. 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



vlUlit 






15. Overlay structure for links 7 and 9 on the IBM 7094/7040(44) DCS. 

5.2-37/). 



LINK 7 



I 



HI I 

it 

IMIll 
• ■VMf 
••Ckia 
llfl 
IHU> 
1(1 ■» 

fWH 

lief 





UIMT 


1 
1 
1 


1 
1 


"""•" 






UMtl 1 


HrMH 




1 niMH 

1 


1 






1 nurnntf 


Tl>l»l 



I /(HI 



1 *ICIII 


i 


1 ftt>*n** 








w 










i i«ir 








1 m, 




1 f* li 




1 !» tl 




— —•■ ■« 


. . „„ 


tl!!! 




ntUi 


1 CTVIII 1 
1 GViCI 1 


.—....„ 


»;ii 1 




1 




J n»»u/ 1 




>•»«..,„. 



'— — "" m»ii 



LINK 9 



I I 

I itILRN I 

I umv I 

1 Sf»UB I 

r ific* t 

I >IICH. I 

I «»Cli«fi \ 

t OlEhit I 

I EkGtfB I 

I IflBB I 

I ■•HIN I 

I ^omie I 

I l*«fC I 

I tiitci I 

I \*\»r t 

I ■< t K t 

I kvtuni ( 

I Hir*Nf I 

) fiiioefl I 

I MMIl I 

r »fw% I 

I FNIII'i I 

I 'fill I 

I .tevif I 

) aieii I 

I iiti*ii ) 

I ■«« I 

I MfUK I 



I 



I' I IT I 



I tUUM 1 

r tfTvti I 

I FHflP I 

I (•D'fN I 

I I 



HEI 

KlVf 



ICMB 



I 

I 

. HI* I 

MgiGf I 

iHvtt I 

■ f*i I 

MClfik I 

niuk I 

•'Uhr I 



MCT 



1 tJttt 1 


1 MIMi, 1 1 vfcCMI 1 
■ 1 1 \Hft»1 I 
'^'""■-"-' l»*«li 1 Wllltitt i 
' 1 1 /IICMI/ 1 
t /lll^'ia/ 1 1 RMIIM 1 


I /li*IIU 1 




I TlHMt 
I F litre 



1 llli>t» 
I CKCM 
t FLCCP 



5. 2- 373 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



UVTH I 

■MM I 

MM I 

iXtff ! 



I H»H 

I IHKf 

I WIN 

I RlU 

I IVIIMf 

I UiMI 

I TOfWO 

I MTni 

I MIM« 

I PMM 

I miT 

I ihSM* 

I IIIM 

I I HTM 



I IMTCN I 



I WNVK I 



I CMTW 
I TIMt* 
I CICOIt 



OtNCW 



I cwia 

I /MtVVI' 



MRU 

Miru 

MUll 



1 itCC-M t 1 1*M» 1 

1 ntni / t 1 /iMfUR/ 1 
1 .cc* I 1 eTft*N» 1 
1 t 1 1 


1 1 r 1 

1 nt.\.M\H 1 1 /OTRINl/ 1 
1 /CICHll/ 1 t 1 



1 lOLVt 1 





SIhl 


1 t«CM 

1 /»»»CI / 

1 IOC* 

1 'KIVM/ 


■ 10l.*l» 


1 1 

1 1liM» 1 

1 /ll«t>i/ 1 

t crith* 1 




1 /eriiiiii/ 1 






iauti> 





Figure 15. Overlay structure for links 7 and 9 on the IBM 7094/7040(44) DCS. 



5.2-37C. 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



Figure 16. Overlay structure for links 10 and 11 on the IBM 7094/7040(44) DCS. 



5.2-39.-^. 



LINK 10 



N I 1 litll^- 



I ft'Zlt 


fM«cei 


1 c«;<cic 

1 






1 /F-RDd/ 
I /SSC« / 




1 /tLIfJI 


I /SSCfiJ / 









LINK 11 





1 /•rii.ct/ 

1 SiCie 




1 1 


CfMca 1 






SSOJ» [ 

TKttc r 




/l-CM / 1 
/ISC.i / 1 

/sscii / [ 



5:2-3^5 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



I GKtC I 



/SKACJ*l/ 1 



1 CISVPK i 


1 C(«Cl« 




inoii 1 

1 


[ MCC" / 1 




, ' 


1 


' 1 


1 /C(10<1/ 




/1X0E1 / 1 



J 001 I 



I CI*.V>>I 



I COtCF-P 1 
I CC»1^ 1 


1 I 1 1 
1 cnt?c I I CLNvP^ 1 
1 cni^BS 1 1 1 


1 CSLfl 1 I [ 


1 I "*'" [ ''"■" ' I 


1 1 



1 CI*. 


VJ 1 


1 D«T 


lO 1 


I CSC 




1 CIX 


6S 1 


I CXT 


RNT 1 


I C<T 




I CiC 




1 COI 


BS 1 


[ cw 




T /CIN 


0«/ 1 


1 /CIN 


"'! 



Figure 16. Overlay structure for links 10 and 11 on the IBM 7094/7040(44) DCS. 

5.2-39C. 



N THE IBM 7094/7040(44) DCS (IBSYS) 



LINK 12 



1 .fCI 1 

I -SDiOK 1 

1 >PUS[ 1 
1 nCPt- 1 
1 lECl 1 


1 /CSCtM/ 1 
1 /EiFl /I 



LINK 13 



I 1 

1 K.\* 1 


1 1 1 1 1 1 
1 -iC-'T [ [ mSIKP [ 1 HPC»([ 1 
1 iv^.)fSCi ! 1 ENtSTi 1 I /liFil / 1 
I k.t<TLIN [[11 iCEl 1 




1 ■PCLC» 1 1 / 
1 »iF» I 1 
[ ■SCSCk 1 

1 »Cl-t*K 1 
[ ■PUM' 1 

1 «CPH [ 

(S*» 

1 /tSCCKt/ 1 



;ure for links 12 and 13 on the IBM 7094/7040(44) DCS. 
5.2-41 fl 



I"tCLC 

kRITRt. 



UNFIil 
PRE(.OC 



I CFP*Br 1 
J /CfPtnW 1 

1 /cfpeui/ [ 

1 /CfCBD*/ I 

I orpiMN J 

I CfPl 1 


I /KBPMK/ 1 







1 ,„, } 1 ,^^^, 1 1 ^^^^^ 1 ■""" { :[«. 1 ! '""' ' ! 


1 /"^BiX ' 1 1 CPhiCCH I III, 


1 1 I /!•*■" 11 I I i i 


1 1 I /CtHKG/ 1 1 1 1 I 


I 1 II 


1 ICRll I 1 SSC21 1 

1 smie 1 1 I 




1 1 I /ssou / 1 
1 /scH*i / 1 I /coflm / 1 

1 /SCOBl /I 1 1 


I t 






PES*CE 





i , 


1 SO»I 




I /lerip / 


1 GPt-JIS 1 
[ 1 



1 ScajF 1 

1 tM*if>l 1 

I /SCHilb/ 1 


' "001 1 I iCCsei I 1 SIltlNl 1 I SIOODI f 
I S«*''l 1 I 1 I SlKiPl 1 1 RCfBEK I 


1 S<'»M1 I [ BIKI 1 IF*! 
I SElAil 1 1 ■>> I I Fb [ 

' sritPLi r I «ii 1 I iHiTR. 1 
1 iOi^'ll 1 I *J I 1 st-tr 

1 STKCCI 1 1 cOtF I 1 SntvEl 1 
I STKBSI t 1 FI-9 [ 1 j 


I SIR^'EI 1 , |F«t 1 
1 SB**! 1 1 FJ<( I 
1 ' I FtJIt 1 


1 1 '° ' ! '"" ; 


[ 1 





P«EI»D 




1 c-su 




1 ?L«*J I 






1 •>L*«aQ 1 


r c^iinc 




1 «'Lt4B 1 


I C4cr 




t fmcD 1 


1 ;.8E*« 

1 Cl^ft- 




[ PkBAR 1 
1 /PL»'.2n/ 1 


1 CCC^E" 






1 /CSllOP/ 






I /£St«*»/ 






I /C1I*(I/ 


OSI*x> 


1 /PLilijX/ 1 






1 /Cil*n/ 





3- 



:-HI» 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



ccxi [ 



I OSl I 



Figure 17. Overlay structure for links 12 and 13 on the IBM 7094/7040(44) DCS. 



5.2-41C 



7094/7040(44) DCS (IBSYS) 



LINK 14 



for link 14 on the IBM 7094/7040 DCS, 



5.2-43A 



NASTRAN ON THE IBM 7094/7040(44) DCS (IBSYS) 



1 KflLllK 1 
1 $E»CBC t 


[ l>SE>>M 1 




I KFthCQ 1 


1 OI-EOS 1 


1 CICSIC 1 


1 i.RII«v 1 


1 FOWfcMC 1 




1 iHtn I 




1 Hit 1 




1 NHITRL 1 


1 -EiKGE 1 


1 riii't 1 


1 l>£III 1 


I INIPK 1 


1 t.NI'»C» ( 
1 CNf[if 1 


I PRELQL [ 


1 ssi.rcf 1 



I fiwiit/ 



Figure 18. Overlay structure for link 14 on the IBM 7094/7040 DCS. 

5.2-43g 



NASTRAN - OPERATING SYSTEM INTERFACES 



REFERENCE 



1. Bluett, David E., SUBSYS, A Package for Improving the Efficiency of IBSYS. SHARE 
Distribution Agency, SDA#3369. 



5.2-44 (7/1/70) 



NASTRAN or 



Figure 18. Overlay s 



NASTRAN ON THE IBM SYSTEM/360 OPERATING SYSTEM (0S) 

5.3 NASTRAN ON THE IBM SYSTEM/350 OPERATING SYSTEM (0S) 

5.3.1 Introduction 

NASTRAN operates as a standard, single step job on the IBM Syi.teni/360 class of computers 
under Operating System (0S). NASTRAN is created as a Partitioned Data Set (PDS) with each 
data set member containing the structure and content of a NASTRAN link. One additional member, 
unique to the 360 NASTRAN configuration and residing in memory at all times, controls the 
loading of all other links and the necessary inter-link communication. This additional member, 
referred to as the Super-link, contains the FORTRAN 1/0' routines and the (?S macros necessary 
to load and execute the subordinate functional links (NASTRAN links). 

Within each functional link, a 360 dependent control routine contains the entry point 
for the Super-link call, the corresponding call to the proper XSEMi subroutine, plus the 
transfer points for F0RTRAN 1/0, SEARCH and EXIT. This control routine is identical within 
each link with the exception of its entry point name and its XSEMi call which incorporates 
the link number (e.g., for link 6, the control routine entry point will be LINKNS06, and the 
XSEMi call will be CALL XSEM6). The 0S PDS member name for the Super-link is "NASTRAN"; 
the member names for the functional links are the same as the control routine entry ooints 
(i.e., LINKNSOl, LINKNS02, etc.). 

To operate the NASTRAN system, the PDS containing the link members is attached to 0S 
by a J0BLIB control statement. Execution is initiated through an // EXEC PGM=NASTRAN job 
control statement (If the NASTRAN procedure is in PR0CL1B, only // EXEC NASTRAN is required. 
See section 5,3.5). This job control statement causes the member named NASTRAN (the Super-link) 
to be loaded and entered. The Super-link £ilways calls LINKNSOl (the Preface link) first. From 
this point on, the link execution sequence is determined by SEARCH calls from the operating 
functional link which returns control to the Super-link asking for another functional link. This 
sequence continues until a call to EXIT from within an operating link terminates NASTRAN and 
returns control to 0S. The downward calls from the Super-link to the function link members are 
accomplished via the 0S LINK macro-instruction. All intra-link calls are accomplished via standard 
F0RTRAN call statements within the XSEMi subroutine. 



5.3-1 



NASTRAN - OPERATING SYSTEM INTERFACES 

5.3.2 Input/Output 

All NASTRAN 1/(3 is performed through normal FORTRAN 1/0 statements. Hard copy/printed 
output is generated by formatted output statements to F0RTRAN logical unit 6 (DDNAME=FT06F001 ). 
This output may be routed as desired although it normally appears as a system output (SYS0UT) 
class. Data card input is read by formatted input statements, a card (record) at a time, 
from FjJRTRAN logical unit 5 (DDNAME=FT05F001 ) . Again, the input source may be designated 
as desired although it normally appears as the system input (SYSIN) unit. 

All functional module 1/0 is performed by calls to the various GIN0 routines which in 
turn perform 1/0 via normal F0RTRAN 1/0 statements. GIN0 blocks the data and generates 
standard F0RTRAN unformatted blocked reads, writes, backspaces, etc. The number of files 
available to GIN0 is a function of the number of data definition (DD) cards within the NASTRAN 
job containing acceptable F0RTRAN DDNAMEs (FTxxFOOl). These DDNAMEs should designate only 
the first file (FOOl) even though GIN0 may provide internal multi-file capability. 

Since GIN0 accesses the F0RTRAN units through the NASTRAN Executive tables XFIAT and 
FIAT, the GNFIAT (Generate FIAT) subroutine must interpret the available DD cards and place 
appropriate entries in these tables. GNFIAT extracts the task 1/0 table (TI0T) address from 
0S through the EXTRACT macro. The TI0T contains pointers to the DD cards for the NASTRAN 
job. The DD cards are scanned for acceptable F0RTRAN DDNAMEs. Any DDNAME containing a unit 
number between 8 and 75 inclusive will be placed in the XFIAT/FIAT table (if FTxxFOOl is the 
DDNAME, XX is the unit number). As each unit number is stored, a check of the device type 
code determines whether the XFIAT/FIAT magnetic tape flag should be set. 

The SGIN0 (Special GIN0) plotter output routines within the S/360 NASTRAN system function 
independently of other 1/0. Unique DD cards within the Execution Deck Setup (see section 
5.3.5) describe the required output tape file formats. Two separate plotter files may be 
generated, one on F0RTRAN unit 13 and the other on unit 14. 

5.3.3 Link Switching 

NASTRAN link switching on the 360 is performed by the Super-link and directed by the 
SEARCH entry within the control routine, LINKNSi , i = 01 , 02 13. When the XSEMi sub- 
routine within an operating functional link determines that the next module to be operated 



5.3-2 



NASTRAN ON THE IBM SYSTEM/360 OPERATING SYSTEM (0S) 



resides in a link other than its own, the required link is requested through a call to SEARCH. 
The SEARCH call carries an argument naming the link requested. SEARCH branches back to the 
Super-link with the new link name. The Super-link executes the LINK macro to load the proper 
member and transfer control into this new NASTRAN link. Only one functional link at a time 
will occupy the 360 memory below the Super-link. Since the functional links are individual 
members of the NASTRAN Partitioned Data Set, the number of links is essentially onen ended. 

5.3.4 Overlay Considerations and Open Core Implementation 

Each NASTRAN functional link is created by the 0S Linkage Editor during the generation 
(SUBSYS) procedure (see section 5.3.6). Each link contains a zero level or root segment and 
the series of overlay segments necessary to NASTRAN operating logic. The special named 
common blocks which define the beginning of various open core areas are placed at their 
required location by linkage editor INSERT directives. An 0S overlay tree functions by auto- 
matically loading all segments in the branch between the calling segment and the called segment. 
Local F0RTRAN variables and common blocks residing within segments are not cleared at load time. 

Several NASTRAN links contain a special type origin for the overlay tree. This origin 
is created by declaring a particular segment boundary to be at a Region Boundary. This region 
boundary automatically begins at the end of the longest branch in the previous region. Since 
many links contain a series of small functional module drivers of different lengths followed 
by a structure of matrix routines used by these drivers, a region boundary is usually utilized 
following the drivers. The following sketch illustrates a link structure with regions. 



T 

Region A 

1 " 

Region Boundary 

I 

Region B_ 

r 











1 A 












2 A 




3 A 




4 A 




7 A 








5 A 




6 A 








/0C1/ 
















1 B 








2 B 




3 B 










4 B 




5 B 




















/HOi/ 







Figure 1. A tree diagram for a NASTRAN link on the IBM 360 



5.3-3 



NASTRAN - OPERATING SYSTEM INTERFACES 

Note that since segment IB was requested to be begun at a region boundary, the 0S Linkage 
Editor placed its origin following the longest segment (7A) of the previous region. 

Special caution must be exercised when operating within open core under a region 
structure. Operations within each region are independent of other regions. Thus, if a branch 
of segments within region B, say IB and 3B, is in core because of previous calls, a call from 
region A to region B, say 5B, will not reload segments IB and 3B. Therefore, vf an open 
core area starting at 0C1/ were utilized, some of the programs within region B could be 
destroyed without the 0S loader's knowledge. Because of this possibility, all NASTRAN open 
core origins lie within a lower level region. Therefore open core starting areas such as 
/0C1/ are not used in S/360 NASTRAN overlay structures. 

Because flASTRAN must operate on most models of System/360 with a variety of memory sizes and 
0S operating modes, a flexible method of utilizing all memory available to the job is incorporated. 
In both primary and multi -programmed environments, the 0S loader requests storage from the core 
memory available to the job through the 0S GETMAIN macro. 0S storage-management routines make 
sufficient core available, and the link is placed in memory. Core memory outside of that requested 
for the link is storage protected by the 0S system. An attempt to store into these protected areas 
causes an interrupt and job termination. The NASTRAN open core concept requires use of those 
areas that are available but protected (i.e., the area between the link and the region boundary). 
To remove this protected status, the NASTRAN initialization program within each functional link 
issues a conditional GETMAIN for all remaining memory within the job region. The return from 
this GETMAIN specifies the origin and the size of the block of core memory acquired. A small 
portion of this block is returned (via the FREEMAIN macro) to 03 for use as F0RTRAN 1/0 buffers and 
for other 0S functions. The remainder of this memory is made available to NASTRAN by adjusting 
the upper core address used by the NASTRAN C0RSZ function. All NASTRAN modules may thus utilize 
the maximum core memory provided to the job. 

5.3.5 Execution Deck Setup 

Running or executing the NASTRAN system on a System/360 computer once the generation 
procedure (see section 5.3.6) is complete requires some basic knowledge of the type of 
structural problem being solved and the type of output requested. In addition, the hardware 
configuration and capacities should be known in order to most adequately match the problem 
being solved to the computer. 

5.3-4 



NASTRAN ON THE IBM SYSTEM/360 OPERATING SYSTEM (0S) 

The following procedure should provide the basic Job Control Language (JCL) necessary for all 
NASTRAN runs. 

Table 1. Basic Job Control Language (JCL) for All NASTRAM Runs. 



1 //nPhAUI. I PKOC P« n^>T= A, SPl = L, SP? = S, BLK l = 7?()'.,KLK^ = 7?0H, VC r=l 

2 //^iS i-VhC PG'4 = MASTHAN 

4 //FTOAF-Df)! fin SYS.^llT:--f,PRI^iT 

5 // i-Tn-jFoni no nnMAMh = SYS i n 

6 //t-T()(SF()ni fif! SYSiiii r = r.pKiMT. spAr,'- = ( r.YL .(?,?) ) 

7 //p TO ffon} fii) sYsrin r = R 

8 / /HTnp.pnni nn dm it= ( sys^a , r vr T i . sPAr.p= (c yl - ( r. spi ,'; sh? ) ) . vni ^( , , ,c. vc t ) ,x 

// PiCi^= (RPCFM = V.LPPr,L = r, KLK 1 .RLKS U.E = f, HLK? .hlJP!-l)=l ,()PN-^'i) 

9 //[- TDQFf.'O! no ooN&MF = np rp 

10 //'^TinPOOl on OONA''E=NPTP 

11 //PTllFOOl iMi OMf r=SYSnA, SPAr.F= ( TKK. 1 ) , LAHFI. = ( ,BLP ) , 

// nr,R= ( Rt-r.FM = v'.|. PFr,L = C. HLKl .BI.KS IZF = f>Pl K? .BMFMIJ = 1 ,(1FN=? ) 

12 //PT1?F001 on tJM I r=SYSnA, SPACF= ( fKK. 1 ) , LARPI.= ( ,KLP ) . 

// nCF<= (KFC Fp = V,LkFr,F = r,HLK 1 ,PLKS [ZE = (;HLK2 .HnFlM)=l .OFN = ^ ) 

13 //FTi'^Fnoi no nf)i-^AMP^pLTi 

13A //FT 1 '^fOO? 01' SPACF= ( VKK , 1) . LABFL= 102 , RLP) , VnLliMF = kFF=*.Fl 1 3F0ni , X 

/ / nc P= ( R^^, FN'=n, HLKSI /F = 740(), KOI-i^iO= 1 ,nFM= I ,TR1CH=F ) 

13B //FT1'-(F()1 S no SPACF= ( TRK. 1) , LA'<FL= ( 15.BLP ) , X 

// V0LOPt = RFF = *.FTl 3F()ni ,OCB=- .F 1 1 '-!F00? 

14 //FTlAFOOl n[l nnNAMF = Pll7 

15 //FTlbFOril no UNT T = .SYSnA .SPACF= ( TRK. 1 ) , OCR = - .F 1 08F 0(n . L A B FL = ( . BL P ) 

20 //FT?nF001 OMIT= ( SYSOA .r VCT ) . SPAC F= (C YL, ( f. SPl .F, SP;' ) 1 . VOL = I , , , F, VC T ) , X 
// Or,B= ( K'-rj M = v. Lkrr,|_=F. hl.K 1 ,BLKS I/F = f.HI K7 .BOl-Fi(J=l ) 

//Fi ?iFooi no I in I T:= I SYSOA.Fo/r.T ) , spACF= (CYi. , ( F, SP1 ,>, SP2 ) ) . voL = ( , , ,F, vr; r ) ,x 

// r;r,B = « . F 1 ^npnoi . SFP= ( FT?f)F001 ) 

/ /'-T ??hon] nn on rT= ( sysoa. f vct) , spAr,F= ( r. yl . ( ;. spi ,f sp? ) ) .vol = ( , , .r, vr.T ) ,x 

// OC,B = « , rT?0Fn0 1 , SrF= ( F i;^0FOni , ft;*! FOOl ) 

//FT?^F()01 00 l)MrT= (^YSOA.f, vr.T) ,^PACF=(CYL. (f.SPl ,f, SP? 1 ) ,VllF = ( , , ,f,VCr ) ,X 

/ ' Or,B = -. rl ;^(lFnni .,SFP= ( FT?0F()()1 , FT21 FOOl .FI ?2^()()1 ) 

50 //FTMiFiini oFi ||^J!T= c^ ysoa.f, vc r ) , spacf= ( c yl, ( F. ^. Pl .f. sp? ) ) , vi)l = ( , , ,r vr, i ) ,x 

// nr,H = ~.FT?OFnni ,SFP= ( F I ^BFOOl ,FT4Sh00n 

SP //SMAPSHIIT on SYSni!T = FPRTWT 

NT //NPTH nn UN 1 T = sysoa , sPAr,F= ( r, yl , ( i . ? ) ) , ocB=>;-- .F i oKFoni ,l abfl = ( ,blp ) 

OT //IIPTP 00 ON! T = .SYSOA, SPACF= ( TRK, 1 1 ,OCB = ':: .FTOBFOOl ,LABFL = ( ,BLP ) 

PI //PLTl no UMI T = SYSOA .SPACF= ( TRK, ] ) ,LAHFL=( 01 ,BLP ) .DCB = *.FT1 3FOn2 

P2 //PIT? on l)NIT = SYSOA. SPAr,F= ( TRK, I ) ,LABFL = ( ,RLP ) . X 

// OCH= I RFr.FM = 0,BLKS 1 /'E = ?^nO,BUFMO=l ,0EM=1 ) 

This deck is presented in a form so that it may be added to an installation's Procedure 
Library (PR0CLIB) to permit easy recall, modification, and reuse of this NASTRAN JCL. Although 
the remaining discussion and examples will assume the preceding deck to be a catalogued procedure, 
similar JCL may, of course, be used within the job stream with each problem submission. 

Each card or group of cards within the NASTRAN procedure is discussed by item below. The 
item numbers match those along the left margin of the preceding deck listing. 



5.3-5 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

ITEM 

1. Provides default value for various symbolic parejneters within the procedure. PRINT=A, 
defines the output printer class as A. SP1=1 defines the primary space allocation request 
as 1 cylinder. SP2=5 defines the secondary space allocation request as 5 cylinders. 
BLK1=7204 defines the logical record length as 7204 bytes. BLK2=7208 defines the block 
size as 7208 bytes. 

2. Loads member NASTRAN from NSTNLM0D data set attached to 0S by J0BLIB. 

4. Defines unit 4 for C0NMSG (section 3.3.12) output to SYS0UT. 

5. Defines unit 5 as the standard system input unit. 

6. Defines unit 6 as the standard system output unit to SYS0LiT. Note the SPACE item 
enlarges the spooling space for system output. 

7. Defines unit 7 as the standard system punch unit. NASTRAN restart decks are output to 
this unit. 

8. Defines unit 8 as a standard GIN0 file. This unit will be placed in Executive table 
XFIAT as the Data Pool (P00L) File. 

9. Defines unit 9 to contain the Old Problem Tape (0PTP), if one is to exist for this run. 
Also points to DDNAME 0PTP DO card for remaining definitions (see item 0T). 

10. Defines unit 10 to contain the New Problem Tape (NPTP), if one is to exist for this run. 
Also points to DDNAME NPTP DD card for remaining definitions (see item NT). 

11. Designates unit 11 for the User Master File (UKF). If this function is desired, this 
DD card must be overridden. 

12. Designates unit 12 for the New User Master File (NUMF). If this function is desired, 
this DD card must be overridden. 

13. Defines unit 13 to contain PLTl (EAI 3500) plotter output. Also points to DDNAME PLTl DD 
card for remaining definitions. 

13A through 13B. Defines files 2 through 15 (note dot (•) for missing but similar cards) of 
unit 13 to contain additional plots on the PLTl plot tape. Some plotters (e.g., the EAI 3500) 
require file marks between plots; 0S data management routines require a new DD card for each 

5.3-6 (12-1-69) 



NASTRAN ON THE IBM SYSTEM/ 360 OPERATING SYSTEM (0S) 

file even though they reside on the same unit. The DCB parameter sets density at 556 BPI 
and even parity as required by the plotter hardware. If more than 15 plots are to be 
generated on PLTl, additional DD cards must be provided. 

14. Defines unit 14 to contain PLT2 {SC4020) plotter output. Also points to DDNAME PLT2 DD 
card for remaining definitions. 

15. Designates unit 15 as an auxiliary input unit. If this function is desired, this DD 
card must be overridden. 

Units 8 through 15 reside in Executive table XFIAT and with the exception of unit 8 (P00L) 
perform no NASTRAN function unless their UNIT parameters are altered to a physical tape by a 
DD override. 

20 through 50. Defines units 20 through 50 as general GIN0 files. These units are placed in 
the FIAT Executive table and are thus available for assignment by the Executive Segment File 
Allocator (XSFA) module. The data sets generated by these DD cards are requested to be 
separated from each other and to extend over multiple volumes if possible. The space size 
requests are controlled by the default values in the PR0C card or some execution time override. 

SP. Defines the system output unit for any error dumps and backtraces produced by a NASTRAN 
run. (CALL PDUMP). 

NT. Defines the attributes of the New Problem Tape (NPTP) attached to unit 10 (see item 10), 
and provides a convenient place for a UNIT parameter override when the Problem Tape is used. 

0T. Defines the attributes of the Old Problem Tape (0PTP) attached to unit 9 (see item 9), 
and provides a convenient place for a UNIT parameter override when the Problem Tape is used. 

PI. Defines the attributes of the PLTl plot tape (for the EAI 3500 plotter) attached to unit 

13 (see item 13) and provides a convenient place for a UNIT parameter override when this 
plotter output is requested. The DCB parameter sets density for 556 BPI and even parity 
required by the plotter hardware. 

P2, Defines the attributes of the PLT2 plot tape (for the SC 4020 plotter) attached to unit 

14 (see item 14) and provides a convenient place for a UNIT parameter override when this 
plotter output is requested. The DCB sets density for 556 BPI required by the plotter 



5.3-7 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

hardware. 

Assuming that the above NASTRAN procedure is in the installation's PR0CLIB, various 
examples of NASTRAN runs follow: 

RUN A. Cold start, no UMF, no check pointing, no plotting, large memory available, 
2314 disk packs. 

//NASA JOB ( 5048321 ,013,1^-01) .A. USER. M3GLEVEL=i ,REGION = 1000i<i 

//JObLIB DD USI\1AME = NSTNLM0D,D!SP = SHH: 
//PI EXEC NASTRAN 

//NS.SYSIN OD * 

• 

/♦ 
RUN B. Restart, no checkpointing, SC 4020 plots, small memory available, 2311 disk oacks. 



//NASA JOB ( b04832i ,C13. 14-01 ) .A. USER, MSt.LEVtL=l ,RtbION = 2bOK 

//JObLIB 00 DSNAME=NSTNLMUD.DISP=SHR 

//P2 EXEC NASTRAN. SP2 = l.BLKl = 3604,BLr;2 = 3608 

//NS.OPTP OD UNIT=2400.V0LUME=SER=T324 

//NS.PLT2 DD UNIT=24U0,VOLUME=SER=T621 

//NS.SYSIN DD * 

NASTRAN BUFFSIZE=9a3 



/♦ 



RUN C. Cold start, using UMF, checkpointing, EAI 3500 plots, medium memory available, 
2314 disk packs. 

//NASA JOB (5048321.013,14-01) , A. USER,. •1SGLEVEL=1,REGI0N = 500K 

//JOBLIB DD DSNAME=NSTNLMOD.DISP=SHR 

//P3 EXEC NASTRAN 

//NS.FTllFOul UU UNI T=2400,V0LUME=SEK=T491 

//NS.NPTP DU UNI 1 =24OO»VOLUK,E = SER = T320 

//NS.PLTi DD UNIT=24U0,V0LUME=StR=T822 

//NS.SYSIN DD « 

• 

/♦ 
Note: Units designated for plot tapes are always 7 track, therefore the installations 

SYSGEN'ed mnemonic for a 7 track unit should be used following the UNIT = keyword 
(e.g.. 2400-2, 2400-7, 2400-7T, etc.). Units designated for any remaining tapes 
(PROBLEM TAPES, UMF, etc.) may be 7 or 9 track as the user desires and thus the 
appropriate unit mnemonic should be used. 



NASTRAN ON THE IBM SYSTEM/350 OPERATING SYSTEM (0S) 

The above examples assume that the tapes used do not possess meaningful labels. The 
parameter (Tijk) within the V0LUME=SER=Ti.jk is used only to identify to the computer 
operator the physical reel of tape to be mounted. Should it be desired to use 0S standard 
tape labeling, the LABEL keyword must be overridden to SL and a DSNAME keyword added. The 
tape labels and DSNAMES used should be unique for each physical reel. 

NASTRAN data decks (Executive Control Deck, Case Control Deck, Bulk Data Deck) must be 
added to the above set-ups following the //NS.SYSIN DD * card. Note that Run B contains a 
special data card, NASTRAN, (see section 6.3.1) to reduce the GIN0 buffer size to a value 

consistent with the storage blocks on the 2311 disk pack. The ratio between BUFFSIZE, BLKl and 
BLK2 is determined as follows: 1) a BUFFSIZE corresponding to the desired physical record size 
on the file storage device is chosen (normally a full track on disk). BUFFSIZE is stated in words 
(4 bytes/word); 2) BLK2 is then set to 4 bytes less than BLKSIZE and BLKl is set to 4 bytes less 
than BLK2. BLK2 and BLKl are stated in bytes . 

5.3.6 Generation of the NASTRAN Executable System (SUBSYSING ) 

The following card listing is a sample subset of the Job Control Language (JCL) and 
Linkage Editor control statements necessary to produce a functional link of the NASTRAN 
Executable System on the System 360. A dot (.) on a line indicates missing cards similar to those 
preceding. 



//LKED EXEC PGM= I bWL .PARM= • MAP ,l I ST .OVLY .DC .LET .S I ZE= ( lOOOK . lOOK ) ' 

//SYSPRINT DD SYSOUT=A 

//SYSUTl DD UNIT=SYSDA,SPACE=(CYL» ( 10.10) ) 

//SYSLIB DD DSNAME = SYS1.F0RTLIE).DISP = SHR 

//LIB DD DSNAME=P2L0AD.DISP=SHR 

//SYSLMOD DD 0SNAME=N5 INLMOD ,D I SP=OLD 

//SYSLIN DD » 

INCLUDE LIB( LINICNS04) 

INCLUDE LIB(ROOTSEG) 

• 

CHANGE NTRAN(RETURN) 
INCLUDE LIB(ENDSYS) 
INCLUDE LIB(GP^) 

• 

INCLUDE LIB(LOOP) 
INCLUDE LIB(EJDUM2) 
OVERLAY A 
INSERT MCEl 
INSERT MCE2 
OVERLAY A 
INSERT SMPl 



5.3-9 



NASTRAN - OPERATING SYSTEM INTERFACES 

• 

OVERLAY MATRX(RtGION) 

INSERT 6MMATD 

INSERT SMA3A 

INSERT INVERD 

• 

OVERLAY OEND(REGION) 
INSERT EJDUM2 
ENTRY LIN<NS04 
NAME LINKNS04(R) 
/♦ 

The above statements assume that all of the necessary NASTRAN subroutines have been 
previously compiled and that their object modules ex^^c as members of the Partitioned Data 
Set P2L0AD. Also, the output Partitioned Data Set (NSTNLM0D) for the complete executable 
system must be allocated and available. Note that al i ucilq aets listed in the JCL are assumed 
to be catalogued. The Linkage Editor control statements (i.e., those following SYSLIN) first 
select the necessary object modules from the P2L0AD library through the INCLUDE cards. Any 
cross references may be altered at the time by a CHANGE card. Note that the ENDSYS subroutine 
reference to NTRAN (a Univac 1108 dependent program) is altered to a RETURN. Following all 
necessary INCLUDES, the overlay is structured through OVERLAY and INSERT cards. The 0VERLAY 
card defines the beginning of a new segment, while the INSERT card places object modules within 
that segment. ENTRY and NAME cards are required to generate the proper entry address and data 
set member name for the functional link. A set of cards similar to this sample is required to 
generate each link member of the NSTNLM0D data set. These cards are included within the NASTRAN 
delivery package. After the creation of all necessary NASTRAN links, the NSTNLM0D data set will 
contain the complete Executable System. This data set may then be attached to (JS as a 
J0BLIB and the NASTRAN system executed {see section 5.3.5). 

5.3.7 Machine Dependent Routines 

The following utility routines necessary to NASTRAN operation must, by their nature, be 
implemented in a machine dependent manner. They are written in S/360 Assembly Language. 

5.3.7.1 Clocks 

An elapsed real (wall clock) time is available within the 360 NASTRAN system through a 
call to routine WHEN. A call to WHEN executes the 0S TIME macro, which returns time in 26 u 
sec. increments from midnight. The initial call saves an initial time which is then used to 
produce elapsed times. WHEN returns time in integer seconds from the initial call. 



5.3-10 



NASTRAN ON THE IBM SYSTEM/360 OPERATING SYSTEM (0S) 

A processor or task time is available within the 360 NASTRAN through a call to routine 
N0W. The NS3W routine initializes and uses the interval timer on S/360 configurations with 
the timer option. N0W sets and interrogates the interval timer through the STIMER and TTIMER 
0S macros. The STIMER macro is executed with the TASK option which specifies that the timer 
is to operate only when the task is active. This has the effect of measuring only the central 
processor operating time for the particular job. N0W returns time in integer seconds from 
the initial call . 

5.3.7.2 DUMP and PDUMP 

A F0RTRAN CALL PDUMP causes a subordinate call to the 0S SNAP macro to be executed. This 
subordinate call (to PDUMPX) contains a parameter designating whether the SNAP macro is to 
produce only a trace table or a complete Problem Program memory dump. A CALL PDUMP will return 
control to NASTRAN at the statement following the call. PDUMP outputs via DDNAME SNAPSHOT. 

5.3.7.3 Date 

The current date is available for NASTRAN problem identification and titling through a 
call to routine TDATE. A call to TDATE executes the 0S TIME macro which returns the Julian 
date. This date is converted to month, day, and year by TDATE. TDATE returns the date in a 
three word integer array as month, day, year, e.g., 3,27,69. 

5.3.7.4 On-Line Messages 

Eight-character messages may be printed on the operator console from a NASTRAN problem 
through a call to routine TYPWRT. TYPWRT moves the eight characters from the calling sequence 
to the message section of an 0S WT0 macro and executes the macro. 

5.3.8 Special Error Codes from NASTRAN on the System/360 

One of the following two types of error codes will accompany any abnormal end (ABEND) 
output from NASTRAN operating under 05 on the IBM System/360: 

1. SYSTEM=XXX 

where XXX is an 0S code described in the IBM System Reference Library (SRL), Form C28-6631, 

titled IBM System/360 Operating System Messages and Codes. 



5.3-11 



NASTRAN - OPERATING SYSTEM INTERFACES 

2. USER=YY 

where YY is a NASTRAN code described as: 

Code Explanation 

1 A link name has been requested by SEARCH (3.3.6) which is beyond the range of 
those available. See the assembly listing for the link names available. 

2 Insufficient DD cards have been provided to the NASTRAN job to fill the XFIAT 
(2.4.1.1) and FIAT (2.4.1.2) tables with files to the level required by the MAX 0PEN 

parameter in /SYSTEM/ (2.4.1.8), 

3 Insufficient core memory has been provided beyond the NASTRAN link to provide 
space for the FORTRAN I/jJ buffers of all MAX (JPEN files. 

4 A core memory discontinuity exists between the end of the NASTRAN link and the 
beginning of open core found by the GETMAIN macro (see 5.3.4). 

12 A NASTRAN subroutine issued a "CALL DUMP". See the system trace-back for the 
subroutine name. 



5.3-12 



NASTRAN ON THE UN I VAC 1108 (EXEC 8) 

5.4 NASTRAN ON THE UNIVAC 1108 (EXEC 8) 

5.4.1 Introduction 

The purpose of this section is to describe the unique operating features of NASTRAN on 
the Univac 1108 computer under the Exec 8 operating system. 

The choice of EXEC 8 over EXEC II as the 1108 Executive System was made due to the added 
flexibility obtainable in the control language. The size and complexity of the NASTRAN system 
necessitates the use of a system allowing open ended expansion. 

Much of the final checkout and validation of NASTRAN was done under EXEC 8. The use of 
catalogued files for the source, object, and absolute program files simplified the task of 
modifying and updating the NASTRAN system. 

As can be seen in the following discussions, good advantage of the capabilities of EXEC 8 
has been taken. 

5.4.2 Input/Output 

The machine dependent 1/(3 routines in NASTRAN can be classified into three categories: 
1) obtaining the logical files, 2} performing the actual 1/0 (other than plot output), and 3) 
generating the plot tapes. 

GNFIAT is the subroutine responsible for identifying the logical files available for use 
by NASTRAN. For the Univac 1108, it is written in F0RTRAN. Its functional description can be 
found in section 3. Under EXEC 8, GNFIAT operates In conjunction with the system routine NTAB$. 
NTAB$ was reassembled for NASTRAN to allow access to logical units 1-40. CorresDondingly a 
table is generated in GNFIAT to indicate the status of each of these units. The status code 
of 1 implies the unit is unconditionally available for insertion into the FIAT Executive table. 
A code of 2 means the unit can be used if it is not set up as a tape. A status code of 3 means 
the unit is unavailable. GNFIAT searches this table and inserts the available logical units 
into the FIAT. 

In addition to the expanded NTAB$, NTRAN$ was assembled with the number of packets increased 
to 30. This was necessary due to the number of files used in NASTRAN at any one time. 

The actual 1/0 on the Univac 1108 is controlled through the blocked 1/0 package, consisting of 
GIN0 and its associated routines. The physical 1/0 directives are restricted to GIN0I0. 

5.4-1 



NASTRAN - OPERATING SYSTEM INTERFACES 

GIN0I0 has branches on machine type (360, DCS or 1108) to transfer to the proper 1/0 instructions 
for a given machine. Under EXEC 8, NTRAN is used exclusively for 1/0. The reader should consult 
the subroutine descriptions for GIN0 and GIN0I0 in section 3 for more information. 

The final 1/0 dependent routine is SGIN0, whose responsibility is to generate the un- 
formatted BCD and binary tapes for the plotters. The restriction in SGIN0 is that the output 
records must be free of any NASTRAN or system control words. NTRAN satisfies these requirements 
and is used to perform the 1/0. 

5.4.3 Link Switching 

A link on the Univac 1108 consists of a main program, MAINi, that calls subroutine XSEMi which 
in turn has calls to the subroutines corresponding to the modules residing in that link. Thus, 
a link is, in itself, a complete executable program. 

The problem of link switching reduces to the problem of selectively controlling the 
execution of the various programs (links). This is accomplished under EXEC 8 by virtue of the 
TEST control card and by the executive request (ER) SETC$. 

The option to either execute or skip a link is achieved by the following two system 
control cards: 

@TEST TNE/i/T3 

PXQT NASTRAN. LINKi 

The right third of the condition word which is tested by the TEST command is set by an ER to 
SET$. By setting this third of the word to the value i, LINKi will be executed. If the value 
of the word is not i, the XQT instruction will be skipped. 

A packet of these control cards consisting of TEST and XQT cards for each link gives the 
user the flexibility he desires. However, due to the capability of looping in NASTRAN, many 
of these packets are usually put on a catalogued file such that one ADD card can redirect the 
control card stream to the proper file. 

The above description gives the external controls required for link switching. Internally, 
NASTRAN uses subroutines ENDSYS and SEARCH to direct the link switch. Their functional des- 
criptions can be found in section 3. ENDSYS is used mainly for saving information required 
across links. SEARCH, however, is the routine which controls the link switch. Under EXEC 8, 



5.4-2 



NASTRAN ON THE UNIVAC 1108 (EXEC 8) 

this consists simply of setting the condition word to the value of the desired link, and terminat- 
ing the execution of the current link. 

Upon initiation of a new link, BGNSYS is called to restore previous information. An addi- 
tional function of BGNSYS on the Univac 1108, controlled by a branch on machine type, is to 
restore drum pointers for all files off the load point. Since GIN0 maintains a table of file 
positions, this table can be used to upaate the system drum pointers. 

5.4.4 Overlay Considerations and Implementation of Open Core 

The complex nature of the NASTRAN overlay picture and the peculiarities of the EXEC 8 loader 
pose some special problems on the 1108. The loader under EXEC 8 is a "block" or "segment" 
loader. A segment is loaded only when a subroutine within that segment is called. Also, when 
a segment is loaded, local data and common blocks are set to zero. 

The implications of these features of the loader can be seen in the following overlay 
example, given in Table 1 and Figure 1. If common block /XX/ is initialized by the Block Data 
subprogram E, and subroutine A calls D directly, then D cannot reference the data in /XX/ since 
that segment has not been loaded. Also, if subroutine A stores data in /YY/. and subsequently 
calls subroutine C, /YY/ will be reset to zero as it is loaded. 



5.4-3 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

Table 1. Example of Input to the MAP Processor for a UASTRAN Overlay on the Univac 1108. 
@MAP,1 SAMPLE 

SEG AA 



Segment C0RE- 



/DFC0R/ 
Segment CC- 



IN 


A 


SEG 


BB* 


IN 


B.XX 


SEG 


CC* 


IN 


C.YY 


SEG 


DD*,CC 


IN 


D 


SEG 


CORE*.BB 


IN 


DEFC0R,DFC0R 





Subroutine A 


■* — Segment AA 


DEFCIilR 




Subroutine B 
Block Data E 



■Segment 



/XX/ 



Subroutine C 


Segment DD »• 


Subroutine D 



/YY/ 



Figure 1, Example of NASTRAN overlay on the Univac 1108 



5.4-4 



NASTRAN ON THE UNIVAC 1108 (EXEC 8) 

As seen by the above example, some common blocks will have to be repositioned higher 
(in lower order core) in the overlay on the Univac 1108 than on the IBM 7094 and IBM 360 to protect 
NASTRAN from the loader. 

The implementation of open core on the Univac 1108 consists of defining a segnrent of suffi- 
cient length to reserve core. This is seen in Figure 1 as segment C0RE. The F0RTRAN array in 
common block /DFC0R/ is dimensioned as large as possible. The last location of this common 
block is defined as the end of open core. 

5.4.5 Execution Deck Setup 

The following table gives a typical deck setup for NASTRAN on the 1108. 



5.4-5 



NASTRAN - OPERATING SYSTEM INTERFACES 



Table 2. Execution Deck Setup for NASTRAN on the Univac 1108 



@RUN 




©ASG.T 


3,F7//200 


@AS6,T 


4.F///200 


(aASG.T 


7,F///200 


eASG.T 


8,F///200 


@ASG,T 


9.F///200 


@ASGJ 


10,F///200 


@ASG.T 


ll,F///200 


(3ASG,T 


12,F///200 


@ASG.T 


13,F///200 


@ASG,T 


14,F///200 



. 0PTP 

. NPTP 

. UMF 

. NUMF 

. PLTl 

. PLT2 



001 

002 

003 

004 

005 

006 

007 

008 

009 

010 

Oil 



@ASG,T 35,F///200 

PHDG.N 

0XQT NASTRAN. LINK1 

NASTRAN DATA DECKS (Executive Control Deck, Case Control Deck, 

Bulk Data Deck) 
@TEST TNE/1/T3 

@XQT NASTRAN. L I NK1 

@TEST TNE/2/T3 

@XqT NASTRAN.LINK2 



032 
033 
034 

035 
036 
037 
038 



@TEST TNE/14/T3 
@XQT NASTRAN. LINKl 2 

@TEST TNE/17/S6 
@JUMP END 
@END:PMD,EB 



047 
048 
049 
050 
051 



5.4-6 



NASTRAN ON THE UNIVAC 1108 (EXEC 8) 

The following comments explain particular cards or groups of cards: 

1. Card 001 consists of the standard RUN card required by the itistallation. 

2. Cards 002-032 assign the logical files to Fastran or some other auxiliary storage 
device. These assign cards allow a maximum of 200 tracks or approximately 350,000 
words for each file. This assignment can vary per run or per device used. 

3. Cards 004-010 have a dual usage and can be used as user tapes. If a checkpoint 
is required then card 006 must be replaced with 

@ASG,T 9,T,TAPE# 

4. Depending upon the devices available, the assign cards can reference Fastran, 
drum, disk or tape. 

5. Card 033 turns off the standard system heading. 

6. Card 034 initiates execution of LINK!. 

7. The NASTRAN data decks are inserted between cards 034 and 035. 

8. Cards 035 to 050 constitute a packet of NASTRAN control cards. Many of these 
packets may be required for one run. 

9. For user convenience, cards 002-034 and a series of packets each consisting of cards 
035-050 can be catalogued. The execution deck setup can then consist of: 

@RUN 

@ADD ASGCRDS. 

NASTRAN DATA DECKS 

@ADD C0NTR(3L. 

where ASGCRDS and C0NTR0L are catalogued files. 

5.4.6 Generation of the NASTRAN Executable System (Subsysinq ) 

The initial generation of the NASTRAN executables or the modifying of a given link is 
easily accomplished. Since each link is considered as a separate program, each link can be 
processed independently of any other link. Assuming the source and object decks are catalogued, 
a link of NASTRAN can be created by 



5.4-7 



NASTRAN - OPERATING SYSTEM INTERFACES 

@MAP,S SPU.LINKi, NASTRAN. LINKi. 

The symbolic MAP deck for LINKi resides as an element of the catalogued source file, S0U. 
The absolute element is stored in the catalogued file NASTRAN. A LIB card in the symbolic 
MAP directs the processor to the relocatable elements. 

5.4.7 Machine Dependent Routines 

The routines discussed in this section consist of those programs unique to the Univac 1108 
or those which are implemented differently from other machines. 

1. MAINi 

MAINi is the main program for LINKi. Its sole function is to call DEFC0R and XSEMi. 

2. DEFC0R 

DEFC0R is responsible for defining a segment long enough to reserve core for NASTRAN. 
The last location of this segment is saved as the end of open core. 

3. MAPFNS 

In addition to the standard functions described in section 3, the following functions 

were added: 

a) SETC(I) - Sets the condition word to I. 

b) XC0RSZ(J) - Saves the address of J as the end of open core. 

c) FACIL(UNIT,ID) - Sets ID = 1 if UNIT is assigned as a tape. 

4. PPDUMP 

PPDUMP provides an entry point for DUMP and PDUMP. When called, a DUMP of the open core 
is given and an error exit is forced if a DIAG 1 card is present in the Executive Control 
Deck. 

5. UTIL 

UTIL provides entry points for the NASTRAN clocks. These clocks return the elaosed CPU 

time in seconds. 



5.4-8 



NASTRAN ON THE CDC 6400/6600 (SCOPF. 3) 

5.5 NASTRAN ON TKE CDC 6400/5600 (SCOPE 3) 

5.5.1 Introduction 

NASTRAN operates as a single job step on the CDC 6400/6600 computers under the SCOPE 3 
Operating System. NASTRAN is created by the Linkage Editor (see section 5.6), a special program 
developed for the CDC 6400/6600 computers to provide compatibility with the other computing sys- 
tems for which NASTRAN has been developed. 

The overlay structure for NASTRAN on the CDC 6400/6600 is somewhat different from the other 
computing systems in that one link. Link 0, remains in core at all times during program execution. 
This link contains subroutines and Executive tables common to all links (e.g., GIN0, PDTRL, FNAME, 
/XXFIAT/, /XFIAT/, /SYSTEM/). Consequently, the primary functions of ENDSYS and BGNSYS (see 
section 3.3.5), which save and restore Executive tables, are not required. Link switching is 
accomplished in a manner similar to the IBM 360 through a CALL LINK. LINK is an entry point in 
the segment loader, which was developed in conjunction with the linkage editor. 

The NASTRAN executable program normally exists as a sequential file on tape, although it may 
exist as an indexed file on disk. The first few records of the file contain an initial load 
program produced by the linkage editor. The remainder of the file is comprised of the NASTRAN 
links (one directory record per link plus one logical record per segment). To initiate the 
NASTRAN program, a control statement such as NASTRAN. is executed. This causes the CDC loader to 
load the initial program load portion of the NASTRAN file and transfer control to XB0(3T (see 
section 5.6.1.1). The XB00T program reads the remainder of the file, writes it on the disk in 
indexed form, reads Link into central memory and transfers control to Link 0. Link receives 
control through a small main program called NASTRAN which in turn calls LinK 1 (the Preface link). 
Execution continues until the problem terminates through a call to PEXIT which in turn calls EXIT. 

5.5.2 Input/Output 

NASTRAN input/output is performed in three ways: (1) card input, printed output, and punched 
output is accomplished through standard F0RTRAN formatted input and output statements; (2) all 
other input/output except plots is accomplished through the GIN0 routines which in turn call 
106600 (see section 5.5.6.4) to perform reads and writes; and (3) plot output is accomplished 
through SGIN0 (see section 3.4.51). 



5.5-1 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

The number of files available to GIN0 is a function of the MAXFILES parameter in the SYSTEM 
common block (see section 2.4.1,8). All NASTRAM files which have not been assigned to tape are 
treated as indexed files on the disk. A master index for each file is permanently maintained in 
central memory near the end of the field length (see Figure 2). The master index contains a disk 
pointer for each subindex record. The subindex records contain disk pointers for each of the 
blocked NASTRAN records. 106600 maintains the position of each file in the common block GIN066. 
Subindex records are read or written at open and close time and during reading or writing when a 
subindex boundary is passed. Actual input/output is accomplished through XI0RTNS (see section 
5.5.6.8), which is a C0MPASS subprogram. XI0RTNS communicates with the SC0PE Operating System 
through calls tc CPC. 

SGIN0 on the CDC 6400/6600 functions independently of other 1/0. Its point of commonality 
with other 1/0 routines is XI0RTNS, which is used to perform the physical writing of data. 

Figure 1 depicts a complete buffer as used by GIN0, 106600 and XI0RTNS. 



5.5-2 (12-1-69) 



NASTRAN ON THE CDC 6400/6600 (SCOPE 3) 



i 



□3 

ca 






+ 

ca 



z: 

1 



GIN0 Control Words 



GIN0 Block 



File Environment Tablf 



Circular Buffer 



Subindex 



See section 3.4.12 



Note: SYSBUP", NBRCBU 
and NBRSUB are 
defined in the 
SYSTEM common 
block (see sec- 
tion 2.4.1.8) 



Figure 1. GINj) buffer on the CDC 6400/6600. 



5.5-3 (12-1-69) 



;iASTRAN - OPERATING SYSTEM INTERFACES 

5.5.3 Layout of Core Storage 

Figure 2 illustrates the layout of core storage on the CDC 6400/6600. 



63c 



76 r 



100c 



FL' 



Field Length 



FL' 



PL' 



Link 



Current Link 



"Open Core" 



Storane for Master Indices 



Communication area 
for SC0PE Operating 
System 



NASTRAN code 



NASTRAN working 
storage 



length = MAXFIL* 

(NBRMST+1) 

(see section 2.4.1.8) 



Figure 2. Layout of core storage on the CDC 6400/6600. 
5.5-4 (12-1-69) 



NASTRAN ON THE CDC 6400/6600 (SCOPE 3) 

The primary function of GNFIAT (see section 3.3.4), which operates in Link 1, is to initialize 

the XFIAT and FIAT Executive tables. As a secondary function, GNFIAT reserves an area at the end 

of core storage for storage of the master index pointers for each file. The length of this 

reserved area is subtracted from the field length for the problem, and the available memory, FL', 

is stored in words 63g and 76g. The length of open core is returned to a calling program by the 

C0RSZ function. C0RSZ subtracts the address passed to it from the contents of word 76o. All 

8 * 

NASTRAN modules may then utilize maximum core storage provided to the job. 

The discussion in section 5.3.4 regarding overlay considerations on the IBM 360 applies 
equally to the CDC 6400/6600. 



5,5-5 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 



5.5.4 Execution Deck Setup 

The following examples illustrate the control statements necessary to execute the NASTRAN 
program once the generation procedure (see section 5.5.5) is complete. The numbers in parentheses 
to the right of some of the control statements refer to notes, which follow the examples. 



Example 



C 
D 
E 
F 



MASTRAN 



tape 

tape 

disk(common) 

disk (common) 

tape 

tape 



Problem Conditions 



Bulk Data 
Input Medium 



cards 

UMF 

cards 

UMF 

0PTP 

0PTP 



Checkpoint 



no 

no 

yes 

yes 

no 

yes 



Restart 



no 

no 

no 

no 

yes 

yes 



DD80 Plot 



no 

no 

yes 

no 

no 

yes 



Example A 

(1) J(3B,p,t,fl. 

N0RFL. 

N(3MAP . 

REQUEST NASTRAN, HI. reel#,Ri3L 

NASTRAN . 

DR0PFIL(NASTRAN) 

\ \ 

-^NASTRAN Data Decks ^ 



Example B 

J0B,p,t,fl, 
N0RFL . 



5.5-6 (12-1-69) 



NASTRAN ON THE CDC 6400/6500 (SCOPE 3) 





N0MAP. 






REQUEST NSTRN.HI. reel*,R(3L 




REQUEST UMF.HI. 


reel#,R0L 


(2) 


NSTRN. CREATE (NASTRAN) 




DR0PFIL(NSTRN) 






DR(3PFIL(UMF) 






^NASTRAN Data 


Decksl 




s 






'^8 
^9 




Example C 






J0B,p,t,fl. 






U0RFL, 






N0HAP. 






REQUEST NPTP.HI. 


, SAVTP.RIL 




REQUEST PLT2,HI. 


SAVTP.RIL 


(3) 


ATTACH(NASTRAN) 
NASTRAN. ATTACH 
DR(3PFIL(NPTP) 
DR(aPFIL(PLT2) 






JnASTRAN Data 


Decksl 




\ 










E_xair 


iple D 
J0B,p.t,fl. 
N0RFL. 

mm?. 






REQUEST UMF.HI. 


reel#,R0L 



5.5-7 (12-1-59) 



HASTRAK - OPERATING SYSTEM INTERFACES 



REQUEST NPTP.HI. SAVTP.RIL 
ATTACH (NASTRAN) 
NASTRAN. ATTACH 
DR0PFIL(UMF) 
DR0PFIL(NPTP) 

\ X 

iNASTRAN Data Decks!- 



\ 



h 
% 



Example E 

J0B,p,t,fl. 

N0RFL. 

N0f1AP. 

REQUEST 0PTP,HI. reel#,R0L 

REQUEST NASTRAN. HI. ree1#,R0L 

NASTRAN. 

DR0PFIL{0PTP) 

DR0PFIL{NASTRAN) 

7o 



/nASTRAN Data Decks (including RESTART packet in the Executive Control Deck)| 



S 



«7, 



Example F 

J0B,p,t,fl. 

N0RFL. 

N0MAP. 

REQUEST NASTRAN, HI, reel#,R0L 

REQUEST NPTP.HI. SAVTP.RIL 

REQUEST 0PTP,HI, reel#,R0L 



5.5-8 (12-1-69) 



IWSTRAN ON THE CDC 5400/6600 (SCOPE 3) 

REQUEST PLT2,HI, SAVTP.RIL 

NASTRAN . 

DR0PFIL(fiASTRAN) 

DR0PFIL(NPTP) 

DR(3PFIL(i3PTP) 

DR0PFIL(PLT2) 

• NASTRAN Data Decks (including RESTART packet in the Executive Control Deck)! 
\ 

^9 

Notes 

(1) On the J0B card: p = priority, t = time in octal seconds and fl = field length in 
octal words. 

(2) In addition to executing the NASTRAN program, this control statement will cause the 
NASTRAN file to be declared a common file. 

(3) This control statement attaches the common file to the job. If NASTRAN is executed 
as a common file, running time will be approximately 5-8 minutes faster in elapsed 
time and 20 seconds faster in CPU time. 

5.5.5 Generation of the NASTRAN Executable System 

Due to the differing formats of nonstandard returns and multiple entries in CDC F0RTRAN in 
comparison with Univac and IBM F0RTRAN's, the tape contair.ing the symbolic card images of all the 
NASTRAN decks must first be converted to CDC compatible format by a utility program prepared for 
this purpose. The NASTRAN source tape is used as the input, and the CDC compatible source tape 
is written as output. The following control cards are used to execute this NASTRAN source con- 
version utility: 

JS)B,0 1,20, 150000. 

Ni3RFL. 

REQUEST TAPE!, HI, reel#,R0L 

REQUEST TAPE20,HI. SAVTP.RIL 

5.5-9 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTtliFACES 



C0PYBF(TAPE1,TAPE1Q) 

REWIND(TAPEIO) 

INPUT. 

REWIND(TAPE20) 

7 

JNASTRAN SOURCE CONVERSION UTILITY BINARY DECKS 



°'. 



\ 

6-, 

The output tape, SAVTP, is then compiled using the follovnng control cards to produce a 
relocatable tape, NAST0BJ. 

J0B,O1 ,20,150000. 

N0RFL. 

REQUEST TAPE!, HI, reel#,R0L 

REQUEST NASTSJBJ.HI. SAVTP, RIL 

C0PYBF(TAPE1 .SOURCE) 

REWIND(S0URCE) 

RUN(S,,,S0URCE,,NAST0BJ,,1,1) 

\ 

Having produced the relocatable tape, the NASTRAM executable tape can be generated using the 
NASTRAN CDC 6400/6600 Linkage Editor. This process vjith examples may be found in section 5.6. 

5.5.6 Machine Dependent Routines 

The following utility routines necessary to NASTRAN operation must, by their nature, be 
implemented in a machine dependent manner. Certain of the routines have been written in C0MPASS 
language, and the remainder are in F0RTRAN language. 

5.5.6.1 MAPFMS (C0MPASS) 

The MAPFNS deck embodies a set of 22 utility functions and routines. These are as follows: 

5.5-10 (12-1-69) 



flASTkAN ON THE CDC e-^iOO/SeOO (SCOPE 2) 

Logical Functions 
ANDF (logical product of tvr:- v;ords) 
0RF (logical sum of tvio words) 
X0RF (logical difference of tv;o words) 
C0MPLF (complement of a word) 
LSHIFT (left shift of a word) 
RSHIFT (right shift of a wcrLi' 

Utility Functions 
C0RSZ (returns length of "ofc^n cere") 
C0RWDS (returns difference uf two addresses + 1) 
LW0RDS (returns difference of two addresses. CDC 6600 only) 
L0CF (returns the value of an eddres;:;. CDC 5600 only) 

Utility Routines (CDC 6600 on ly) 
XST0RE (stores an array at an absolute position in core) 
XFETCH (fetches an array fro;; an absolute position in core) 
XJUMP (transfers control to an absolute location in core) 
ZAP (stores zeros between specified locations in core) 
REC0VRY (initializes PR routine RCV) 

LINK20. (provides a special call to Link 20, the NASTRAN exit link) 
XC0MM0N (executes the C0MM0N macro and returns the status of a file) 
FIELDLN (returns the field length assigned to the job) 
FLUSH (makes a special call to SYSTlM. to empty output buffers) 
TDATE (returns month, day, year, tiriie) 
KLjICK (returns current value of CPU clock) 
DAYTIME (returns current time on wall clock) 

5.5.6.2 C0NMSG (F0RTRAN) 

The C0NMSG routine enters messages in the DAYFILE denoting the times of the initiation and 
completion of modules during NASTRAN e.-.ocLition. 

5.5.6.3 GNFIAT (F0RTRAN) 

6NFIAT initializes the XFIAT and FIAT tables and reserves storage for the master indices 

5.5-n (12-1-69) 



fiASTRAN - OPERATING SYSTEM INTERFACES 

(see section 5.5.2). 

5.5.6.4 106600 (F0RTRAN) 

Calls from GIN0 to GIN0Iia are renamed to 106600 on the CDC 6400/5600. Section 5.5.2 contains 
a discussion of the function of 106600. 

5.5.6.5 DUMP and PDUMP (F0RTRAN) 

A call to PDUMP produces a trace back listing and, if a DIAG 1 card appeared in the Executive 
Control Deck, a memory dump is given. PDUMP returns to the calling program. DUMP operates 
similarly except terminates with a CALL EXIT. 

5.5.6.6 PEXIT66 (F0RTRAN) 

PEXIT66 is called from PEXIT only. It terminates activity on all NASTRAN files. Tapes are 
unloaded. Space assigned to disk files is evicted. PEXIT66 terminates with a CALL EXIT. 

5.5.6.7 SGIN0 (F0RTRAN) 

SGIN0 is used by the plot routines to write plot tapes. Actual writes are accomplished by 
SGIN0 through calls to XI0RTNS. 

5.5.6.8 XI0RTNS (C0MPASS) 

The XI0RTNS deck embodies a set of utility routines which communicate with the SC0PE Opera- 
ting System through CPC to accomplish various file operations. 

Entry Points 
X0PEN (constructs FET and initiates activity for file) 
XCL0SE (terminates activity for file) 
XEVICT (evicts space assigned to a disk file) 
REINDX (resets index pointers in the FET) 
XWRITE (writes a portion or a complete logical record) 
XREAD (reads a portion or a complete logical record) 
XREWIND (repositions file to load point) 
XBKREC (repositions file one logical record backwards) 
XBKPREC (repositions file one physical record backwards) 
XFRDREC (repositions file one logical record forwards) 

5.5-12 (12-1-69) 



NASTRAN ON THE CDC 6400/6600 (SCOPE 3) 

XREQST (issues REQUEST macro) 

5.5.6.9 GN66BD (F0RTRAN) 

GN66BD is a BL0CK DATA subprogram which initializes the GIN066 common block with names of 
each of the possible NASTRAN files. 



5.5-13 (12-1-69) 



ThE CDC 6400/6600 LINKAGE EDITOR 

5.6 THE CDC 6400/6600 LINKAGE EDITOR 
5.6.1 In troduction 

5.6.1.1 Concept of the Linkage Editor 

The linkage editor has been designed to provide an efficient and effective means of utilizing 
core storage for medium to large programs. The existing loader for the CDC 6400/6600 systems has 
the following disadvantages: 

1. Only two levels of overlay are provided beyond the root segment. 

2. An overlay segment must be explicitly called. Consequently, the overlay structure must 
be known when the program is coded. 

3. An overlay segment may be entered at one point only. Consequently, downward calls are 
extremely limited. 

4. No facility exists to explicitly position named common blocks. 

5. Loading of overlay segments is accomplished from a sequential file, thus providing 
unnecessary search time. 

The CDC 6400/6600 Linkage Editor in conjunction with its partner, the Segment Loader, over- 
comes these disadvantages in the following ways: 

1. An unlimited number of overlay levels is provided. 

2. The programmer describes the overlay structure to the linkage editor after the program 
is coded. The linkage editor provides implicit segment loading. 

3. Complete communication between all levels of overlay is maintained. 

4. Linkage editor control statements may be used to explicitly position subprograms and 
named common blocks. 

5. The overlay segments are maintained in an indexed file. Consequently, every segment is 
immediately available to the segment loader. 

As may be seen from Figure 1, the primary input sources to the linkage editor include: 

1. Object decks (relocatable binary decks) 

2. Control statements 

5.6-1 (12-1-69) 



iJASTRAN - OPERATING SYSTEM INTERFACES 

3. A call library from which unsatisfied external references are resolved. 

Another source of input (not shown in Figure 1) is a file containing executable links from a 
previous linkage editor run. This feature allows changes or additions of links while not altering 
previous links to which no changes are required. 

The file produced by the linkage editor contains three portions: 

1. A sequence of object decks suitable for loading by the CDC loader. The main program in 
this sequence, named XBSI0T, reads the remainder of the file containing the executable links 
and writes it on the disk as an indexed file. XB00T reads Link into central memory and 
transfers control to the entry point which initiates execution of the problem program. This 
sequence of decks is terminated by a null record. 

2. Three records: 

(1) Link directory record; 

(2) Link symbol dictionary containing entry points and common blocks in Link and 
their associated addresses; 

(3) Link executable record. 

3. A directory record for each succeeding link and one logical record per segment containing 
executable instructions and data. 

This sequence of records is terminated by a directory record which contains the word EriDLINKS. 

Link remains in central memory at all times during program execution. Link contains no 
overlay segments. The linkage editor supplies a routine named XL0ADER when Link is constructed. 
XL0ADER accomplishes the loading of segments and links when requested. Segment load requests 
are supplied automatically by the linkage editor through tables called ENTAB$ (see section 
5.6.3.2) which are written as a part of the text for each segment which may require additional 
segment loading. An additional table, SEGTAB$ (see section 5.6.3.2), which is constructed by 
the linkage editor as a part of the root segment of every link, is used by XL0ADER to facilitate 
segment loading. 

Major divisions of a program are links. Each link consists of a self-contained overlay 
structure and might be thought of as a complete program in itself. All routines in a link 
communicate freely with Link routines. Consequently, Link may be thought of as logically 

5.6-2 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 

belonging to every link. For many programs, a single link in addition to Link will be sufficient. 
Because of its size, however, MASTRAN has been divided into 14 links. 

5.6.1.2 Functions of the Linkage Editor 

The basic function of the linkage editor is the linking of separately assembled or compiled 
subprograms into a link. The link is in a format suitable for loading and execution. 

Although this linking or combining of subprograms is its primary function, the linkage editor 
also: 

1. Incorporates subprograms from a library file to resolve undefined external references. 

2. Constructs an overlay program in a format suitable for loading and execution. 

3. Rearranges control sections and renames external references as directed by linkage editor 
control statements. 

4. Reserves storage for common control sections generated by C0MPASS and F0RTRAN. 

5. Provides processing options and diagnostic messages. 

5.6.1.3 Subprogram Linkage 

Processing by the linkage editor makes it possible for the programmer to divide his program 
into several subprograms which may be separately assembled or compiled. The linkage editor com- 
bines these subprograms into a link with contiguous storage addresses. The link is written in an 
indexed file. The linkage editor can process more than one link in a single job step. Each link 
is written with a unique link number. 

5.6.1.4 Input Sources 

Input to the linkage editor consists of one or more sequential files (libraries) containing 
subprograms in relocatable format as produced by COMPASS or F0RTRAN, and linkage editor control 
statements contained in INPUT, the standard input file. 

External references that are undefined after processing all subprograms cause the automatic 
library call mechanism to search for subprograms that will resolve the references. When these 
subprograms are found, they are processed by the linkage editor and become part of the link. 



5.6-3 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

5.6.1.5 Programs in an Overlay Structure 

To minimize main storage requirements, the programmer can organize his program into an over- 
lay structure by dividing it into segments according to the functional relationshp of the sub- 
programs. Two or more segments that need not be in main storage at the same time can be assigned 
the same storage addresses, and can be loaded at different times. The programmer uses linkage 
editor control statements to specify the relationship of segments within the overlay structure. 

5.6.1.6 Options and Diagnostic Messages 

The linkage editor can produce a storage map and a cross-reference table that show the 
arrangement of control sections in the link and how they communicate with each other. A list of 
the linkage editor control statements that were processed can be produced. Additionally, pro- 
cessing options that negate the effect of minor errors and specify the disposition of input and 
output files can be specified by the programmer. 

Throughout processing by the linkage editor, errors and possible error conditions are printed. 
Serious errors cause a link not be written on the output file. 



5.6-4 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 



Previously 
Compiled 
Object Decks 



^ 



Object 

Deck 

Library 



Call 
Library 



Source 
Programs 



^ 



LINKLIB 



Run 
Compiler 



File 

Containing 
Object Decks 



Indexed 
File With 
Links 



Linkage 
Editor Control 
Statements 




LINKAGE 
EDITOR 



Link 
In Central 
Memory 




File 

Containing 
Executable 
Links 



CDC 
Loader 



Figure 1. Linkage editor processing. 



5.6-5 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

5.6.2 Preparing for Linkage Editor Processing 

5.6.2.1 Object Decks 

An object deck (relocatable binary deck), which is produced by the F0RTRAN compiler or 
C0MPASS assembler, consists of the following tables: 

1. Program Identification and Length (PIDL), which defines a) subprogram identification and 
length and b) each of the common blocks referenced by the subprogram; 

2. Entry Point (ENTR), which defines each of the entry points to the subprogram and its 
relative location; 

3. Text (TEXT), which defines instructions and data for relocation; 

4. Fill (FILL), which contains information to relocate previously defined address fields 
(in particular, references to coinmon blocks); 

5. Link (LINK), which indicates each external reference by the subprogram and its relative 
location; 

6. Replication (REPL), which permits the repetition of a block of data. 

Any other tables which may be contained in an object deck are ignored by the linkage editor. 
For a complete description of the format of these tables, see the SC0PE Reference Manual, 
Appendix D. 

5.6.2.2 Libraries 

All object decks that are to be processed by the linkage editor are contained in libraries. 
A library is a sequential file (which may reside on tape or disk) consisting of one or more 
logical records with one object deck per logical record. 

A file named LINKLIB must always be defined for linkage editor processing. This file con- 
tains object decks for automatic library call plus object decks which are required in construct- 
ing the initial load portion of the output file. 

There is no theoretical limit to the number of libraries which may be defined for linkage 
editor processing. Subprograms of the same name may appear in more than one library. 



5.6-6 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 

5,6.3 Designing an Overlay Program 

5.6.3.1 Overlay Tree Structure 

In order to place a program in an overlay structure, the programmer should be familiar with 
the following terms: 

1. A control section consists of all instructions and data defined for a subprogram or a 
common block. 

2. A segment is the smallest functional unit (one or more control sections) that can be 
loaded as one logical entity during program execution. 

3. A path consists of a segment and all segments in the same region between it and the root 
segment (first segment). The root segment is a part of every path in every region. When a 
segment is in main storage, all segments in its path are also in main storage. 

4. A region is a continguous area of main storage within which segments can be loaded 
independently of paths in other regions. An overlay program can be designed in single or 
multiple regions. 

5. A link is a collection of one or more segments which comprise a logical subdivision of 
the program. Link (consisting of one segment only) is in main storage at all times. It is 
the first link to receive control when execution of the program is initiated. The root 
segment of any other link resides in main storage at all times that that link is being 
executed. An overlay program must consist of at least one link other than Link 0. 

6. A tree is the graphic representation that shows how segments can use main storage at 
different times. It does not imply the order of execution. 

The design of an overlay program requires the organization of the control sections of the 
program in an overlay tree structure. The tree structure is developed considering: 

1. The amount of available main storage. 

2, The frequency of use of each control section. 

3. The dependencies between control sections. 

4, The manner in which control should pass within a path, from one path to another, and 
from one region to another. 

5.6-7 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

When the programmer has determined the overlay structure for a program, he prepares 0VERLAY, 
INSERT and REGI0N statements that will segment the program in that manner. The use of these con- 
trol statements is described in section 5.6.4. 

5.6.3.2 Overlay Characteristics 

During execution of an overlay program, the segment loader uses tables that were generated 
by the linkage editor and incorporated into the text of applicable segments. Since these tables 
are an integral part of the program, their size must be considered when planning the use of 
available main storage. These tables are described as follows. 

1. Input/Output Control Table 

There is one Input/Output Control Table (LINKO$) in the root segment of Link only 
which contains a File Environment Table (FET), a circular buffer, a master index and a sub- 
index. The LINKO$ table is used by the segment loader to read requested segments into 
central memory. LINKO$ is the first control section in Link 0. Its size is determined as 
follows: 

Length in words = PARAM(l) + PARAM(4) + PARAM(5) + 4 . 

Section 5.6.4.2 contains definitions of the parameters. 

2. Segment Table 

There is one Segment Table (SEGTAB$) in the root segment of each link except Link 0. 
The segment table is used to keep track of: (1) the relationship of the segments in the 
program; (2) which segments are in main storage or scheduled to be loaded; (3) the main 
storage address and length of each segment; and (4) the entry address of the link. 

SE6TAB$ is the first control section in the root segment of each link. Its size is 
determined as follows: 

Length in words = n + 2, 

where n is the number of segments in the link. 

3. Entry Table 

There can be an Entry Table (ENTAB$) in each segment of the program. The loader 

5.6-8 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 

uses the entry table to determine the segment to be loaded when an external reference is 
made to a segment not in the path. 

An entry table may be produced as the last control section of a segment. An ENTAB$ entry 
is created for a symbol to which control is to be passed. The symbol is defined in a seg- 
ment not in the path. The size of ENTAB$ is determined as follows: 

n 
Length in words = 3n + Z &., 

i = l ^ 

where n is the number of unique external references not in the path and 6. = MAX(m.-6,0), 
m. = number of arguments for each external reference not in the path. 

4. Dump Control Word 

In the text produced by the linkage editor for each segment, a uniquely formatted word 
which identifies the control section is written immediately prior to each control section. 
This word is recognized by the storage dump routine XDUMP in order to produce relative 
addresses fcr each control section. 

5.6.3.3 Overlay Communication 

There are two ways in which the programmer can have his program request the overlay facilities 
of the segment loader: 

1. By a CALL statement (FORTRAN language) or RJ instruction (C0MPASS language) which 
Ciiuses a segment to be loaded and control to be passed to the symbol defined in that segment. 

2. By a CALL LINK(N) (F0RTRAN language) or the equivalent in the C0MPASS language, where N 
is the link number, which causes segment one (the root segment) of the requested link to be 
loaded and control to be passed to the symbol named on the linkage editor control statement 
ENTRY. 

5.6.3.4 Reserving Storage 

In F0RTRAN and C0MPASS the programmer can create control sections that reserve main storage 
areas containing no data or instructions. Referred to as "common", these control sections are 
produced by the language translator. These common areas are either named or blank (unnamed). 

During processing, the linkage editor collects these common areas. If more than one blank 
common area is found, the largest blank common area is contained in the link. If two or more 

5.6-9 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

common areas have the same name, the largest common area having that name is reserved in the link. 
All references to a common area (named or blank] refer to the largest area defined. This largest 
area is the one which is retained. 

If the linkage editor encounters data or text for the same common area in more than one sub- 
program, only data from the first subprogram encountered are retained and a diagnostic message is 
generated for any subsequent data definitions. 

When object decks which reference common areas are to be placed in an overlay structure, the 
linkage editor automatically "promotes" the common areas tc the root segment (unless otherwise 
directed by an INSERT control statement, see section 5.6,4.8). The position of a promoted common 
area in relation to other control sections in the root segment is generally unpredictable. 

Note : Blank common is treated by the linkage editor as a named common block with the 
special name BLANK., and is listed on the storage map with this name. Consequently, it is possible 
to position this control section with the statement INSERT BLANK... 

5.6.3.5 Processing Options 

1 . List of control statements 

The linkage editor automatically produces a listing of all control statements unless 
the programmer selects the N0LIST option in the LINKEDIT statement (see section 5.6.4.2). 
In the latter case, only the LINKEDIT, LIBRARY and ENDLINKS statements are listed (see 
sections 5.6.4.2, 5.6.4.3 and 5.6.4.12 respectively for details), 

2. Storage map and cross-reference table 

The linkage editor automatically produces a storage map of each link unless the programmer 
selects the NCIMAP option in the LINKEDIT statement. For each segment, the storage map lists 
the control sections in ascending order according to their assigned address. Included with 
each control section is a list of all entry point names and assigned addresses. 

When the XREF option in the LINKEDIT statement is specified, the linkage editor produces 
a table of all references to each entry point in the link. Additional options (PARAM(7) 
parameter, see section 5.6.4.2) allow the table to be extended to include all references from 
the link to LINK entry points and an additional table of all external references from each 
subprogram to be produced. 

5,6-10 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 

The N0MAP and XREF options are mutually exclusive. Therefore, if XREF is selected, N0MAP 
is ignored and a storage map is produced. 

3. The LET option 

When the LET option of the LINKEDIT statement is selected, the linkage editor disregards 

all errors except two and writes the link on the output file. The two errors which preclude 

the link from being written are: (1) an undefined entry point to the link; and (2) insuffi- 
cient storage space to form the link to be written. 



5.6-11 (12-1-69) 



■ASTRAN - OPERATING SYSTEM INTERFACES 

5.6.4 Linkage Editor Control Statements 
5.6.4.1 General Statement Format 

All linkage editor control statements are coded from the following possible forms: 



operation 


operand 




VERB 


a. b(c), KEYW0RD, KEYW0RD = a, KEYW0RD 
KEYW0RD(i) = n, a = a, b(c) = a.n 


= b(c). 



where 

a is an unsubscripted symbol, 

b is a subscripted symbol, 

c is a subscript symbol, 

KEYW0RD is an explicit name or option, 

i is an integer subscript, 

n is an integer value. 

The operation field must contain the name of the operation to be performed. The operand 
field must contain one or more symbols or subscripted symbols (except REGI(3N, END and ENDLINKS 
which have no operands). Operands in the operand field are separated by a comma or blank (or both). 
Two or more symbols within parentheses are similarly separated. A keyword must be written exactly 
as shown. 

The operation field begins with the first nonblank column on the card. The operand field is 
separated from the operation field by at least one blank column. 

The LINKEDIT and LIBRARY control statements may be continued on subsequent cards by coding a 
comma as the last nonblank column. The continuation begins with the first nonblank column of the 
succeeding card. These two control statements are the only ones which may be continued. 

5.6.4.2 The LINKEDIT Statement 

The LINKEDIT statement specifies input and output file names and status, processing options 
and size characteristics of the link(s) to be link-edited. 



5.6-12 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 



operation operands 

LINKEDIT INFILE = nanie(a) .0UTFILE = name(b), 
LET,N0LIST,Ni2MAP,XREF.PARAM(i) = n 



INFILE specifies the name of a file which was 

previously produced by the linkage editor. 
INFILE is named only when previously link- 
edited links are to be updated. 

a must be coded T or C. T specifies that the 
file is a sequential file on tape or disk. 
C specifies that the file is an indexed file 
on disk and, therefore, a common file as 
defined by SC0PE. 

0UTFILE specifies the name of the file on which the 
initial load program and the links will be 
written. 0LITFILE must always be named. 

b must be coded T or C. The links are written 
internally by the linkage editor on an indexed 
file. If C is coded, the links are written 
directly on the file specified by 0UTFILE, 
which must be a common file. If T is coded, 
the initial load program and the links are 
copied from the internal file to the specified 
sequential file (tape or disk). 

LET directs the linkage editor to ignore the effect of 
most errors. 

N0LIST directs the linkage editor to suppress the 
listing of control statements. 

N0MAP directs the linkage editor to suppress storage 
maps. 



5.6-13 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 



XREF 



directs the linkage editor to list a table of 
external references to each entry point in each 
link. 



Default Value 



530 



PARAM(2) 

PARAM(3) 

PARAM(4) 
PARAM(5) 

PARAM(6) 



1000 

500 

32 
128 

5000 



Keyword Description 

PARAM(l) Length of FET + circular buffer 

for all files used by the linkage 

editor 

Maximum number of object decks in 
all libraries 

Maximum size of any table in an 
object deck 

Maximum number of links 

Maximum number of segments in any 
link 

Maximum length (in words) of any 
control section for which text is 
defined 

PARAM(7) Additional options if XREF is 

selected 

=1: produce a table of references 
from each subprogram 

=2: list all references to entry 
points in Link .0 

=3: provide both of the above 

Placement : The LINKEDIT statement must be the first statement of the input record. 
Only one such statement may appear in a job step. 

Notes : (1) The files named on INFILE and 0UTFILE may be the same; however, if so, 
their status must be the same (i.e., both T or both C) 



5.6-14 (12-1-69) 



Examples : 



THE CDC 6400/6600 LINKAGE EDITOR 

(2) If XREF is selected. N0MAP is ignored 

(3) If XREF is not selected, PARAM(7) is ignored 

LINKEDIT 0UTFILE=LINKS(T) .LET, XREF 

LINKEDIT INFILE=0LDLNKS(T),0UTFILE=NEWLNKS(T),N0LIST,PARAK(1)=1O5O 

LINKEDIT INFILE=ABS(C) ,0UTFILE=ABS(C) ,PARAM(6)=S000 

LINKEDIT 0UTFILE=MYFILE(T) 



5.6.4.3 The LIBRARY Statement 

The LIBRARY statement names each file which may possibly occur on INCLUDE control statements 
(see secton 5.6.4.5). 



operation operands 
LIBRARY name-i.name^, 



name specifies the name of a sequential file 
containing object decks. 

Placement : The LIBRARY statement must appear immediately after the LINKEDIT statement. 
Only one such statement may appear in a job step. 

Example : 

LIBRARY MASTER, NEWDCKS 

5.6.4.4 The LINK Statement 

The LINK statement specifies the link number and directs the linkage editor to initiate 
processing of a link. 



operation operand 
LINK n 



n is a nonnegative integer 

specifying the link number. 

Placement : The first LINK statement must appear immediately following the LIBRARY 
statement. Subsequent LINK statements must appear immediately following 

5.6-15 (12-1-69) 



Example : 



NASTRAN - OPERATING SYSTEM INTERFACES 

an END statement. If Link is being processed, it must be the first link 
to be processed. 

LINK 



5.6.4.5 The INCLUDE Statement 

The INCLUDE statement directs the linkage editor to include the named object deck from the 
specified library in the link currently being processed. 



operation operands 

INCLUDE name(deck,BLKDATA(comname) 



name 



specifies the name of a sequential 
file which was previously defined 
in the LIBRARY statement. 



deck 



specifies the name of an object 
deck contained in the file. 
BLKDATA indicates that the deck to be 
included is a BL0CK DATA sub- 
program. 

comname is the name of the first mentioned 
common block in the BL0CK DATA sub- 
program. 

Placement : An INCLUDE statement may appear in any position between the LINK and END 
statements. Subprograms will be included in the order in which 
INCLUDE statements are encountered. 



Examples : 



INCLUDE MASTER{MAIN) 

INCLUDE NEWDCKS(M|aDl,M0D2.M0D3) 

INCLUDE MASTER (BLKDATA{C0M1),BLKDATA{C0M2)) 



5.6-16 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 



5.6.4.6 The REGI0N Statement 



The REGI0N statement indicates the beginning of a new region. 



operation 

REGI0N 



Placement: The REGI0N statement follows statements which define the overlay structure 
for a previous region, and it indicates the beginning of a new region. 

5.6.4.7 The 0VERLAY Statement 

The 0VERLAY statement indicates the beginning of an overlay segment. 



operation operand 
0VERLAY name 



name is the symbolic 

origin of a segment. 
The symbol is not 
related to external 
symbols in the link. 

Placement: The 0VERLAY statement may appear in any position between the LINK and END 
statements. If a REGI0N statement is coded, an 0VERLAY statement must 
appear immediately following the REGI0N statement. An 0VERLAY statement 
may not be coded for Link 0. 



Examples : 



1. Single region structure (no REGI0N statement necessary) 

INCLUDE MASTER(SUBl) 

INCLUDE MASTER(BLKDATA(C0M1)) 

0VERLAY ALPHA 

INCLUDE NEWDCKS(M0D1) 

0VERLAY BETA 

INCLUDE NEWDCKS(M0D2,M0D3) 

0VERLAY BETA 

5.6-17 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 



INCLUDE MASTER(PR0GA) 

0VERLAY ALPHA 

INCLUDE MASTER(PR0GB,PR0GC) 

Figure 2 depicts a tree diagram for the above example. 



SUB! 
/C0M1 / 



ALPHA 



BETA 



M0D1 



M0D2 
M8ID3 



PR0GA 



PR0GB 
PR0GC 



Figure 2. Tree diagram of a single region overlay structure. 



2. Multiple region structure 

INCLUDE 0BJ(A,B,C) 

0VERLAY 0NE 

INCLUDE DECKS(AA,BB) 

0VERLAY TW0 

INCLUDE 0BJ{D) 

0VERLAY TW0 

INCLUDE DECKS(CC,DD) 

0VERLAY 0NE 

INCLUDE 0BJ(E,F,6) 
REGI0N 

0VERLAY THREE 

INCLUDE 0BJ(I,J) 



5.6-18 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 



0VERLAY THREE 

IMCLUDE DECKS(EE) 

OVERLAY F0UR 

INCLUDE DECKS(FF,GG) 

0VERLAY F(3UR 

INCLUDE 0BJ(K) 

Figure 3 depicts a tree diagram for the above example. 



Region 1 





0NE 




A 
B 
C 


TW0 


AA 
BB 




D 




CC 
DD 



Region 2 



THREE 



F0UR 



EE 



FF 
GG 



Figure 3. Tree diagram of a multiple region overlay structure. 



5,6.4.8 The INSERT Statement 



The INSERT statement positions control sections in overlay segments. 



operation operands 

INSERT name 



name 



specifies the 
name of a control 
section that is to 
be positioned. 



5.6-19 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

Placement : The INSERT statement is placed in the control statement sequence following 

an 0VERLAY statement that defines the segment in which the control section is 
to be placed. 

Caution : A control section should be named only once on an INSERT statement since a 
control section can appear only once within a link. If the same control 
section appears on more than one INSERT statement, the last statement 
encountered will control positioning and previous statements will be ignored. 



Examples : 



INSERT C0M1 
INSERT C0M2,C0M3 



5.6.4.9 The RENAME Statement 

The RENAME statement changes external references to a symbol to a new symbol either globally 
(throughout the link) or locally (within a subprogram). 



operation operand 

RENAME oldname=newname [global] 

RENAME oldname(subprogram)=newname [local] 



oldname is the symbol to which an external reference 
exists. 

newname is the symbol to which the external reference 
is to be made. 

subprogram is the name of the subprogram in which the 
change is to be made. 

Placement : The RENAME statement may appear in any position between the LINK and the END 
statements. 

Notes : (1) Only one rename may be coded on a single statement. 

(2) No error occurs if no references are made to oldname. If reference 
is made to oldname and newname is not specifically included, the automatic 
call logic will be invoked. 



5.6-20 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 



Examples: 



RENAME SQRT=SQRTXX 
RENAME DUMP(M0D1)=RETURN 

5.6.4.10 The ENTRY Statement 

The ENTRY statement specifies the symbolic name of the entry point in the link to which 
control will be transferred after thelink is loaded. 



operation operand 
ENTRY name 



name is the symbol defining the 

entry point for the link. The 
name must be defined in the root 
segment of the link. For Link 0, 
name must be the name of a main 
program. For any link other than 
Link 0, name must be the name of a 
subroutine. 

Placement: The ENTRY statement may appear in any position between the LINK and the END 
statements. 



Examples: 



ENTRY MAIN 
ENTRY SUB! 



5.6-21 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

5.6.4.11 The END Statement 

The END statement specifies the conclusion of control statements for the current link being 
processed. 



operation 
END 



Placement : The END statement must appear following all statements which define the link. 
There must be one END statement for each LINK statement. 

5.6.4.12 The ENDLINKS Statement 

The ENDLINKS statement defines the end of all processing by the linkage editor. 



operation 

ENDLINKS 



Placement : The ENDLINKS statement must immediately follow an END statement. One such 
statement is required. 



5.6-22 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 
5.6.5 Examples of Linkage Editor Processing 

In the following examples, it is assumed that the file containing the call library (LINKLIB) 
and a file containing the linkage editor program (LINKEDT) are contained on separate magnetic 
tapes. These examples are intended to illustrate various deck setups. 



Conditions of Problem 


Example 


Source Program 


Previously Compiled Decks 


Execution 


A 
B 
C 


yes 

no 

no 


in input stream 

on tape 

input stream 
and on tape 


yes 

no 

yes 



Example A 



J0B, 01, 100, 60000. 

N0RFL. 

NjilMAP. 

RUN(S NEW) 

REWIND(NEW) 

C0PYBR(INPUT,0LD,n) 

REWIND(!3LD) 

REQUEST LINKEDT, HI. reel#,R0L 

REQUEST LINKLIB, HI. reel#,R0L 

CREATE(LINKS) 

LINKEDT. 

DR0PFIL(LINKLIB) 

DR0PFIL(LINKEDT) 

LINKS. ATTACH 

RELEASE(LINKS) 

7c 



8n 



|f0RTRAN or C0MPASS source programs 1 



5.6-23 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 



\ 



|n object decks i 
LINKEDIT 0UTFILE=LINKS{C) 



LIBRARY NEW.0LD 
LINK 
(1) RENAME SYSTEM=SYSTEM. 

jlNCLUDE statements! 
ENTRY entry point 
END 

LINK 1 
RENAME SYSTEH=SYSTEM. 

llNCLUDE, OVERLAY, etc. statements 
ENTRY entry point 
END 

ENDLINKS 
7o 



■ data for problem programV 
^9 


^7 




Example B 




J0B, 01, 100, 60000. 




N0RFL. 




N0MAP. 




REQUEST 0BJECT,HI. 


reel#,R0L 


REQUEST LINKLIB.HI. 


reel#,R0L 


REQUEST LINKEDT.HI, 


reel#,R0L 


REQUEST LINKFIL.HI. 


SAVTP.RIL 


LINKEDT. 




DR0PFIL{0BJECT) 





5.6-24 (12-1-69) 



THE CDC 6400/5600 LINKAGE EDITOR 

DR0PFIL(LINKLIB) 
DR(3PFIL(LINKEDT) 
DR(3PFIL(LINKFIL) 

\ 

LINKEDIT 0UTFILE=LINKFIL(T) ,LET,XREF,PARAM(7)=2 

LIBRARY 0BJECT 

LINK 

RENAME SYSTEM = SYSTEM. 

{include statements for Link ol 

ENTRY entry point 

END 

LINK 1 

RENAME SYSTEM=SYSTEM. 

{include, OVERLAY, etc. statements for Link ll 

ENTRY entry point 

END 

ENDLINKS 

\ 



Example C 



J0B, 01, 200, 70000. 

N(3RFL. 

N0f4AP, 

C0PYBR(INPUT,0BJ,n) 

REWIND(0BJ) 

REQUEST MASTER, HI. reel#,R0L 

REQUEST LINKLIB.HI. reel#,R0L 

REQUEST LINKEDT,HI. reel#,R0L 



5.6-25 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

REQUEST LINKFIL.HI. reel#,RIL 

LINKEDT. 

DR0PFIL( MASTER) 

DR0PFIL{LINKLIB) 

DR!JPFIL(LINKEDT) 

LINKFIL. 

DR0PFIL(LINKFIL) 

\ 

in object decks> 
LINKEDIT INFILE=LINKFIL(T).0UTFILE=LINKFIL(T),PARAM(6)=9OOOO 
LIBRARY MASTER,0BJ 
LINK 2 
RENAME SYSTEM=SYSTEM. 

llNCLUDE, 0VERLAY, etc. statements for Link 2| 

ENTRY entry point 

END 

ENDLINKS 

7, 



^9 



\ 



h 

Sg 



jdata for problem program > 



In Example A, the output of the linkage editor is written on a common file and executed from 
that file. This method is most efficient for "compile-and-go" type code check runs. 

In Example B, the output of the linkage editor is written on tape. This would be the 
most common form of a run in which most of the coding errors have been eliminated and the execu- 
table program is saved on tape for subsequent repeated executions. 

In Example C, it is assumed that a previously link-edited file exits (created, for example 
in Example B) and that it is desired to add a new link (or modify an existing link). In this 
case, the input and output files are both the same (although this is not necessary). The output 

5.6-26 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 

of the linkage editor is written on tape and the problem program is executed from this tape fild. 

Note: (1) To avoid possible conflict with a user (viz. NASTRAN) named common with the name 
SYSTEM, the CDC system routine has been reassembled with the name SYSTEM, and has 
been placed on LINKLIB with the name SYSTEM.. In order that other library routines may 
be properly linked, the statement RENAME SYSTEM=SYSTEM. is reconmended for all links. 

In the example illustrated in Figure 4, the following linkage editor control statements will 
produce the indicated overlay structure: 

LINKEDIT 0UTFILE=LINKS(T) 

LIBRARY LIBA,LIBB 

LINK 

RENAME SYSTEM=SYSTEM. 

INCLUDE LIBA(MAIN) 

INCLUDE LIBB(UTIL1,UTIL2) 

INCLUDE LIBA(UTIL3) 

ENTRY MAIN 

END 

LINK 1 

RENAME SYSTEM=SYSTEM. 

INCLUDE LIBB(START,M0D1) 

0VERLAY A 

INCLUDE LIBA(M!3D2) 

INCLUDE LIBB(M0D3) 

INSERT C0M1 

0VERLAY A 

INCLUDE LIBA(M0D4) 

0VERLAY B 

INCLUDE LIBB(M0D5) 

INCLUDE LIBA(M0D6) 

INSERT C0M2 

0VERLAY B 

INCLUDE LIBB(M0D7) 

5.6-27 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 



INSERT C0M3 
ENTRY START 
END 
ENDLINKS 



Link 


D 


MAIN 
UTIL1 
UTIL2 
UTIL3 








Link 


1 
A 


START 
M0D1 




M0D4 






M0D2 

M0D3 
/C0M1/ 




B 






M0D5 
M0D6 
/C0H2/ 




^0D7 
/C0M3/ 



LIBA 



LIBB 



MAIN 




UTILl 


UTIL3 




UTIL2 


M0D2 




START 


M0D4 




M0D1 


M0D6 




M0D3 
M0D5 










M0D7 



Figure 4. Example of a two-link overlay structure. 



5.6-28 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 

5.6.6 Storage Requirements for the Linkage Editor 

Figure 5 illustrates the layout of core storage for the linkage editor. For the discussion 
below, it is assumed that the linkage editor has not itself been link-edited. A link-edited 
version of the linkage editor is available. A memory saving of approximately 4000,„(10000„) words 

I (J O 

results. 

The principal open-ended table is the Symbol Chain Table. A three-word entry is created in 
this table for each subprogram name, entry point, common block and unique external reference not 
in the path. For a link other than Link 0, a three-word entry for each entry point and common 
block in Link is also created. A conservative estimate for the requirements of this table is 
as follows: 

Link 0: length in words = 4* (no. of entry points + common blocks). 
Link ?^ 0: length in words = 6* (no. of entry points + common blocks) 

+3* (no, of entry points + common blocks in Link 0). 

The largest table is likely to be the Working Storage Table. It must hold all instructions 

and data for the largest control section for which text is defined. If this figure is not known, 

a linkage editor run can be made. The storage map will be printed even if the link is not written. 

A scan of the lengths listed (in octal) will identify the largest control section. Note that 
common blocks for which no data are defined are not to be used in defining the maximum. 

Field length for the linkage editor may be estimated from the following: 
field length^Q = 15000 + MAX (10*N, 2000) + MAX(T,2000) + 3*PARAM(1) 



where 



and 



N = number of subprograms defined on INCLUDE statements, 
T = length of largest subprogram or common block for which 
instructions or data are defined, 



PARAM(l) is defined in section 5.6.4.2. 



5.6-29 (12-1-69) 



NASTRAN - OPERATING SYSTEM INTERFACES 

If default values for the linkage editor are used, a program of less than 200 decks would 
require a field length of 23,600^q = 60,000g. 

Efficiency of the linkage editor may be improved by increasing the buffer size {PARAM(l)). 
For NASTRAN, PARAM(l) = 2080 is used. Additionally, one deck requires 16,000^q words of text 
storage (PARAM(6) = 16000). Consequently, for a link of 300 decks, the field length works out 
as 

field length-iQ = 15000 + 3000 + 16000 + 6240 = 40240^^ = 1200003 ' 



5.6-30 (12-1-69) 



THE CDC 6400/6600 LINKAGE EDITOR 



Size 






Instructions 
and Data 


=14000^Q 


Buffer, 




Buffer2 




Buffer, 




Master Index 




Segment Index 




Library Index 




Names Table 




Entry Point Table 




Library Table 




Region Definition Table 




Segment Definition Table 




Segment Chains Table 




Rename Table 




Symbol Chain Table 


Field Length 


Working Storage 



PARAM(l) 
PARAMd) 

PARAM(l) 
PARAM(4) 

PARAM(5) 

No. of decks in all 
Libraries (^ PARAM(6)) 

No. of decks in all 
Libraries (<_ PARAM(6)) 

No. of entry points in 
LINKLIB (= 200) 

No, of libraries 

No. of regions + 1 

No, of segments + 1 
(< PARAM(4) + 1) 

No. of segments + 1 
{<_ PARAM(4) + 1) 

3*(no. of RENAME 
statements) 



Remaining storage 



PARAM(3) + PARAM{6) 



Figure 5. Layout of core storage for the linkage editor. 



5.6-31 (12-1-69) 



INTRODUCTION 

6.1 INTRODUCTION 

Modifications and additions are continuously made to large programming systems. NASTRAN will 
not be an exception to this rule. Section 6.2 presents the F0RTRAN IV language restrictions that 
must be followed in order to produce equivalent object code across the computing machines on 
which NASTRAN operates. The remaining sections discuss areas of the program which experience, 
gained during program development, has shown to be those areas most subject to modifications and 
additions. 



6.1-1 



F0RTRAN IV LANGUAGE RESTRICTIONS 

6.2 FORTRAN IV LANGUAGE RESTRICTIONS 

NASTRAN was developed in the F0RTRAN IV programming language to the greatest extent possible 
in order to simplify the task of conversion from the development machine, which, for the major- 
ity of program development, was the IBM 7094/7040(44) DCS, to third generation computing systems. 
The same F0RTRAN IV code can execute differently across computing machines. This fact is all but 
too well known to those who have labored through the task of conversion from one computing sys- 
tem to another. For this reason, modifications and additions to NASTRAN must be accomplished 
with F0RTRAN code that will produce equivalent object code across computing machines. The basic 
set of rules governing programming in F0RTRAN IV for NASTRAN is incorporated in the following 
manual in the IBM Systems Reference Library: IBM 7090/7094 IBSYS Operating System, Version 13, 
F0RTRAN IV Language, File No. 7090-25, Form C28-6390-3. The following is a list of exceptions to 
the rules set forth in this manual. 

31 

1. An integer constant may not be greater than 2-1. 

2. Subscripted variables should contain no more than 3 subscripts. 

3. A reference to the first variable in a subscripted array must contain the subscript 1, 
e.g., A(l) = 0.0. 

4. A C0NTINUE statement requires a F0RTRAN statement number. 

5. The PAUSE statement is not to be used. 

6. The NAMELIST statement is not to be used. 

7. Implied D0's in DATA statements are not allowed. 

8. The last statement of a D0 loop may not be a logical IF statement. 

9. BL0CK DATA subprograms may contain only type (e.g., REAL, INTEGER), DIMENSI0N, C0i1M0N 
and DATA statements. 

10. All Hollerith data should be defined in the form 4H 

11. Do not use octal (0) in DATA or F0RMAT statements. 

12. Specification statements should precede any executable statement. 



6.2-1 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

13. The order of specification statements should be as follows: 
COMPLEX 

D0UBLE PRECISION 

REAL 

INTEGER 

LOGICAL 

EXTERNAL 

DIMENSION 

COMMON 

EQUIVALENCE 

DATA 

14. The variables in blank COMMON or a block of COMMON should be ordered as follows: 
complex, double precision, real, integer and logical. 

15. Variables stored as single precision cannot be referenced as double precision variables 
(via the FORTRAN EQUIVALENCE statement) because of the different internal word storage format 
for single and double precision words on the Univac 1108. 

16. Caution must be exercised to insure that types (REAL, INTEGER, etc.) of FORTRAN function 
values agree in the function subprogram and in the calling program. This agreement between 
types is necessary for machines (e.g., IBM S/360) on which REAL and INTEGER values of 
FORTRAN functions are returned in different registers. 

17. Do not attempt to extend the length of arrays through the EQUIVALENCE statement. 

18. Caution must be exercised when using the EQUIVALENCE statement. One should not use the 
EQUIVALENCE statement to give different variable names to the same cell, since modern 
compilers, because of their optimization techniques, do not guarantee that the values of the 
equivalenced variables will be the same. Hence EQUIVALENCE should be used only between 
variables which have non-intersecting use spans in a program. 



6.2-2 



F0RTRAN IV LANGUAGE RESTRICTIONS 

19. Nonstandard returns in a SUBROUTINE statement must immediately follow the left paren- 
thesis which starts the names of the subroutine's arguments, e.g. SUBROUTINE XYZ (*,*,A,B) is 
the correct form; SUBROUTINE XYZ (*,A,*,B) is not acceptable. 

20. There must be agreement with respect to the number of arguments and the type of each 
argument in the argument list of a calling program and the subprogram called. 

21. For consistency with current NASTRAN practice, deck (or member) names for subroutines 
should agree with the primary entry point names. Deck names for Block Data subprograms 
should end with the characters "BD". 



6.2-3 



THE EXECUTIVE CONTROL DECK 

6.3 THE EXECUTIVE CONTROL DECK 

The capabilities of the Executive Control Deck may be changed or increased by modifying 
existing control card functions or adding completely new card types. Executive control cards 
are processed within two modules of the Preface: XCSA, (Executive Control Section Analysis, 
section 4.2) and XGPI (Executive General Problem Initialization, section 4.7). Some cards are 
handled completely within XCSA, while others are only partially checked by XCSA and then passed 
to XGPI, via the Executive Control Table (section 2.4.2.5), for final processing. 

To modify the content or function of an existing control card, first locate the proper 
section within module XCSA. The block of F0RTRAN statements related to the processing of each 
type of card is appropriately commented. Also, it can be determined from these statements 
whether part of the processing is being passed to module XGPI. The required modifications can 
then be made within XCSA and/or XGPI. 

To add a new control card type to those currently acceptable, the following steps should be 
taken. First, add the card type name to the local F0RTRAN array ECTT (Executive Control Type 
Table) within module XCSA, and increase the table length parameter (LECTT) by three for each 
new entry. The three word entry consists of two BCD words (4 characters /word) for the card type 
mnemonic and a one word integer flag indicating whether the card type is to be optional (=0) or 
required (=1) within the NASTRAN Executive Control Deck. Second, add a statement number to the 
computed-go-to branch vector. This branch vector transfers the XCSA logic to the correct card 
processing section within the module. Third, create the processing code, and add it to the 
module. If additional processing must be performed in XGPI, the Control Table format should be 
modified and the necessary logic added to the XGPI module. 

6.3.1 The NASTRAN Card 

A facility is provided whereby the default values in /SYSTEM/, which are initialized by the 
system Block Data subprogram, SEMDBD, or subroutine BTSTRP, can be altered at execution time. 
The contents of /SYSTEM/ are described in section 2.4.1.8. 

The card which provides this capability is called the NASTRAN card. If this card is used, 
it must be the first card of the data deck (i.e., the card must precede the Executive Control 



6.3-1 



th 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

Deck). The NASTRAN card is a free field card (similar to cards in the Executive Control and 
Case Control Decks). Its format is as follows: 

NASTRAN keyword^ "Value, keyword2=value, ... 

where the list of allowable keywords is as follows: 

1. BUFFSIZE - Defines the number of words in a GIN0 buffer. Note: fixed length records 
written by GIN0 are of length BUFFSIZE - 3. This keyword changes the first word of 
/SYSTEM/. 

2. MAXCIPEN - Defines the maximum number of files that may be open at any one point in the 
program. This keyword changes the 30 word of /SYSTEM/. 

3. C0NFIG - Defines the computer configuration for use in the timing equations in the 
matrix decomposition subroutines SDCSaWP, DEC0MP and CDCJIMP. This keyword changes the 28 
word of /SYSTEM/. 

4. MAXFILES - Defines the maximum number of files to be placed in /XFIAT/ by GNFIAT. This 
keyword changes the 29^ word of /SYSTEM/. 

5. SYSTEM(I) - I refers to the I^'^ word of /SYSTEM/. This is a general form of altering 
any word in /SYSTEM/. Note that BUFFSIZE and SYSTEM(l) are equivalent, and MAXFILES and 
SYSTEM(29) are equivalent. 

Examples of use of the NASTRAN card follow. 

NASTRAN BUFFSIZE=878, SYSTEM(2)=3, MAXiJPEN^lO 

The above card changes the 1^^, 2"*^ and 30^*^ words of /SYSTEM/. SYSTEM(2)=3 changes the system 
output unit from 6 to 3. 

NASTRAN SYSTEM(4)=4, MAXFILES=21 

The above card changes the 4**^ and 29^^ words of /SYSTEM/, SYSTEM(4)=4 changes the system 
input unit from 5 to 4 (which means that all subsequent data must be present on unit 4). 



6.3-2 



THE CASE CONTROL DECK 



6.4 THE CASE CONTROL DECK 



The Case Control Deck is processed by the IFPl module, whose Module Functional Description 
can be found in section 4.3. A card can be added to the Case Control Deck by implementing the 
following steps. 

1. Assignment of a Word in the CASECC Data Block (see section 2.3.1.1). 

If the card datum is to be passed on, a word must be assigned in CASECC. Several words are 
currently empty in CASECC. If more space in the fixed portion of CASECC is needed, modules 
which use CASECC to prepare data blocks for the Output File Processor (0FP) module (e.g., 
SDR2, VDR, PLA3) , will need to be updated since they dre sensitive to the length of CASECC. 
Otherwise, just change the value of LENCC in /IFPIA/. Some Case Control Cards only change 
cells in /SYSTEM/ and do not need space in CASECC. 

2. Addition (or change of) a Key Word. 

To add another key word simply lengthen /IFPIA/ by the number of new words, changing the 
IFPABD Block Data subprogram. The same procedure will allow you to change the spelling of a 
current keyword. 

3. Identification of Card Type. 

In IFPl there are approximately 30 logical IF statements in a row. Simply add another one 
modeled after the existing statements with the new key word. 

4. Addition of Card Dependent Code. 

Add a small internal subroutine to process the new card. The simplest form of such an 
internal routine is to extract one integer from a card of the form SPC =1. In this case 
set "IK" to the word assigned to the card in CASECC and transfer to the common code for this 
purpose. There are many examples of more complex cards under each card type. Changing these 
card dependent areas of code allows easy modification of existing card types. 

5. Restart Implications 

See the subroutine description for IFPIB in the Module Function Description for IFPl for a 
description of the restart functions of IFPl. 



6.4-1 



THE BULK DATA DECK 
6.5 THE BULK DATA DECK 

The module which processes the Bulk Data Deck is the Input File Processor (IFP), whose 
Module Functional Description can be found in section 4.5. There are two primary reasons for 
adding or modifying a bulk data card. First, a new structural element or some other item is to 
be added to the NASTRAN system. This will require additional code in several other modules 
besides the Input File Processor (IFP); however, only IFP changes will be discussed here. 
Second, an alternate form of user input is desired for an already existing item. For example, 
the SPCl card is an alternate for:n of the SPC card. In some cases, an alternate form can be 
accommodated on the same card. An example of this technique is found on the SP0INT card. The 
advantage gained in this case is that changes to the NASTRAN system are isolated to the Input 
File Processor. 

There are three major references for the programmer who desires to make modifications or 
additions to the Input File Processor, Section 2 of the User's Manual gives a functional 
description of each bulk data card. Section 2.3.2 of the Progranmer's Manual describes the 
format of the output data blocks generated by the Input File Processor, and section 4.5 of the 
Programmer's Manual contains a description of the processing flow which occurs within IFP. Any 
programmer responsible for making changes to the Input File Processor would be well advised to 
select a card which is similar to the one he is changing or implementing and "follow It through" 
the code, using the three references described above to guide him. 

In most cases, the work required to add a new card will amount to adding entries to already 
existing tables in the IFP Block Data subprograms. The detailed steps for adding a new card to 
the Input File Processor are listed below. 

1. Add the card name and corresponding table data to the IFP data tables contained in 
Block Data Subprograms IFXIBD, IFX2BD, IFX3BD, IFX4BD, IFX5BD, IFX6BD, and if needed, 
IFX7BD. The meaning of these entries is discussed in section 4.5.7. 

2. Add an entry in the IFP code to call one of the IFP secondary routines IFSIP, IFS2P, 
IFS3P, or IFS4P, wherein the card dependent processing takes place, and add the necessary 
csrd dependent code to the appropriate secondary routine. 



6.5-1 



iiODIFICATIONS AND ADDITIONS TO NASTRAN 

3. If the new card is to be used in conjunction with a Rigid Format, appropriate entries 
must be made in the restart bit tables in /IFXO/ and in the Rigid Format tables. See 
section 1.10 for details. 



6.5-2 



RIGID FORMATS 
6.6 RIGID FORMATS 

The following steps will allow the addition of a new NASTRAN Rigid Format, 

1. Compile and test the DMAP sequence throughly by running problems on it using APPR0ACH = 
DMAP or by using the ALTER feature with an existing Rigid Format. 

2. All Rigid Formats must be classified F0RCE or DISPLACEMENT. A call to a subroutine which 
stores the new Rigid Format must be added to subroutine XRGDFM of module XCSA (see section 
4.2). The subroutines which contain current Displacement Rigid Formats are called LDi , 

i = 01, 02, ..., 12. Dumtny calls are already setup for Displacement Rigid Formats LD45-LD50. 
They correspond to solutions 13 through 19. By choosing to use solutions 13 through 19 and 
creating the appropriate LDi routine, this step can be skipped. 

3. An LDi routine must be written. The LDi routine must write the DMAP sequence, the 
Decision Tables, the File Name Table, and the Card Name Table on the NPTP. The format 
is as follows: 

Record 1 : 

This record contains the coded DMAP sequence, 4 characters per word. Note that every 

DMAP instruction must end with the character: $. In the existing LDi programs the data for 

this record are stored in the RD array. 

Record 2: 



Number of 
Words 



NBIT*DMAF 



Contents 

Number of DMAP instructions (NDMAP). 

Number of words in the decision table for each DMAP 
instruction (NBIT), 1 < NBIT < 5. 

Decision table for each instruction with the entries for 
instructions not in this subset set to zero. The words 
cannot be all zero. The zeroing of the subset entries 
can be accomplished by a call to XSBSET. (See XCSA MFD 
write-up). In the existing LDi programs, this table is 
stored in the IS! array. 

Number of entries in the File Name Table (NFILE). This 
number may be zero if no File Name Table is desired. 



6.6-1 



MODIFICATIONS AND ADDITIONS TO NASTRAN 



Number of 
Words 

3*NFILE 



3*NCARD 



Contents 

File Name Table - Each entry consists of 2 BCD 
words giving the data block name of any data 
block In the Rigid Format and one integer giving 
Its bit position in the Decision Table. In the 
existing LDi programs, the File Name Table is stored in 
the JNM array. 

Number of entries in the Card Name Table (NCARD). 

This number may be zero if no Card Name Table is desired. 

Card Name Table - Each entry consists of 2 BCD words 
giving the card Name of any NASTRAK Data Card and 
one integer giving its bit position in the Decision 
Table. In the existing LDi programs, the Card Name Table 
is stored in the INM array. 



To modify an existing rigid format the appropriate tables (Decision, Card Name, File Name or 
DMAP) should be changed. Their locations in the existing LDi routines are detailed above. 



6.6-2 



FUNCTIONAL MODULES 

6.7 FUNCTIONAL MODULES 

A functional module communicates with the NASTRAN Executive System, and hence indirectly with 
other functional modules, only through its input data blocks, its output data blocks and its 
DMAP parameters. Hence a modification to a functional module which disturbs neither its output 
data blocks nor its DMAP parameters can be made without changing any other functional modules. 
If a modification to a functional module affects its output data blocks or its DMAP parameters, 
it must be determined (by referring to section 4, Module Functional Descriptions, of the Pro- 
grammer's Manual and/or section 3, Rigid Formats, of the User's Manual) what modules use these 
output data blocks and DMAP parameters as input. If these modules are numercus, or if the 
changes to them are very extensive, 1t may be more profitable to write a new module(s) to 
accomplish the task at hand. 

To add a functional module to the system three changes must be made: 1) update the Module 
Properties List (MPL) , the Executive table which contains the (DMAP) name of the module, the 
number of input data blocks, the number of output data blocks, the number of scratch data blocks 
and the DMAP parameter list (see the description of the MPL in section 2.4 for more details); 
2) update the Link Specification Table (LNKSPC), the Executive table which contains the (DMAP) 
name of the module, the module's entry point name and the link residence keys for the four machine 
types (see the description of the LNKSPC table in section 2.4 for more details); and 3) update 
one or more link driver routines, XSEM1 , (see section 3.3.7) so that the module is called from 
one or more links. Steps 2 and 3 have been automated within the NASTRAN system. These auto- 
mated procedures are described in sections 6,11.3.1 and 6.11.3.2 respectively. 



6.7-1 



STRUCTURAL ELEMENTS 

6.8 STRUCTLRAL ELEMENTS 

Code which is structural e'lement dependent is found in the following modules: IFP. IFP3 
(conical shell element only), GPl , GP2. GPS, TAl , PLTSET. SMAl , SMA2. SSGl , SDR2, DSMGl , PLAl , 
PLA3, PLA4, and 0FP. To modify element dependent code in any of these modules, the corresponding 
Module Functional Description in section 4 and the mathematical descriptions of the elements at 
the end of section 4 should be consulted. To add an element to the NASTRAN system the following 
changes are required to the above referenced modules. 

6.8.1 IFP (Input File Processor ) 

An element connection (e.g., CRfilD) bulk data card will have to be designed and added to the 
set of admissible NASTRAN bulk data cards. An element property card (e.g.. PR0D) may have to be 
added. See section 6.5 for details on additions to the Bulk Data Deck. 

^•^•2 GPl, GP2. GP3, and TAl (Geometry Processor and Table Assembler Modules ) 

Processing of element data in GPl, GP2. GPS, and TAl is entirely controlled by descriptive 
infomation contained in /GPTAl/ (see section 2.5.2.1). If a new element is to be added to 
NASTRAN, the following changes are made to /GPTAl/: 

WORD CHANGE 

1 Increase the number of entries by 1. Call the new 

number of entries n. 

2 Increase the pointer to the last element by the 

number of words per entry (currently 13). 

3 No change 

4 ■*■ (n-l)*13 T n ^ .u 

5 + (n-l)*13 Include the new element name. 

6 + (n-l)*13 Assign a new element type identification number which 

is unique. 



7 + (n-l)*13 
16 + (n-l)*13 



Complete items in accordance with definitions in 
section 2.5.2.1. 



Notes; 



1. The new entry should be inserted so that the alphabetical sort on words 1 and 2 of each 
entry in the table is maintained. 



6.8-1 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

2. The new element type identification number will be used by any module reading the 
ECPT, EST, ECPTNL. ECPTNLl , ESTNL or ESTNLl data blocks. 

6,8.3 PLTSET (Plot Set Definition Processor ) 

Processing of element data in PLTSET is controlled by descriptive information in /EDES/. which 
is initialized in the EDESBD Block Data subprogram {see section 4.23.9.2). If the new element to 
be added is to be plotted, the following changes are to be made to /EDES/. 

1. Increase the first word of /EDES/, the number of element types defined In this table, 
by one. 

2. Add the two word BCD name of the element to the ENAM array in /EDES/. The name of the 
element here is defined to be the connection bulk data card mnemonic with the leading 
character "C" deleted. For example, the name of the element defined by a CR0D connection 
card would be "R0D". 

3. Add the two word element code defined for subroutine L0CATE to the array EC0D in /EDES/, 
so that the connection card record in the ECT data block may be found. 

4. Update the EWRD, ENGP and ESYM arrays in /EDES/ (see section 4.23.9.2). 

6.8.4 SMAl (Structural Matrix Assembler - Phase 1) 

In order to add an element the following changes must be made in module SMAl. 

1. The FORTRAN arrays I0VRLY and NW0RDS in /SMAICL/ must be updated in Block Data sub- 
program SMAIBD. 

2. The computed-go-to statement in subroutine SMAIA which performs a branch on element 
identification number must be changed, and a call to the new element routine must be 
Inserted following this computed-go-to statement. 

3. The element subroutine must "insert" only the 6 by 6 submatrlces of the element stiffness 
matrix into the submatrix of [K^g] or [K*g] in core corresponding to the current pivot point, 
NPVT, which is contained in /SMAICL/. The "insertion" routine is subroutine SMAIB. 



6.8-2 (12-1-69) 



STRUCTURAL ELEMENTS 

6.8.5 SMA2 (Structural Matrix Assembler - Phase 2 ) 

The changes outlined above for module SMAl apply equally to module St-IAZ with the following 

name changes: 1) replace /SMAICL/ with /smzCL/; 2) replace SMAIBD with SMA2BD; 3) replace 

SMAIA with SMA2A; 4) replace SMAIB with SHA2B; and 5) replace [K ] with either [M ] or [B ]. 

gg "• gg "• gg-* 

6.8.6 SSGl (static Solution Generator - Phase 1 ) 

Subroutine EDTL of module SSGl is a driver routine which: 1) stores the thermal field, 
2) initializes the MAT routine and 3) processes the EST data block one element type at a time. 
Several changes must be made to EDTL to add an element. 

1. An additional entry must be made to the local F0RTR.AN array NECPT. The entries are the 
number of words per element in the EST. 

2. A computed-go-to on ELTYPE must be changed to point to the new element dependent code. 

3. Element dependent code must be added to: 1) read the EST element entry into /TRIMEX/, 
2) look up the temperature at each element grid point (subroutine FGPTT), and 3) call the 
element routine giving these temperatures as well as the beginning of the load vector array. 

In addition, an element thermal routine must be written to compute the equivalent loads. 
The results of these computations should be accumulatively added to the load vector array. 
Several general purpose subroutines are available for these computations: MAT for finding 
material properties; MPYL and MPYLT for in-core matrix multiplication; BASGLB and GLBBAS for 
coordinate system transformations. The descriptions of these routines can be found in section 3 
or in the "subroutines" section, section 4.41.11, of the Module Functional Description for 
SSGl. 

6.8.7 SDR2 (Stress Data Recovery - Phase 2 ) 

If an element is to be added, the following changes to the SDR2 module must be accomplished. 

1. Create two computation routines: SXXXXl , to generate element stress matrices; and 
SXXXX2, to perform final stress and force computation. Model the above two routines after 
element routines now in the NASTRAN program, e.g., SR0D1 and SR0D2. The "XXXX" in the 
names SXXXXl and SXXXX2 should be 4 letters of the element name. 



6.8-3 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

2. Block Data changes to SDR2BD. 

a) Increase the dimension of ELEM2 by 9 words, and initialize these words with the 
following: 

Word Description 

1 I Element name (BCD - 4 characters/word) 

3 Number of words for the element entry in the EST 
data block. 

4 Number of grid points associated with the element. 

5 Number of words output by SXXXXl. 

6 Number of stress words output by SXXXX2. 

7 Number of force words output by SXXXX2. 

8 Pointer to the first word of complex stress output 
string in the C0MPLX array of subroutine SDR2E, 

9 Pointer to the first word of complex force output string 
in the C0MPLX array of subroutine SDR2E. 

b) Increase data count of NELEM by 1, and increase data count of LAST by 9. 

3. The following change must be made to subroutine SDR2B. 

a) Add an address to the computed-go-to branch vector, and add the call to SXXXXl. 

4. The following changes must be made to subroutine SDR2E. 

a) Add an address to the computed-go-to branch vector, and add the call to SXXXX2. 

b) Increase the dimension of the C0MPLX array, and add a pointer string for 
stresses and forces. If complex stresses and forces are not permitted, set the two 
CI3MPLX pointers in the Block Data subprogram SDR2BD to 0. 

6.8.8 DSMG1 (Differential Stiffness Matrix Generator - Phase 1 ) 

Changes must be made to module DSMGl if either a new element is to have contributions to 
the differential stiffness matrix or a current element which currently has no contribution to 
the differential stiffness matrix is to have contributions. 

The following changes must be made in subroutine DSl. 

1. The local arrays DSARY, NW0RDS and NGPTS must each be updated. The array DSARY is 

defined as follows: DSARY(I) = 1 if the I^*^ element type is an element for which 

6.8-4 (12-1-69) 



STRUCTURAL ELEMENTS 



differential stiffness is defined; otherwise, DSARY(I) = 0. NW!aRDS(I) is the number of 
words of an ECPT data block entry for the I^'^ element, and NGPTS(I) is the number of- grid 
points associated with the I^*^ element. 

2. When appending the components of the displacement vector to the ECPT element entry, 
either the three translational components of displacement at each grid point or all six 
components of displacement at each grid point can be appended. 

The following changes must be made in Block Data subprogram DSIABD and in subroutine DSIA. 

1. The FORTRAN arrays I0VRLY and NW0RDS (the number of words to be read from the ECPTDS 
scratch file), which reside in /DSIAAA/, must be updated. If another element routine overlay 
segment is constructed, NLINKS must be changed. These changes are to be made in DSIABD. 

2. The computed-go-to statement in subroutine DSIA which performs a branch on element 
identification number must be changed, and a call to the new element routine must be 
inserted. 

3. The element subroutine must "insert" only the 6 by 6 submatrices of the element differ- 
ential stiffness matrix into the submatrix of [K^ ] in core corresponding to the current 
pivot point, NPVT, which is contained in /DSIAAA/. The "insertion" routine is subroutine 
DSIB. 

6.8.9 PLAl (Piecewise Linear Analysis - Phase 1 ) 

The following changes must be made to module PLAl if either the added element is to be 
admissible to the set of elements for which Piecewise Linear Analysis is defined or a current 
element is to change its status to an element for which Piecewise Linear Analysis is defined. 

1. The computed-go-to (on element identification number), which reflects whether an element 
is in the set of elements for which Piecewise Linear Analysis is defined, must be altered. 

2. Element dependent code which initializes stress Information appended to the ECPT and 
EST data blocks must be added. The commented code in PLAl along with the descriptions in 
section 2 for the ECPTNL and ESTNL data blocks serve as models for the addition of this code. 

3. The local array, PLAARY. must be updated. PLAARY(I) = 1 if the I**^ element type is an 
element for which Piecewise Linear Analysis is defined, and PLAARY(I) = otherwise. 



6.8-5 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

6.8.10 PLA3 (Plecewise Linear Analysis - Phase 3) 

The following changes must be made to module PLA3 if either the added element is to be 
admissible to the set of elements for which Piecewise Linear Analysis is defined or a current 
element is to change its status to an element for which Piecewise Linear Analysis is defined. 

The following changes must be made to subroutine PLA31 . 

1. The local arrays ESTWDS, which defines the number of words to be read from the ESTNL 
data block for each element, and NGPTS. which defines the number of grid points for each 
element, must be updated. 

2. When appending the components of the displacement vector to the LSTNL element entry, 
either the three translational components of displacement at each grid point or all six 
components of displacement at each grid point can be appended. 

The following changes must be made to subroutine PLA32, 

1. The array ESTWDS. as defined above, must be updated. The array NSTWDS, which defines the 
number of words per element written on the 0NLES data block, must be updated. The array 
NWDSP2, which defines the number of words per entry in the scratch data block ESTNLS. must be 
updated. 

2. The computed-go-to statement which performs a branch on element identification number 
must be changed, and a call to the new element routine must be inserted following this 
computed-go-to statement. 

6,8.11 PLA4 (Piecewise Linear Analysis - Phase 4 ) 

The following changes must be made to module PLA4 if either the added element is to be 
admissible to the set of elements for which Piecewise Linear Analysis is defined or a current 
element is to change its status to an element for which Piecewise Linear Analysis is defined. 

The following changes must be made to subroutine PLA41 . 

1. The local arrays NWjJRDS and NGPTS must be updated. NW0RDS{I) is the number of words to 
be read from the ECPTNL data block, for the I*^ element, and NGPTS(I) is the number of grid 

+ h 

points associated with the I element. 

2. When appending the components of the displacement vector to the ECPTNL element entry. 



6.8-6 



STRUCTURAL ELEMENTS 

either the three translational components of displacement at each grid point or all six 
components of displacement at each grid point can be appended. 

The following changes must be made to Block Data subprogram PLA4BD and subroutine PLA42. 

1. The variables I0VRLY, NW0RDS, and possibly NLINKS, are to be changed in PLA4BD, 

2. In PLA42, the local array NWDSP2, which defines the number of words per element entry 
to be written on the ECPTNLl data block, must be updated. 

3. The computed-go-to statement in PLA42 which performs a branch on element identification 
number must be changed, and a call to the new element routine must be inserted following 
this computed-go-to statement. 

4. The element routine must "insert" only the 6 by 6 submatrices of the element stiffness 

nA-, 

gg-l 



matrix into the submatrix of [k" ] in core corresponding to the current pivot point, NPVT, 



which is in /PLA42C/. 

6.8.12 gIFP (Output File Processor ) 

0FP will automatically print, using the TABPT routine, any data not recognized, and this 
Includes undefined (new) element stress and force output. If standard NASTRAN formatting is 
desired, the NASTRAN systems programmer should implement additional heading formats to 0FP1A 
and pointers in the Block Data subprograms 0FP1BD, 0FP2BD, 0FP4BD, and 0FP5BD. This data may be 
selected by noting the data for currently operating element outputs. Reference the Module 
Functional Description for 0FP and the data block descriptions in section 2 for any stress or 
force output data block, e.g., 0ES1, 0EF1 



6.8-7 



PRINTED OUTPUT 

6.9 PRINTED OUTPUT 

The majority of the NASTRAN data scheduled for output are input to the Output File Processor 
(0FP) module. This module performs the actual formatting and outputting of the data. 

To implement additional output capability in the 0FP, the following ground rules should be 
observed in designing a data block intended to be input to 0FP for output to the system printer 
or punch unit. 

1. The data block's name, for consistency, should begin with an "0". 

2. There should be one or more repeating record pairs, where the record pair is of the 
following form: 



WORD 

1 

2 

3 

4 

5 



MODE 


DESCRIPTION ' 


Available for Data 




I 


Major ID 


I 


Minor ID 


I 


Subcase ID 



Icentification 
Record 



• 


Available for Data 




9 






10 


I 


Number of words 


11 




per entry 


• 


Available for Data 




50 






51 


BCD 


32 Words Title 
32 Words Subtitle 
32 Words Label 


146 


BCD 





(An odd- 
numbered 
Record) 



Repeating data entries of the length specified in the 
preceding record. This record may be null but should 
exist. 



Data Record 
(An even- 
numbered Record) 



6.9-1 



Major ID 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

3. The Major ID is formulated depending on the data type as follows. 

a. For a new data type an integer should be selected which equals I, where I is a value 
one greater than the current number of accepted data types within 0FP. 

b. The Major ID then depends on the data classification 

I = S0RT1 - Real 
1000 + I = SQRTl - Complex 
2000 + I = S0RT2 - Real 
3000 + I = S0RT2 - Complex 

4. The Minor ID is optional to distinguish subclasses of the Major ID. 

With the data block format outlined above, the NASTRAN systems programmer may implement the 
new data formats within the current 0FP procedure by modeling from any current data type now 
handled by 0FP. The current 0FP has dynamic formatting for the outputting of entries of the 
Data Record. However, if the programmer is not familiar with the five level pointer procedure 
used for the dynamic formatting, it is recommended that he implement logic to explicitly output 
the Data Record. 

0FP will, without modification, output new data blocks via the table print routine, TABPT. 



6.9-2 



PLOTTER OUTPUT 

6.10 PLOTTER OUTPUT 

Plotted output in NASTRAN 1s restricted to three modules: 1) the Structural Plotter (PL|2T - 
see section 4.24); 2) the XY Plotter (XYPL0T - see section 4.69); and 3) the Matrix Plotter 
(SEEf'IAT - see section 4.74). Each of these modules uses the NASTRAN plotter software package of 
utility routines, each of which is individually documented in section 3.4. 

6.10.1 Changes to the Plotter Software 

In order to add a new plotter to the NASTRAN plotter software, the following must be done: 
1) up to four (4) new subroutines (AXISi, LINEi, TYPEi , WPLTi) must be written, where "i" is the 
internal index of the new plotter (see section 3.1 for the current values of i); and, 2) changes 
and/or additions must be made to ten (10) existing subroutines (AXIS, FNDPLT, LINE, PL0TBD, SELCAM, 
SKPFRM, SYMBOL, TIPE, TYPFLT, TYPINT). 

Initially, it should be decided which of the four possible new subroutines will be needed for 
the new plotter. For the most part, three will be the minimum: LINEi, TYPEi, WPLTi. If the new 
plotter has no typing capability, an existing subroutine, DRWCHR, will be used in place of TYPEi. 
It is strongly recommended that the calling sequences of any new subroutines be the same as those 
of their existing counterparts. None of the four possible new subroutines should present much 
difficulty to the programmer if he uses their existing counterparts as models. 

Subroutine AXISi need only be written if the following two conditions are true on the new 
plotter: 1) lines must be drawn generally as a series of short lines; and 2) there does exist a 
special plotter instruction permitting the drawing of a horizontal or vertical line without repre- 
senting it as a series of short lines. Both of these conditions do exist for plotter 3 and may 
exist for plotter 10. If either one of these two conditions is not true for the new plotter, then 
LINE should be used in place of AXISi. 

Subroutine LINEi is always required. If the new plotter must be put into the line drawing 
mode before any lines can be drawn, LINEI, LINE2, LINE9 and LINEIO should be used as models. If 
the new plotter is an incremental plotter, LINE4 should be used as the model. Otherwise, use 
LINE3 as the model. In addition, LINEI, LINE2 and LINE3 represent lines as series of short lines; 
LINE9 and LINEIO use only one plot command to draw a line of any length. 



6.10-1 (12-1-69) 



MOUiFICATlONS AND ADDITIONS TO MASTRAN 

Subroutine TYPEi should be written if there is a typing capability on the new plotter. If 
the new plotter must be put into the typing mode before any lines can be drawn, TYPEI, TYPE2, 
TYPE9 and TYPEIO should be used as models. Otherwise, use TVPE3 as the model. All characters 
should be vertically oriented and miniature in size. Each of the model subroutines has three 
important symbols initialized in a DATA statement: LSTCHR, NCHR and CHAR. LSTCHR is the index 
of the last legitimate character in the CHAR94 table (see section 2.5) available on the new 
plotter. NCHR is the number of characters for which the character code on the new plotter differs 
from the corresponding character code in the CHAR94 table. CHAR is a list of NCHR pairs of 
indices into the CHAR94 table: CHAR, . is the index value of the character code which will pro- 
duce the wrong typed character on the plotter, and CHAR^ - 1s the index value of the character 
code which will produce the correct typed character. One further note: some plotters have both 
a "typewriter" and "single-character typing" mode. The existing TYPEi subroutines use only the 
"single-character typing" mode. It is strongly recommended that this policy be continued for all 
new plotters. 

Subroutine WPLTi is almost entirely dependent upon the structure of the plot commands for 
the new plotter. The existing WPLTi subroutines will help the programmer only insofar as the over- 
all logic is concerned. Once the plot command is constructed, it is written using subroutine 
SWRITE. Some plotters also require special information at the beginning and/or end of each 
record on the plot tape. If this is the case with the new plotter, WPLT3. WPLT4, WPLT9 and WPLTIO 
contain the logic necessary to recognize the beginning and/or end of a plot tape record. In 
addition, all the existing WPLTi subroutines, except for WPLT4, generate fixed-length plot commands. 
This results in a simpler subroutine and also adapts easier to the computer-independent char- 
acteristic of NASTRAN. It is therefore recommended that this policy be continued, if at all 
possible, for all new plotters. 

Of the ten (10) subroutines to which changes and/or additions must be made, changes in six 
of the ten subroutines are dependent upon a) the internal index of the new plotter; and b) which 
of the four possible new subroutines have been written. These j'x (5) subroutines are: AXIS, 
LINE, SYMBOL, TIPE, TYPFLT and TYPINT. In each there are one or two computed-go-to statements 
based upon the internal index of the new plotter which will have to be enlarged. Then corres- 
ponding statements calling the new subroutines (AXISi, LINEi , or TYPEi) will have to be added. 
If an AXISi subroutine was not written for the new plotter, subroutine LINE should be called 

6.10-2 (12-1-69) 



PLOTTER OUTPUT 

from subroutine AXIS instead of calling AXISi. If a TYPEi subroutine was not written for the new 
plotter, then subroutine DRWCHR shnuld be called from subroutines SYMB0L, TIPE, TYPFLT and TYPINT 
insteiid of calling TYPEi, 

Subroutine FMDPLT relates the external plotter and model names with its internal plotter and 
model indices. There is a table witiiir. this subroutine which reflects this relationship. The 
programmer need only append the extern.'! name of the new plotter and/or an additional model name 
to an existing plotter, together with tiie corresponding internal plotter and model indices. In 
addition, the value of the variable MPLTRS will have to be incremented by one whenever a new 
external plotter name is added. 

Subroutine PL0TBD is a Block Oata subprogram. Both the PLTDAT and SYMBLS tables (see 
section 2.5) must be expanded to reflect the addition of the new plotter. A new 20-word section 
must be appended to the PLTDAT table reflecting the physical characteristics of the new plotter. 
The values in this new section iiiust correspond on a one-to-one basis with the values defined for 
the existing plotters. In addition, the buffer size defined for the new plotter must be a 
multiple of 60 characters if computer independency is to be preserved. A new 20-word section must 
be appended to the SYHBLS teble. The first "MSYM" values in this new section are indices into 
the CHAR94 or CHRDRW tables (see section 2.5). These indices represent the special symbols used 
by the SYMB{)L subroutine for the new plotter. 

A new section must be added to subroutine SELCAM. The function of the new section varies 
depending upon the requirements of the new plotter. If the new plotter is a table plotter, a 
plot command should be generated to stop the plotter so that the operator can prepare for the 
next plot. If the new plotter is a microfilm plotter, the requested camera must be selected. 
Some plotters require a special "header" record at the beginning of each plot. If so, it must 
be generated in this subroutine. Again, the function of this subroutine varies depending upon 
the requirements of the new plotter, and as a result, the added section is very likely to be 
entirely plotter-dependent. In addition, there are two computed-go-to statements (based upon 
the internal index of the new plotter) which must be enlarged to reflect the new plotter. 

The last subroutine to which changes and/or additions must be made is SKPFRM. Its function 
is to skip a variable number of frames on a microfilm plotter, or to skip over the current plot 
on a drum plotter. If the new plottes is neither a microfilm nor a drum plotter, no new section 

5.10-3 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

is needed. In either case, there is a computed-go-to statement (based upon the internal index of 
the new plotter) which must be enlarged to reflect the new plotter. If the new plotter is a 
microfilm plotter, the commands necessary to skip the frame(s) must be added to the subroutine 
(e.g., plotters 3 and 9). If the new plotter is a drum plotter, then the comr.ands necessary to 
skip over the current plot must be added to the subroutine (e.g., plotter 4). As with subroutine 
SELCAM, any added section is very likely going to be plotter-dependent. 

Finally, an important word of caution to the programmer must be stated: if the computer and 
installation independence of the NASTRAN plotter software package is to be maintained, no existing 
software provided for his computer or installation ought to be used to accomplish the task of 
adding a new plotter to the NASTRAN plotter software package. This restriction prevents the 
direct usage of on-line plotters. NASTRAN does provide however for the indirect usage of on-line 
plotters as described in section 6.10.6. 

6. ,0.2 Changes to the PLgT Module, the Structural Plotter 

In order to add a new plotter to the NASTRAN structural plotter module, PL0T, only one 
subroutine need be altered: PLT0PR. This subroutine generates messages to the plotter operator. 
Probably the only message which should be added is one to identify the plotter for which the 
structural plots are being generated. There is a repertoire of other messages in this subroutine 
which should be general enough to apply to any plotter type. If additional messages are needed, 
the programmer must remember that the plotter operator is not normally a "programmer type". 
Hence he will be more apt to respond to messages written in his language than to messages written 
in programming terminology. In addition, there are several computed-go-to statements based upon 
the internal index of the new plotter. These will have to be enlarged to reflect the new plotter. 

6.10.3 Changes to the XYPL0T Module, the XY Plotter 

No changes are required within the XYPL0T module when adding a new plotter. However, a minor 
change is required in subroutine IFPIXY of the IFP module if and only if the new plotter uses the 
NASTRAN BCD plot tape, PLTl . If this is the case, the new internal plotter number which is gen- 
erated by subroutine FNDPLT of the NASTRAN plotter software should be added to the F0RTRAN logical 
IF statement directly after the following comment in subroutine IFPIXY: 



6.10-4 (3/1/70) 



PLOTTER OUTPUT 



C 

C IF M0RE BCD PLOTTERS ARE ADDED EXPAND THE FiZLL0WING TEST 

C 

6.10.4 Changes to the SEEMAT Module, the Matrix Plotter 

No changes to the SEEMAT module are necessary when a new plotter Is to be added since the 
plotter and model names are communicated to the module through the DMAP calling sequence (see 
section 4.74). 



6.10-5 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

6.10.5 Use of the NASTRAN Plotter Software in a New Module 

There exists in NASTRAN a self-contained computer-independent environment for creating plots 
on a large number of plotters. Currently three modules use this environment: 1) PL0T, the 
Structural Plotter; 2) XYPL0T, the XY Plotter; and 3) SEEMAT, the Matrix Plotter. In order for 
another module to generate plots in this same environment, it is essential that the module writer 
understand this erivironment. 

The NASTRAN plotting environment can be understood most easily if viewed as being composed 
of five parts: 1) parameter definitions; 2) parameter initialization; 3) plot initiation; 4) plot 
creation; and 5) plot termination. 

There is one DMAP parameter (passed through blank common) and two named common blocks in the 

parameter definition section of the NASTRAN plotting environment. The DMAP parameter is PLTNUM, 

the plot number of the last plot created, and is both an input and output integer value. The two 
named common blocks, with their symbolic contents, are as follows: 

C0MM0N/XXPARM/PBFSIZ,MEDIUM,BFRAMS,SKIP(4),XPAPSZ,YPAPSZ 

where: 

PBFSIZ = size of the plot tape buffer (integer) 
MEDIUM = medium output request (integer, default value = 2) 
1 = film only 
= < 2 = paper only 
3 = both 
BFRAMS = number of blank frames (on film only) between plots (integer, default 

value = 1) 
XPAPSZ = width of the paper (inches, for table plotters only) to be used (real, 

default value = 8.5 inches) 
YPAPSZ = height of the paper (inches, for table plotters only) to be used (real, 
default value = 11.0 inches) 
C0MM0N/PLTDAT/M(3DEL,Pl.!aTER,REGI0N(4),AXMAX,AYMAX,XEDGE.YEDGE,SKIP(lO),PCNTIN,CNTCHX,CNTCHY, 
SKIP(4) ,PLTYPE,PLTAPE,SKIP(2) .FCNTIN 



6.10-6 (12-1-69) 



PLOTTER OUTPUT 



where: 



M0DEL = model index of the plotter to be used (integer, default value = 1) 
PL0TER = plotter index of the plotter to be used (integer, default value = 3 - the 

SC 4020 microfilm plotter) 
REGI0N = the region of the plotting surface (x^^^.^, y^^^^, x^^^, y^^^^) in which a plot 

is being created (real) 
AXMAX = width of the plotting surface less any borders (real) 
AYMAX = height of the plotting surface less any borders (real) 

XEDGE = width of the border on the left and right side of the plotting surface (real) 
YEDGE = height of the border on the top and bottom of the plotting surface (real) 
PCNTIN = number of counts (plotter units) per inch of paper (real) 
CNTCHX = the width (includes horizontal spacing between characters) of each printed 

or drawn character (real) 
CNTCHY = the height (includes vertical spacing between characters) of each printed 

or drawn character (real) 
PLTYPE = plotter type (integer) 

j^l = microfilm plotter 
= /+2 = table plotter 

+3 = drum plotter 

<0 if no typing capability exists on the plotter. 
>0 if typing capability does exist on the plotter. 
PlTAPE = GIN0 file name of the plot tape (BCD) 
(PLTl for an even parity plot tape 
IpLT2 for an odd parity plot tape 
FCNTIN = number of counts (plotter units) per inch of film (real, FCNTIN = PCNTIN if 
the plotter is not a microfilm plotter) 



The usage and initialization of each of the variables listed above are detailed in the following 
descriptions of the four remaining sections of the NASTRAN plotting environment (see section 2.5 
for a more detailed description of /XXPARM/ and /PLTDAT/). 



6.10-7 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

The parameter initialization section of the NASTRAN plotting environment involves initializing 
all the variables listed above for the /XXPARM/ and /PLTDAT/ named common blocks, with the excep- 
tion of MEDIUM and BFRAMS. First, the plotter and model indices (PL0TER, M0DEL) of the plotter 
to be used must be set by using subroutine FNDPLT: 

CALL FNDPLT (PLTTER,M(3DELN,PLTID,M0DID) 

where: 

PLTTER = plotter index of the plotter specified in PLTID and M0DID (integer, output) 
M0DELN = model index of the plotter specified in PLTID and M0DID (integer, output) 
PLTID(2) = 8 character name (4 characters per word, left-adjusted, with all remaining 

characters blank) of the plotter of interest (BCD, input). 
H0DID(2) = model identification of the plotter of interest. M0DID. may either be 

numeric or BCD, depending upon the way in which various models are identified 
for the plotter of interest. If M0DID^ is BCD, it must be 4 characters, 
left-adjusted, with all remaining characters blank. (Integer and/or BCD, 
input and output) . 
See section 3.1 for a list of current plotter and model names. 

Subroutine FNDPLT will attempt to match PLTID with an internal list of plotters available in 
the NASTRAN plotting environment. If no match is found, FNDPLT sets both PLTTER and M0DELN = 
and immediately returns. Otherwise, FNDPLT will attempt to match M0DID with an internal list of 
models for the plotter of interest. If no match is found, a default model for the plotter is 
stored in M0DID. Then the corresponding plotter and model indices are stored in PLTTER and M0DELN. 
Generally, PLTID and M0DID will be provided by the NASTRAN user. It is suggested that the module 
writer set M0DID(1) and M0DID(2) equal to zero before inserting the user supplied values for 
M0DID. This provides the user with the capability of defaulting to a standard default model for 
his specified plotter by supplying no values for M0DID or by supplying a value only for M0DID(1). 

Having called subroutine FNDPLT to determine the plotter and model indices, the module writer 
should then set PL0TER and I'10DEL equal to PLTTER and M0DELN, respectively: 

PL0TER = PLTTER 

MODEL = M0DELN 

6.10-8 (12-1-69) 



PLOTTER OUTPUT 

Next, the remainder of the /PLTDAT/ named common block must be initialized. Subroutine 
PLTSET must be used to do this. PLTSET sets all the variables in /PLTDAT/, except M0DEL and 
PL0TER, to values dependent upon the plotter index (PL0TER). In addition, if the plotter is a 
table plotter, AXMAX and AYMAX are also functions of the paper size (XPAPSZ, YPAPSZ) . For this 
reason, if the current or default paper size is to be changed, it must be done before calling 
PLTSET. Finally REGI(3N is initialized in PLTSET as follows: 

REGigfN(l) = 0. 

REGI!2N(2) = 0. 

REGIi2N(3) = AXI^X 

REGI!aN(4) = AYMAX 

and the plot tape buffer size (PBFSIZ) in the /XXPARM/ named common block is initialized. 

This completes the parameter initialization section of the NASTRAN plotting environment. 

The next step is plot initiation . Once this step is initiated, none of the parameters in either 

the /XXPARM/ or /PLTDAT/ named common blocks may be changed, except for MEDIUM, BFRAMS and 
REGION, without repeating the parameter initialization step. 

In the plot initiation step, the module writer must first ensure that the plot tape (PLTAPE) 
is indeed a physical tape . This can be done by using logical function TAPBIT. If the function 
result is .FALSE., the plot tape is not a physical tape and hence no plotting should be attempted 
by the module: 

IF (.N0T.TAPBIT(PLTAPE)) "no physical tape setup" 

Having verified the existence of a physical plot tape, an array of PBFSIZ words must be provided 
for the NASTRAN plotting software as follows: 

CALL S0PEN ($n, PLTAPE, BUFFER, PBFSIZ) 

where: 

n = F0RTRAN statement number to which S0PEN is to return if PLTAPE has not been 

correctly initialized. 
BUFFER = an array of PBFSIZ full words. 



6.10-9 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

Next, the plotter must be started. However, before doing this, the plot number (PLTNUM) 
should be incremented by one. In addition, this is the module writer's last opportunity to change 
the medium request (MEDIUM) and the number of blank frames between plots (BFRAMS). To start the 
plotter, the module writer must call subroutine STPL0T: 

CALL STPLJ3T (PLTNUM) 

Subroutine STPL0T will select the proper medium (if appropriate), generate an identification plot 
(if necessary), and insert the specified number of blank frames (on film only). 

Having initiated a plot, the module writer must then create the plot. In the plot creation 
section of the NASTRAN plotting environment, there are seven (7) subroutines provided for various 
tasks: AXIS, LINE, PRINT, SYMB0L, TIPE, TYPFLT, TYPINT. An explanation of the calling sequence 
and purpose of each of these subroutines exists in section 3. It is essential that the module 
writer familiarize himself with the calling sequences and purposes of these subroutines. In 
addition, it is just as essential that he also understand a certain amount of the philosophy which 
exists in these subroutines as a class. What follows is an attempt to explain this philosophy, 
together with pertinent suggestions. 

There are three operating modes defined in these seven subroutines: 1) axis mode; 
2) straight line mode; and 3) typing mode. These three modes are totally independent of each other 
and are mutually self-exclusive . What this actually implies is that only one mode can be active 
at any one point in time. Subroutine AXIS operates in the axis mode; subroutine LINE operates 
in the straight line mode; and subroutines PRINT, SYMB0L, TIPE, TYPFLT and TYPINT all operate 
in the typing mode. 

Each of these subroutines has a common argument, which is always the last argument in each 
of the calling sequences. This argument (0PT) is used to initiate a mode (0PT=-1), operate within 
a mode (0PT=O), or terminate a logical subset of plot commands within a mode (0PT=+1). Only 
while operating within a mode (0PT=O) do any of the other arguments in a calling sequence have 
any meaning. For this reason, it is usually a good practice to use zeros for the other arguments 
when initiating a mode or when terminating a logical subset of plot commands. 

It is strongly recommended that the set of all commands used to create a plot be grouped into 
logical subsets of commands, with each subset operating in only one of the three possible modes. 

6.10-10 (12-1-69) 



PLOTTER OUTPUT 

This does not mean that all axes or all lines or all typing be included in one subset of commands. 
In many cases it is more logical to create several subsets of axis commands or straight line 
commands. The module writer must call one of the subroutines which operates within the same mode, 
with 0PT=-1, so that the mode will be properly initiated . It is then recommended that, following 
such a subset of commands, the module writer again call one of the subroutines which operates 
within the same mode, with 0PT=+1 , to terminate the subset of plot commands. An example of these 
recommendations is as follows: 

CALL TIPE (0,0,0,0,0,-1) 

CALL PRINT ( ,0) 

CALL TIPE ( .0) 

CALL SYMB0L ( 0) 

CALL TYPFLT ( O) 

CALL TYPINT ( 0) 

CALL TIPE (0,0,0.0,0,+1) 

Generally, the module writer should avoid constantly changing plot modes. This is suggested 
for two reasons. First, some plotters operate very inefficiently in a mode switching environment. 
Second, should an error exist in either the software or hardware, it might be necessary to dump 
the generated plot tape. Interpreting this dump would generally be no easy task. However, if the 
idea of creating subsets of commands was used in generating the plot tape, the task of locating 
the command(s) causing the problem(s) would be eased considerably in most cases. 

All the subroutines used 1n creating a plot require that at least one of the arguments be the 
location of a point on the plotting surface. In each case, the point(s) must be specified as real 

6.10-11 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

numbers already scaled to the plotter units. There is no general recommendation as to when this 
scaling should take place. In some cases, it would be more logical to perform all the scaling at 
once. In other cases, it would be more logical to perform the scaling on each subset of plot 
commands. While in other cases, it would be more logical to perform scaling only on an as-needed 
basis. The choice is left entirely to the discretion of the module writer. Since AXMAX and AYMAX 
in the /PLTDAT/ named common block define the width and height of the plotting surface in plotter 
units, and since the plotter origin can always be assumed to be in the lower left corner of the 
plotting surface, the required scaling ought to be a relatively easy task. 

The lower left corner of the plotting surface is always at (0.,0.), while the upper right 
corner of the plotting surface is always at ( AXMAX, AYMAX ) . These are also the default values of 
REGI0N (see the /PLTDAT/ named common block) as set by the PLTSET subroutine. The purpose of the 
REGI0N parameters is to define a rectangular plotting area, outside of which no plotting is to be 
attempted. For this reason, each of the seven subroutines used in creating a plot always compares 
the point(s) specified in the calling sequence with the REGI0N values. No portion of any line or 
axis will be drawn outside the corresponding rectangular plotting area. Nor will any typing be 
attempted outside this same area. The usage of these REGI0N parameters is left to the discretion 
of the module writer and the requirements of the module design. In most cases, the default values 
of REGI0N will not be altered by the module. One situation in which the REGION parameters will be 
altered is when the user has the capability of specifying that a plot is to be drawn only within 
a specific portion of the total plotting surface and that any part of the plot which appears 
outside this area is not to be drawn. In any case, if the REGI0N parameters are altered within 
the module, this can be done at any time on an as-necessary basis. 

Having created the desired plot in the plot creation step, the only remaining task for the 
module writer is terminating the plot. This is a very simple task, accomplished by calling 
STPL0T: 

CALL STPL0T (-1) 

This subroutine, which was also used to initiate the plot, upon sensing a negative argument, will 
terminate the current subset of plot commands, skip to a new frame (if appropriate), and write an 
end-of-file mark on the plot tape (if necessary). 



6.10-12 (12-1-69) 



PLOTTER OUTPUT 

If additional plots are to be created within the same module, the entire process just des- 
cribed must be repeated, starting with step 3 (plot initiation). If, however, a new plotter is 
specified for the succeeding plots, step 2 (parameter initiaiization) must also be repeated. If 
a new paper size is specified, subroutine PLTSET must be re-executed prior to repeating step 3. 

This concludes the description of the MASTPM plotting environment. There are two other 
sections in the MASTRAN Programmer's Manual which deal with this environment. It is suggested 
that the module writer read these sections also so that he may acquire more of an understanding of 
the NASTRAN plotting environment than this section affords him. These other sections are: Changes 
to the Plotter Software, section 6.10.1, and NASTRAN General Purpose Plotter, section 6.10.6. 



6.10-13 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

6.10.6 NASTRAN General Purpose Plotter 

One feature which the NASTRAN plotting software lacks is the capability of direct usage of 
the plotting equipment attached on-line to a computer. This is due not to special purpose pro- 
gramming, but rather to one of the basic characteristics of NASTRAN: computer independence. Tc 
access on-line plotters would not only make NASTRAN computer-dependent, but probably installation- 
dependent also. This installation dependency would result from the necessity of using special 
subroutines provided by the computer installation to access the on-line plotter, with no guarantee 
that subroutines having the same name and calling sequences would be available at any other 
computer installation. Even so, there would almost certainly occur a subroutine naming conflict, 
due to the great number of subroutines in NASTRAN. 

An effort is made in NASTRAN to partially overcome this deficiency. In general, NASTRAN will 
produce a plot tape which can be used directly by any one of several off-line plotters. In 
addition, NASTRAN can be directed by the user to produce a so-called "General Purpose Plotter" 
tape. Another program, completely external to NASTRAN, would then have to exist, its function 
being to translate this "plot" tape for the on-line plotter so that it will produce the plots 
intended by NASTRAN. This implies that in order to produce a NASTRAN plot, two programs must be 
run: first, NASTRAN itself; and then the external translator program. 

The purpose of this section is to explain the characteristics and construction of the 
"NASTRAN General Purpose Plotter" tape, so that a programmer will be able to write a program to 
translate this "plot" tape for the on-line plotter. Understanding the overall logic used by the 
NASTRAN plotter software package in producing a plot tape will simplify the task of writing this 
translator program. It is therefore recommended that the programmer familiarize himself not 
only with this section of the Programmer's Manual, but also with sections 6.10.1 and 6.10.5, 
which describe the technique of adding a new plotter to the NASTRAN plotting software package. 

The "NASTRAN General Purpose Plotter" tape is composed of a simple set of elementary plot 
operations, which can easily be deciphered by a F0RTRAN program on any digital computer. As each 
operation is deciphered, the translator program should direct the on-line plotter to appropriate 
action. This would normally be done by using the installation software to interface between the 
translate program and the on-line plotter. With the existence of this external translator pro- 
gram, NASTRAN would then have the capability of indirectly referencing the corresponding on-line 

6.10-14 (12-1-69) 



PLOTTER OUTPUT 

plotter. A by-product of this environment is the implied capability of indirectly accessing any 
plotter, whether on-line or off-line, assuming the appropriate external translator programs are 
written. 

The ''MASTRAN General Purpose Plotter" tape is a seven-track, odd parity, fixed-length record 
tape. An end-of-file mark follows the last plot only. Each record is composed of 300 six-bit 
unsigned integers (75 words on an IBM S/360, 50 words on an IBM 7094 or Univac 1108, 30 words on 
a CDC 6600) and is composed of 10 plot commands, each being composed of 30 six-bit unsigned 
integers (15 half-words on an IBM S/360, 5 words on an IBM 7094 or Univac 1108, 3 words on a 
CDC 6600). Not all plot commands will have useful information in all 30 six-bit integers. Some 
commands use only two of the 30 six-bit integers, while others use 22. The general format of each 
command is as follows: 

PCR4R3R2R^RqS4S3S2S^SqT^T3T2T^TqU4U3U2U^Uq00000000 , 

where: 

P = plot command, 

C = control index, 

R^ = decimal digit of an integer called R, 

S^ = decimal digit of an integer called S, 

T^ = decimal digit of an integer called T, 

U^ = decimal digit of an integer called U, 

O = zero . 

The plot command is a six-bit integer, any one of seven (7) possible plot commands, as 
follows: 

= no operation, 

1 = start new plot, 

2 = select camera, 

3 = skip to a new frame, 

4 = type a character (may also = 14), 

5 = draw a line (may also = 15), 

6 = draw an axis (may also = 16). 

6.10-15 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

The control index is also a six-bit integer. It may be a pen number, a line density, a camera 
number, or c pointer into a list of characters and symbols. The four integer values (R,S,T,U) 
specified in a command must be reconstructed by the external translator program. Each integer 
value is represented in the command as follows: 

V3'^2''l''o • 
where the original integer value is given by: 

dglO^ + d^lO"^ + dglO^ + djlO^ + d^lO° . 

The significance of each of the four integer values {R,S,T,U) may vary from one plot command to 
another. 

The no-operation (0) command is simply a padding for plot records which may otherwise have 
been less than 300 characters long. All 30 characters of this command will be zero. 

The start-new-plot (1) command will always be the first command introducing each new plot. 
The first integer (R) will be the plot number. The second and third integers (S and T) are the 
maximum x and y values specified in any other command for this plot. The minimum x and y values 
are always zero and are therefore not specified in the start new plot command. If necessary, the 
translator program can use these maximum x and y values to scale subsequent integer values so 
that the plot will not exceed the limits of the plotting surface. The plot number is included 
because some plotters require the plot number as part of the first command for each new plot. In 
addition, if the receiving plotter is a table plotter, the translator program should issue a 
command to the plotter which will stop it so that the plotter operator can change the paper. If 
the plotter is a drum plotter, the translator program must skip a sufficient amount of paper to 
insure that the previous plot will not be over-plotted. And if the receiving plotter is a micro- 
film plotter, nothing else need be done. 

The select-camera (2) command uses only the control index (C). The remaining 28 characters 
are always zeros. This command is meaningful only on a microfilm plotter having both film and 
hardcopy output. The control index is the camera or medium request number: 1 = film only; 
2 = hardcopy (paper) only; and 3 = both. Upon receiving this command, the translator program 
should issue a command to the receiving plotter selecting the requested camera or output medium, 

6.10-16 (12-1-69) 



PLOTTER OUTPUT 

then this command should be ignored. 

The skip-to-a-new-frame (3) command also uses only the control index. The remaining 28 
characters are always zeros. This command is meaningful only on a microfilm plotter. The 
control index is the camera or output medium request number: 1 = film only; 2 = hardcopy 
(paper) only; and 3 = both. The appropriate camera will have already been selected in a pre- 
vious select-camera command. The only reason the camera number is included in this command is 
because some microfilm plotters require the camera or output medium to be specified in both a 
select camera and skip frame command. Upon receiving this command, the translator program should 
issue a command to the receiving plotter to skip to a new frame. If the receiving plotter is not 
a microfilm plotter, then this command should be ignored. Note: at least one skip-to-a-new-frame 
command will appear after each start-new-plot command and before the next start-new-plot command . 

The type-character (4), draw- line (5), and draw-axis (6) commands will always occur in sets, 
i.e., a set of type-character commands, a set of draw-line commands, a set of draw-axis commands. 
There may be more than one set of each type of command, but within a set the coirmands will all be 
of an identical type. This is done because on some plotters it is very inefficient to frequently 
change modes (e.g., typing mode, line drawing mode) of operation. The plot command of the first 
command in a set will always = 10 + the basic plot command value, i.e., type-character = 14; 
draw-line = 15; and draw-axis = 16. In all subsequent plot commands in the set, the plot coimand 
value will always equal the basic plot command value. 

For a type-character command, the control index is a pointer into a specific list of charac- 
ters and special symbols. The list of characters to which the pointer applies is Section I of the 
CHAR94 table (see section 2.5), with the following exceptions: 48 = dot, 49 = circle, 50 = square, 
51 = diamond, 52 = triangle (point up). The first two integer values (R and S) in the plot command 
represent the x and y coordinates of the point on the plotting surface at which the center of .' 
character or symbol should be typed. The remaining 18 characters of the command are always zeros. 
Upon receipt of a type-character command, the translator program should issue a command to the 
receiving plotter to type the requested character or special synbol at the specified point. Of 
course, there is no guarantee that all the possible characters and special symbols can be type 
the receiving plotter. If any character or special symbol cannot be typed by the receiving 
plotter, the translator program will then have to make a substitution or not type the charac- - .v 
all. 

6.10-17 (12-1-69) 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

For a draw- line command, the control Index is either a pen number (for table and drum plot- 
ters) or a line density (for microfilm plotters). If the receiving plotter is a microfilm plotter, 
it is recommended that the translator program simply draw the line as many times as is indicated by 
the line density value, rather than using any special density settings available on the plotter 
hardware. The first two integer values (R and S) represent the x and y coordinates of the starting 
point of the line. The next two integer values (T and U) represent the x and y coordinates of the 
ending point of the line. The last 8 characters of the command are always zeros. Upon receipt of 
this command, the translator program should issue a command to the receiving plotter to draw the 
line. Note : some plotters require that a line be broken into a series of short lines. If this 
is the case on the receiving plotter, the translator program will have to accomplish this task 
unless the installation software makes provision for this automatically. 

The draw- ax is command is i dentical to the draw-line command. The only difference is in the 
orientation of the drawn line. The line drawn by a draw-axis command will always be either hori- 
zontal or vertical. For most plotters, the translator program will handle this command just like 
a draw-line command. However, some plotters which would ordinarily require that lioes be broken 
Into a series of short lines, may have a special command available to draw a horizontal or vertical 
line of any length. For these few plotters only will this command have any special significance 
in the translator program. If such is the situation, the translator program, upon receipt of 
this command, should issue a command to the receiving plotter to draw the axis. Otherwise, the 
translator program should simply issue a command to the receiving plotter to draw a line repre- 
senting the axis. 



5.10-18 (12-1-69) 



ADDITION OF A NEW LINK 

6.n ADDITION OF A 'AEU LINK 

Links can be added to the NASTRAN system with little effort if the total number of links does 
not exceed fifteen (15). There are at present thirteen (13) links. Links are numbered consecu- 
tively, and this should be maintained. If the total number of links must exceed 15, Executive 
System changes to increase the link limit will be required. These Executive System changes are 
described in section 6.11.5. 

It is assumed that the reader is familiar with the other alternatives for adding new material 
to the system (section 6.2 through 6.10), and that a new link is normally needed only if the 
addition of new modules to a present link makes that link non-executable because of an excess of 
overlay structure or decks. In this case, the programmer generates a new link through the 
following steps (assuming the link limit is not exceeded): 

1. Decide what modules to include in the new link. 

2. Add any new modules to the MPL Executive table (see section 2.4.2.2) in deck XMPLBD. 

3. Generate a new Link Specification Table and a new link driver. 

4. Subsys (create an absolute element of) the new link. 

6.11.1 Modules to Include 

The following entry points of Executive modules must be included in each new link: XCHK, 
XCEI, XSAVE, XPURGE, XEQUIV, XSFA and QPARAM. The following non-root segment subroutines must 
be included in each new link: MSGWRT, USRMSG, BTSTRP, ENDSYS and XEj3T. The following DMAP 
output modules should be included in each new link: TABPT, MATPRN and PRTPARM. Diagrams for 
the IBM 7094/7040(44) DCS overlay structures for all these routines can be found In section 5.2.9. 
The addition or use of any other module 1s at the discretion of the NASTRAN systems programmer. 
Any existing NASTRAN module can be included in the new link if it is so desired. 

6.11.2 Addition of New Modules 



All new modules must be added to the MPL Executive table (see section 2.4.2.2). Once this Is 
done, the new MPL needs to be added to the present NASTRAN system before proceeding to generate a 
new Link Specification Table and a new link driver. The new modules need not be present in the 
system, but their entry points in the MPL must be in the system. 



6.11-1 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

6.11.3 Generation of a New Link Specification Table and a New Link Driver 

The addition of a new link requires that: a) the Link Specification Table, LNKSPC, (see 
section 2.4.2.7) be updated; and b) a new XSEMi deck (see section 3.3.7), which will be the main 
program for the new link, be generated. 

The F0RTRAN code, in punched card form, necessary to accomplish both of the above tasks can 
be produced automatically in a NASTRAN run using a LNKSPC update deck as indicated below. 

6.11.3.1 Link Specification Table Update 

To update the Link Specification Table the user must insert a LNKSPC update deck after the 
Bulk Data Deck in a NASTRAN run. The processing of a LNKSPC update deck is initiated by logical 
"sense switches" on a DIAG card in the Executive Control Deck (see explanation below); hence no 
special header card is required in the LNKSPC update deck. The format of each card of the LNKSPC 
update deck is as follows: 



a e L^, ..., L^ 



where 



a = Module DMAP name (1 to 8 characters) 

- \ Entry point name (1 to 6 characters) 

^ °) "(N0NE)" (6 characters) if there is no entry point name 

L,. . L = zero or more integers, specifying all links the module resides in. 
1 ' n 

The a, B and L. fields must be separated by at least one blank or one comma. An example of a 
card in a LNKSPC update deck is 

CHKPNT XCHK 1.2,3,4,5,6,7,8,9,10.11,12.13.14 

At present the Executive module CHKPNT with entry point XCHK Is in links 1 to 13; the above card 

will add it to a new link 14. Be sure to include all the other Executive modules In any new link. 

Cards in this format are repeated until all the modules in the new link have been named. The end 
of the LNKSPC update is specified by the following card: 

ENDDATA 



6.11-2 



ADDITION OF A NEW LINK 

The following logical sense switches, set by a DIAG card in the Executive Control Deck, must 
be used to process the LNKSPC update deck: 

1. Logical sense switch 29 allows the LNKSPC update deck to be processed. 

2. Logical sense switch 28 causes the new Link Specification Table to be punched.* 

3. Logical sense switch 31 causes the new Link Specification Table to be printed. 
The following DIAG card within the Executive Control Deck 

DIAG 28,29,31 
accomplishes this result. 

*This code is for the Block Data subprogram XBSBD, and may be compiled under that name as punched, 
or altered into the present deck to retain the comments presently in that deck. The latter pro- 
cedure is recommended. 

6.11.3.2 Generating New Link Driver Decks 

The F0RTRAN code necessary to make a new link driver deck can be produced by setting logical 
sense switch 30 and the logical sense switches corresponding to the desired 1ink(s). For example 
the Executive Control Deck card: 

DIAG 30,2,14 

will punch the code for XSEM2 and XSEM14. The F0RTRAN code produced, when altered into the deck 
"XSEMXX" (see section 3.3.8), will produce the desired XSEMi routine. XSEMXX is the model for the 
link drivers. 

This driver code may be produced in the same run as the code for the Link Specification Table, 
or this coce may be produced by adding the new XBSBD deck to the user's system and then setting 
the appropriate sense switches on a subsequent run. 

If logical sense switch 30 is set, the program will automatically terminate after satisfying 
all sense switch requests to punch XSEMi 's. In essence, the structural problem submitted is only 
a dummy needed to start NASTRAN. The user is cautioned to check his DIAG card(s) carefully when 
logical sense switch 30 is set to be sure only the sense switches corresponding to the desired 
links are set. 



6.11-3 



MODIFICATIONS AND ADDITIONS TO NASTRAN 

6.11.4 Subsys the New Link 

The sybsys deck necessary to add a new link will vary with the computing machine (see section 
5). The safest way for the NASTRAN systems programmer to develop the subsys deck for the new link 
is to copy the overlay structure of the necessary routines, which are listed in section 6.11.1, 
and then add the new functional module(s) to this base. The mechanisms for switching from one link 
to another already exists in NASTRAN up to 15 links, so that, once the subsys of the new link has 
been accomplished, NASTRAN will be able to assimilate it. 

6.11.5 Increasing the Link Limit 

To increase the link limit beyond 15, the following Executive System changes must be made. 

1. Increase the size of the NAME array in the /SEM/ common block to the desired link limit. 
Add the additional link names (e.g., NS16, NS17, etc.) to the NAME array via the DATA state- 
ment. The /SEM/ common block is defined in the System Block Data subprogram, SEMDBD. 

2. Items MAXLNK, DRVRNM, and LNKEDT, defined in subroutine XGPIBS of Executive Preface 
module XGPI (see section 4.7), must be updated. Increase the value for MAXLNK in the /XLINK/ 
common block to the desired link limit. Add the additional XSEMi names (e.g., XSEM16, XSEM17, 
etc.) to the local DRVRNM array via the DATA statement. Add the additional link numbers 
(e.g., 16, 17, etc.) to the local LNKEDT array via the DATA statement. 



6.11-4 



